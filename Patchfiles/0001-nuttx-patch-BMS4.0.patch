From 0b38bc0acccb81cc6dd533274b9e3b8f10c3d354 Mon Sep 17 00:00:00 2001
From: Cis van Mierlo <cis.van.mierlo@nxp.com>
Date: Fri, 3 Sep 2021 10:27:25 +0200
Subject: [PATCH] nuttx patch BMS4.0

---
 Kconfig                                       |    1 +
 arch/arm/src/s32k1xx/Kconfig                  |   46 +-
 arch/arm/src/s32k1xx/Make.defs                |    9 +
 .../src/s32k1xx/hardware/s32k1xx_flexcan.h    |    2 +
 arch/arm/src/s32k1xx/hardware/s32k1xx_pmc.h   |    1 +
 arch/arm/src/s32k1xx/hardware/s32k1xx_smc.h   |    6 +-
 arch/arm/src/s32k1xx/s32k1xx_clockconfig.c    |  818 ++++-
 arch/arm/src/s32k1xx/s32k1xx_clockconfig.h    |   26 +
 arch/arm/src/s32k1xx/s32k1xx_flexcan.c        |   96 +-
 arch/arm/src/s32k1xx/s32k1xx_lpi2c.c          |   65 +-
 arch/arm/src/s32k1xx/s32k1xx_lpi2c_slave.c    |  929 ++++++
 arch/arm/src/s32k1xx/s32k1xx_lpi2c_slave.h    |   90 +
 arch/arm/src/s32k1xx/s32k1xx_lpspi.c          |  618 +++-
 arch/arm/src/s32k1xx/s32k1xx_periphclocks.c   |   58 +-
 arch/arm/src/s32k1xx/s32k1xx_periphclocks.h   |   17 +
 arch/arm/src/s32k1xx/s32k1xx_pingpio.c        |   10 +-
 arch/arm/src/s32k1xx/s32k1xx_pminitialize.c   |   78 +
 arch/arm/src/s32k1xx/s32k1xx_resetcause.c     |  350 ++
 arch/arm/src/s32k1xx/s32k1xx_resetcause.h     |   83 +
 arch/arm/src/s32k1xx/s32k1xx_serial.c         |  406 ++-
 boards/Kconfig                                |   12 +
 boards/arm/s32k1xx/drivers/Kconfig            |    8 +
 boards/arm/s32k1xx/drivers/Make.defs          |   21 +
 .../arm/s32k1xx/drivers/smart_battery/Kconfig |   12 +
 .../s32k1xx/drivers/smart_battery/Make.defs   |   27 +
 .../drivers/smart_battery/simple_sbs.c        |  805 +++++
 .../drivers/smart_battery/simple_sbs.h        |  183 +
 boards/arm/s32k1xx/rddrone-bms772/Kconfig     |  189 ++
 boards/arm/s32k1xx/rddrone-bms772/README.txt  |   15 +
 .../rddrone-bms772/configs/bms/.gitignore     |    2 +
 .../rddrone-bms772/configs/bms/defconfig      |  122 +
 .../configs/bmsdebug/.gitignore               |    2 +
 .../rddrone-bms772/configs/bmsdebug/defconfig |  123 +
 .../s32k1xx/rddrone-bms772/include/board.h    |  167 +
 .../rddrone-bms772/include/nsh_romfsimg.h     |   89 +
 .../rddrone-bms772/include/rcS.template       |   20 +
 .../s32k1xx/rddrone-bms772/scripts/Make.defs  |  108 +
 .../s32k1xx/rddrone-bms772/scripts/flash.ld   |  152 +
 .../rddrone-bms772/scripts/s32k144.cfg        |   58 +
 .../s32k1xx/rddrone-bms772/scripts/sram.ld    |  129 +
 .../arm/s32k1xx/rddrone-bms772/src/.gitignore |    2 +
 .../arm/s32k1xx/rddrone-bms772/src/Makefile   |   79 +
 .../rddrone-bms772/src/rddrone-bms772.h       |  217 ++
 .../rddrone-bms772/src/s32k1xx_appinit.c      |   94 +
 .../rddrone-bms772/src/s32k1xx_autoleds.c     |  165 +
 .../s32k1xx/rddrone-bms772/src/s32k1xx_boot.c |   93 +
 .../rddrone-bms772/src/s32k1xx_bringup.c      |  216 ++
 .../rddrone-bms772/src/s32k1xx_buttons.c      |  164 +
 .../rddrone-bms772/src/s32k1xx_clockconfig.c  |  217 ++
 .../s32k1xx/rddrone-bms772/src/s32k1xx_gpio.c |  549 +++
 .../rddrone-bms772/src/s32k1xx_nrstcheck.c    |  390 +++
 .../rddrone-bms772/src/s32k1xx_periphclocks.c |  159 +
 .../rddrone-bms772/src/s32k1xx_reset.c        |   77 +
 .../rddrone-bms772/src/s32k1xx_smartbattery.c |  229 ++
 .../s32k1xx/rddrone-bms772/src/s32k1xx_spi.c  |  168 +
 .../rddrone-bms772/src/s32k1xx_userleds.c     |  138 +
 boards/boardctl.c                             |    8 +
 include/sys/boardctl.h                        |    4 +-
 net/can/can_callback.c                        |    6 +-
 net/can/can_setsockopt.c                      |    2 +-
 net/devif/devif_poll.c                        |    9 +-
 net/utils/net_lock.c                          |   22 +-
 sched/Makefile                                |    1 +
 sched/init/nx_start.c                         |    4 +
 sched/irq/irq_dispatch.c                      |   13 +
 sched/pthread/pthread_create.c                |   11 +
 sched/pthread/pthread_exit.c                  |    4 +
 sched/sched/sched_addblocked.c                |   16 +
 sched/sched/sched_addreadytorun.c             |    4 +
 sched/sched/sched_resumescheduler.c           |    2 +
 sched/semaphore/sem_trywait.c                 |    6 +-
 sched/systemview/Global.h                     |  113 +
 sched/systemview/Kconfig                      |   66 +
 sched/systemview/Make.defs                    |   47 +
 sched/systemview/Makefile                     |   76 +
 sched/systemview/SEGGER.h                     |  248 ++
 sched/systemview/SEGGER_RTT.c                 | 2009 +++++++++++
 sched/systemview/SEGGER_RTT.h                 |  325 ++
 sched/systemview/SEGGER_RTT_ASM_ARMv7M.S      |  235 ++
 sched/systemview/SEGGER_RTT_Conf.h            |  388 +++
 sched/systemview/SEGGER_RTT_printf.c          |  504 +++
 sched/systemview/SEGGER_SYSVIEW.c             | 2945 +++++++++++++++++
 sched/systemview/SEGGER_SYSVIEW.h             |  346 ++
 sched/systemview/SEGGER_SYSVIEW_Conf.h        |  203 ++
 .../systemview/SEGGER_SYSVIEW_ConfDefaults.h  |  172 +
 .../systemview/SEGGER_SYSVIEW_Config_NuttX.c  |  194 ++
 sched/systemview/SEGGER_SYSVIEW_Int.h         |  100 +
 sched/systemview/SEGGER_SYSVIEW_NuttX.c       |  269 ++
 sched/systemview/SEGGER_SYSVIEW_NuttX.h       |  156 +
 sched/task/task_create.c                      |    2 +
 sched/task/task_start.c                       |    6 +
 91 files changed, 17171 insertions(+), 255 deletions(-)
 create mode 100644 arch/arm/src/s32k1xx/s32k1xx_lpi2c_slave.c
 create mode 100644 arch/arm/src/s32k1xx/s32k1xx_lpi2c_slave.h
 create mode 100644 arch/arm/src/s32k1xx/s32k1xx_pminitialize.c
 create mode 100644 arch/arm/src/s32k1xx/s32k1xx_resetcause.c
 create mode 100644 arch/arm/src/s32k1xx/s32k1xx_resetcause.h
 create mode 100644 boards/arm/s32k1xx/drivers/Kconfig
 create mode 100644 boards/arm/s32k1xx/drivers/Make.defs
 create mode 100644 boards/arm/s32k1xx/drivers/smart_battery/Kconfig
 create mode 100644 boards/arm/s32k1xx/drivers/smart_battery/Make.defs
 create mode 100644 boards/arm/s32k1xx/drivers/smart_battery/simple_sbs.c
 create mode 100644 boards/arm/s32k1xx/drivers/smart_battery/simple_sbs.h
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/Kconfig
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/README.txt
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/configs/bms/.gitignore
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/configs/bms/defconfig
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/configs/bmsdebug/.gitignore
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/configs/bmsdebug/defconfig
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/include/board.h
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/include/nsh_romfsimg.h
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/include/rcS.template
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/scripts/Make.defs
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/scripts/flash.ld
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/scripts/s32k144.cfg
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/scripts/sram.ld
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/src/.gitignore
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/src/Makefile
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/src/rddrone-bms772.h
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_appinit.c
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_autoleds.c
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_boot.c
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_bringup.c
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_buttons.c
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_clockconfig.c
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_gpio.c
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_nrstcheck.c
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_periphclocks.c
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_reset.c
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_smartbattery.c
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_spi.c
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_userleds.c
 create mode 100644 sched/systemview/Global.h
 create mode 100644 sched/systemview/Kconfig
 create mode 100644 sched/systemview/Make.defs
 create mode 100644 sched/systemview/Makefile
 create mode 100644 sched/systemview/SEGGER.h
 create mode 100644 sched/systemview/SEGGER_RTT.c
 create mode 100644 sched/systemview/SEGGER_RTT.h
 create mode 100644 sched/systemview/SEGGER_RTT_ASM_ARMv7M.S
 create mode 100644 sched/systemview/SEGGER_RTT_Conf.h
 create mode 100644 sched/systemview/SEGGER_RTT_printf.c
 create mode 100644 sched/systemview/SEGGER_SYSVIEW.c
 create mode 100644 sched/systemview/SEGGER_SYSVIEW.h
 create mode 100644 sched/systemview/SEGGER_SYSVIEW_Conf.h
 create mode 100644 sched/systemview/SEGGER_SYSVIEW_ConfDefaults.h
 create mode 100644 sched/systemview/SEGGER_SYSVIEW_Config_NuttX.c
 create mode 100644 sched/systemview/SEGGER_SYSVIEW_Int.h
 create mode 100644 sched/systemview/SEGGER_SYSVIEW_NuttX.c
 create mode 100644 sched/systemview/SEGGER_SYSVIEW_NuttX.h

diff --git a/Kconfig b/Kconfig
index c69636205e..c23d98de40 100644
--- a/Kconfig
+++ b/Kconfig
@@ -1764,6 +1764,7 @@ endmenu
 menu "RTOS Features"
 source sched/Kconfig
 source syscall/Kconfig
+source sched/systemview/Kconfig
 endmenu
 
 menu "Device Drivers"
diff --git a/arch/arm/src/s32k1xx/Kconfig b/arch/arm/src/s32k1xx/Kconfig
index 59700aecd1..e421c54735 100644
--- a/arch/arm/src/s32k1xx/Kconfig
+++ b/arch/arm/src/s32k1xx/Kconfig
@@ -272,12 +272,12 @@ config S32K1XX_FTM7
 	select S32K1XX_FTM
 	depends on S32K1XX_HAVE_FTM7
 
-menuconfig S32K1XX_LPI2C0
+config S32K1XX_LPI2C0
 	bool "LPI2C0"
 	default n
 	select S32K1XX_LPI2C
 
-menuconfig S32K1XX_LPI2C1
+config S32K1XX_LPI2C1
 	bool "LPI2C1"
 	default n
 	select S32K1XX_LPI2C
@@ -618,7 +618,7 @@ config S32K1XX_EDMA_EDBG
 
 endmenu # eDMA Global Configuration
 
-menu "LPI2C0 Configuration"
+menu "LPI2C0 Master Configuration"
 	depends on S32K1XX_LPI2C0
 
 config LPI2C0_BUSYIDLE
@@ -633,9 +633,26 @@ config LPI2C0_FILTSDA
 	int "I2C master digital glitch filters for SDA input in clock cycles"
 	default 0
 
-endmenu # LPI2C0 Configuration
+endmenu # LPI2C0 Master Configuration
 
-menu "LPI2C1 Configuration"
+menu "LPI2C0 Slave Configuration"
+	depends on S32K1XX_LPI2C0
+
+config LPI2C0_SLAVE_ADDRESS
+	int "7-bit I2C address in decimal"
+	default 8
+	range 8 119
+
+config LPI2C0_SLAVE_BUS
+	bool "Separate I2C slave bus"
+	default n
+	---help---
+		When selected, the LPI2C slave will use separate SDA/SCL pins from
+		the LPI2C master.  These pins need to be defined in the board.h file
+
+endmenu # LPI2C0 Slave Configuration
+
+menu "LPI2C1 Master Configuration"
 	depends on S32K1XX_LPI2C1
 
 config LPI2C1_BUSYIDLE
@@ -650,7 +667,24 @@ config LPI2C1_FILTSDA
 	int "I2C master digital glitch filters for SDA input in clock cycles"
 	default 0
 
-endmenu # LPI2C1 Configuration
+endmenu # LPI2C1 Master Configuration
+
+menu "LPI2C1 Slave Configuration"
+	depends on S32K1XX_LPI2C1
+
+config LPI2C1_SLAVE_ADDRESS
+	int "7-bit I2C address in decimal"
+	default 9
+	range 8 119
+
+config LPI2C1_SLAVE_BUS
+	bool "Separate I2C slave bus"
+	default n
+	---help---
+		When selected, the LPI2C slave will use separate SDA/SCL pins from
+		the LPI2C master.  These pins need to be defined in the board.h file
+
+endmenu # LPI2C1 Slave Configuration
 
 menu "Ethernet Configuration"
 	depends on S32K1XX_ENET
diff --git a/arch/arm/src/s32k1xx/Make.defs b/arch/arm/src/s32k1xx/Make.defs
index 46bf525019..59e5700da2 100644
--- a/arch/arm/src/s32k1xx/Make.defs
+++ b/arch/arm/src/s32k1xx/Make.defs
@@ -81,6 +81,7 @@ endif
 
 ifeq ($(CONFIG_S32K1XX_LPI2C),y)
 CHIP_CSRCS += s32k1xx_lpi2c.c
+CHIP_CSRCS += s32k1xx_lpi2c_slave.c
 endif
 
 ifeq ($(CONFIG_S32K1XX_LPSPI),y)
@@ -107,6 +108,14 @@ ifeq ($(CONFIG_S32K1XX_EEEPROM),y)
 CHIP_CSRCS += s32k1xx_eeeprom.c
 endif 
 
+ifneq ($(CONFIG_ARCH_CUSTOM_PMINIT),y)
+CHIP_CSRCS += s32k1xx_pminitialize.c
+endif
+
+ifeq ($(CONFIG_RESET_CAUSE_PROC_FS), y) 
+CHIP_CSRCS += s32k1xx_resetcause.c
+endif
+
 # Source files specific to the ARM CPU family and to the S32K1xx chip family
 
 ifeq ($(CONFIG_ARCH_CHIP_S32K11X),y)
diff --git a/arch/arm/src/s32k1xx/hardware/s32k1xx_flexcan.h b/arch/arm/src/s32k1xx/hardware/s32k1xx_flexcan.h
index aba9b7f331..69ce1dba26 100644
--- a/arch/arm/src/s32k1xx/hardware/s32k1xx_flexcan.h
+++ b/arch/arm/src/s32k1xx/hardware/s32k1xx_flexcan.h
@@ -103,6 +103,7 @@
 #  define S32K1XX_CAN_RXIMR29_OFFSET  0x08f4  /* R29 Individual Mask Registers */
 #  define S32K1XX_CAN_RXIMR30_OFFSET  0x08f8  /* R30 Individual Mask Registers */
 #  define S32K1XX_CAN_RXIMR31_OFFSET  0x08fc  /* R31 Individual Mask Registers */
+#define S32K1XX_CAN_RXIMR_COUNT       32      /* Individual Mask Registers Count */
 
 #define S32K1XX_CAN_CTRL1_PN_OFFSET   0x0b00  /* Pretended Networking Control 1 register */
 #define S32K1XX_CAN_CTRL2_PN_OFFSET   0x0b04  /* Pretended Networking Control 2 register */
@@ -387,6 +388,7 @@
 #define CAN_CTRL1_CLKSRC              (1 << 13) /* Bit 13: CAN Engine Clock Source */
 #define CAN_CTRL1_ERRMSK              (1 << 14) /* Bit 14: Error Mask */
 #define CAN_CTRL1_BOFFMSK             (1 << 15) /* Bit 15: Bus Off Mask */
+#define CAN_CTRL1_TIMINGMSK           (0xFFFF << 16)
 #define CAN_CTRL1_PSEG2(x)            (((uint32_t)(((uint32_t)(x)) << 16)) & 0x70000)
 #define CAN_CTRL1_PSEG1(x)            (((uint32_t)(((uint32_t)(x)) << 19)) & 0x380000)
 #define CAN_CTRL1_RJW(x)              (((uint32_t)(((uint32_t)(x)) << 22)) & 0xC00000)
diff --git a/arch/arm/src/s32k1xx/hardware/s32k1xx_pmc.h b/arch/arm/src/s32k1xx/hardware/s32k1xx_pmc.h
index fdf656f072..771e4a5bb8 100644
--- a/arch/arm/src/s32k1xx/hardware/s32k1xx_pmc.h
+++ b/arch/arm/src/s32k1xx/hardware/s32k1xx_pmc.h
@@ -78,6 +78,7 @@
 
 /* Regulator Status and Control Register */
 
+#define PMC_REGSC_BIASEN        	(1 << 0)  /* Bit 0:  Bias Enable Bit */
 #define PMC_REGSC_CLKBIASDIS        (1 << 1)  /* Bit 1:  Clock Bias Disable Bit */
 #define PMC_REGSC_REGFPM            (1 << 2)  /* Bit 2:  Regulator in Full Performance Mode Status Bit */
 #define PMC_REGSC_LPOSTAT           (1 << 6)  /* Bit 6:  LPO Status Bit */
diff --git a/arch/arm/src/s32k1xx/hardware/s32k1xx_smc.h b/arch/arm/src/s32k1xx/hardware/s32k1xx_smc.h
index f0fc3d22ab..58a63f1f01 100644
--- a/arch/arm/src/s32k1xx/hardware/s32k1xx_smc.h
+++ b/arch/arm/src/s32k1xx/hardware/s32k1xx_smc.h
@@ -87,8 +87,10 @@
 
 /* SMC Power Mode Protection register */
 
-#define SMC_PMPROT_AVLP             (1 << 5)  /* Bit 5:  Allow Very-Low-Power Modes */
-#define SMC_PMPROT_AHSRUN           (1 << 7)  /* Bit 7:  Allow High Speed Run mode */
+#define SMC_PMPROT_AVLP_SHIFT       (5)  /* Bit 5:  Allow Very-Low-Power Modes */
+#define SMC_PMPROT_AVLP             (1 << SMC_PMPROT_AVLP_SHIFT)  
+#define SMC_PMPROT_AHSRUN_SHIFT 	(7)  /* Bit 7:  Allow High Speed Run mode */
+#define SMC_PMPROT_AHSRUN           (1 << SMC_PMPROT_AHSRUN_SHIFT)  
 
 /* SMC Power Mode Control register */
 
diff --git a/arch/arm/src/s32k1xx/s32k1xx_clockconfig.c b/arch/arm/src/s32k1xx/s32k1xx_clockconfig.c
index 00c7108be8..b0b5937889 100644
--- a/arch/arm/src/s32k1xx/s32k1xx_clockconfig.c
+++ b/arch/arm/src/s32k1xx/s32k1xx_clockconfig.c
@@ -63,6 +63,7 @@
 #include <debug.h>
 
 #include <nuttx/arch.h>
+#include <nuttx/power/pm.h>
 
 #include "arm_arch.h"
 #include "arm_internal.h"
@@ -73,6 +74,7 @@
 #include "hardware/s32k1xx_pmc.h"
 #include "s32k1xx_periphclocks.h"
 #include "s32k1xx_clockconfig.h"
+#include "s32k1xx_start.h"
 
 #include <arch/board/board.h>  /* Include last.  May have dependencies */
 
@@ -120,18 +122,28 @@
 #define SCG_SPLL_REF_MIN 8000000
 #define SCG_SPLL_REF_MAX 32000000
 
+/* Power management definitions */
+
+#if defined(CONFIG_PM)
+#ifndef PM_IDLE_DOMAIN
+#  define PM_IDLE_DOMAIN      0 /* Revisit */
+#endif
+#endif
+
+#ifndef OK
+#define OK 0
+#endif 
+
 /****************************************************************************
  * Private Types
  ****************************************************************************/
 
-enum scg_system_clock_mode_e
-{
-  SCG_SYSTEM_CLOCK_MODE_CURRENT = 0,  /* Current mode. */
-  SCG_SYSTEM_CLOCK_MODE_RUN     = 1,  /* Run mode. */
-  SCG_SYSTEM_CLOCK_MODE_VLPR    = 2,  /* Very Low Power Run mode. */
-  SCG_SYSTEM_CLOCK_MODE_HSRUN   = 3,  /* High Speed Run mode. */
-  SCG_SYSTEM_CLOCK_MODE_NONE          /* MAX value. */
-};
+#ifdef CONFIG_PM
+static void up_pm_notify(struct pm_callback_s *cb, int dowmin,
+                         enum pm_state_e pmstate);
+static int  up_pm_prepare(struct pm_callback_s *cb, int domain,
+                          enum pm_state_e pmstate);
+#endif
 
 /****************************************************************************
  * Private Data
@@ -205,6 +217,14 @@ static uint32_t g_rtc_clkin;                 /* RTC CLKIN clock */
 static uint32_t g_tclkfreq[NUMBER_OF_TCLK_INPUTS];  /* TCLKx clocks */
 #endif
 
+#ifdef CONFIG_PM
+static  struct pm_callback_s g_clock_pmcb =
+{
+  .notify       = up_pm_notify,
+  .prepare      = up_pm_prepare,
+};
+#endif
+
 /****************************************************************************
  * Private Functions
  ****************************************************************************/
@@ -228,59 +248,6 @@ static inline uint32_t s32k1xx_get_scgclk_source(void)
   return ((getreg32(S32K1XX_SCG_CSR) & SCG_CSR_SCS_MASK) >> SCG_CSR_SCS_SHIFT);
 }
 
-/****************************************************************************
- * Name: s32k1xx_get_runmode
- *
- * Description:
- *   Get the current running mode.
- *
- * Input Parameters:
- *   None
- *
- * Returned Value:
- *   The current running mode.
- *
- ****************************************************************************/
-
-static enum scg_system_clock_mode_e s32k1xx_get_runmode(void)
-{
-  enum scg_system_clock_mode_e mode;
-
-  /* Get the current running mode */
-
-  switch (getreg32(S32K1XX_SMC_PMSTAT) & SMC_PMSTAT_PMSTAT_MASK)
-    {
-      /* Run mode */
-
-      case SMC_PMSTAT_PMSTAT_RUN:
-        mode = SCG_SYSTEM_CLOCK_MODE_RUN;
-        break;
-
-      /* Very low power run mode */
-
-      case SMC_PMSTAT_PMSTAT_VLPR:
-        mode = SCG_SYSTEM_CLOCK_MODE_VLPR;
-        break;
-
-      /* High speed run mode */
-
-      case SMC_PMSTAT_PMSTAT_HSRUN:
-        mode = SCG_SYSTEM_CLOCK_MODE_HSRUN;
-        break;
-
-      /* This should never happen - core has to be in some run mode to
-       * execute code
-       */
-
-      case SMC_PMSTAT_PMSTAT_VLPS:
-      default:
-        mode = SCG_SYSTEM_CLOCK_MODE_NONE;
-        break;
-    }
-
-    return mode;
-}
-
 /****************************************************************************
  * Name: s32k1xx_get_soscfreq
  *
@@ -755,7 +722,7 @@ static int s32k1xx_firc_config(bool enable,
 }
 
 /****************************************************************************
- * Name: s32k11_firc_clocksource
+ * Name: s32k1xx_firc_clocksource
  *
  * Description:
  *   Configure to the FIRC clock source.
@@ -769,7 +736,7 @@ static int s32k1xx_firc_config(bool enable,
  *
  ****************************************************************************/
 
-static int s32k11_firc_clocksource(void)
+static int s32k1xx_firc_clocksource(void)
 {
   struct scg_system_clock_config_s firccfg;
   int ret = OK;
@@ -916,6 +883,57 @@ static int s32k1xx_sirc_config(bool enable,
   return ret;
 }
 
+/****************************************************************************
+ * Name: s32k1xx_sirc_clocksource
+ *
+ * Description:
+ *   Configure to the SIRC clock source.
+ *
+ * Input Parameters:
+ *   None
+ *
+ * Returned Value:
+ *   Zero (OK) is returned a success;  A negated errno value is returned on
+ *   any failure.
+ *
+ ****************************************************************************/
+
+static int s32k1xx_sirc_clocksource(void)
+{
+  struct scg_system_clock_config_s sirccfg;
+  int ret = OK;
+
+  /* If the current system clock source is not SIRC:
+   * 1. Enable SIRC (if it's not enabled)
+   * 2. Switch to SIRC.
+ */
+
+  if (s32k1xx_get_scgclk_source() != SCG_SYSTEM_CLOCK_SRC_SIRC)
+    {
+      /* If SIRC is not on, then SIRC is configured with the default
+       * configuration
+       */
+
+      if (s32k1xx_get_sircfreq() == 0)
+        {
+          ret = s32k1xx_sirc_config(true, NULL);
+        }
+
+      /* SIRC is enabled, transition the system clock source to SIRC. */
+
+      if (ret == OK)
+        {
+          sirccfg.src     = SCG_SYSTEM_CLOCK_SRC_SIRC;
+          sirccfg.divcore = g_tmp_sysclk[TMP_SIRC_CLK][TMP_SYS_DIV];
+          sirccfg.divbus  = g_tmp_sysclk[TMP_SIRC_CLK][TMP_BUS_DIV];
+          sirccfg.divslow = g_tmp_sysclk[TMP_SIRC_CLK][TMP_SLOW_DIV];
+          ret             = s32k1xx_transition_systemclock(&sirccfg);
+        }
+    }
+
+  return ret;
+}
+
 /****************************************************************************
  * Name: s32k1xx_sosc_config
  *
@@ -1359,9 +1377,23 @@ static int s32k1xx_scg_config(const struct scg_config_s *scgcfg)
 
   DEBUGASSERT(scgcfg != NULL);
 
-  /* Configure a temporary system clock source: FIRC */
-
-  ret = s32k11_firc_clocksource();
+  /* Configure a temporary system clock source: FIRC if enabled*/
+  // if(scgcfg->firc.initialize)
+  // {
+    ret = s32k1xx_firc_clocksource();
+  // }
+  // /* Configure a temporary system clock source: SIRC if enabled*/
+  // else if(scgcfg->sirc.initialize)
+  // {
+  //   ret = s32k1xx_sirc_clocksource();
+  // }
+  // else
+  // {
+  //   // error
+  //   DEBUGASSERT(false);
+  //   ret = !OK;
+  // }
+  
   if (ret == OK)
     {
       /* Configure clock sources from SCG */
@@ -1619,6 +1651,9 @@ static void s32k1xx_pmc_config(const struct pmc_config_s *pmccfg)
           regval |= PMC_REGSC_LPODIS;
         }
 
+      /* Enable Biasing (needed for VLPR mode, no effect in RUN mode) */
+      regval |= PMC_REGSC_BIASEN;
+
       putreg8(regval, S32K1XX_PMC_REGSC);
 
       /* Write trimming value. */
@@ -1627,9 +1662,649 @@ static void s32k1xx_pmc_config(const struct pmc_config_s *pmccfg)
     }
 }
 
+/****************************************************************************
+ * Name: s32k1xx_allow_vlprmode
+ *
+ * Description:
+ *   allow the very low power run mode.
+ *
+ * Input Parameters:
+ *   allow - true if allowed, false otherwise.
+ *
+ * Returned Value:
+ *   none.
+ *
+ ****************************************************************************/
+
+void s32k1xx_allow_vlprmode(bool allow)
+{
+  uint32_t regval;
+
+  // get the SMC_PMPROT register
+  regval  =  getreg32(S32K1XX_SMC_PMPROT);
+
+  // mask the AVLP bit
+  regval &= ~SMC_PMPROT_AVLP;
+
+  // set the new bit 
+  regval |= (allow << SMC_PMPROT_AVLP_SHIFT);
+
+  // set the registervalue
+  putreg32(regval, S32K1XX_SMC_PMPROT);
+}
+
+/****************************************************************************
+ * Name: up_pm_notify
+ *
+ * Description:
+ *   Notify the driver of new power state. This callback is  called after
+ *   all drivers have had the opportunity to prepare for the new power state.
+ *
+ * Input Parameters:
+ *
+ *    cb - Returned to the driver. The driver version of the callback
+ *         structure may include additional, driver-specific state data at
+ *         the end of the structure.
+ *
+ *    pmstate - Identifies the new PM state
+ *
+ * Returned Value:
+ *   None - The driver already agreed to transition to the low power
+ *   consumption state when when it returned OK to the prepare() call.
+ *
+ ****************************************************************************/
+
+#ifdef CONFIG_PM
+static void up_pm_notify(struct pm_callback_s *cb, int domain,
+                         enum pm_state_e pmstate)
+{
+  int returnValue;
+
+  // check if the transition is from the IDLE domain to the NORMAL domain
+  if(pm_querystate(PM_IDLE_DOMAIN) == PM_IDLE &&
+    pmstate == PM_NORMAL)
+  {
+    // return
+    return;
+  }
+
+  // check what the new power state is
+  switch (pmstate)
+    {
+      // if it needs to be set to RUN mode
+      case(PM_NORMAL):
+        {
+          /* Logic for PM_NORMAL goes here */
+
+          // change the microcontroller to RUN mode 
+          // and wait until in RUN mode
+          returnValue = (int)s32k1xx_set_runmode(SCG_SYSTEM_CLOCK_MODE_RUN);
+          
+          // check for debug assertion
+          DEBUGASSERT(returnValue != (int)SCG_SYSTEM_CLOCK_MODE_NONE);
+
+          // enable all clock sources again if needed 
+          // these could be the FIRC, PPL, and SOSC
+          
+          // check if the FIRC was enabled and it is not the system clock source
+          if(g_initial_clkconfig.scg.firc.initialize && 
+            (s32k1xx_get_scgclk_source() != SCG_SYSTEM_CLOCK_SRC_SIRC))
+          {
+            // enable FIRC
+            returnValue = s32k1xx_firc_config(true, &g_initial_clkconfig.scg.firc);
+            DEBUGASSERT(!returnValue); 
+          }
+          // check if the FIRC needs to be disabled and if it is enabled
+          else if((!(g_initial_clkconfig.scg.firc.initialize)) && 
+            (s32k1xx_get_srcfreq(SCG_SYSTEM_CLOCK_SRC_FIRC)))
+          {
+            // disable FIRC
+            returnValue = s32k1xx_firc_config(false, &g_initial_clkconfig.scg.firc);
+            DEBUGASSERT(!returnValue);
+          }
+
+          // check if the SOSC was enabled and it is not the system clock source
+          if(g_initial_clkconfig.scg.sosc.initialize && 
+            (s32k1xx_get_scgclk_source() != SCG_SYSTEM_CLOCK_SRC_SYS_OSC) &&
+            (s32k1xx_get_scgclk_source() != SCG_SYSTEM_CLOCK_SRC_SYS_PLL))
+          {
+            // enable SOSC
+            returnValue = s32k1xx_sosc_config(true, &g_initial_clkconfig.scg.sosc);
+            DEBUGASSERT(!returnValue);
+          }
+          // check if the SOSC needs to be disabled and if it is enabled
+          else if((!(g_initial_clkconfig.scg.sosc.initialize)) && 
+            (s32k1xx_get_srcfreq(SCG_SYSTEM_CLOCK_SRC_SYS_OSC)))
+          {
+            // disable SOSC
+            returnValue = s32k1xx_sosc_config(false, &g_initial_clkconfig.scg.sosc);
+            DEBUGASSERT(!returnValue);
+          }
+
+          // check if the SPLL was enabled and it is not the system clock source
+          if(g_initial_clkconfig.scg.spll.initialize && 
+            (s32k1xx_get_scgclk_source() != SCG_SYSTEM_CLOCK_SRC_SYS_OSC) &&
+            (s32k1xx_get_scgclk_source() != SCG_SYSTEM_CLOCK_SRC_SYS_PLL))
+          {
+            // enable SPLL
+            returnValue = s32k1xx_spll_config(true, &g_initial_clkconfig.scg.spll);
+            DEBUGASSERT(!returnValue);
+          }
+          // check if the SPLL needs to be disabled and if it is enabled
+          else if((!(g_initial_clkconfig.scg.spll.initialize)) && 
+            (s32k1xx_get_srcfreq(SCG_SYSTEM_CLOCK_SRC_SYS_PLL)))
+          {
+            // disable SPLL
+            returnValue = s32k1xx_spll_config(false, &g_initial_clkconfig.scg.spll);
+            DEBUGASSERT(!returnValue);
+          }
+
+          // check if the RCCR clock source is enabled 
+          if(s32k1xx_get_srcfreq(g_initial_clkconfig.scg.clockmode.rccr.src) != 0)
+          {
+            // change the system clock back to the configured clock 
+            // and wait until clock changed
+            if(s32k1xx_transition_systemclock(&g_initial_clkconfig.scg.clockmode.rccr))
+            {
+              // error 
+              DEBUGASSERT(false);
+            }
+          }
+          // if it is 0
+          else
+          {
+            // error
+            DEBUGASSERT(false);
+          }
+
+          // calculate the new clock ticks
+          up_timer_initialize();
+        }
+        break;
+
+      case(PM_IDLE):
+        {
+          /* Logic for PM_IDLE goes here */
+        }
+        break;
+
+      // if it needs to be set to VLPR mode
+      case(PM_STANDBY):
+        {
+          /* Logic for PM_STANDBY goes here */
+
+#ifdef CONFIG_RUN_STANDBY
+
+          // change the microcontroller to RUN mode 
+          // and wait until in RUN mode
+          returnValue = (int)s32k1xx_set_runmode(SCG_SYSTEM_CLOCK_MODE_RUN);
+          DEBUGASSERT(returnValue != (int)SCG_SYSTEM_CLOCK_MODE_NONE);
+
+          // enable all clock sources again if needed 
+          // these could be the FIRC, PPL, and SOSC
+          
+          // check if the FIRC was enabled and it is not the system clock source
+          if(g_initial_clkconfig.scg.firc.initialize && 
+            (s32k1xx_get_scgclk_source() != SCG_SYSTEM_CLOCK_SRC_SIRC))
+          {
+            // enable FIRC
+            returnValue = s32k1xx_firc_config(true, &g_initial_clkconfig.scg.firc);
+            DEBUGASSERT(!returnValue);
+          }
+          // check if the FIRC needs to be disabled and if it is enabled
+          else if((!(g_initial_clkconfig.scg.firc.initialize)) && 
+            (s32k1xx_get_srcfreq(SCG_SYSTEM_CLOCK_SRC_FIRC)))
+          {
+            // disable FIRC
+            returnValue = s32k1xx_firc_config(false, &g_initial_clkconfig.scg.firc);
+            DEBUGASSERT(!returnValue);
+          }
+
+          // check if the SOSC was enabled and it is not the system clock source
+          if(g_initial_clkconfig.scg.sosc.initialize && 
+            (s32k1xx_get_scgclk_source() != SCG_SYSTEM_CLOCK_SRC_SYS_OSC) &&
+            (s32k1xx_get_scgclk_source() != SCG_SYSTEM_CLOCK_SRC_SYS_PLL))
+          {
+            // enable SOSC
+            returnValue = s32k1xx_sosc_config(true, &g_initial_clkconfig.scg.sosc);
+            DEBUGASSERT(!returnValue);
+          }
+          // check if the SOSC needs to be disabled and if it is enabled
+          else if((!(g_initial_clkconfig.scg.sosc.initialize)) && 
+            (s32k1xx_get_srcfreq(SCG_SYSTEM_CLOCK_SRC_SYS_OSC)))
+          {
+            // disable SOSC
+            returnValue = s32k1xx_sosc_config(false, &g_initial_clkconfig.scg.sosc);
+            DEBUGASSERT(!returnValue);
+          }
+
+          // check if the SPLL was enabled and it is not the system clock source
+          if(g_initial_clkconfig.scg.spll.initialize && 
+            (s32k1xx_get_scgclk_source() != SCG_SYSTEM_CLOCK_SRC_SYS_OSC) &&
+            (s32k1xx_get_scgclk_source() != SCG_SYSTEM_CLOCK_SRC_SYS_PLL))
+          {
+            // enable SPLL
+            returnValue = s32k1xx_spll_config(true, &g_initial_clkconfig.scg.spll);
+            DEBUGASSERT(!returnValue);
+          }
+          // check if the SPLL needs to be disabled and if it is enabled
+          else if((!(g_initial_clkconfig.scg.spll.initialize)) && 
+            (s32k1xx_get_srcfreq(SCG_SYSTEM_CLOCK_SRC_SYS_PLL)))
+          {
+            // disable SPLL
+            returnValue = s32k1xx_spll_config(false, &g_initial_clkconfig.scg.spll);
+            DEBUGASSERT(!returnValue);
+          }
+
+          // check if the RCCR clock source is enabled 
+          if(s32k1xx_get_srcfreq(g_initial_clkconfig.scg.clockmode.rccr.src) != 0)
+          {
+            // change the system clock back to the configured clock 
+            // and wait until clock changed
+            if(s32k1xx_transition_systemclock(&g_initial_clkconfig.scg.clockmode.rccr))
+            {
+              // error 
+              DEBUGASSERT(false);
+            }
+          }
+          // if it is 0
+          else
+          {
+            // error
+            DEBUGASSERT(false);
+          }
+
+#endif // CONFIG_RUN_STANDBY
+
+#ifdef CONFIG_VLPR_STANDBY
+
+          // set the system clock to the SIRC 8MHz freq
+          // this freq will change to the predefined vccr settings when the mode change occures
+          // and wait until system clock changed
+          returnValue = s32k1xx_sirc_clocksource();
+          DEBUGASSERT(!returnValue);
+
+          // disable the other clock sources if not already disabled
+          // these are the FIRC, PPL, and SOSC
+
+          // check if the SPLL is enabled
+          if(s32k1xx_get_spllfreq() != 0)
+          {
+            // disable SPLL
+            returnValue = s32k1xx_spll_config(false, &g_initial_clkconfig.scg.spll);
+            DEBUGASSERT(!returnValue);
+          }
+
+          // check if the SOSC is enabled
+          if(s32k1xx_get_soscfreq() != 0)
+          {
+            // disable SOSC
+            returnValue = s32k1xx_sosc_config(false, &g_initial_clkconfig.scg.sosc);
+            DEBUGASSERT(!returnValue);
+          }
+
+          // check if the FIRC is enabled
+          if(s32k1xx_get_fircfreq() != 0)
+          {
+            // disable FIRC
+            returnValue = s32k1xx_firc_config(false, &g_initial_clkconfig.scg.firc);
+            DEBUGASSERT(!returnValue);
+          }
+
+  #ifdef CONFIG_ARCH_CHIP_S32K11X
+            // TODO make sure CMU is gated? (only for S32k11x)
+            #error Make sure CMU is gated
+  #endif
+
+          // change the microcontroller to VLPR mode 
+          // and wait until it is in that runmode
+          returnValue = (int)s32k1xx_set_runmode(SCG_SYSTEM_CLOCK_MODE_VLPR);
+          DEBUGASSERT(returnValue != (int)SCG_SYSTEM_CLOCK_MODE_NONE);
+
+#endif // CONFIG_VLPR_STANDBY
+
+          // calculate the new clock ticks
+          up_timer_initialize();
+
+        }
+        break;
+
+      case(PM_SLEEP):
+        {
+          /* Logic for PM_SLEEP goes here */
+
+#ifdef CONFIG_RUN_SLEEP
+
+          // change the microcontroller to RUN mode 
+          // and wait until in RUN mode
+          returnValue = (int)s32k1xx_set_runmode(SCG_SYSTEM_CLOCK_MODE_RUN);
+          DEBUGASSERT(returnValue != (int)SCG_SYSTEM_CLOCK_MODE_NONE);
+
+          // enable all clock sources again if needed 
+          // these could be the FIRC, PPL, and SOSC
+          
+          // check if the FIRC was enabled and it is not the system clock source
+          if(g_initial_clkconfig.scg.firc.initialize && 
+            (s32k1xx_get_scgclk_source() != SCG_SYSTEM_CLOCK_SRC_SIRC))
+          {
+            // enable FIRC
+            returnValue = s32k1xx_firc_config(true, &g_initial_clkconfig.scg.firc);
+            DEBUGASSERT(!returnValue);
+          }
+          // check if the FIRC needs to be disabled and if it is enabled
+          else if((!(g_initial_clkconfig.scg.firc.initialize)) && 
+            (s32k1xx_get_srcfreq(SCG_SYSTEM_CLOCK_SRC_FIRC)))
+          {
+            // disable FIRC
+            returnValue = s32k1xx_firc_config(false, &g_initial_clkconfig.scg.firc);
+            DEBUGASSERT(!returnValue);
+          }
+
+          // check if the SOSC was enabled and it is not the system clock source
+          if(g_initial_clkconfig.scg.sosc.initialize && 
+            (s32k1xx_get_scgclk_source() != SCG_SYSTEM_CLOCK_SRC_SYS_OSC) &&
+            (s32k1xx_get_scgclk_source() != SCG_SYSTEM_CLOCK_SRC_SYS_PLL))
+          {
+            // enable SOSC
+            returnValue = s32k1xx_sosc_config(true, &g_initial_clkconfig.scg.sosc);
+            DEBUGASSERT(!returnValue);
+          }
+          // check if the SOSC needs to be disabled and if it is enabled
+          else if((!(g_initial_clkconfig.scg.sosc.initialize)) && 
+            (s32k1xx_get_srcfreq(SCG_SYSTEM_CLOCK_SRC_SYS_OSC)))
+          {
+            // disable SOSC
+            returnValue = s32k1xx_sosc_config(false, &g_initial_clkconfig.scg.sosc);
+            DEBUGASSERT(!returnValue);
+          }
+
+          // check if the SPLL was enabled and it is not the system clock source
+          if(g_initial_clkconfig.scg.spll.initialize && 
+            (s32k1xx_get_scgclk_source() != SCG_SYSTEM_CLOCK_SRC_SYS_OSC) &&
+            (s32k1xx_get_scgclk_source() != SCG_SYSTEM_CLOCK_SRC_SYS_PLL))
+          {
+            // enable SPLL
+            returnValue = s32k1xx_spll_config(true, &g_initial_clkconfig.scg.spll);
+            DEBUGASSERT(!returnValue);
+          }
+          // check if the SPLL needs to be disabled and if it is enabled
+          else if((!(g_initial_clkconfig.scg.spll.initialize)) && 
+            (s32k1xx_get_srcfreq(SCG_SYSTEM_CLOCK_SRC_SYS_PLL)))
+          {
+            // disable SPLL
+            returnValue = s32k1xx_spll_config(false, &g_initial_clkconfig.scg.spll);
+            DEBUGASSERT(!returnValue);
+          }
+
+          // check if the RCCR clock source is enabled 
+          if(s32k1xx_get_srcfreq(g_initial_clkconfig.scg.clockmode.rccr.src) != 0)
+          {
+            // change the system clock back to the configured clock 
+            // and wait until clock changed
+            if(s32k1xx_transition_systemclock(&g_initial_clkconfig.scg.clockmode.rccr))
+            {
+              // error 
+              DEBUGASSERT(false);
+            }
+          }
+          // if it is 0
+          else
+          {
+            // error
+            DEBUGASSERT(false);
+          }
+
+#endif // CONFIG_RUN_SLEEP
+
+#ifdef CONFIG_VLPR_SLEEP
+
+          // set the system clock to the SIRC 8MHz freq
+          // this freq will change to the predefined vccr settings when the mode change occures
+          // and wait until system clock changed
+          returnValue = s32k1xx_sirc_clocksource();
+          DEBUGASSERT(!returnValue);
+
+          // disable the other clock sources if not already disabled
+          // these are the FIRC, PPL, and SOSC
+
+          // check if the SPLL is enabled
+          if(s32k1xx_get_spllfreq() != 0)
+          {
+            // disable SPLL
+            returnValue = s32k1xx_spll_config(false, &g_initial_clkconfig.scg.spll);
+            DEBUGASSERT(!returnValue);
+          }
+
+          // check if the SOSC is enabled
+          if(s32k1xx_get_soscfreq() != 0)
+          {
+            // disable SOSC
+            returnValue = s32k1xx_sosc_config(false, &g_initial_clkconfig.scg.sosc);
+            DEBUGASSERT(!returnValue);
+          }
+
+          // check if the FIRC is enabled
+          if(s32k1xx_get_fircfreq() != 0)
+          {
+            // disable FIRC
+            returnValue = s32k1xx_firc_config(false, &g_initial_clkconfig.scg.firc);
+            DEBUGASSERT(!returnValue);
+          }
+
+  #ifdef CONFIG_ARCH_CHIP_S32K11X
+            // TODO make sure CMU is gated? (only for S32k11x)
+            #error Make sure CMU is gated
+  #endif
+          // change the microcontroller to VLPR mode 
+          // and wait until it is in that runmode
+          returnValue = (int)s32k1xx_set_runmode(SCG_SYSTEM_CLOCK_MODE_VLPR);
+          DEBUGASSERT(returnValue != (int)SCG_SYSTEM_CLOCK_MODE_NONE);
+
+#endif // CONFIG_VLPR_SLEEP
+
+          // calculate the new clock ticks
+          up_timer_initialize();
+        }
+        break;
+
+      default:
+
+        /* Should not get here */
+
+        break;
+    }
+}
+#endif
+
+/****************************************************************************
+ * Name: up_pm_prepare
+ *
+ * Description:
+ *   Request the driver to prepare for a new power state. This is a warning
+ *   that the system is about to enter into a new power state. The driver
+ *   should begin whatever operations that may be required to enter power
+ *   state. The driver may abort the state change mode by returning a
+ *   non-zero value from the callback function.
+ *
+ * Input Parameters:
+ *
+ *    cb - Returned to the driver. The driver version of the callback
+ *         structure may include additional, driver-specific state data at
+ *         the end of the structure.
+ *
+ *    pmstate - Identifies the new PM state
+ *
+ * Returned Value:
+ *   Zero - (OK) means the event was successfully processed and that the
+ *          driver is prepared for the PM state change.
+ *
+ *   Non-zero - means that the driver is not prepared to perform the tasks
+ *              needed achieve this power setting and will cause the state
+ *              change to be aborted. NOTE: The prepare() method will also
+ *              be called when reverting from lower back to higher power
+ *              consumption modes (say because another driver refused a
+ *              lower power state change). Drivers are not permitted to
+ *              return non-zero values when reverting back to higher power
+ *              consumption modes!
+ *
+ *
+ ****************************************************************************/
+
+#ifdef CONFIG_PM
+static int up_pm_prepare(struct pm_callback_s *cb, int domain,
+                         enum pm_state_e pmstate)
+{
+  /* Logic to prepare for a reduced power state goes here. */
+  return OK;
+}
+#endif
+
 /****************************************************************************
  * Public Functions
  ****************************************************************************/
+/****************************************************************************
+ * Name: s32k1xx_get_runmode
+ *
+ * Description:
+ *   Get the current running mode.
+ *
+ * Input Parameters:
+ *   None
+ *
+ * Returned Value:
+ *   The current running mode.
+ *
+ ****************************************************************************/
+
+/*static*/ enum scg_system_clock_mode_e s32k1xx_get_runmode(void)
+{
+  enum scg_system_clock_mode_e mode;
+
+  /* Get the current running mode */
+
+  switch (getreg32(S32K1XX_SMC_PMSTAT) & SMC_PMSTAT_PMSTAT_MASK)
+    {
+      /* Run mode */
+
+      case SMC_PMSTAT_PMSTAT_RUN:
+        mode = SCG_SYSTEM_CLOCK_MODE_RUN;
+        break;
+
+      /* Very low power run mode */
+
+      case SMC_PMSTAT_PMSTAT_VLPR:
+        mode = SCG_SYSTEM_CLOCK_MODE_VLPR;
+        break;
+
+      /* High speed run mode */
+
+      case SMC_PMSTAT_PMSTAT_HSRUN:
+        mode = SCG_SYSTEM_CLOCK_MODE_HSRUN;
+        break;
+
+      /* This should never happen - core has to be in some run mode to
+       * execute code
+       */
+
+      case SMC_PMSTAT_PMSTAT_VLPS:
+      default:
+        mode = SCG_SYSTEM_CLOCK_MODE_NONE;
+        break;
+    }
+
+    return mode;
+}
+
+/****************************************************************************
+ * Name: s32k1xx_set_runmode
+ *
+ * Description:
+ *   Set the running mode.
+ *
+ * Input Parameters:
+ *   nextRunMode - The next running mode.
+ *
+ * Returned Value:
+ *   The current running mode.
+ *
+ ****************************************************************************/
+
+enum scg_system_clock_mode_e s32k1xx_set_runmode(enum scg_system_clock_mode_e nextRunMode)
+{
+  enum scg_system_clock_mode_e mode;
+
+  // get the current run mode
+  mode = s32k1xx_get_runmode();
+  uint32_t regval;
+
+  // check if the current runmode is not the same as the next runmode
+  if(mode != nextRunMode)
+  {
+    // check what the next mode is
+    switch(nextRunMode)
+    {
+      // in case of the RUN mode
+      // it will use the clock configuration from S32K1XX_SCG_RCCR
+      case SCG_SYSTEM_CLOCK_MODE_RUN:
+
+        // check if in VLPR mode
+        if(mode == SCG_SYSTEM_CLOCK_MODE_VLPR)
+        {
+          // get the SMC_PMCTRL register
+          regval = getreg32(S32K1XX_SMC_PMCTRL);
+
+          // mask the RUNM bits
+          regval &= ~SMC_PMCTRL_RUNM_MASK;
+
+          // change the mode to RUN mode
+          regval |= SMC_PMCTRL_RUNM_RUN;
+
+          // write the register
+          putreg32(regval, S32K1XX_SMC_PMCTRL);
+
+          // wait until it is in RUN mode
+          while(s32k1xx_get_runmode() != SCG_SYSTEM_CLOCK_MODE_RUN);
+        }
+
+      break;
+      // in case of the VLPR mode
+      // it will use the clock configuration from S32K1XX_SCG_VCCR
+      case SCG_SYSTEM_CLOCK_MODE_VLPR:
+
+        // check if in RUN mode and VLPR mode is allowed
+        if((mode == SCG_SYSTEM_CLOCK_MODE_RUN) && 
+          (getreg32(S32K1XX_SMC_PMPROT) & SMC_PMPROT_AVLP))
+        {
+          // get the SMC_PMCTRL register
+          regval = getreg32(S32K1XX_SMC_PMCTRL);
+
+          // mask the RUNM bits
+          regval &= ~SMC_PMCTRL_RUNM_MASK;
+
+          // change the mode to VLPR mode
+          regval |= SMC_PMCTRL_RUNM_VLPR;
+
+          // write the register
+          putreg32(regval, S32K1XX_SMC_PMCTRL);
+
+          // wait until it is in VLPR mode
+          while(s32k1xx_get_runmode() != SCG_SYSTEM_CLOCK_MODE_VLPR);
+        }
+
+      break;
+
+      // others are not implemented 
+      default:
+      break;
+    }
+
+    // get the current run mode
+    mode = s32k1xx_get_runmode();
+  }
+
+  // return the mode
+  return mode;
+}
 
 /****************************************************************************
  * Name: s32k1xx_clockconfig
@@ -1655,11 +2330,22 @@ int s32k1xx_clockconfig(const struct clock_configuration_s *clkcfg)
 
   DEBUGASSERT(clkcfg != NULL);
 
+#ifdef CONFIG_PM
+  /* Register to receive power management callbacks */
+
+  ret = pm_register(&g_clock_pmcb);
+  DEBUGASSERT(ret == OK);
+#endif
+
   /* Set SCG configuration */
 
   ret = s32k1xx_scg_config(&clkcfg->scg);
   if (ret >= 0)
     {
+
+      /* Allow the VLPR mode */
+      s32k1xx_allow_vlprmode(true);
+
       /* Set PCC configuration */
 
       s32k1xx_periphclocks(clkcfg->pcc.count, clkcfg->pcc.pclks);
diff --git a/arch/arm/src/s32k1xx/s32k1xx_clockconfig.h b/arch/arm/src/s32k1xx/s32k1xx_clockconfig.h
index 6dcbd86084..2f0c0b7276 100644
--- a/arch/arm/src/s32k1xx/s32k1xx_clockconfig.h
+++ b/arch/arm/src/s32k1xx/s32k1xx_clockconfig.h
@@ -440,6 +440,15 @@ struct clock_configuration_s
   struct pmc_config_s pmc;             /* PMC Clock configuration */
 };
 
+enum scg_system_clock_mode_e
+{
+  SCG_SYSTEM_CLOCK_MODE_CURRENT = 0,  /* Current mode. */
+  SCG_SYSTEM_CLOCK_MODE_RUN     = 1,  /* Run mode. */
+  SCG_SYSTEM_CLOCK_MODE_VLPR    = 2,  /* Very Low Power Run mode. */
+  SCG_SYSTEM_CLOCK_MODE_HSRUN   = 3,  /* High Speed Run mode. */
+  SCG_SYSTEM_CLOCK_MODE_NONE          /* MAX value. */
+};
+
 /****************************************************************************
  * Inline Functions
  ****************************************************************************/
@@ -462,6 +471,23 @@ extern "C"
 /****************************************************************************
  * Public Function Prototypes
  ****************************************************************************/
+/*static*/ enum scg_system_clock_mode_e s32k1xx_get_runmode(void);
+  
+/****************************************************************************
+ * Name: s32k1xx_set_runmode
+ *
+ * Description:
+ *   Set the running mode.
+ *
+ * Input Parameters:
+ *   nextRunMode - The next running mode.
+ *
+ * Returned Value:
+ *   The current running mode.
+ *
+ ****************************************************************************/
+
+enum scg_system_clock_mode_e s32k1xx_set_runmode(enum scg_system_clock_mode_e nextRunMode);
 
 /****************************************************************************
  * Name: s32k1xx_clockconfig
diff --git a/arch/arm/src/s32k1xx/s32k1xx_flexcan.c b/arch/arm/src/s32k1xx/s32k1xx_flexcan.c
index 8d28042d71..86312496c2 100644
--- a/arch/arm/src/s32k1xx/s32k1xx_flexcan.c
+++ b/arch/arm/src/s32k1xx/s32k1xx_flexcan.c
@@ -507,12 +507,16 @@ static void s32k1xx_setfreeze(uint32_t base, uint32_t freeze);
 static uint32_t s32k1xx_waitmcr_change(uint32_t base,
                                        uint32_t mask,
                                        uint32_t target_state);
+static uint32_t s32k1xx_waitesr2_change(uint32_t base,
+                                       uint32_t mask,
+                                       uint32_t target_state);
 
 /* Interrupt handling */
 
 static void s32k1xx_receive(FAR struct s32k1xx_driver_s *priv,
                             uint32_t flags);
-static void s32k1xx_txdone(FAR void *arg);
+static void s32k1xx_txdone_work(FAR void *arg);
+static void s32k1xx_txdone(FAR struct s32k1xx_driver_s *priv);
 
 static int  s32k1xx_flexcan_interrupt(int irq, FAR void *context,
                                       FAR void *arg);
@@ -798,6 +802,8 @@ static int s32k1xx_txpoll(struct net_driver_s *dev)
     {
       if (!devif_loopback(&priv->dev))
         {
+          s32k1xx_txdone(priv);
+
           /* Send the packet */
 
           s32k1xx_transmit(priv);
@@ -806,9 +812,14 @@ static int s32k1xx_txpoll(struct net_driver_s *dev)
            * not, return a non-zero value to terminate the poll.
            */
 
-          if (s32k1xx_txringfull(priv))
+          if ((getreg32(priv->base + S32K1XX_CAN_ESR2_OFFSET) &
+              (CAN_ESR2_IMB | CAN_ESR2_VPS)) ==
+              (CAN_ESR2_IMB | CAN_ESR2_VPS))
             {
-              return -EBUSY;
+              if (s32k1xx_txringfull(priv))
+                {
+                  return -EBUSY;
+                }
             }
         }
     }
@@ -963,7 +974,7 @@ static void s32k1xx_receive(FAR struct s32k1xx_driver_s *priv,
  * Function: s32k1xx_txdone
  *
  * Description:
- *   An interrupt was received indicating that the last TX packet(s) is done
+ *   Check transmit interrupt flags and clear them
  *
  * Input Parameters:
  *   priv  - Reference to the driver state structure
@@ -972,14 +983,12 @@ static void s32k1xx_receive(FAR struct s32k1xx_driver_s *priv,
  *   None
  *
  * Assumptions:
- *   Global interrupts are disabled by the watchdog logic.
- *   We are not in an interrupt context so that we can lock the network.
+ *   None
  *
  ****************************************************************************/
 
-static void s32k1xx_txdone(FAR void *arg)
+static void s32k1xx_txdone(FAR struct s32k1xx_driver_s *priv)
 {
-  FAR struct s32k1xx_driver_s *priv = (FAR struct s32k1xx_driver_s *)arg;
   uint32_t flags;
   uint32_t mbi;
   uint32_t mb_bit;
@@ -1010,13 +1019,38 @@ static void s32k1xx_txdone(FAR void *arg)
 
       mb_bit <<= 1;
     }
+}
+
+/****************************************************************************
+ * Function: s32k1xx_txdone_work
+ *
+ * Description:
+ *   An interrupt was received indicating that the last TX packet(s) is done
+ *
+ * Input Parameters:
+ *   priv  - Reference to the driver state structure
+ *
+ * Returned Value:
+ *   None
+ *
+ * Assumptions:
+ *   Global interrupts are disabled by the watchdog logic.
+ *   We are not in an interrupt context so that we can lock the network.
+ *
+ ****************************************************************************/
+
+static void s32k1xx_txdone_work(FAR void *arg)
+{
+  FAR struct s32k1xx_driver_s *priv = (FAR struct s32k1xx_driver_s *)arg;
+
+  s32k1xx_txdone(priv);
 
   /* There should be space for a new TX in any event.  Poll the network for
    * new XMIT data
    */
 
   net_lock();
-  devif_poll(&priv->dev, s32k1xx_txpoll);
+  devif_timer(&priv->dev, 0, s32k1xx_txpoll);
   net_unlock();
 }
 
@@ -1072,7 +1106,7 @@ static int s32k1xx_flexcan_interrupt(int irq, FAR void *context,
           flags  = getreg32(priv->base + S32K1XX_CAN_IMASK1_OFFSET);
           flags &= ~(IFLAG1_TX);
           putreg32(flags, priv->base + S32K1XX_CAN_IMASK1_OFFSET);
-          work_queue(CANWORK, &priv->irqwork, s32k1xx_txdone, priv, 0);
+          work_queue(CANWORK, &priv->irqwork, s32k1xx_txdone_work, priv, 0);
         }
     }
 
@@ -1174,6 +1208,26 @@ static void s32k1xx_setenable(uint32_t base, uint32_t enable)
   s32k1xx_waitmcr_change(base, CAN_MCR_LPMACK, 1);
 }
 
+static uint32_t s32k1xx_waitesr2_change(uint32_t base, uint32_t mask,
+                                       uint32_t target_state)
+{
+  const uint32_t timeout = 1000;
+  uint32_t wait_ack;
+
+  for (wait_ack = 0; wait_ack < timeout; wait_ack++)
+    {
+      uint32_t state = (getreg32(base + S32K1XX_CAN_ESR2_OFFSET) & mask);
+      if (state == target_state)
+        {
+          return true;
+        }
+
+      up_udelay(10);
+    }
+
+  return false;
+}
+
 static void s32k1xx_setfreeze(uint32_t base, uint32_t freeze)
 {
   uint32_t regval;
@@ -1333,7 +1387,9 @@ static void s32k1xx_txavail_work(FAR void *arg)
        * packet.
        */
 
-      if (!s32k1xx_txringfull(priv))
+      if (s32k1xx_waitesr2_change(priv->base,
+                             (CAN_ESR2_IMB | CAN_ESR2_VPS),
+                             (CAN_ESR2_IMB | CAN_ESR2_VPS)))
         {
           /* No, there is space for another transfer.  Poll the network for
            * new XMIT data.
@@ -1532,6 +1588,9 @@ static int s32k1xx_initialize(struct s32k1xx_driver_s *priv)
 
 #ifndef CONFIG_NET_CAN_CANFD
   regval  = getreg32(priv->base + S32K1XX_CAN_CTRL1_OFFSET);
+
+  regval &= ~(CAN_CTRL1_TIMINGMSK); /* Reset timings */
+
   regval |= CAN_CTRL1_PRESDIV(priv->arbi_timing.presdiv) | /* Prescaler divisor factor */
             CAN_CTRL1_PROPSEG(priv->arbi_timing.propseg) | /* Propagation segment */
             CAN_CTRL1_PSEG1(priv->arbi_timing.pseg1) |     /* Phase buffer segment 1 */
@@ -1540,8 +1599,8 @@ static int s32k1xx_initialize(struct s32k1xx_driver_s *priv)
   putreg32(regval, priv->base + S32K1XX_CAN_CTRL1_OFFSET);
 
 #else
-  regval  = getreg32(priv->base + S32K1XX_CAN_CBT_OFFSET);
-            regval |= CAN_CBT_BTF |                       /* Enable extended bit timing
+
+  regval  = CAN_CBT_BTF |                                 /* Enable extended bit timing
                                                            * configurations for CAN-FD for setting up
                                                            * separately nominal and data phase */
             CAN_CBT_EPRESDIV(priv->arbi_timing.presdiv) | /* Prescaler divisor factor */
@@ -1557,8 +1616,7 @@ static int s32k1xx_initialize(struct s32k1xx_driver_s *priv)
   regval |= CAN_MCR_FDEN;
   putreg32(regval, priv->base + S32K1XX_CAN_MCR_OFFSET);
 
-  regval  = getreg32(priv->base + S32K1XX_CAN_FDCBT_OFFSET);
-  regval |= CAN_FDCBT_FPRESDIV(priv->data_timing.presdiv) |  /* Prescaler divisor factor of 1 */
+  regval  = CAN_FDCBT_FPRESDIV(priv->data_timing.presdiv) |  /* Prescaler divisor factor of 1 */
             CAN_FDCBT_FPROPSEG(priv->data_timing.propseg) |  /* Propagation
                                                               * segment (only register that doesn't add 1) */
             CAN_FDCBT_FPSEG1(priv->data_timing.pseg1) |      /* Phase buffer segment 1 */
@@ -1568,9 +1626,7 @@ static int s32k1xx_initialize(struct s32k1xx_driver_s *priv)
 
   /* Additional CAN-FD configurations */
 
-  regval  = getreg32(priv->base + S32K1XX_CAN_FDCTRL_OFFSET);
-
-  regval |= CAN_FDCTRL_FDRATE |     /* Enable bit rate switch in data phase of frame */
+  regval  = CAN_FDCTRL_FDRATE |     /* Enable bit rate switch in data phase of frame */
             CAN_FDCTRL_TDCEN |      /* Enable transceiver delay compensation */
             CAN_FDCTRL_TDCOFF(5) |  /* Setup 5 cycles for data phase sampling delay */
             CAN_FDCTRL_MBDSR0(3);   /* Setup 64 bytes per message buffer (7 MB's) */
@@ -1590,7 +1646,7 @@ static int s32k1xx_initialize(struct s32k1xx_driver_s *priv)
 
   putreg32(0x0, priv->base + S32K1XX_CAN_RXFGMASK_OFFSET);
 
-  for (i = 0; i < TOTALMBCOUNT; i++)
+  for (i = 0; i < S32K1XX_CAN_RXIMR_COUNT; i++)
     {
       putreg32(0, priv->base + S32K1XX_CAN_RXIMR_OFFSET(i));
     }
@@ -1868,6 +1924,8 @@ int s32k1xx_caninitialize(int intf)
 
   ninfo("callbacks done\r\n");
 
+  s32k1xx_initialize(priv);
+
   s32k1xx_ifdown(&priv->dev);
 
   /* Register the device with the OS so that socket IOCTLs can be performed */
diff --git a/arch/arm/src/s32k1xx/s32k1xx_lpi2c.c b/arch/arm/src/s32k1xx/s32k1xx_lpi2c.c
index 2eb9f19aec..bee6eb3b2c 100644
--- a/arch/arm/src/s32k1xx/s32k1xx_lpi2c.c
+++ b/arch/arm/src/s32k1xx/s32k1xx_lpi2c.c
@@ -15,7 +15,7 @@
  *    the documentation and/or other materials provided with the
  *    distribution.
  * 3. Neither the name NuttX nor the names of its contributors may be
- *    used to endorse or promote products derived from this softwareGPIO
+ *    used to endorse or promote products derived from this software
  *    without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
@@ -118,22 +118,11 @@
 #  define CONFIG_I2C_NTRACE 32
 #endif
 
-#ifdef CONFIG_I2C_SLAVE
-#  error I2C slave logic is not supported yet for S32K1XX
-#endif
-
 #define LPI2C_MASTER    1
 #define LPI2C_SLAVE     2
 
-#define MKI2C_OUTPUT(p) (((p) & GPIO_PADMUX_MASK) | \
-                         IOMUX_OPENDRAIN | IOMUX_DRIVE_33OHM | \
-                         IOMUX_SLEW_SLOW | (5 << GPIO_ALT_SHIFT) | \
-                         IOMUX_PULL_NONE | GPIO_OUTPUT_ONE)
-
-#define MKI2C_INPUT(p) (((p) & GPIO_PADMUX_MASK) | \
-                        IOMUX_DRIVE_HIZ | IOMUX_SLEW_SLOW | \
-                        IOMUX_CMOS_INPUT | (5 << GPIO_ALT_SHIFT) | \
-                        IOMUX_PULL_NONE)
+#define MKI2C_OUTPUT(p) (((p) & (~_PIN_MODE_MASK)) | GPIO_OUTPUT | GPIO_OUTPUT_ONE)
+#define MKI2C_INPUT(p)  (((p) & (~_PIN_MODE_MASK)) | GPIO_INPUT)
 
 /****************************************************************************
  * Private Types
@@ -155,10 +144,10 @@ enum s32k1xx_trace_e
   I2CEVENT_NONE = 0,      /* No events have occurred with this status */
   I2CEVENT_SENDADDR,      /* Start/Master bit set and address sent, param = msgc */
   I2CEVENT_SENDBYTE,      /* Send byte, param = dcnt */
-  I2CEVENT_RCVBYTE,       /* Read more dta, param = dcnt */
+  I2CEVENT_RCVBYTE,       /* Read more data, param = dcnt */
   I2CEVENT_NOSTART,       /* BTF on last byte with no restart, param = msgc */
   I2CEVENT_STARTRESTART,  /* Last byte sent, re-starting, param = msgc */
-  I2CEVENT_STOP,          /* Last byte sten, send stop, param = 0 */
+  I2CEVENT_STOP,          /* Last byte sent, send stop, param = 0 */
   I2CEVENT_ERROR          /* Error occurred, param = 0 */
 };
 
@@ -173,7 +162,7 @@ struct s32k1xx_trace_s
   clock_t time;                  /* First of event or first status */
 };
 
-/* I2C Device hardware configuration */
+/* I2C device hardware configuration */
 
 struct s32k1xx_lpi2c_config_s
 {
@@ -283,7 +272,7 @@ static inline void
 static inline uint32_t
   s32k1xx_lpi2c_getstatus(FAR struct s32k1xx_lpi2c_priv_s *priv);
 
-static int s32k1xx_lpi2c_isr_process(struct s32k1xx_lpi2c_priv_s * priv);
+static int s32k1xx_lpi2c_isr_process(struct s32k1xx_lpi2c_priv_s *priv);
 
 #ifndef CONFIG_I2C_POLLED
 static int s32k1xx_lpi2c_isr(int irq, void *context, FAR void *arg);
@@ -321,9 +310,9 @@ static const char *g_trace_names[] =
 
 static const struct i2c_ops_s s32k1xx_lpi2c_ops =
 {
-  .transfer = s32k1xx_lpi2c_transfer
+  .transfer = s32k1xx_lpi2c_transfer,
 #ifdef CONFIG_I2C_RESET
-  , .reset  = s32k1xx_lpi2c_reset
+  .reset  = s32k1xx_lpi2c_reset,
 #endif
 };
 
@@ -338,11 +327,7 @@ static const struct s32k1xx_lpi2c_config_s s32k1xx_lpi2c0_config =
   .filtsda    = CONFIG_LPI2C0_FILTSDA,
   .scl_pin    = PIN_LPI2C0_SCL,
   .sda_pin    = PIN_LPI2C0_SDA,
-#ifndef CONFIG_I2C_SLAVE
   .mode       = LPI2C_MASTER,
-#else
-  .mode       = LPI2C_SLAVE,
-#endif
 #ifndef CONFIG_I2C_POLLED
   .irq        = S32K1XX_IRQ_LPI2C0M,
 #endif
@@ -359,9 +344,9 @@ static struct s32k1xx_lpi2c_priv_s s32k1xx_lpi2c0_priv =
   .ptr        = NULL,
   .dcnt       = 0,
   .flags      = 0,
-  .status     = 0
+  .status     = 0,
 };
-#endif
+#endif /* CONFIG_S32K1XX_LPI2C0 */
 
 #ifdef CONFIG_S32K1XX_LPI2C1
 static const struct s32k1xx_lpi2c_config_s s32k1xx_lpi2c1_config =
@@ -372,11 +357,7 @@ static const struct s32k1xx_lpi2c_config_s s32k1xx_lpi2c1_config =
   .filtsda    = CONFIG_LPI2C1_FILTSDA,
   .scl_pin    = PIN_LPI2C1_SCL,
   .sda_pin    = PIN_LPI2C1_SDA,
-#ifndef CONFIG_I2C_SLAVE
   .mode       = LPI2C_MASTER,
-#else
-  .mode       = LPI2C_SLAVE,
-#endif
 #ifndef CONFIG_I2C_POLLED
   .irq        = S32K1XX_IRQ_LPI2C1M,
 #endif
@@ -393,9 +374,9 @@ static struct s32k1xx_lpi2c_priv_s s32k1xx_lpi2c1_priv =
   .ptr        = NULL,
   .dcnt       = 0,
   .flags      = 0,
-  .status     = 0
+  .status     = 0,
 };
-#endif
+#endif /* CONFIG_S32K1XX_LPI2C1 */
 
 /****************************************************************************
  * Private Functions
@@ -605,12 +586,14 @@ static inline int
       s32k1xx_lpi2c_putreg(priv, S32K1XX_LPI2C_MIER_OFFSET, 0);
     }
 
+#if 0
   /* Enable Interrupts when slave mode */
 
   else
     {
       s32k1xx_lpi2c_putreg(priv, S32K1XX_LPI2C_SIER_OFFSET, 0);
     }
+#endif
 
   leave_critical_section(flags);
   return ret;
@@ -1212,7 +1195,7 @@ static int s32k1xx_lpi2c_isr_process(struct s32k1xx_lpi2c_priv_s *priv)
 
   s32k1xx_lpi2c_tracenew(priv, status);
 
-  /* After an error we can get an SDF  */
+  /* After an error we can get a STOP Detect Flag  */
 
   if (priv->intstate == INTSTATE_DONE && (status & LPI2C_MSR_SDF) != 0)
     {
@@ -1285,9 +1268,9 @@ static int s32k1xx_lpi2c_isr_process(struct s32k1xx_lpi2c_priv_s *priv)
     {
       if (priv->msgc > 0 && priv->msgv != NULL)
         {
-          priv->ptr        = priv->msgv->buffer;
-          priv->dcnt    = priv->msgv->length;
-          priv->flags    = priv->msgv->flags;
+          priv->ptr   = priv->msgv->buffer;
+          priv->dcnt  = priv->msgv->length;
+          priv->flags = priv->msgv->flags;
 
           if ((priv->msgv->flags & I2C_M_NOSTART) == 0)
             {
@@ -1444,9 +1427,9 @@ static int s32k1xx_lpi2c_isr(int irq, void *context, FAR void *arg)
 
 static int s32k1xx_lpi2c_init(FAR struct s32k1xx_lpi2c_priv_s *priv)
 {
-  /* Power-up and configure GPIOs .
+  /* Power-up and configure pins.
    *
-   * NOTE: Clocking to the LPSPI peripheral must be provided by
+   * NOTE: Clocking to the LPI2C peripheral must be provided by
    * board-specific logic as part of the clock configuration logic.
    */
 
@@ -1460,7 +1443,7 @@ static int s32k1xx_lpi2c_init(FAR struct s32k1xx_lpi2c_priv_s *priv)
   s32k1xx_lpi2c_putreg(priv, S32K1XX_LPI2C_MCR_OFFSET, LPI2C_MCR_RST);
   s32k1xx_lpi2c_putreg(priv, S32K1XX_LPI2C_MCR_OFFSET, 0);
 
-  /* Disable doze mode (Set DOZEN bit in 1 to disable) */
+  /* Disable doze mode (Set DOZEN bit to 1 to disable) */
 
   s32k1xx_lpi2c_putreg(priv, S32K1XX_LPI2C_MCR_OFFSET, LPI2C_MCR_DOZEN);
 
@@ -1598,7 +1581,7 @@ static int s32k1xx_lpi2c_transfer(FAR struct i2c_master_s *dev,
 
   priv->status = 0;
 
-  /* Wait for an ISR, if there was a timeout, fetch latest status to get
+  /* Wait for ISR. If there was a timeout, fetch latest status to get
    * the BUSY flag.
    */
 
@@ -1833,7 +1816,7 @@ FAR struct i2c_master_s *s32k1xx_i2cbus_initialize(int port)
     }
 
   /* Initialize private data for the first time, increment reference count,
-   * power-up hardware and configure GPIOs.
+   * power-up hardware and configure pins.
    */
 
   flags = enter_critical_section();
diff --git a/arch/arm/src/s32k1xx/s32k1xx_lpi2c_slave.c b/arch/arm/src/s32k1xx/s32k1xx_lpi2c_slave.c
new file mode 100644
index 0000000000..6b8422750b
--- /dev/null
+++ b/arch/arm/src/s32k1xx/s32k1xx_lpi2c_slave.c
@@ -0,0 +1,929 @@
+/****************************************************************************
+ * arch/arm/src/s32k1xx/s32k1xx_lpi2c_slave.c
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.  The
+ * ASF licenses this file to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ *
+ ****************************************************************************/
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include <sys/types.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <errno.h>
+#include <debug.h>
+
+#include <nuttx/arch.h>
+#include <nuttx/irq.h>
+#include <nuttx/clock.h>
+#include <nuttx/i2c/i2c_slave.h>
+
+#include <arch/irq.h>
+
+#include "arm_arch.h"
+
+#include "s32k1xx_pin.h"
+#include "hardware/s32k1xx_pinmux.h"
+#include "s32k1xx_lpi2c.h"
+#include "s32k1xx_periphclocks.h"
+
+#include <arch/board/board.h>
+
+/* At least one I2C peripheral must be enabled */
+
+#ifdef CONFIG_S32K1XX_LPI2C
+
+/****************************************************************************
+ * Pre-processor Definitions
+ ****************************************************************************/
+
+#ifdef CONFIG_ARCH_CHIP_S32K11X
+#warning LPI2C slave logic does not support S32K11X (yet)
+#endif
+
+#ifdef CONFIG_I2C_POLLED
+#warning LPI2C slave logic does not support polling (yet)
+#endif
+
+#ifdef CONFIG_I2C_TRACE
+#warning LPI2C slave logic does not support I2C trace debugging (yet)
+#endif
+
+/****************************************************************************
+ * Private Types
+ ****************************************************************************/
+
+/* I2C slave device hardware configuration */
+
+struct s32k1xx_lpi2c_slave_config_s
+{
+  uint32_t base;      /* LPI2C base address */
+  bool     slave_bus; /* Separate I2C slave bus? */
+  uint32_t scl_pin;   /* GPIO configuration for SCL as SCL */
+  uint32_t sda_pin;   /* GPIO configuration for SDA as SDA */
+  uint32_t irq;       /* Event IRQ */
+};
+
+/* I2C slave device private data */
+
+struct s32k1xx_lpi2c_slave_priv_s
+{
+  const struct i2c_slaveops_s *ops;                  /* I2C slave operations */
+  const struct s32k1xx_lpi2c_slave_config_s *config; /* LPI2C slave configuration */
+
+  int slave_addr; /* I2C address of the slave */
+  int addr_nbits; /* 7- or 10-bit addressing */
+
+  uint8_t *read_buffer; /* Read buffer (master wants to write, slave will read data) */
+  int read_buflen;      /* Read buffer size */
+  int read_bufindex;    /* Read buffer index */
+
+  const uint8_t *write_buffer; /* Write buffer (master wants to read, slave will write data) */
+  int write_buflen;            /* Write buffer size */
+  int write_bufindex;          /* Write buffer index */
+
+  int (*callback)(FAR void *arg); /* Callback function when data has been received */
+  void *callback_arg;             /* Argument of callback function */
+
+  int refs; /* Reference count */
+};
+
+/****************************************************************************
+ * Private Function Prototypes
+ ****************************************************************************/
+
+static inline uint32_t s32k1xx_lpi2c_slave_getreg(
+  FAR struct s32k1xx_lpi2c_slave_priv_s *priv, uint16_t offset);
+static inline void s32k1xx_lpi2c_slave_putreg(
+  FAR struct s32k1xx_lpi2c_slave_priv_s *priv, uint16_t offset,
+  uint32_t value);
+static inline void s32k1xx_lpi2c_slave_modifyreg(
+  FAR struct s32k1xx_lpi2c_slave_priv_s *priv, uint16_t offset,
+  uint32_t clearbits, uint32_t setbits);
+
+static int s32k1xx_lpi2c_slave_isr_process(
+  FAR struct s32k1xx_lpi2c_slave_priv_s *priv);
+static int s32k1xx_lpi2c_slave_isr(int irq, void *context, FAR void *arg);
+
+static int s32k1xx_lpi2c_slave_init(
+  FAR struct s32k1xx_lpi2c_slave_priv_s *priv);
+static int s32k1xx_lpi2c_slave_deinit(
+  FAR struct s32k1xx_lpi2c_slave_priv_s *priv);
+
+static int s32k1xx_lpi2c_setownaddress(FAR struct i2c_slave_s *dev, int addr,
+                                       int nbits);
+static int s32k1xx_lpi2c_write(FAR struct i2c_slave_s *dev,
+                               FAR const uint8_t *buffer, int buflen);
+static int s32k1xx_lpi2c_read(FAR struct i2c_slave_s *dev,
+                              FAR uint8_t *buffer, int buflen);
+static int s32k1xx_lpi2c_registercallback(FAR struct i2c_slave_s *dev,
+                                          int (*callback)(FAR void *arg),
+                                          FAR void *arg);
+
+/****************************************************************************
+ * Private Data
+ ****************************************************************************/
+
+/* I2C slave interface */
+
+static const struct i2c_slaveops_s s32k1xx_lpi2c_slaveops =
+{
+  .setownaddress    = s32k1xx_lpi2c_setownaddress,
+  .write            = s32k1xx_lpi2c_write,
+  .read             = s32k1xx_lpi2c_read,
+  .registercallback = s32k1xx_lpi2c_registercallback,
+};
+
+/* I2C device structures */
+
+#ifdef CONFIG_S32K1XX_LPI2C0
+static const struct s32k1xx_lpi2c_slave_config_s s32k1xx_lpi2c0s_config =
+{
+  .base      = S32K1XX_LPI2C0_BASE,
+
+#ifdef CONFIG_LPI2C0_SLAVE_BUS
+  .slave_bus = true,
+  .scl_pin   = PIN_LPI2C0S_SCL,
+  .sda_pin   = PIN_LPI2C0S_SDA,
+#else
+  .slave_bus = false,
+  .scl_pin   = PIN_LPI2C0_SCL,
+  .sda_pin   = PIN_LPI2C0_SDA,
+#endif
+
+  .irq       = S32K1XX_IRQ_LPI2C0S,
+};
+
+static struct s32k1xx_lpi2c_slave_priv_s s32k1xx_lpi2c0s_priv =
+{
+  .ops            = &s32k1xx_lpi2c_slaveops,
+  .config         = &s32k1xx_lpi2c0s_config,
+  .slave_addr     = CONFIG_LPI2C0_SLAVE_ADDRESS,
+  .addr_nbits     = 7,
+  .read_buffer    = NULL,
+  .read_buflen    = 0,
+  .read_bufindex  = 0,
+  .write_buffer   = NULL,
+  .write_buflen   = 0,
+  .write_bufindex = 0,
+  .callback       = NULL,
+  .callback_arg   = NULL,
+  .refs           = 0,
+};
+#endif /* CONFIG_S32K1XX_LPI2C0 */
+
+#ifdef CONFIG_S32K1XX_LPI2C1
+static const struct s32k1xx_lpi2c_slave_config_s s32k1xx_lpi2c1s_config =
+{
+  .base      = S32K1XX_LPI2C1_BASE,
+
+#ifdef CONFIG_LPI2C1_SLAVE_BUS
+  .slave_bus = true,
+  .scl_pin   = PIN_LPI2C1S_SCL,
+  .sda_pin   = PIN_LPI2C1S_SDA,
+#else
+  .slave_bus = false,
+  .scl_pin   = PIN_LPI2C1_SCL,
+  .sda_pin   = PIN_LPI2C1_SDA,
+#endif
+
+  .irq       = S32K1XX_IRQ_LPI2C1S,
+};
+
+static struct s32k1xx_lpi2c_slave_priv_s s32k1xx_lpi2c1s_priv =
+{
+  .ops            = &s32k1xx_lpi2c_slaveops,
+  .config         = &s32k1xx_lpi2c1s_config,
+  .slave_addr     = CONFIG_LPI2C1_SLAVE_ADDRESS,
+  .addr_nbits     = 7,
+  .read_buffer    = NULL,
+  .read_buflen    = 0,
+  .read_bufindex  = 0,
+  .write_buffer   = NULL,
+  .write_buflen   = 0,
+  .write_bufindex = 0,
+  .callback       = NULL,
+  .callback_arg   = NULL,
+  .refs           = 0,
+};
+#endif /* CONFIG_S32K1XX_LPI2C1 */
+
+/****************************************************************************
+ * Private Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: s32k1xx_lpi2c_slave_getreg
+ *
+ * Description:
+ *   Get a 32-bit register value by offset
+ *
+ * Input Parameters:
+ *   priv   - I2C slave device private data
+ *   offset - Register offset with respect to the base address of the I2C
+ *            peripheral
+ *
+ * Returned Value:
+ *   The 32-bit value retrieved from the register
+ *
+ ****************************************************************************/
+
+static inline uint32_t s32k1xx_lpi2c_slave_getreg(
+  FAR struct s32k1xx_lpi2c_slave_priv_s *priv, uint16_t offset)
+{
+  return getreg32(priv->config->base + offset);
+}
+
+/****************************************************************************
+ * Name: s32k1xx_lpi2c_slave_putreg
+ *
+ * Description:
+ *  Put a 32-bit register value by offset
+ *
+ * Input Parameters:
+ *   priv   - I2C slave device private data
+ *   offset - Register offset with respect to the base address of the I2C
+ *            peripheral
+ *   value  - The 32-bit value that should be put into the register
+ *
+ ****************************************************************************/
+
+static inline void s32k1xx_lpi2c_slave_putreg(
+  FAR struct s32k1xx_lpi2c_slave_priv_s *priv, uint16_t offset,
+  uint32_t value)
+{
+  putreg32(value, priv->config->base + offset);
+}
+
+/****************************************************************************
+ * Name: s32k1xx_lpi2c_slave_modifyreg
+ *
+ * Description:
+ *   Modify a 32-bit register value by offset
+ *
+ * Input Parameters:
+ *   priv      - I2C slave device private data
+ *   offset    - Register offset with respect to the base address of the I2C
+ *               peripheral
+ *   clearbits - Bitmask with the bits that should be cleared (put to 0)
+ *   setbits   - Bitmask with the bits that should be set (put to 1)
+ *
+ ****************************************************************************/
+
+static inline void s32k1xx_lpi2c_slave_modifyreg(
+  FAR struct s32k1xx_lpi2c_slave_priv_s *priv, uint16_t offset,
+  uint32_t clearbits, uint32_t setbits)
+{
+  modifyreg32(priv->config->base + offset, clearbits, setbits);
+}
+
+/****************************************************************************
+ * Name: s32k1xx_lpi2c_slave_isr_process
+ *
+ * Description:
+ *   Process LPI2C slave interrupts.  Check for relevant flags and read or
+ *   write data to buffers.  After a block of data has been received a
+ *   callback function (if any) may be invoked, which might install a new
+ *   write buffer to transmit data when requested.
+ *
+ * Input Parameters:
+ *   priv - I2C slave device private data
+ *
+ * Returned Value:
+ *   OK when successful, or a negated errno when there is an error.
+ *
+ ****************************************************************************/
+
+static int s32k1xx_lpi2c_slave_isr_process(
+  FAR struct s32k1xx_lpi2c_slave_priv_s *priv)
+{
+  uint32_t status = s32k1xx_lpi2c_slave_getreg(priv,
+                                               S32K1XX_LPI2C_SSR_OFFSET);
+
+  /* Slave Address Valid Flag */
+
+  if (status & LPI2C_SSR_AVF)
+    {
+      /* A new transfer was initiated by a bus master.  The transfer request
+       * was addressed to this particular device.  It needs to be checked if
+       * the master wants to read or write.
+       */
+
+      uint16_t address = (uint16_t) (s32k1xx_lpi2c_slave_getreg(priv,
+        S32K1XX_LPI2C_SASR_OFFSET) & LPI2C_SASR_RADDR_MASK);
+
+      if (address & I2CS_READBIT)
+        {
+          /* Master wants to read, so the slave needs to write/transmit.
+           * The Transmit Data Interrupt will only be enabled now, see
+           * erratum 10792.  Also reset the buffer index back to zero to
+           * start sending again from the beginning.
+           */
+
+          s32k1xx_lpi2c_slave_modifyreg(priv, S32K1XX_LPI2C_SIER_OFFSET, 0,
+                                        LPI2C_SIER_TDIE);
+
+          priv->write_bufindex = 0;
+        }
+      else
+        {
+          /* Master wants to write, so the slave needs to read.  The Receive
+           * Data Interrupt remains enabled, so just reset the buffer index.
+           */
+
+          priv->read_bufindex = 0;
+        }
+    }
+
+  /* Slave Transmits Data Flag (master wants to read) */
+
+  if (status & LPI2C_SSR_TDF)
+    {
+      /* Make sure that interrupts are enabled for this event */
+
+      if (s32k1xx_lpi2c_slave_getreg(priv,
+        S32K1XX_LPI2C_SIER_OFFSET) & LPI2C_SIER_TDIE)
+        {
+          if (priv->write_buflen > priv->write_bufindex)
+            {
+              /* Transmit data from buffer */
+
+              s32k1xx_lpi2c_slave_putreg(priv, S32K1XX_LPI2C_STDR_OFFSET,
+                (uint32_t) priv->write_buffer[priv->write_bufindex]);
+              priv->write_bufindex++;
+            }
+          else
+            {
+              /* Beyond the buffer length.  Transmit dummy data... */
+
+              s32k1xx_lpi2c_slave_putreg(priv, S32K1XX_LPI2C_STDR_OFFSET, 0);
+            }
+        }
+    }
+
+  /* Slave Receives Data (master wants to write) */
+
+  if (status & LPI2C_SSR_RDF)
+    {
+      /* Make sure that interrupts are enabled for this event */
+
+      if (s32k1xx_lpi2c_slave_getreg(priv,
+        S32K1XX_LPI2C_SIER_OFFSET) & LPI2C_SIER_RDIE)
+        {
+          if (priv->read_buflen > priv->read_bufindex)
+            {
+              /* Read data into buffer */
+
+              priv->read_buffer[priv->read_bufindex] =
+                (uint8_t) s32k1xx_lpi2c_slave_getreg(priv,
+                  S32K1XX_LPI2C_SRDR_OFFSET);
+              priv->read_bufindex++;
+            }
+          else
+            {
+              /* Dummy read, throw away the data */
+
+              s32k1xx_lpi2c_slave_getreg(priv, S32K1XX_LPI2C_SRDR_OFFSET);
+            }
+        }
+    }
+
+  /* Stop or Repeated Start (current transfer is over) */
+
+  if (s32k1xx_lpi2c_slave_getreg(priv, S32K1XX_LPI2C_SSR_OFFSET) & \
+      (LPI2C_SSR_SDF | LPI2C_SSR_RSF))
+    {
+      /* Clear Stop Detect / Repeated Start Flags */
+
+      s32k1xx_lpi2c_slave_putreg(priv, S32K1XX_LPI2C_SSR_OFFSET,
+                                 LPI2C_SSR_SDF | LPI2C_SSR_RSF);
+
+      /* Disable the Transmit Data Interrupt again, see erratum 10792 */
+
+      s32k1xx_lpi2c_slave_modifyreg(priv, S32K1XX_LPI2C_SIER_OFFSET,
+                                    LPI2C_SIER_TDIE, 0);
+
+      /* Execute the registered callback function if data was received */
+
+      if ((priv->read_bufindex > 0) && (priv->callback != NULL))
+        {
+          priv->callback(priv->callback_arg);
+        }
+    }
+
+  /* Slave Bit Error (abort current transfer) */
+
+  if (s32k1xx_lpi2c_slave_getreg(priv, S32K1XX_LPI2C_SSR_OFFSET) & \
+      LPI2C_SSR_BEF)
+    {
+      /* Clear Bit Error Flag */
+
+      s32k1xx_lpi2c_slave_putreg(priv, S32K1XX_LPI2C_SSR_OFFSET,
+                                 LPI2C_SSR_BEF);
+
+      /* Disable the Transmit Data Interrupt again, see erratum 10792 */
+
+      s32k1xx_lpi2c_slave_modifyreg(priv, S32K1XX_LPI2C_SIER_OFFSET,
+                                    LPI2C_SIER_TDIE, 0);
+    }
+
+  return OK;
+}
+
+/****************************************************************************
+ * Name: s32k1xx_lpi2c_slave_isr
+ *
+ * Description:
+ *   Interrupt Service Routine for LPI2C slave devices.  Retrieves the
+ *   private data from the argument, further processing is done by
+ *   s32k1xx_lpi2c_slave_isr_process().
+ *
+ * Input Parameters:
+ *   irq     - Number of the IRQ that generated the interrupt
+ *   context - Interrupt register state save info (architecture-specific)
+ *   arg     - I2C slave device private data
+ *
+ * Returned Value:
+ *   OK when successful, or a negated errno when there is an error.
+ *
+ ****************************************************************************/
+
+static int s32k1xx_lpi2c_slave_isr(int irq, void *context, FAR void *arg)
+{
+  struct s32k1xx_lpi2c_slave_priv_s *priv =
+    (struct s32k1xx_lpi2c_slave_priv_s *)arg;
+
+  DEBUGASSERT(priv != NULL);
+
+  return s32k1xx_lpi2c_slave_isr_process(priv);
+}
+
+/****************************************************************************
+ * Name: s32k1xx_lpi2c_slave_init
+ *
+ * Description:
+ *   Initialize the LPI2C slave device.  Enable and configure the peripheral
+ *   and enable the interrupts and attach handlers.
+ *
+ * Input Parameters:
+ *   priv - I2C slave device private data
+ *
+ * Returned Value:
+ *   OK when successful, or a negated errno when there is an error.
+ *
+ ****************************************************************************/
+
+static int s32k1xx_lpi2c_slave_init(
+  FAR struct s32k1xx_lpi2c_slave_priv_s *priv)
+{
+  int ret;
+
+  /* Reset LPI2C slave mode logic before configuring it */
+
+  s32k1xx_lpi2c_slave_putreg(priv, S32K1XX_LPI2C_SCR_OFFSET, LPI2C_SCR_RST);
+  s32k1xx_lpi2c_slave_putreg(priv, S32K1XX_LPI2C_SCR_OFFSET, 0);
+
+  /* Configure pins and power up peripheral.
+   *
+   * NOTE: Clocking to the LPI2C peripheral must be provided by
+   * board-specific logic as part of the clock configuration logic.
+   */
+
+  ret = s32k1xx_pinconfig(priv->config->scl_pin);
+  if (ret != OK)
+    {
+      return ret;
+    }
+
+  ret = s32k1xx_pinconfig(priv->config->sda_pin);
+  if (ret != OK)
+    {
+      return ret;
+    }
+
+  /* Choose between a combined or separated LPI2C master and slave.  When a
+   * separate slave bus is selected, the LPI2C slave will use different pins
+   * than the LPI2C master.  These pins should be defined in board.h
+   */
+
+  if (priv->config->slave_bus)
+    {
+      s32k1xx_lpi2c_slave_modifyreg(priv, S32K1XX_LPI2C_MCFGR1_OFFSET, 
+        LPI2C_MCFGR1_PINCFG_MASK, LPI2C_MCFGR1_PINCFG4);
+    }
+  else
+    {
+      s32k1xx_lpi2c_slave_modifyreg(priv, S32K1XX_LPI2C_MCFGR1_OFFSET, 
+        LPI2C_MCFGR1_PINCFG_MASK, LPI2C_MCFGR1_PINCFG0);
+    }
+
+  /* Configure slave address
+   *
+   * TO DO: Allow 10-bit addressing
+   */
+
+  s32k1xx_lpi2c_slave_modifyreg(priv, S32K1XX_LPI2C_SAMR_OFFSET, 0,
+                                LPI2C_SAMR_ADDR0(priv->slave_addr));
+
+  /* Enable clock stretching */
+
+  s32k1xx_lpi2c_slave_modifyreg(priv, S32K1XX_LPI2C_SCFGR1_OFFSET, 0,
+    LPI2C_SCFGR1_ADRSTALL | LPI2C_SCFGR1_RXSTALL | LPI2C_SCFGR1_TXSTALL);
+
+  /* Configure LPI2C slave interrupts */
+
+  s32k1xx_lpi2c_slave_modifyreg(priv, S32K1XX_LPI2C_SIER_OFFSET, 0,
+    LPI2C_SIER_RDIE | LPI2C_SIER_AVIE | LPI2C_SIER_RSIE | LPI2C_SIER_SDIE | \
+    LPI2C_SIER_BEIE);
+
+  /* Attach ISR and enable interrupt */
+
+  ret = irq_attach(priv->config->irq, s32k1xx_lpi2c_slave_isr, priv);
+  if (ret != OK)
+    {
+      return ret;
+    }
+
+  up_enable_irq(priv->config->irq);
+
+  /* Enable I2C slave */
+
+  s32k1xx_lpi2c_slave_modifyreg(priv, S32K1XX_LPI2C_SCR_OFFSET, 0,
+                                LPI2C_SCR_SEN);
+
+  return OK;
+}
+
+/****************************************************************************
+ * Name: s32k1xx_lpi2c_slave_deinit
+ *
+ * Description:
+ *   Deinitialize the LPI2C slave device.  Disable and reset the peripheral
+ *   and disable the interrupts and attached handlers.
+ *
+ * Input Parameters:
+ *   priv - I2C slave device private data
+ *
+ * Returned Value:
+ *   OK when successful, or a negated errno when there is an error.
+ *
+ ****************************************************************************/
+
+static int s32k1xx_lpi2c_slave_deinit(
+  FAR struct s32k1xx_lpi2c_slave_priv_s *priv)
+{
+  int ret;
+
+  /* Disable LPI2C slave */
+
+  s32k1xx_lpi2c_slave_modifyreg(priv, S32K1XX_LPI2C_SCR_OFFSET,
+                                LPI2C_SCR_SEN, 0);
+
+  /* Reset LPI2C slave */
+
+  s32k1xx_lpi2c_slave_putreg(priv, S32K1XX_LPI2C_SCR_OFFSET, LPI2C_SCR_RST);
+  s32k1xx_lpi2c_slave_putreg(priv, S32K1XX_LPI2C_SCR_OFFSET, 0);
+
+  /* Disable and detach interrupts */
+
+  up_disable_irq(priv->config->irq);
+  ret = irq_detach(priv->config->irq);
+  if (ret != OK)
+    {
+      return ret;
+    }
+
+  /* NOTE that clocking is left enabled */
+
+  return OK;
+}
+
+/****************************************************************************
+ * Device Driver Operations
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: s32k1xx_lpi2c_setownaddress
+ *
+ * Description:
+ *   Set our own I2C address.
+ *
+ *   One may register a callback to be notified about reception. During the
+ *   slave mode reception, the methods READ and WRITE must be used to
+ *   to handle reads and writes from a master.
+ *
+ * Input Parameters:
+ *   dev     - I2C slave device-specific state data
+ *   address - Our own slave address
+ *   nbits   - The number of address bits provided (7 or 10)
+ *
+ * Returned Value:
+ *   OK when successful, or a negated errno when there is an error.
+ *
+ ****************************************************************************/
+
+static int s32k1xx_lpi2c_setownaddress(FAR struct i2c_slave_s *dev, int addr,
+                                       int nbits)
+{
+  FAR struct s32k1xx_lpi2c_slave_priv_s *priv;
+  irqstate_t flags;
+
+  DEBUGASSERT(dev);
+  priv = (FAR struct s32k1xx_lpi2c_slave_priv_s *)dev;
+
+  flags = enter_critical_section();
+
+  /* Deinit slave before we change its configuration */
+
+  int ret = s32k1xx_lpi2c_slave_deinit(priv);
+  if (ret != OK)
+    {
+      leave_critical_section(flags);
+      return ret;
+    }
+
+  /* Modify configuration */
+
+  switch (nbits)
+    {
+      case 7:
+        {
+          priv->slave_addr = (addr & 0x7f);
+          priv->addr_nbits = 7;
+        }
+        break;
+
+      case 10:
+        {
+          priv->slave_addr = (addr & 0x03ff);
+          priv->addr_nbits = 10;
+        }
+        break;
+
+      default:
+        {
+          leave_critical_section(flags);
+          return ERROR;
+        }
+        break;
+    }
+
+  /* Reinitialize slave with the changed config */
+
+  s32k1xx_lpi2c_slave_init(priv);
+
+  leave_critical_section(flags);
+
+  return OK;
+}
+
+/****************************************************************************
+ * Name: s32k1xx_lpi2c_write
+ *
+ * Description:
+ *   Send a block of data on I2C when a bus master wants to read data from
+ *   this particular device.
+ *
+ * Input Parameters:
+ *   dev    - I2C slave device-specific state data
+ *   buffer - A pointer to the read-only buffer of data to be written to the
+ *            device
+ *   buflen - The number of bytes to send from the buffer
+ *
+ * Returned Value:
+ *   OK when successful, or a negated errno when there is an error.
+ *
+ ****************************************************************************/
+
+static int s32k1xx_lpi2c_write(FAR struct i2c_slave_s *dev,
+                               FAR const uint8_t *buffer, int buflen)
+{
+  FAR struct s32k1xx_lpi2c_slave_priv_s *priv;
+  irqstate_t flags;
+
+  DEBUGASSERT(dev);
+  priv = (FAR struct s32k1xx_lpi2c_slave_priv_s *)dev;
+
+  flags = enter_critical_section();
+
+  /* Update the registered buffer and length */
+
+  priv->write_buffer = buffer;
+  priv->write_buflen = buflen;
+
+  leave_critical_section(flags);
+
+  return OK;
+}
+
+/****************************************************************************
+ * Name: s32k1xx_lpi2c_read
+ *
+ * Description:
+ *   Receive a block of data from I2C when a bus master writes data addressed
+ *   to this particular device.
+ *
+ * Input Parameters:
+ *   dev    - I2C slave device-specific state data
+ *   buffer - A pointer to a buffer of data to receive the data from the
+ *            device
+ *   buflen - The maximum size of the buffer
+ *
+ * Returned Value:
+ *   OK when successful, or a negated errno when there is an error.
+ *
+ ****************************************************************************/
+
+static int s32k1xx_lpi2c_read(FAR struct i2c_slave_s *dev,
+                              FAR uint8_t *buffer, int buflen)
+{
+  FAR struct s32k1xx_lpi2c_slave_priv_s *priv;
+  irqstate_t flags;
+
+  DEBUGASSERT(dev);
+  priv = (FAR struct s32k1xx_lpi2c_slave_priv_s *)dev;
+
+  flags = enter_critical_section();
+
+  /* Update the registered buffer and length */
+
+  priv->read_buffer = buffer;
+  priv->read_buflen = buflen;
+
+  leave_critical_section(flags);
+
+  return OK;
+}
+
+/****************************************************************************
+ * Name: s32k1xx_lpi2c_registercallback
+ *
+ * Description:
+ *   Register a callback function that will be invoked when something is
+ *   received on I2C.
+ *
+ * Input Parameters:
+ *   dev      - I2C slave device-specific state data
+ *   callback - The function to be called when something has been received.
+ *   arg      - User provided argument to be used with the callback
+ *
+ * Returned Value:
+ *   OK when successful, or a negated errno when there is an error.
+ *
+ ****************************************************************************/
+
+static int s32k1xx_lpi2c_registercallback(FAR struct i2c_slave_s *dev,
+  int (*callback)(FAR void *arg), FAR void *arg)
+{
+  FAR struct s32k1xx_lpi2c_slave_priv_s *priv;
+  irqstate_t flags;
+
+  DEBUGASSERT(dev);
+  priv = (FAR struct s32k1xx_lpi2c_slave_priv_s *)dev;
+
+  flags = enter_critical_section();
+
+  /* Update the registered callback and argument */
+
+  priv->callback = callback;
+  priv->callback_arg = arg;
+
+  leave_critical_section(flags);
+
+  return OK;
+}
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: s32k1xx_i2cbus_slave_initialize
+ *
+ * Description:
+ *   Initialize the I2C slave device and increase the reference counter.
+ *   If the device has already been initialized only the reference counter
+ *   will be increased.
+ *
+ * Input Parameters:
+ *   port - Port number (for hardware that has multiple I2C interfaces).
+ *
+ * Returned Value:
+ *   A valid I2C device structure reference on success; a NULL on failure.
+ *
+ ****************************************************************************/
+
+FAR struct i2c_slave_s *s32k1xx_i2cbus_slave_initialize(int port)
+{
+  struct s32k1xx_lpi2c_slave_priv_s *priv;
+  irqstate_t flags;
+
+  /* Get I2C private structure */
+
+  switch (port)
+    {
+#ifdef CONFIG_S32K1XX_LPI2C0
+      case 0:
+        priv = (struct s32k1xx_lpi2c_slave_priv_s *)&s32k1xx_lpi2c0s_priv;
+        break;
+#endif
+
+#ifdef CONFIG_S32K1XX_LPI2C1
+      case 1:
+        priv = (struct s32k1xx_lpi2c_slave_priv_s *)&s32k1xx_lpi2c1s_priv;
+        break;
+#endif
+
+      default:
+        return NULL;
+    }
+
+  flags = enter_critical_section();
+
+  if ((volatile int) priv->refs == 0)
+    {
+      /* Initialize private data for the first time, increment reference
+       * count, power-up hardware and configure pins.
+       */
+
+      s32k1xx_lpi2c_slave_init(priv);
+    }
+
+  priv->refs++;
+
+  leave_critical_section(flags);
+
+  return (struct i2c_slave_s *)priv;
+}
+
+/****************************************************************************
+ * Name: s32k1xx_i2cbus_slave_uninitialize
+ *
+ * Description:
+ *   Decrease the reference counter of the I2C slave device.  When there are
+ *   no more references left the I2C slave device is unitialized.
+ *
+ * Input Parameters:
+ *   dev - Device structure as returned by s32k1xx_i2cbus_slave_initialize().
+ *
+ * Returned Value:
+ *   OK on success, ERROR when there is an internal reference count mismatch
+ *   or dev points to an invalid hardware device.
+ *
+ ****************************************************************************/
+
+int s32k1xx_i2cbus_slave_uninitialize(FAR struct i2c_slave_s *dev)
+{
+  FAR struct s32k1xx_lpi2c_slave_priv_s *priv =
+    (struct s32k1xx_lpi2c_slave_priv_s *)dev;
+  irqstate_t flags;
+
+  DEBUGASSERT(dev);
+
+  /* Check reference count for underflow, then decrement */
+
+  flags = enter_critical_section();
+
+  if (priv->refs == 0)
+    {
+      leave_critical_section(flags);
+      return ERROR;
+    }
+
+  priv->refs--;
+
+  if (priv->refs > 0)
+    {
+      leave_critical_section(flags);
+      return OK;
+    }
+
+  leave_critical_section(flags);
+
+  /* Disable power and other HW resources (pins) */
+
+  s32k1xx_lpi2c_slave_deinit(priv);
+
+  return OK;
+}
+
+#endif /* CONFIG_S32K1XX_LPI2C */
diff --git a/arch/arm/src/s32k1xx/s32k1xx_lpi2c_slave.h b/arch/arm/src/s32k1xx/s32k1xx_lpi2c_slave.h
new file mode 100644
index 0000000000..d7839b1998
--- /dev/null
+++ b/arch/arm/src/s32k1xx/s32k1xx_lpi2c_slave.h
@@ -0,0 +1,90 @@
+/****************************************************************************
+ * arch/arm/src/s32k1xx/s32k1xx_lpi2c_slave.h
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.  The
+ * ASF licenses this file to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ *
+ ****************************************************************************/
+
+#ifndef __ARCH_ARM_SRC_S32K1XX_S32K1XX_LPI2C_SLAVE_H
+#define __ARCH_ARM_SRC_S32K1XX_S32K1XX_LPI2C_SLAVE_H
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/i2c/i2c_slave.h>
+
+/****************************************************************************
+ * Public Data
+ ****************************************************************************/
+
+#ifndef __ASSEMBLY__
+
+#ifdef __cplusplus
+#define EXTERN extern "C"
+extern "C"
+{
+#else
+#define EXTERN extern
+#endif
+
+/****************************************************************************
+ * Public Function Prototypes
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: s32k1xx_i2cbus_slave_initialize
+ *
+ * Description:
+ *   Initialize the I2C slave device and increase the reference counter.
+ *   If the device has already been initialized only the reference counter
+ *   will be increased.
+ *
+ * Input Parameters:
+ *   port - Port number (for hardware that has multiple I2C interfaces).
+ *
+ * Returned Value:
+ *   A valid I2C device structure reference on success; a NULL on failure.
+ *
+ ****************************************************************************/
+
+FAR struct i2c_slave_s *s32k1xx_i2cbus_slave_initialize(int port);
+
+/****************************************************************************
+ * Name: s32k1xx_i2cbus_slave_uninitialize
+ *
+ * Description:
+ *   Decrease the reference counter of the I2C slave device.  When there are
+ *   no more references left the I2C slave device is unitialized.
+ *
+ * Input Parameters:
+ *   dev - Device structure as returned by s32k1xx_i2cbus_slave_initialize().
+ *
+ * Returned Value:
+ *   OK on success, ERROR when there is an internal reference count mismatch
+ *   or dev points to an invalid hardware device.
+ *
+ ****************************************************************************/
+
+int s32k1xx_i2cbus_slave_uninitialize(FAR struct i2c_slave_s *dev);
+
+#undef EXTERN
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __ASSEMBLY__ */
+#endif /* __ARCH_ARM_SRC_S32K1XX_S32K1XX_LPI2C_SLAVE_H */
diff --git a/arch/arm/src/s32k1xx/s32k1xx_lpspi.c b/arch/arm/src/s32k1xx/s32k1xx_lpspi.c
index b0cb406a93..53d9a4277e 100644
--- a/arch/arm/src/s32k1xx/s32k1xx_lpspi.c
+++ b/arch/arm/src/s32k1xx/s32k1xx_lpspi.c
@@ -114,6 +114,25 @@
 #  error "Cannot enable both interrupt mode and DMA mode for SPI"
 #endif
 
+/* Power management definitions */
+
+#if defined(CONFIG_PM) && !defined(CONFIG_S32K1XX_PM_SPI_ACTIVITY)
+#  define CONFIG_S32K1XX_PM_SPI_ACTIVITY 10
+#endif
+
+#if defined(CONFIG_PM)
+#ifndef PM_IDLE_DOMAIN
+#  define PM_IDLE_DOMAIN      0 /* Revisit */
+#endif
+#endif
+
+#if defined(CONFIG_PM_SPI0_STANDBY) || defined(CONFIG_PM_SPI0_SLEEP)
+#   define CONFIG_PM_SPI0
+#endif
+#if defined(CONFIG_PM_SPI1_STANDBY) || defined(CONFIG_PM_SPI1_SLEEP)
+#   define CONFIG_PM_SPI1
+#endif
+
 /************************************************************************************
  * Private Types
  ************************************************************************************/
@@ -151,12 +170,12 @@ static inline void s32k1xx_lpspi_putreg32(FAR struct s32k1xx_lpspidev_s *priv,
               uint8_t offset, uint32_t value);
 static inline uint32_t s32k1xx_lpspi_readword(FAR struct s32k1xx_lpspidev_s *priv);
 static inline void s32k1xx_lpspi_writeword(FAR struct s32k1xx_lpspidev_s *priv,
-              uint16_t byte);
-static inline bool s32k1xx_lpspi_9to16bitmode(FAR struct s32k1xx_lpspidev_s *priv);
+              uint32_t byte);
+static inline uint16_t s32k1xx_lpspi_9to16bitmode(FAR struct s32k1xx_lpspidev_s *priv);
 static uint32_t s32k1xx_lpspi_pckfreq(uintptr_t base);
-static inline void s32k1xx_lpspi_set_delays(FAR struct s32k1xx_lpspidev_s
+static inline void s32k1xx_lpspi_master_set_delays(FAR struct s32k1xx_lpspidev_s
               *priv, uint32_t delay_ns, enum s32k1xx_delay_e type);
-static inline void s32k1xx_lpspi_set_delay_scaler(FAR struct
+static inline void s32k1xx_lpspi_master_set_delay_scaler(FAR struct
               s32k1xx_lpspidev_s *priv, uint32_t scaler, enum s32k1xx_delay_e type);
 
 /* SPI methods */
@@ -181,6 +200,13 @@ static void s32k1xx_lpspi_recvblock(FAR struct spi_dev_s *dev, FAR void *rxbuffe
               size_t nwords);
 #endif
 
+#ifdef CONFIG_PM
+static void up_pm_notify(struct pm_callback_s *cb, int dowmin,
+                         enum pm_state_e pmstate);
+static int  up_pm_prepare(struct pm_callback_s *cb, int domain,
+                          enum pm_state_e pmstate);
+#endif
+
 /* Initialization */
 
 static void s32k1xx_lpspi_bus_initialize(FAR struct s32k1xx_lpspidev_s *priv);
@@ -327,6 +353,14 @@ static struct s32k1xx_lpspidev_s g_lpspi2dev =
 };
 #endif
 
+#ifdef CONFIG_PM
+static  struct pm_callback_s g_spi1_pmcb =
+{
+  .notify       = up_pm_notify,
+  .prepare      = up_pm_prepare,
+};
+#endif
+
 /************************************************************************************
  * Private Functions
  ************************************************************************************/
@@ -457,7 +491,7 @@ static inline uint32_t s32k1xx_lpspi_readword(FAR struct s32k1xx_lpspidev_s *pri
  ************************************************************************************/
 
 static inline void s32k1xx_lpspi_writeword(FAR struct s32k1xx_lpspidev_s *priv,
-                                           uint16_t word)
+                                           uint32_t word)
 {
   /* Wait until the transmit buffer is empty */
 
@@ -470,6 +504,36 @@ static inline void s32k1xx_lpspi_writeword(FAR struct s32k1xx_lpspidev_s *priv,
   s32k1xx_lpspi_putreg32(priv, S32K1XX_LPSPI_TDR_OFFSET, word);
 }
 
+/************************************************************************************
+ * Name: s32k1xx_lpspi_writeDword
+ *
+ * Description:
+ *   Write two words to SPI
+ *
+ * Input Parameters:
+ *   priv - Device-specific state data
+ *   word0, word1 - words to send
+ *
+ * Returned Value:
+ *   None
+ *
+ ************************************************************************************/
+
+static inline void s32k1xx_lpspi_writeDword(FAR struct s32k1xx_lpspidev_s *priv,
+                                           uint32_t word0, uint32_t word1)
+{
+  /* Wait until the transmit buffer is empty */
+
+  while ((s32k1xx_lpspi_getreg32(priv, S32K1XX_LPSPI_SR_OFFSET) & LPSPI_SR_TDF) == 0)
+    {
+    }
+
+  /* Then send the words, use the FIFO */
+
+  s32k1xx_lpspi_putreg32(priv, S32K1XX_LPSPI_TDR_OFFSET, word0);
+  s32k1xx_lpspi_putreg32(priv, S32K1XX_LPSPI_TDR_OFFSET, word1);
+}
+
 /************************************************************************************
  * Name: s32k1xx_lpspi_readbyte
  *
@@ -531,29 +595,22 @@ static inline void s32k1xx_lpspi_writebyte(FAR struct s32k1xx_lpspidev_s *priv,
  *
  * Description:
  *   Check if the SPI is operating in more then 8 bit mode
+ *   On the S32K the frame size can grow to 4096 bit/frame
  *
  * Input Parameters:
  *   priv     - Device-specific state data
  *
  * Returned Value:
- *   true: >8 bit mode-bit mode, false: <= 8-bit mode
+ *   value: frame size
  *
  ************************************************************************************/
 
-static inline bool s32k1xx_lpspi_9to16bitmode(FAR struct s32k1xx_lpspidev_s *priv)
+static inline uint16_t s32k1xx_lpspi_9to16bitmode(FAR struct s32k1xx_lpspidev_s *priv)
 {
-  bool ret;
-
-  if (((s32k1xx_lpspi_getreg32(priv, S32K1XX_LPSPI_TCR_OFFSET) &
-        LPSPI_TCR_FRAMESZ_MASK) + 1) < 9)
-    {
-      ret = false;
-    }
-  else
-    {
-      ret = true;
-    }
+  uint16_t ret;
 
+  ret = ((s32k1xx_lpspi_getreg32(priv, S32K1XX_LPSPI_TCR_OFFSET) &
+        LPSPI_TCR_FRAMESZ_MASK) + 1);
   return ret;
 }
 
@@ -640,7 +697,7 @@ static uint32_t s32k1xx_lpspi_pckfreq(uintptr_t base)
 }
 
 /************************************************************************************
- * Name: s32k1xx_lpspi_set_delays
+ * Name: s32k1xx_lpspi_master_set_delays
  *
  * Description:
  *   SET LPSPI Delay times
@@ -655,10 +712,9 @@ static uint32_t s32k1xx_lpspi_pckfreq(uintptr_t base)
  *
  ************************************************************************************/
 
-static inline void s32k1xx_lpspi_set_delay_scaler(FAR struct
-                                                  s32k1xx_lpspidev_s *priv,
-                                                  uint32_t scaler,
-                                                  enum s32k1xx_delay_e type)
+static inline void s32k1xx_lpspi_master_set_delay_scaler(FAR struct s32k1xx_lpspidev_s *priv,
+                                                         uint32_t scaler,
+                                                         enum s32k1xx_delay_e type)
 {
   switch (type)
     {
@@ -686,7 +742,7 @@ static inline void s32k1xx_lpspi_set_delay_scaler(FAR struct
 }
 
 /************************************************************************************
- * Name: s32k1xx_lpspi_set_delays
+ * Name: s32k1xx_lpspi_master_set_delays
  *
  * Description:
  *   SET LPSPI Delay times
@@ -701,7 +757,7 @@ static inline void s32k1xx_lpspi_set_delay_scaler(FAR struct
  *
  ************************************************************************************/
 
-static inline void s32k1xx_lpspi_set_delays(FAR struct s32k1xx_lpspidev_s *priv,
+static inline void s32k1xx_lpspi_master_set_delays(FAR struct s32k1xx_lpspidev_s *priv,
                                                    uint32_t delay_ns,
                                                    enum s32k1xx_delay_e type)
 {
@@ -786,7 +842,7 @@ static inline void s32k1xx_lpspi_set_delays(FAR struct s32k1xx_lpspidev_s *priv,
 
   if (initial_delay_ns >= delay_ns)
     {
-      s32k1xx_lpspi_set_delay_scaler(priv, 0, type);
+      s32k1xx_lpspi_master_set_delay_scaler(priv, 0, type);
     }
   else
     {
@@ -823,7 +879,7 @@ static inline void s32k1xx_lpspi_set_delays(FAR struct s32k1xx_lpspidev_s *priv,
             }
         }
 
-      s32k1xx_lpspi_set_delay_scaler(priv, best_scaler, type);
+      s32k1xx_lpspi_master_set_delay_scaler(priv, best_scaler, type);
     }
 }
 
@@ -852,7 +908,8 @@ static int s32k1xx_lpspi_lock(FAR struct spi_dev_s *dev, bool lock)
 {
   FAR struct s32k1xx_lpspidev_s *priv = (FAR struct s32k1xx_lpspidev_s *)dev;
   int ret;
-
+// TODO; Needs to be switched of for debugging
+#if 0
   if (lock)
     {
       ret = nxsem_wait_uninterruptible(&priv->exclsem);
@@ -863,6 +920,9 @@ static int s32k1xx_lpspi_lock(FAR struct spi_dev_s *dev, bool lock)
     }
 
   return ret;
+#else
+  return 1;
+#endif
 }
 
 /************************************************************************************
@@ -960,11 +1020,11 @@ static uint32_t s32k1xx_lpspi_setfrequency(FAR struct spi_dev_s *dev,
       priv->frequency = frequency;
       priv->actual = best_frequency;
 
-      s32k1xx_lpspi_set_delays(priv, 1000000000 / best_frequency,
+      s32k1xx_lpspi_master_set_delays(priv, 1000000000 / best_frequency,
                                     LPSPI_PCS_TO_SCK);
-      s32k1xx_lpspi_set_delays(priv, 1000000000 / best_frequency,
+      s32k1xx_lpspi_master_set_delays(priv, 1000000000 / best_frequency,
                                     LPSPI_LAST_SCK_TO_PCS);
-      s32k1xx_lpspi_set_delays(priv, 1000000000 / best_frequency,
+      s32k1xx_lpspi_master_set_delays(priv, 1000000000 / best_frequency,
                                     LPSPI_BETWEEN_TRANSFER);
 
       /* Re-enable LPSPI if it was enabled previously */
@@ -1220,6 +1280,57 @@ static uint32_t s32k1xx_lpspi_send(FAR struct spi_dev_s *dev, uint32_t wd)
   return ret;
 }
 
+/************************************************************************************
+ * Name: s32k1xx_lpspi_send2
+ *
+ * Description:
+ *   Exchange two words on SPI
+ *
+ * Input Parameters:
+ *   dev - Device-specific state data
+ *   wd0, wd1  - The word to send.  the size of the data is determined by the
+ *         number of bits selected for the SPI interface.
+ *
+ * Returned Value:
+ *   response
+ *
+ ************************************************************************************/
+
+static uint32_t s32k1xx_lpspi_send2(FAR struct spi_dev_s *dev, uint32_t wd0, uint32_t wd1, uint32_t *rw1)
+{
+  FAR struct s32k1xx_lpspidev_s *priv = (FAR struct s32k1xx_lpspidev_s *)dev;
+  uint32_t regval;
+  uint32_t ret;
+
+  DEBUGASSERT(priv && priv->spibase);
+
+#if 1
+  /* check if the receive buffer is empty, if not clear it */
+  while ((s32k1xx_lpspi_getreg32(priv, S32K1XX_LPSPI_SR_OFFSET) & LPSPI_SR_RDF)) {
+    s32k1xx_lpspi_getreg32(priv, S32K1XX_LPSPI_RDR_OFFSET);
+  }
+#endif
+
+  s32k1xx_lpspi_writeDword(priv, wd0, wd1);
+
+  while ((s32k1xx_lpspi_getreg32(priv, S32K1XX_LPSPI_SR_OFFSET) & LPSPI_SR_RDF) !=
+         LPSPI_SR_RDF);
+
+  ret  = s32k1xx_lpspi_readword(priv);
+  *rw1 = s32k1xx_lpspi_readword(priv);
+
+  /* Check and clear any error flags (Reading from the SR clears the error
+   * flags).
+   */
+
+  regval = s32k1xx_lpspi_getreg32(priv, S32K1XX_LPSPI_SR_OFFSET);
+
+  spiinfo("Sent: %02x %08x  Return: %04x Status: %02x\n", wd1, wd0, ret, regval);
+
+  UNUSED(regval);
+  return ret;
+}
+
 /************************************************************************************
  * Name: s32k1xx_lpspi_exchange (no DMA).  aka s32k1xx_lpspi_exchange_nodma
  *
@@ -1254,42 +1365,91 @@ static void s32k1xx_lpspi_exchange_nodma(FAR struct spi_dev_s *dev,
 {
   FAR struct s32k1xx_lpspidev_s *priv = (FAR struct s32k1xx_lpspidev_s *)dev;
   DEBUGASSERT(priv && priv->spibase);
+  uint16_t frameSize;
 
   spiinfo("txbuffer=%p rxbuffer=%p nwords=%d\n", txbuffer, rxbuffer, nwords);
 
-  /* 8- or 16-bit mode? */
+#if defined(CONFIG_PM) && CONFIG_S32K1XX_PM_SPI_ACTIVITY > 0
+  /* Report serial activity to the power management logic */
 
-  if (s32k1xx_lpspi_9to16bitmode(priv))
+  pm_activity(PM_IDLE_DOMAIN, CONFIG_S32K1XX_PM_SPI_ACTIVITY);
+#endif
+
+  /* 8- or 16-bit mode? */
+  frameSize = s32k1xx_lpspi_9to16bitmode(priv);
+  if (frameSize > 8)
     {
-      /* 16-bit mode */
+      /* 16-bit, 32-bit or 40-bit mode */
+      /* take care of big endian mode of hardware !! */
 
-      const uint16_t *src = (const uint16_t *)txbuffer;
-      uint16_t *dest = (uint16_t *) rxbuffer;
-      uint16_t word;
+      const uint8_t *src = (const uint8_t *)txbuffer;
+      uint8_t *dest = (uint8_t *) rxbuffer;
+      uint32_t word, word1, rword1;
+      bool     dwords = false;
 
-      while (nwords-- > 0)
-        {
+      while (nwords-- > 0) {
           /* Get the next word to write.  Is there a source buffer? */
 
-          if (src)
-            {
-              word = *src++;
-            }
-          else
-            {
-              word = 0xffff;
-            }
+          if (src) {
+			// read the required number of bytes
+			switch (frameSize) {
+			  case 16:
+				   word = (src[0] << 8) + src[1];
+				   src += 2;
+				   break;
+			  case 32:
+				   word = (src[0] << 24) + (src[1] << 16) + (src[2] << 8) + src[3];
+				   src += 4;
+				   break;
+			  case 40:
+				   word = (src[0] << 24) + (src[1] << 16) + (src[2] << 8) + src[3];
+				   word1 = src[4];
+				   src += 5;
+				   dwords = true;
+			  default: // expect 40 bit TODO
+					  break;
+			}
+          } else {
+              word = 0xffffffff;
+          }
 
           /* Exchange one word */
-
-          word = (uint16_t) s32k1xx_lpspi_send(dev, (uint32_t) word);
+          if (dwords) {
+              word = s32k1xx_lpspi_send2(dev, word, word1, &rword1);
+          } else {
+            word = s32k1xx_lpspi_send(dev, word);
+          }
 
           /* Is there a buffer to receive the return value? */
 
-          if (dest)
-            {
-              *dest++ = word;
+          if (dest) {
+			switch (frameSize) {
+			  case 16:
+				   dest[0] = (word >> 8) & 0xff;
+				   dest[1] =  word       & 0xff;
+				   dest += 2;
+				   break;
+			  case 32:
+				   dest[0] = (word >> 24) & 0xff;
+				   dest[1] = (word >> 16) & 0xff;
+				   dest[2] = (word >>  8) & 0xff;
+				   dest[3] =  word        & 0xff;
+				   dest += 4;
+				   break;
+			  case 40:
+				   dest[0] = (word >> 24) & 0xff;
+				   dest[1] = (word >> 16) & 0xff;
+				   dest[2] = (word >>  8) & 0xff;
+				   dest[3] =  word        & 0xff;
+				   dest[4] =  rword1      & 0xff;
+				   dest += 5;
+				   break;
+
+			  default: // expect 40 bit TODO
+
+					  break;
             }
+	      }
         }
     }
   else
@@ -1456,6 +1616,349 @@ static void s32k1xx_lpspi_bus_initialize(struct s32k1xx_lpspidev_s *priv)
   s32k1xx_lpspi_modifyreg32(priv, S32K1XX_LPSPI_CR_OFFSET, 0, LPSPI_CR_MEN);
 }
 
+/****************************************************************************
+ * Name: up_pm_notify
+ *
+ * Description:
+ *   Notify the driver of new power state. This callback is  called after
+ *   all drivers have had the opportunity to prepare for the new power state.
+ *
+ * Input Parameters:
+ *
+ *    cb - Returned to the driver. The driver version of the callback
+ *         structure may include additional, driver-specific state data at
+ *         the end of the structure.
+ *
+ *    pmstate - Identifies the new PM state
+ *
+ * Returned Value:
+ *   None - The driver already agreed to transition to the low power
+ *   consumption state when when it returned OK to the prepare() call.
+ *
+ ****************************************************************************/
+
+#ifdef CONFIG_PM
+static void up_pm_notify(struct pm_callback_s *cb, int domain,
+                         enum pm_state_e pmstate)
+{
+  #ifdef CONFIG_PM_SPI0
+
+    FAR struct s32k1xx_lpspidev_s *priv0 = NULL;
+   
+     // make the priv1ate struct for lpspi bus 0
+    priv0 = &g_lpspi0dev;
+
+  #endif
+  #ifdef CONFIG_PM_SPI1
+
+    FAR struct s32k1xx_lpspidev_s *priv1 = NULL;
+
+    // make the priv1ate struct for lpspi bus 1 
+    priv1 = &g_lpspi1dev;
+
+  #endif
+
+  unsigned int count = 0;   // the amount of peripheral clocks to change
+  peripheral_clock_source_t clockSource;
+  
+  //uint32_t clockFreq = 0;
+
+  // check if the transition is from the IDLE domain to the NORMAL domain
+  // or the mode is already done
+  if(((pm_querystate(PM_IDLE_DOMAIN) == PM_IDLE) && (pmstate == PM_NORMAL)) ||
+    (((pm_querystate(PM_IDLE_DOMAIN) == pmstate))))
+  {
+    // return
+    return;
+  }
+
+  // check which PM it is 
+  switch(pmstate)
+  {
+
+    //in case it needs to change to the RUN mode
+    case PM_NORMAL:
+    {
+
+      /* Logic for PM_NORMAL goes here */
+      
+      // set the right clock source to go back to RUN mode
+      clockSource = CLK_SRC_SPLL_DIV2;
+
+#ifdef CONFIG_PM_SPI0
+
+      // add 1 to count to do it for SPI0
+      count++;
+#endif
+
+#ifdef CONFIG_PM_SPI1
+
+      // add 1 to count to do it for SPI1
+      count++;
+#endif
+
+    }
+    break;
+
+    default:
+    {
+      // don't do anything, just return OK
+      //return;
+    }
+    break;
+  }
+
+  // check if the LPSPI needs to change
+  if(count)
+  {
+    // make the peripheral clock config struct
+    const struct peripheral_clock_config_s clockConfig[] = 
+    {
+#ifdef CONFIG_PM_SPI0
+
+      {
+        .clkname  =   LPSPI0_CLK,
+        .clkgate  =   true,
+        .clksrc   =   clockSource,
+        .frac     =   MULTIPLY_BY_ONE,
+        .divider  =   1,
+      },
+#endif
+#ifdef CONFIG_PM_SPI1
+
+      {
+        .clkname  =   LPSPI1_CLK,
+        .clkgate  =   true,
+        .clksrc   =   clockSource,
+        .frac     =   MULTIPLY_BY_ONE,
+        .divider  =   1,
+      }
+#endif
+    }; 
+
+#ifdef CONFIG_PM_SPI0
+
+    /* disable LPSP0 */
+    s32k1xx_lpspi_modifyreg32(priv0, S32K1XX_LPSPI_CR_OFFSET, 0, !LPSPI_CR_MEN);
+
+#endif
+#ifdef CONFIG_PM_SPI1
+
+    /* disable LPSPI */
+    s32k1xx_lpspi_modifyreg32(priv1, S32K1XX_LPSPI_CR_OFFSET, 0, !LPSPI_CR_MEN);
+
+#endif
+
+    // change the clock config for the new mode
+    s32k1xx_periphclocks(count, clockConfig);
+
+#ifdef CONFIG_PM_SPI0
+
+    /* Enable LPSP0 */
+    s32k1xx_lpspi_modifyreg32(priv0, S32K1XX_LPSPI_CR_OFFSET, 0, LPSPI_CR_MEN);
+
+#endif
+#ifdef CONFIG_PM_SPI1
+
+    /* Enable LPSPI */
+    s32k1xx_lpspi_modifyreg32(priv1, S32K1XX_LPSPI_CR_OFFSET, 0, LPSPI_CR_MEN);
+#endif
+
+    // get the clock freq
+    //clockFreq = s32k1xx_lpspi_pckfreq(S32K1XX_LPSPI1_BASE);
+  }
+  // return
+  return;
+}
+#endif
+
+/****************************************************************************
+ * Name: up_pm_prepare
+ *
+ * Description:
+ *   Request the driver to prepare for a new power state. This is a warning
+ *   that the system is about to enter into a new power state. The driver
+ *   should begin whatever operations that may be required to enter power
+ *   state. The driver may abort the state change mode by returning a
+ *   non-zero value from the callback function.
+ *
+ * Input Parameters:
+ *
+ *    cb - Returned to the driver. The driver version of the callback
+ *         structure may include additional, driver-specific state data at
+ *         the end of the structure.
+ *
+ *    pmstate - Identifies the new PM state
+ *
+ * Returned Value:
+ *   Zero - (OK) means the event was successfully processed and that the
+ *          driver is prepared for the PM state change.
+ *
+ *   Non-zero - means that the driver is not prepared to perform the tasks
+ *              needed achieve this power setting and will cause the state
+ *              change to be aborted. NOTE: The prepare() method will also
+ *              be called when reverting from lower back to higher power
+ *              consumption modes (say because another driver refused a
+ *              lower power state change). Drivers are not permitted to
+ *              return non-zero values when reverting back to higher power
+ *              consumption modes!
+ *
+ *
+ ****************************************************************************/
+
+#ifdef CONFIG_PM
+static int up_pm_prepare(struct pm_callback_s *cb, int domain,
+                         enum pm_state_e pmstate)
+{
+  /* Logic to prepare for a reduced power state goes here. */
+  
+  #ifdef CONFIG_PM_SPI0
+    FAR struct s32k1xx_lpspidev_s *priv0 = NULL;
+    
+    // make the private struct for lpspi bus 0
+    priv0 = &g_lpspi0dev;
+  #endif
+  #ifdef CONFIG_PM_SPI1
+    FAR struct s32k1xx_lpspidev_s *priv1 = NULL;
+
+    // make the private struct for lpspi bus 1 
+    priv1 = &g_lpspi1dev;
+  #endif
+
+  unsigned int count = 0;   // the amount of peripheral clocks to change
+  peripheral_clock_source_t clockSource;
+  //uint32_t clockFreq = 0;
+
+  // check if the transition to the mode is already done
+  if(pm_querystate(PM_IDLE_DOMAIN) == pmstate)
+  {
+    // return
+    return OK;
+  }
+
+  // check which PM it is 
+  switch(pmstate)
+  {
+    // in case it needs to prepare for VLPR mode
+    case PM_STANDBY:
+    {
+      /* Logic for PM_STANDBY goes here */
+
+       // set the right clock source
+      clockSource = CLK_SRC_SIRC_DIV2;
+
+#ifdef CONFIG_PM_SPI0_STANDBY
+
+      // increase count to change the SPI0 
+      count++;
+
+#endif
+#ifdef CONFIG_PM_SPI1_STANDBY
+
+      // increase count to change the SPI1
+      count++;
+
+#endif
+    }
+    break;
+    // in case it needs to prepare for VLPR mode
+    case PM_SLEEP:
+    {
+      /* Logic for PM_STANDBY goes here */
+
+      // set the right clock source
+      clockSource = CLK_SRC_SIRC_DIV2;
+
+#ifdef CONFIG_PM_SPI0_SLEEP
+
+      // increase count to change the SPI0 
+      count++;
+
+#endif
+#ifdef CONFIG_PM_SPI1_SLEEP
+
+      // increase count to change the SPI1
+      count++;
+
+#endif
+      
+     
+    }
+    break;
+
+    default:
+    {
+      // don't do anything, just return OK
+      //return OK;
+    }
+    break;
+  }
+
+  // check if you need to change something
+  if(count)
+  {
+    // make the peripheral clock config struct
+    const struct peripheral_clock_config_s clockConfig[] = 
+    {
+#ifdef CONFIG_PM_SPI0
+      {
+        .clkname  =   LPSPI0_CLK,
+        .clkgate  =   true,
+        .clksrc   =   clockSource,
+        .frac     =   MULTIPLY_BY_ONE,
+        .divider  =   1,
+      },
+#endif
+#ifdef CONFIG_PM_SPI1
+      {
+        .clkname  =   LPSPI1_CLK,
+        .clkgate  =   true,
+        .clksrc   =   clockSource,
+        .frac     =   MULTIPLY_BY_ONE,
+        .divider  =   1,
+      }
+#endif
+    };
+
+#ifdef CONFIG_PM_SPI0
+
+    /* disable LPSPI0 */
+    s32k1xx_lpspi_modifyreg32(priv0, S32K1XX_LPSPI_CR_OFFSET, 0, !LPSPI_CR_MEN);
+
+#endif
+#ifdef CONFIG_PM_SPI1
+
+    /* disable LPSPI1 */
+    s32k1xx_lpspi_modifyreg32(priv1, S32K1XX_LPSPI_CR_OFFSET, 0, !LPSPI_CR_MEN);
+
+#endif
+   
+    // change the clock config for the new mode
+    s32k1xx_periphclocks(count, clockConfig);
+
+#ifdef CONFIG_PM_SPI0
+
+    /* Enable LPSPI */
+    s32k1xx_lpspi_modifyreg32(priv0, S32K1XX_LPSPI_CR_OFFSET, 0, LPSPI_CR_MEN);
+
+#endif
+#ifdef CONFIG_PM_SPI1
+
+    /* Enable LPSPI */
+    s32k1xx_lpspi_modifyreg32(priv1, S32K1XX_LPSPI_CR_OFFSET, 0, LPSPI_CR_MEN);
+
+#endif
+
+  }   
+
+  // get the clock freq
+  //clockFreq = s32k1xx_lpspi_pckfreq(S32K1XX_LPSPI1_BASE);
+
+  // return OK
+  return OK;
+}
+#endif
+
 /************************************************************************************
  * Public Functions
  ************************************************************************************/
@@ -1508,6 +2011,17 @@ FAR struct spi_dev_s *s32k1xx_lpspibus_initialize(int bus)
 #ifdef CONFIG_S32K1XX_LPSPI1
   if (bus == 1)
     {
+      #ifdef CONFIG_PM
+        #if defined(CONFIG_PM_SPI_STANDBY) || defined(CONFIG_PM_SPI_SLEEP) 
+          int ret;
+
+          /* Register to receive power management callbacks */
+          
+          ret = pm_register(&g_spi1_pmcb);
+          DEBUGASSERT(ret == OK);
+          UNUSED(ret);
+        #endif
+      #endif
       /* Select SPI1 */
 
       priv = &g_lpspi1dev;
diff --git a/arch/arm/src/s32k1xx/s32k1xx_periphclocks.c b/arch/arm/src/s32k1xx/s32k1xx_periphclocks.c
index cfb623e84a..05e1f27768 100644
--- a/arch/arm/src/s32k1xx/s32k1xx_periphclocks.c
+++ b/arch/arm/src/s32k1xx/s32k1xx_periphclocks.c
@@ -104,29 +104,6 @@ static uint32_t *s32k1xx_get_pclkctrl(enum clock_names_e clkname)
   return NULL;
 }
 
-/************************************************************************************
- * Name: s32k1xx_pclk_disable
- *
- * Description:
- *   This function enables/disables the clock for a given peripheral.
- *
- * Input Parameters:
- *   clkname - The name of the peripheral clock to be disabled
- *   enable  - true:  Enable the peripheral clock.
- *
- * Returned Value:
- *   None
- *
- ************************************************************************************/
-
-static void s32k1xx_pclk_disable(enum clock_names_e clkname)
-{
-  uint32_t *ctrlp = s32k1xx_get_pclkctrl(clkname);
-  DEBUGASSERT(ctrlp != NULL);
-
-  *ctrlp &= ~PCC_CGC;
-}
-
 /************************************************************************************
  * Name: s32k1xx_set_pclkctrl
  *
@@ -276,7 +253,7 @@ void s32k1xx_periphclocks(unsigned int count,
     {
       /* Disable the peripheral clock */
 
-      s32k1xx_pclk_disable(pclks->clkname);
+      s32k1xx_pclk_enable(pclks->clkname, false);
 
       /* Set peripheral clock control */
 
@@ -388,3 +365,36 @@ int s32k1xx_get_pclkfreq(enum clock_names_e clkname, uint32_t *frequency)
 
   return ret;
 }
+
+/************************************************************************************
+ * Name: s32k1xx_pclk_enable
+ *
+ * Description:
+ *   This function enables/disables the clock for a given peripheral.
+ *
+ * Input Parameters:
+ *   clkname - The name of the peripheral clock to be disabled
+ *   enable  - true:  Enable the peripheral clock.
+ *
+ * Returned Value:
+ *   None
+ *
+ ************************************************************************************/
+
+void s32k1xx_pclk_enable(enum clock_names_e clkname, bool enable)
+{
+  uint32_t *ctrlp = s32k1xx_get_pclkctrl(clkname);
+  DEBUGASSERT(ctrlp != NULL);
+
+  // check if it needs to be enabled
+  if(enable)
+  {
+    // enable it
+    *ctrlp |= PCC_CGC;
+  }
+  else
+  {
+    // disable it
+    *ctrlp &= ~PCC_CGC;
+  }
+}
diff --git a/arch/arm/src/s32k1xx/s32k1xx_periphclocks.h b/arch/arm/src/s32k1xx/s32k1xx_periphclocks.h
index 458ce5b844..e0ca6e465a 100644
--- a/arch/arm/src/s32k1xx/s32k1xx_periphclocks.h
+++ b/arch/arm/src/s32k1xx/s32k1xx_periphclocks.h
@@ -267,6 +267,23 @@ void s32k1xx_periphclocks(unsigned int count,
 
 int s32k1xx_get_pclkfreq(enum clock_names_e clkname, uint32_t *frequency);
 
+/************************************************************************************
+ * Name: s32k1xx_pclk_enable
+ *
+ * Description:
+ *   This function enables/disables the clock for a given peripheral.
+ *
+ * Input Parameters:
+ *   clkname - The name of the peripheral clock to be disabled
+ *   enable  - true:  Enable the peripheral clock.
+ *
+ * Returned Value:
+ *   None
+ *
+ ************************************************************************************/
+
+void s32k1xx_pclk_enable(enum clock_names_e clkname, bool enable);
+
 #undef EXTERN
 #if defined(__cplusplus)
 }
diff --git a/arch/arm/src/s32k1xx/s32k1xx_pingpio.c b/arch/arm/src/s32k1xx/s32k1xx_pingpio.c
index 5661da57b6..b8dfedbfb2 100644
--- a/arch/arm/src/s32k1xx/s32k1xx_pingpio.c
+++ b/arch/arm/src/s32k1xx/s32k1xx_pingpio.c
@@ -111,7 +111,6 @@ bool s32k1xx_gpioread(uint32_t pinset)
   bool         ret = false;
 
   DEBUGASSERT((pinset & _PIN_MODE_MASK) == _PIN_MODE_GPIO);
-  DEBUGASSERT((pinset & _PIN_IO_MASK) == _PIN_INPUT);
 
   /* Get the port number and pin number */
 
@@ -127,8 +126,17 @@ bool s32k1xx_gpioread(uint32_t pinset)
 
       /* return the state of the pin */
 
+      //if ((pinset & _PIN_IO_MASK) == _PIN_INPUT)
+      //  {
       regval = getreg32(base + S32K1XX_GPIO_PDIR_OFFSET);
+      //  }
+      // else if ((pinset & _PIN_IO_MASK) == _PIN_OUTPUT)
+      //   {
+      //     regval = getreg32(base + S32K1XX_GPIO_PDOR_OFFSET);
+      //   }
+
       ret    = ((regval & (1 << pin)) != 0);
     }
+
   return ret;
 }
diff --git a/arch/arm/src/s32k1xx/s32k1xx_pminitialize.c b/arch/arm/src/s32k1xx/s32k1xx_pminitialize.c
new file mode 100644
index 0000000000..07e9bad4af
--- /dev/null
+++ b/arch/arm/src/s32k1xx/s32k1xx_pminitialize.c
@@ -0,0 +1,78 @@
+/****************************************************************************
+ * arch/arm/src/s32k1xx/s32k1xx_pminitialize.c
+ *
+ *   Copyright (C) 2012 Gregory Nutt. All rights reserved.
+ *   Author: Gregory Nutt <gnutt@nuttx.org>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include <nuttx/power/pm.h>
+
+#include "arm_internal.h"
+//#include "s32k1xx_pm.h"
+
+#ifdef CONFIG_PM
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: arm_pminitialize
+ *
+ * Description:
+ *   This function is called by MCU-specific logic at power-on reset in
+ *   order to provide one-time initialization the power management subsystem.
+ *   This function must be called *very* early in the initialization sequence
+ *   *before* any other device drivers are initialized (since they may
+ *   attempt to register with the power management subsystem).
+ *
+ * Input Parameters:
+ *   None.
+ *
+ * Returned Value:
+ *   None.
+ *
+ ****************************************************************************/
+
+void arm_pminitialize(void)
+{
+  /* Then initialize the NuttX power management subsystem proper */
+
+  pm_initialize();
+}
+
+#endif /* CONFIG_PM */
diff --git a/arch/arm/src/s32k1xx/s32k1xx_resetcause.c b/arch/arm/src/s32k1xx/s32k1xx_resetcause.c
new file mode 100644
index 0000000000..31e6900c03
--- /dev/null
+++ b/arch/arm/src/s32k1xx/s32k1xx_resetcause.c
@@ -0,0 +1,350 @@
+/******************************************************************************
+ * arch/arm/src/s32k1xx/s32k1xx_resetcause.c
+ *
+ *   Copyright (C) 2019 Gregory Nutt. All rights reserved.
+ *   Author:  Gregory Nutt <gnutt@nuttx.org>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+
+/******************************************************************************
+ * Included Files
+ ******************************************************************************/
+
+#include <nuttx/config.h>
+#include <nuttx/fs/procfs.h>
+#include <nuttx/fs/dirent.h>
+#include <nuttx/kmalloc.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <stdint.h>
+#include <assert.h>
+#include <errno.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>
+#include <debug.h>
+
+#include "arm_arch.h"
+
+#include "hardware/s32k1xx_rcm.h"
+
+// #include "s32k1xx_config.h"
+#include "s32k1xx_resetcause.h"
+
+#include "arm_internal.h"
+
+#include <arch/board/board.h> /* Include last:  has dependencies */
+
+/****************************************************************************
+ * Pre-processor Definitions
+ ****************************************************************************/
+
+/* Determines the size of an intermediate buffer that must be large enough
+ * to handle the longest line generated by this logic.
+ */
+#define RESETCAUSE_LINELEN 6
+
+/****************************************************************************
+ * Private Types
+ ****************************************************************************/
+
+/* This structure describes one open "file" */
+
+struct resetcause_file_s
+{
+  struct procfs_file_s  base;        /* Base open file structure */
+  unsigned int linesize;             /* Number of valid characters in line[] */
+  char line[RESETCAUSE_LINELEN];     /* Pre-allocated buffer for formatted lines */
+  unsigned int resetcause;           /* Variable representing the MCU specific reset cause */
+};
+
+static unsigned int gResetCause = 0;
+
+#if defined(CONFIG_RESET_CAUSE_PROC_FS) && defined(CONFIG_FS_PROCFS)
+
+/****************************************************************************
+ * Private Function Prototypes
+ ****************************************************************************/
+
+/* File system methods */
+
+static int     resetcause_open(FAR struct file *filep, FAR const char *relpath,
+                 int oflags, mode_t mode);
+static int     resetcause_close(FAR struct file *filep);
+static ssize_t resetcause_read(FAR struct file *filep, FAR char *buffer,
+                 size_t buflen);
+
+static int     resetcause_dup(FAR const struct file *oldp,
+                 FAR struct file *newp);
+
+static int     resetcause_stat(FAR const char *relpath, FAR struct stat *buf);
+
+/****************************************************************************
+ * Public Data
+ ****************************************************************************/
+
+const struct procfs_operations resetcause_operations =
+{
+  resetcause_open,   /* open */
+  resetcause_close,  /* close */
+  resetcause_read,   /* read */
+  NULL,              /* write */
+
+  resetcause_dup,    /* dup */
+
+  NULL,              /* opendir */
+  NULL,              /* closedir */
+  NULL,              /* readdir */
+  NULL,              /* rewinddir */
+
+  resetcause_stat    /* stat */
+};
+
+static const struct procfs_entry_s g_resetcause_procfs =
+{
+  "resetcause", &resetcause_operations
+};
+
+/****************************************************************************
+ * Private Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: resetcause_open
+ ****************************************************************************/
+
+static int resetcause_open(FAR struct file *filep, FAR const char *relpath,
+                      int oflags, mode_t mode)
+{
+  FAR struct resetcause_file_s *attr;
+
+  finfo("Open '%s'\n", relpath);
+
+  /* PROCFS is read-only.  Any attempt to open with any kind of write
+   * access is not permitted.
+   *
+   * REVISIT:  Write-able proc files could be quite useful.
+   */
+
+  if ((oflags & O_WRONLY) != 0 || (oflags & O_RDONLY) == 0)
+    {
+      ferr("ERROR: Only O_RDONLY supported\n");
+      return -EACCES;
+    }
+
+  /* "resetcause" is the only acceptable value for the relpath */
+
+  if (strcmp(relpath, "resetcause") != 0)
+    {
+      ferr("ERROR: relpath is '%s'\n", relpath);
+      return -ENOENT;
+    }
+
+  /* Allocate a container to hold the file attributes */
+
+  attr = kmm_zalloc(sizeof(struct resetcause_file_s));
+  if (!attr)
+    {
+      ferr("ERROR: Failed to allocate file attributes\n");
+      return -ENOMEM;
+    }
+
+  /* Save the attributes as the open-specific state in filep->f_priv */
+
+  filep->f_priv = (FAR void *)attr;
+  return OK;
+}
+
+/****************************************************************************
+ * Name: resetcause_close
+ ****************************************************************************/
+
+static int resetcause_close(FAR struct file *filep)
+{
+  FAR struct resetcause_file_s *attr;
+
+  /* Recover our private data from the struct file instance */
+
+  attr = (FAR struct resetcause_file_s *)filep->f_priv;
+  DEBUGASSERT(attr);
+
+  /* Release the file attributes structure */
+
+  kmm_free(attr);
+  filep->f_priv = NULL;
+  return OK;
+}
+
+/****************************************************************************
+ * Name: resetcause_read
+ ****************************************************************************/
+
+static ssize_t resetcause_read(FAR struct file *filep, FAR char *buffer,
+                           size_t buflen)
+{
+  FAR struct resetcause_file_s *attr;
+  size_t linesize;
+  off_t offset;
+  ssize_t ret;
+
+  finfo("buffer=%p buflen=%d\n", buffer, (int)buflen);
+
+  /* Recover our private data from the struct file instance */
+
+  attr = (FAR struct resetcause_file_s *)filep->f_priv;
+  DEBUGASSERT(attr);
+
+  /* Get the resetcause value and store it  */
+  attr->resetcause = gResetCause;
+
+  /* Convert the resetcause to a string */
+  linesize  = snprintf(attr->line, RESETCAUSE_LINELEN, "0x%x", attr->resetcause);
+
+  /* Save the linesize in case we are re-entered with f_pos > 0 */
+
+  attr->linesize = linesize;
+
+  /* Transfer the system reset cause to user receive buffer */
+
+  offset = filep->f_pos;
+
+  ret = procfs_memcpy(attr->line, attr->linesize, buffer, buflen, &offset);
+
+  return ret;
+}
+
+/****************************************************************************
+ * Name: resetcause_dup
+ *
+ * Description:
+ *   Duplicate open file data in the new file structure.
+ *
+ ****************************************************************************/
+
+static int resetcause_dup(FAR const struct file *oldp, FAR struct file *newp)
+{
+  FAR struct resetcause_file_s *oldattr;
+  FAR struct resetcause_file_s *newattr;
+
+  finfo("Dup %p->%p\n", oldp, newp);
+
+  /* Recover our private data from the old struct file instance */
+
+  oldattr = (FAR struct resetcause_file_s *)oldp->f_priv;
+  DEBUGASSERT(oldattr);
+
+  /* Allocate a new container to hold the task and attribute selection */
+
+  newattr = kmm_malloc(sizeof(struct resetcause_file_s));
+  if (!newattr)
+    {
+      ferr("ERROR: Failed to allocate file attributes\n");
+      return -ENOMEM;
+    }
+
+  /* The copy the file attributes from the old attributes to the new */
+
+  memcpy(newattr, oldattr, sizeof(struct resetcause_file_s));
+
+  /* Save the new attributes in the new file structure */
+
+  newp->f_priv = (FAR void *)newattr;
+  return OK;
+}
+
+/****************************************************************************
+ * Name: resetcause_stat
+ *
+ * Description: Return information about a file or directory
+ *
+ ****************************************************************************/
+
+static int resetcause_stat(FAR const char *relpath, FAR struct stat *buf)
+{
+  /* "resetcause" is the only acceptable value for the relpath */
+
+  if (strcmp(relpath, "resetcause") != 0)
+    {
+      ferr("ERROR: relpath is '%s'\n", relpath);
+      return -ENOENT;
+    }
+
+  /* "resetcause" is the name for a read-only file */
+
+  memset(buf, 0, sizeof(struct stat));
+  buf->st_mode = S_IFREG | S_IROTH | S_IRGRP | S_IRUSR;
+  return OK;
+}
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/*!
+ * @brief   this function registrates the reset cause as a proc fs
+ *      
+ * @param   none
+ *
+ * @return  0 if OK, error number otherwise
+ *
+ */
+int s32k1xx_resetcause_initialize_procfs(void)
+{
+  // int ret;
+  return procfs_register(&g_resetcause_procfs);
+  // if (ret < 0)
+  //     ret = -EPERM;
+  // return ret;
+}
+
+/*!
+ * @brief   this function initializes the resetcause
+ *
+ *      It will get the resetcause and store it
+ *      
+ * @param   none
+ *
+ * @return  none
+ *
+ */
+void s32k1xx_resetcause_init(void)
+{
+  uint32_t resetCauseRegister = 0;
+
+  // get the reset cause
+  resetCauseRegister = getreg32(S32K1XX_RCM_SRS);
+
+  // save it in the global variable 
+  gResetCause = (unsigned int) resetCauseRegister;
+}
+
+#endif /* CONFIG_RESET_CAUSE_PROC_FS && CONFIG_FS_PROCFS */
diff --git a/arch/arm/src/s32k1xx/s32k1xx_resetcause.h b/arch/arm/src/s32k1xx/s32k1xx_resetcause.h
new file mode 100644
index 0000000000..0474011a35
--- /dev/null
+++ b/arch/arm/src/s32k1xx/s32k1xx_resetcause.h
@@ -0,0 +1,83 @@
+/******************************************************************************
+ * arch/arm/src/s32k1xx/s32k1xx_resetcause.h
+ *
+ *   Copyright (C) 2019 Gregory Nutt. All rights reserved.
+ *   Author:  Gregory Nutt <gnutt@nuttx.org>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+
+#ifndef __ARCH_ARM_SRC_S32K1XX_RESETCAUSE_H
+#define __ARCH_ARM_SRC_S32K1XX_RESETCAUSE_H
+
+/******************************************************************************
+ * Included Files
+ ******************************************************************************/
+
+#include <nuttx/config.h>
+#include <nuttx/compiler.h>
+
+#include <sys/types.h>
+#include <stdint.h>
+#include <stdbool.h>
+
+// #include "arm_internal.h"
+// #include "s32k1xx_config.h"
+
+/******************************************************************************
+ * Pre-processor Definitions
+ ******************************************************************************/
+
+/******************************************************************************
+ * Public Function Prototypes
+ ******************************************************************************/
+
+/*!
+ * @brief 	this function initializes the resetcause
+ *
+ * 			It will get the resetcause and store it
+ * 			
+ * @param 	none
+ *
+ * @return 	none
+ *
+ */
+void s32k1xx_resetcause_init(void);
+
+/*!
+ * @brief   this function registrates the reset cause as a proc fs
+ *      
+ * @param   none
+ *
+ * @return  0 if OK, error number otherwise
+ *
+ */
+int s32k1xx_resetcause_initialize_procfs(void);
+
+#endif /* __ARCH_ARM_SRC_S32K1XX_RESETCAUSE_H */
diff --git a/arch/arm/src/s32k1xx/s32k1xx_serial.c b/arch/arm/src/s32k1xx/s32k1xx_serial.c
index 3144d40084..f33e31cecb 100644
--- a/arch/arm/src/s32k1xx/s32k1xx_serial.c
+++ b/arch/arm/src/s32k1xx/s32k1xx_serial.c
@@ -70,6 +70,8 @@
 #include "s32k1xx_pin.h"
 #include "s32k1xx_lowputc.h"
 
+#include "s32k1xx_periphclocks.h"
+
 #ifdef USE_SERIALDRIVER
 
 /****************************************************************************
@@ -145,9 +147,42 @@
 #endif
 
 #if defined(CONFIG_PM)
+#ifndef PM_IDLE_DOMAIN
 #  define PM_IDLE_DOMAIN      0 /* Revisit */
 #endif
+#endif
 
+#ifdef HAVE_LPUART_CONSOLE
+#  if defined(CONFIG_LPUART0_SERIAL_CONSOLE)
+#    define S32K1XX_CONSOLE_BASE     S32K1XX_LPUART0_BASE
+#    define S32K1XX_CONSOLE_BAUD     CONFIG_LPUART0_BAUD
+#    define S32K1XX_CONSOLE_BITS     CONFIG_LPUART0_BITS
+#    define S32K1XX_CONSOLE_PARITY   CONFIG_LPUART0_PARITY
+#    define S32K1XX_CONSOLE_2STOP    CONFIG_LPUART0_2STOP
+#  elif defined(CONFIG_LPUART1_SERIAL_CONSOLE)
+#    define S32K1XX_CONSOLE_BASE     S32K1XX_LPUART1_BASE
+#    define S32K1XX_CONSOLE_BAUD     CONFIG_LPUART1_BAUD
+#    define S32K1XX_CONSOLE_BITS     CONFIG_LPUART1_BITS
+#    define S32K1XX_CONSOLE_PARITY   CONFIG_LPUART1_PARITY
+#    define S32K1XX_CONSOLE_2STOP    CONFIG_LPUART1_2STOP
+#  elif defined(CONFIG_LPUART2_SERIAL_CONSOLE)
+#    define S32K1XX_CONSOLE_BASE     S32K1XX_LPUART2_BASE
+#    define S32K1XX_CONSOLE_BAUD     CONFIG_LPUART2_BAUD
+#    define S32K1XX_CONSOLE_BITS     CONFIG_LPUART2_BITS
+#    define S32K1XX_CONSOLE_PARITY   CONFIG_LPUART2_PARITY
+#    define S32K1XX_CONSOLE_2STOP    CONFIG_LPUART2_2STOP
+#  endif
+#endif
+
+#if defined(CONFIG_PM_SERIAL0_STANDBY) || defined(CONFIG_PM_SERIAL0_SLEEP)
+#   define CONFIG_PM_SERIAL0
+#endif
+#if defined(CONFIG_PM_SERIAL1_STANDBY) || defined(CONFIG_PM_SERIAL1_SLEEP)
+#   define CONFIG_PM_SERIAL1
+#endif
+#if defined(CONFIG_PM_SERIAL2_STANDBY) || defined(CONFIG_PM_SERIAL2_SLEEP)
+#   define CONFIG_PM_SERIAL2
+#endif
 /****************************************************************************
  * Private Types
  ****************************************************************************/
@@ -521,8 +556,10 @@ static int s32k1xx_setup(struct uart_dev_s *dev)
   config.invrts     = priv->inviflow;   /* Inversion of outbound flow control */
 #endif
 
+  // configure the LPUART
   ret = s32k1xx_lpuart_configure(priv->uartbase, &config);
 
+  // get the current interrupt bits and place them in ie (used to use the interrupts) 
   priv->ie = s32k1xx_serialin(priv, S32K1XX_LPUART_CTRL_OFFSET) & \
              LPUART_ALL_INTS;
   return ret;
@@ -548,8 +585,11 @@ static void s32k1xx_shutdown(struct uart_dev_s *dev)
   struct s32k1xx_uart_s *priv = (struct s32k1xx_uart_s *)dev->priv;
 
   /* Disable the UART */
-
+  // set the reset bit 
   s32k1xx_serialout(priv, S32K1XX_LPUART_GLOBAL_OFFSET, LPUART_GLOBAL_RST);
+
+  // clear the reset bit again
+  s32k1xx_serialout(priv, S32K1XX_LPUART_GLOBAL_OFFSET, 0);
 }
 
 /****************************************************************************
@@ -1127,38 +1167,172 @@ static bool s32k1xx_txempty(struct uart_dev_s *dev)
 static void up_pm_notify(struct pm_callback_s *cb, int domain,
                          enum pm_state_e pmstate)
 {
-  switch (pmstate)
+ unsigned int count = 0;   // the amount of peripheral clocks to change
+  peripheral_clock_source_t clockSource;
+
+  #ifdef CONFIG_PM_SERIAL0
+    struct s32k1xx_uart_s *priv0 = g_uart0port.priv;
+  #endif
+  #ifdef CONFIG_PM_SERIAL1
+    struct s32k1xx_uart_s *priv1 = g_uart1port.priv;
+  #endif
+  #ifdef CONFIG_PM_SERIAL2
+    struct s32k1xx_uart_s *priv2 = g_uart2port.priv;
+  #endif
+
+  uint32_t retReg = 0;
+  //#ifdef CONSOLE_DEV
+
+  // check if the transition is from the IDLE domain to the NORMAL domain
+  // or the mode is already done
+  if(((pm_querystate(PM_IDLE_DOMAIN) == PM_IDLE) && (pmstate == PM_NORMAL)) ||
+    (((pm_querystate(PM_IDLE_DOMAIN) == pmstate))))
+  {
+    // return
+    return;
+  }
+
+  // check which PM it is 
+  switch(pmstate)
+  {
+    //in case it needs to change to the RUN mode
+    case PM_NORMAL:
     {
-      case(PM_NORMAL):
-        {
-          /* Logic for PM_NORMAL goes here */
-        }
-        break;
+      /* Logic for PM_NORMAL goes here */
+      
+      // set the right clock source to go back to RUN mode
+      clockSource = CLK_SRC_SPLL_DIV2;
 
-      case(PM_IDLE):
-        {
-          /* Logic for PM_IDLE goes here */
-        }
-        break;
+      count = 1;
+    }
+    break;
+    default:
+    {
+      // don't do anything, just return OK
+      //return;
+    }
+    break;
+  }
 
-      case(PM_STANDBY):
-        {
-          /* Logic for PM_STANDBY goes here */
-        }
-        break;
+  // check if something needs to change
+  if(count)
+  {
 
-      case(PM_SLEEP):
-        {
-          /* Logic for PM_SLEEP goes here */
-        }
-        break;
+    #ifdef CONFIG_PM_SERIAL0
+
+      // make the peripheral clock config struct
+      const struct peripheral_clock_config_s clockConfig0 = 
+      {
+        .clkname  =   LPUART0_CLK,
+        .clkgate  =   true,
+        .clksrc   =   clockSource,
+        .frac     =   MULTIPLY_BY_ONE,
+        .divider  =   1,
+      };
 
-      default:
+      // read the FIFO register
+      retReg = getreg32(priv0->uartbase + S32K1XX_LPUART_FIFO_OFFSET);
 
-        /* Should not get here */
+      // make the value
+      retReg |= (LPUART_FIFO_RXFLUSH + LPUART_FIFO_TXFLUSH);
 
-        break;
-    }
+      // write the new value
+      putreg32(retReg, priv0->uartbase + S32K1XX_LPUART_FIFO_OFFSET);
+
+      // shutdown the LPUART1 (soft reset)
+      s32k1xx_shutdown(&g_uart0port);
+
+      // change the clock config for the new mode
+      s32k1xx_periphclocks(count, &clockConfig0);
+
+      // shutdown the LPUART1 (soft reset)
+      s32k1xx_shutdown(&g_uart0port);
+
+      // set up the LPUART1 again for the new mode
+      s32k1xx_setup(&g_uart0port);
+
+      // enable the interrupts
+      s32k1xx_rxint(&g_uart0port, true);
+      s32k1xx_txint(&g_uart0port, true);
+      
+    #endif
+    #ifdef CONFIG_PM_SERIAL1
+
+      // make the peripheral clock config struct
+      const struct peripheral_clock_config_s clockConfig1 = 
+      {
+        .clkname  =   LPUART1_CLK,
+        .clkgate  =   true,
+        .clksrc   =   clockSource,
+        .frac     =   MULTIPLY_BY_ONE,
+        .divider  =   1,
+      };
+
+      // read the FIFO register
+      retReg = getreg32(priv1->uartbase + S32K1XX_LPUART_FIFO_OFFSET);
+
+      // make the value
+      retReg |= (LPUART_FIFO_RXFLUSH + LPUART_FIFO_TXFLUSH);
+
+      // write the new value
+      putreg32(retReg, priv1->uartbase + S32K1XX_LPUART_FIFO_OFFSET);
+
+      // shutdown the LPUART1 (soft reset)
+      s32k1xx_shutdown(&g_uart1port);
+
+      // change the clock config for the new mode
+      s32k1xx_periphclocks(count, &clockConfig1);
+
+      // shutdown the LPUART1 (soft reset)
+      s32k1xx_shutdown(&g_uart1port);
+
+      // set up the LPUART1 again for the new mode
+      s32k1xx_setup(&g_uart1port);
+
+      // enable the interrupts
+      s32k1xx_rxint(&g_uart1port, true);
+      s32k1xx_txint(&g_uart1port, true);
+
+    #endif
+    #ifdef CONFIG_PM_SERIAL2
+
+      // make the peripheral clock config struct
+      const struct peripheral_clock_config_s clockConfig2 = 
+      {
+        .clkname  =   LPUART2_CLK,
+        .clkgate  =   true,
+        .clksrc   =   clockSource,
+        .frac     =   MULTIPLY_BY_ONE,
+        .divider  =   1,
+      };
+
+      // read the FIFO register
+      retReg = getreg32(priv2->uartbase + S32K1XX_LPUART_FIFO_OFFSET);
+
+      // make the value
+      retReg |= (LPUART_FIFO_RXFLUSH + LPUART_FIFO_TXFLUSH);
+
+      // write the new value
+      putreg32(retReg, priv2->uartbase + S32K1XX_LPUART_FIFO_OFFSET);
+
+      // shutdown the LPUART1 (soft reset)
+      s32k1xx_shutdown(&g_uart2port);
+
+      // change the clock config for the new mode
+      s32k1xx_periphclocks(count, &clockConfig2);
+
+      // shutdown the LPUART1 (soft reset)
+      s32k1xx_shutdown(&g_uart2port);
+
+      // set up the LPUART1 again for the new mode
+      s32k1xx_setup(&g_uart2port);
+
+      // enable the interrupts
+      s32k1xx_rxint(&g_uart2port, true);
+      s32k1xx_txint(&g_uart2port, true);
+      
+    #endif
+  }
 }
 #endif
 
@@ -1202,6 +1376,173 @@ static int up_pm_prepare(struct pm_callback_s *cb, int domain,
 {
   /* Logic to prepare for a reduced power state goes here. */
 
+  unsigned int count = 1;   // the amount of peripheral clocks to change
+  peripheral_clock_source_t clockSource;
+
+  #ifdef CONFIG_PM_SERIAL0
+    struct s32k1xx_uart_s *priv0 = (struct s32k1xx_uart_s *)g_uart0port.priv;
+  #endif
+  #ifdef CONFIG_PM_SERIAL1
+    struct s32k1xx_uart_s *priv1 = (struct s32k1xx_uart_s *)g_uart1port.priv;
+  #endif
+  #ifdef CONFIG_PM_SERIAL2
+    struct s32k1xx_uart_s *priv2 = (struct s32k1xx_uart_s *)g_uart2port.priv;
+  #endif
+
+  uint32_t retReg = 0;
+
+  // check if the transition to the mode is already done
+  if(pm_querystate(PM_IDLE_DOMAIN) == pmstate )
+  {
+    // return
+    return OK;
+  }
+
+  // check which PM it is 
+  switch(pmstate)
+  {
+    // in case it needs to prepare for VLPR mode
+    case PM_STANDBY:
+    {
+      /* Logic for PM_STANDBY goes here */
+
+      // set the right clock source
+      clockSource = CLK_SRC_SIRC_DIV2;
+    }
+    break;
+    // in case it needs to prepare for sleep mode
+    case PM_SLEEP:
+    {
+      /* Logic for PM_SLEEP goes here */
+
+      // set the right clock source
+      clockSource = CLK_SRC_SIRC_DIV2;
+    }
+    break;
+    default:
+    {
+      // don't do anything, just return OK
+      return OK;
+    }
+    break;
+  }
+
+  #ifdef CONFIG_PM_SERIAL0
+
+    // make the peripheral clock config struct
+    const struct peripheral_clock_config_s clockConfig0 = 
+    {
+      .clkname  =   LPUART0_CLK,
+      .clkgate  =   true,
+      .clksrc   =   clockSource,
+      .frac     =   MULTIPLY_BY_ONE,
+      .divider  =   1,
+    };
+
+    // read the FIFO register
+    retReg = getreg32(priv0->uartbase + S32K1XX_LPUART_FIFO_OFFSET);
+
+    // make the value
+    retReg |= (LPUART_FIFO_RXFLUSH + LPUART_FIFO_TXFLUSH);
+
+    // write the new value
+    putreg32(retReg, priv0->uartbase + S32K1XX_LPUART_FIFO_OFFSET);
+
+    // shutdown the LPUART1 (soft reset)
+    s32k1xx_shutdown(&g_uart0port);
+
+    // change the clock config for the new mode
+    s32k1xx_periphclocks(count, &clockConfig0);
+
+    // shutdown the LPUART1 (soft reset)
+    s32k1xx_shutdown(&g_uart0port);
+
+    // set up the LPUART1 again for the new mode
+    s32k1xx_setup(&g_uart0port);
+
+    // enable the interrupts
+    s32k1xx_rxint(&g_uart0port, true);
+    s32k1xx_txint(&g_uart0port, true);
+
+  #endif
+  #ifdef CONFIG_PM_SERIAL1
+
+    // make the peripheral clock config struct
+    const struct peripheral_clock_config_s clockConfig1 = 
+    {
+      .clkname  =   LPUART1_CLK,
+      .clkgate  =   true,
+      .clksrc   =   clockSource,
+      .frac     =   MULTIPLY_BY_ONE,
+      .divider  =   1,
+    };
+
+    // read the FIFO register
+    retReg = getreg32(priv1->uartbase + S32K1XX_LPUART_FIFO_OFFSET);
+
+    // make the value
+    retReg |= (LPUART_FIFO_RXFLUSH + LPUART_FIFO_TXFLUSH);
+
+    // write the new value
+    putreg32(retReg, priv1->uartbase + S32K1XX_LPUART_FIFO_OFFSET);
+
+    // shutdown the LPUART1 (soft reset)
+    s32k1xx_shutdown(&g_uart1port);
+
+    // change the clock config for the new mode
+    s32k1xx_periphclocks(count, &clockConfig1);
+
+    // shutdown the LPUART1 (soft reset)
+    s32k1xx_shutdown(&g_uart1port);
+
+    // set up the LPUART1 again for the new mode
+    s32k1xx_setup(&g_uart1port);
+
+    // enable the interrupts
+    s32k1xx_rxint(&g_uart1port, true);
+    s32k1xx_txint(&g_uart1port, true);
+    
+  #endif
+  #ifdef CONFIG_PM_SERIAL2
+
+    // make the peripheral clock config struct
+    const struct peripheral_clock_config_s clockConfig2 = 
+    {
+      .clkname  =   LPUART2_CLK,
+      .clkgate  =   true,
+      .clksrc   =   clockSource,
+      .frac     =   MULTIPLY_BY_ONE,
+      .divider  =   1,
+    };
+
+    // read the FIFO register
+    retReg = getreg32(priv2->uartbase + S32K1XX_LPUART_FIFO_OFFSET);
+
+    // make the value
+    retReg |= (LPUART_FIFO_RXFLUSH + LPUART_FIFO_TXFLUSH);
+
+    // write the new value
+    putreg32(retReg, priv2->uartbase + S32K1XX_LPUART_FIFO_OFFSET);
+
+    // shutdown the LPUART1 (soft reset)
+    s32k1xx_shutdown(&g_uart2port);
+
+    // change the clock config for the new mode
+    s32k1xx_periphclocks(count, &clockConfig2);
+
+    // shutdown the LPUART1 (soft reset)
+    s32k1xx_shutdown(&g_uart2port);
+
+    // set up the LPUART1 again for the new mode
+    s32k1xx_setup(&g_uart2port);
+
+    // enable the interrupts
+    s32k1xx_rxint(&g_uart2port, true);
+    s32k1xx_txint(&g_uart2port, true);
+    
+  #endif
+
+  // return
   return OK;
 }
 #endif
@@ -1249,13 +1590,16 @@ void s32k1xx_earlyserialinit(void)
 void arm_serialinit(void)
 {
 #ifdef CONFIG_PM
-  int ret;
+  #if defined(CONFIG_PM_SERIAL_STANDBY) || defined(CONFIG_PM_SERIAL_SLEEP) 
+ 
+    int ret;
 
-  /* Register to receive power management callbacks */
+    /* Register to receive power management callbacks */
 
-  ret = pm_register(&g_serial_pmcb);
-  DEBUGASSERT(ret == OK);
-  UNUSED(ret);
+    ret = pm_register(&g_serial_pmcb);
+    DEBUGASSERT(ret == OK);
+    UNUSED(ret);
+  #endif
 #endif
 
 #ifdef CONSOLE_DEV
diff --git a/boards/Kconfig b/boards/Kconfig
index ef0913fc4b..e92b23f776 100644
--- a/boards/Kconfig
+++ b/boards/Kconfig
@@ -1313,6 +1313,14 @@ config ARCH_BOARD_S32K144EVB
 		This options selects support for NuttX on the NXP S32K144EVB board
 		featuring the S32K144 Cortex-M4F.
 
+config ARCH_BOARD_RDDRONE_BMS772
+	bool "NXP RDDRONE-BMS772"
+	depends on ARCH_CHIP_S32K144
+	select ARCH_HAVE_LEDS
+	---help---
+		This options selects support for NuttX on the NXP RDDRONE-BMS772 board
+		featuring the S32K144 Cortex-M4F.
+
 config ARCH_BOARD_RDDRONE_UAVCAN144
 	bool "NXP RDDRONE-UAVCAN144"
 	depends on ARCH_CHIP_S32K144
@@ -2276,6 +2284,7 @@ config ARCH_BOARD
 	default "rddrone-uavcan146"        if ARCH_BOARD_RDDRONE_UAVCAN146
 	default "s32k146evb"               if ARCH_BOARD_S32K146EVB
 	default "s32k148evb"               if ARCH_BOARD_S32K148EVB
+	default "rddrone-bms772"           if ARCH_BOARD_RDDRONE_BMS772
 	default "sabre-6quad"              if ARCH_BOARD_SABRE_6QUAD
 	default "sama5d2-xult"             if ARCH_BOARD_SAMA5D2_XULT
 	default "giant-board"              if ARCH_BOARD_GIANT_BOARD
@@ -2416,6 +2425,9 @@ endif
 if ARCH_BOARD_S32K144EVB
 source "boards/arm/s32k1xx/s32k144evb/Kconfig"
 endif
+if ARCH_BOARD_RDDRONE_BMS772
+source "boards/arm/s32k1xx/rddrone-bms772/Kconfig"
+endif
 if ARCH_BOARD_RDDRONE_UAVCAN144
 source "boards/arm/s32k1xx/rddrone-uavcan144/Kconfig"
 endif
diff --git a/boards/arm/s32k1xx/drivers/Kconfig b/boards/arm/s32k1xx/drivers/Kconfig
new file mode 100644
index 0000000000..9029fd4990
--- /dev/null
+++ b/boards/arm/s32k1xx/drivers/Kconfig
@@ -0,0 +1,8 @@
+#
+# For a description of the syntax of this configuration file,
+# see the file kconfig-language.txt in the NuttX tools repository.
+#
+
+if SPECIFIC_DRIVERS
+source "drivers/platform/smart_battery/Kconfig"
+endif
diff --git a/boards/arm/s32k1xx/drivers/Make.defs b/boards/arm/s32k1xx/drivers/Make.defs
new file mode 100644
index 0000000000..be225b3c87
--- /dev/null
+++ b/boards/arm/s32k1xx/drivers/Make.defs
@@ -0,0 +1,21 @@
+############################################################################
+# boards/arm/s32k1xx/drivers/Make.defs
+#
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.  The
+# ASF licenses this file to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance with the
+# License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+# License for the specific language governing permissions and limitations
+# under the License.
+#
+############################################################################
+
+include platform/smart_battery/Make.defs
diff --git a/boards/arm/s32k1xx/drivers/smart_battery/Kconfig b/boards/arm/s32k1xx/drivers/smart_battery/Kconfig
new file mode 100644
index 0000000000..832acf23e0
--- /dev/null
+++ b/boards/arm/s32k1xx/drivers/smart_battery/Kconfig
@@ -0,0 +1,12 @@
+#
+# For a description of the syntax of this configuration file,
+# see the file kconfig-language.txt in the NuttX tools repository.
+#
+
+config SBS_DRIVER
+	bool "Simple SBS driver"
+	default n
+	depends on I2C_SLAVE
+	---help---
+		Simple smart battery driver, implementing a subset of the
+		Smart Battery System (SBS) 1.1 specification for SMBus.
diff --git a/boards/arm/s32k1xx/drivers/smart_battery/Make.defs b/boards/arm/s32k1xx/drivers/smart_battery/Make.defs
new file mode 100644
index 0000000000..cc1dc189cb
--- /dev/null
+++ b/boards/arm/s32k1xx/drivers/smart_battery/Make.defs
@@ -0,0 +1,27 @@
+############################################################################
+# boards/arm/s32k1xx/drivers/smart_battery/Make.defs
+#
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.  The
+# ASF licenses this file to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance with the
+# License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+# License for the specific language governing permissions and limitations
+# under the License.
+#
+############################################################################
+
+ifeq ($(CONFIG_SBS_DRIVER),y)
+  CSRCS += simple_sbs.c
+endif
+
+DEPPATH += --dep-path platform$(DELIM)smart_battery
+VPATH += :platform$(DELIM)smart_battery
+CFLAGS += $(shell $(INCDIR) "$(CC)" $(TOPDIR)$(DELIM)drivers$(DELIM)platform$(DELIM)smart_battery)
diff --git a/boards/arm/s32k1xx/drivers/smart_battery/simple_sbs.c b/boards/arm/s32k1xx/drivers/smart_battery/simple_sbs.c
new file mode 100644
index 0000000000..fb20c8b1fb
--- /dev/null
+++ b/boards/arm/s32k1xx/drivers/smart_battery/simple_sbs.c
@@ -0,0 +1,805 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/drivers/smart_battery/simple_sbs.c
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.  The
+ * ASF licenses this file to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ *
+ ****************************************************************************/
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <debug.h>
+
+#include <nuttx/kmalloc.h>
+#include <nuttx/fs/fs.h>
+#include <nuttx/i2c/i2c_slave.h>
+
+#include "simple_sbs.h"
+
+#ifdef CONFIG_SBS_DRIVER
+
+/****************************************************************************
+ * Pre-processor Definitions
+ ****************************************************************************/
+
+/* Macros for splitting a 16-bit unsigned integer into two bytes */
+
+#define LOBYTE(n) ((uint8_t) ((n) & 0x00ff))
+#define HIBYTE(n) ((uint8_t) (((n) & 0xff00) >> 8))
+
+/****************************************************************************
+ * Private Type Definitions
+ ****************************************************************************/
+
+/* Private data of the SBS device */
+
+struct sbs_dev_s
+{
+  FAR struct i2c_slave_s *i2c_slave_dev; /* Associated I2C slave device */
+  FAR struct sbs_data_s *data;           /* Most recent battery data */
+
+  uint8_t read_buffer[3];   /* Pre-allocated read buffer */
+  uint8_t write_buffer[16]; /* Pre-allocated write buffer */
+
+#ifndef CONFIG_DISABLE_PSEUDOFS_OPERATIONS
+  uint8_t sbs_refs; /* Reference count */
+#endif
+};
+
+/****************************************************************************
+ * Private Function Prototypes
+ ****************************************************************************/
+
+static int sbs_open(FAR struct file *filep);
+static int sbs_close(FAR struct file *filep);
+static ssize_t sbs_read(FAR struct file *filep, FAR char *buffer,
+                        size_t buflen);
+static ssize_t sbs_write(FAR struct file *filep, FAR const char *buffer,
+                         size_t buflen);
+
+/****************************************************************************
+ * Private Data
+ ****************************************************************************/
+
+/* Valid operations that can be performed on the the SBS character device */
+
+static const struct file_operations sbs_fops =
+{
+#ifndef CONFIG_DISABLE_PSEUDOFS_OPERATIONS
+  sbs_open,  /* open */
+  sbs_close, /* close */
+#else
+  NULL,      /* open */
+  NULL,      /* close */
+#endif
+  sbs_read,  /* read */
+  sbs_write, /* write */
+  NULL,      /* seek */
+  NULL,      /* ioctl */
+  NULL,      /* poll */
+#ifndef CONFIG_DISABLE_PSEUDOFS_OPERATIONS
+  NULL,      /* unlink */
+#endif
+};
+
+/****************************************************************************
+ * Private Functions
+ ****************************************************************************/
+
+#ifndef CONFIG_DISABLE_PSEUDOFS_OPERATIONS
+/****************************************************************************
+ * Name: sbs_open
+ *
+ * Description: Open the character device.
+ *
+ * Input Parameters:
+ *   filep - Instance of file struct
+ *
+ * Returned Value:
+ *   OK if the SBS character device was successfully opened; A negated errno
+ *   value is returned on any failure.
+ *
+ ****************************************************************************/
+
+static int sbs_open(FAR struct file *filep)
+{
+  FAR struct sbs_dev_s *dev;
+
+  /* Retrieve the sbs_dev_s struct */
+
+  DEBUGASSERT(filep && filep->f_inode && filep->f_inode->i_private);
+  dev = (FAR struct sbs_dev_s *)filep->f_inode->i_private;
+
+  /* Increase the open reference count */
+
+  dev->sbs_refs++;
+  DEBUGASSERT(dev->sbs_refs > 0);
+
+  return OK;
+}
+
+/****************************************************************************
+ * Name: sbs_close
+ *
+ * Description:
+ *   Close the character device.
+ *
+ * Input Parameters:
+ *   filep - Instance of file struct
+ *
+ * Returned Value:
+ *   OK if the SBS character device was successfully closed; A negated errno
+ *   value is returned on any failure.
+ *
+ ****************************************************************************/
+
+static int sbs_close(FAR struct file *filep)
+{
+  FAR struct sbs_dev_s *dev;
+
+  /* Retrieve the sbs_dev_s struct */
+
+  DEBUGASSERT(filep && filep->f_inode && filep->f_inode->i_private);
+  dev = (FAR struct sbs_dev_s *)filep->f_inode->i_private;
+
+  /* Decrease the open reference count */
+
+  DEBUGASSERT(dev->sbs_refs > 0);
+  dev->sbs_refs--;
+
+  return OK;
+}
+#endif /* CONFIG_DISABLE_PSEUDOFS_OPERATIONS */
+
+/****************************************************************************
+ * Name: sbs_read
+ *
+ * Description:
+ *   Reads the battery data that is currently known by the SBS driver into a
+ *   sbs_data_s struct that needs to be converted to a character buffer.
+ *
+ * Input Parameters:
+ *   filep  - Instance of file struct
+ *   buffer - Pointer to an empty sbs_data_s struct (cast to a char *)
+ *            which will be filled with the most recent battery data that is
+ *            available in the SBS driver.
+ *   buflen - Size of the provided sbs_data_s struct
+ *
+ * Returned Value:
+ *   On success, buflen is returned to indicate that all data has been
+ *   copied.  Zero will be returned if the provided buffer length is not
+ *   sufficient for a sbs_data_s struct.
+ *
+ ****************************************************************************/
+
+static ssize_t sbs_read(FAR struct file *filep, FAR char *buffer,
+                        size_t buflen)
+{
+  irqstate_t flags;
+  struct sbs_dev_s *dev;
+  struct sbs_data_s *read_data;
+
+  /* Make sure that the read process (i.e. copying data from the SBS
+   * driver) cannot be interrupted.
+   */
+
+  flags = enter_critical_section();
+
+  if (buflen < sizeof(struct sbs_data_s))
+    {
+      /* Something went wrong. The provided buffer length is not sufficient
+       * for a sbs_data_s struct.  Return zero to indicate that nothing was
+       * read.
+       */
+
+      return 0;
+    }
+
+  /* Retrieve the SBS device struct and the data struct that holds the new
+   * data that should be copied to the SBS driver.
+   */
+
+  DEBUGASSERT(filep && filep->f_inode && filep->f_inode->i_private);
+  dev = (FAR struct sbs_dev_s *)filep->f_inode->i_private;
+
+  DEBUGASSERT(buffer);
+  read_data = (struct sbs_data_s *)buffer;
+
+  /* Copy the new data into the SBS device struct */
+
+  read_data->temperature              = dev->data->temperature;
+  read_data->voltage                  = dev->data->voltage;
+  read_data->current                  = dev->data->current;
+  read_data->average_current          = dev->data->average_current;
+  read_data->max_error                = dev->data->max_error;
+  read_data->relative_state_of_charge = dev->data->relative_state_of_charge;
+  read_data->absolute_state_of_charge = dev->data->absolute_state_of_charge;
+  read_data->remaining_capacity       = dev->data->remaining_capacity;
+  read_data->full_charge_capacity     = dev->data->full_charge_capacity;
+  read_data->run_time_to_empty        = dev->data->run_time_to_empty;
+  read_data->average_time_to_empty    = dev->data->average_time_to_empty;
+
+  read_data->cycle_count              = dev->data->cycle_count;
+  read_data->design_capacity          = dev->data->design_capacity;
+  read_data->design_voltage           = dev->data->design_voltage;
+  read_data->manufacture_date         = dev->data->manufacture_date;
+  read_data->serial_number            = dev->data->serial_number;
+  read_data->manufacturer_name        = dev->data->manufacturer_name;
+  read_data->device_name              = dev->data->device_name;
+  read_data->device_chemistry         = dev->data->device_chemistry;
+  read_data->manufacturer_data        = dev->data->manufacturer_data;
+  read_data->manufacturer_data_length = dev->data->manufacturer_data_length;
+
+  read_data->cell1_voltage            = dev->data->cell1_voltage;
+  read_data->cell2_voltage            = dev->data->cell2_voltage;
+  read_data->cell3_voltage            = dev->data->cell3_voltage;
+  read_data->cell4_voltage            = dev->data->cell4_voltage;
+  read_data->cell5_voltage            = dev->data->cell5_voltage;
+  read_data->cell6_voltage            = dev->data->cell6_voltage;
+
+  leave_critical_section(flags);
+
+  return buflen;
+}
+
+/****************************************************************************
+ * Name: sbs_write
+ *
+ * Description:
+ *   Updates the battery data of the SBS driver.  The data is contained in a
+ *   sbs_data_s struct that needs to be converted to a character buffer.
+ *   This data is then copied into the private data structure of the SBS
+ *   driver and used to prepare a write buffer for the I2C slave when a valid
+ *   request is received on the I2C bus.
+ *
+ * Input Parameters:
+ *   filep  - Instance of file struct
+ *   buffer - Pointer to a sbs_data_s struct (cast to a const char *)
+ *            containing updated battery data.
+ *   buflen - Size of the provided sbs_data_s struct
+ *
+ * Returned Value:
+ *   On success, buflen is returned to indicate that all data has been
+ *   copied.  Zero will be returned if the provided buffer length is not
+ *   sufficient for a sbs_data_s struct.
+ *
+ ****************************************************************************/
+
+static ssize_t sbs_write(FAR struct file *filep, FAR const char *buffer,
+                         size_t buflen)
+{
+  irqstate_t flags;
+  struct sbs_dev_s *dev;
+  struct sbs_data_s *new_data;
+
+  /* Make sure that the write process (i.e. copying new data to the SBS
+   * driver) cannot be interrupted.
+   */
+
+  flags = enter_critical_section();
+
+  if (buflen < sizeof(struct sbs_data_s))
+    {
+      /* Something went wrong. The provided buffer length is not sufficient
+       * for a sbs_data_s struct.  Return zero to indicate that nothing was
+       * written.
+       */
+
+      return 0;
+    }
+
+  /* Retrieve the SBS device struct and the data struct that holds the new
+   * data that should be copied to the SBS driver.
+   */
+
+  DEBUGASSERT(filep && filep->f_inode && filep->f_inode->i_private);
+  dev = (FAR struct sbs_dev_s *)filep->f_inode->i_private;
+
+  DEBUGASSERT(buffer);
+  new_data = (struct sbs_data_s *)buffer;
+
+  /* Copy the new data into the SBS device struct */
+
+  dev->data->temperature              = new_data->temperature;
+  dev->data->voltage                  = new_data->voltage;
+  dev->data->current                  = new_data->current;
+  dev->data->average_current          = new_data->average_current;
+  dev->data->max_error                = new_data->max_error;
+  dev->data->relative_state_of_charge = new_data->relative_state_of_charge;
+  dev->data->absolute_state_of_charge = new_data->absolute_state_of_charge;
+  dev->data->remaining_capacity       = new_data->remaining_capacity;
+  dev->data->full_charge_capacity     = new_data->full_charge_capacity;
+  dev->data->run_time_to_empty        = new_data->run_time_to_empty;
+  dev->data->average_time_to_empty    = new_data->average_time_to_empty;
+
+  dev->data->cycle_count              = new_data->cycle_count;
+  dev->data->design_capacity          = new_data->design_capacity;
+  dev->data->design_voltage           = new_data->design_voltage;
+  dev->data->manufacture_date         = new_data->manufacture_date;
+  dev->data->serial_number            = new_data->serial_number;
+  dev->data->manufacturer_name        = new_data->manufacturer_name;
+  dev->data->device_name              = new_data->device_name;
+  dev->data->device_chemistry         = new_data->device_chemistry;
+  dev->data->manufacturer_data        = new_data->manufacturer_data;
+  dev->data->manufacturer_data_length = new_data->manufacturer_data_length;
+
+  dev->data->cell1_voltage            = new_data->cell1_voltage;
+  dev->data->cell2_voltage            = new_data->cell2_voltage;
+  dev->data->cell3_voltage            = new_data->cell3_voltage;
+  dev->data->cell4_voltage            = new_data->cell4_voltage;
+  dev->data->cell5_voltage            = new_data->cell5_voltage;
+  dev->data->cell6_voltage            = new_data->cell6_voltage;
+
+  leave_critical_section(flags);
+
+  return buflen;
+}
+
+/****************************************************************************
+ * Name: sbs_callback
+ *
+ * Description:
+ *   Callback function that is to be invoked by the I2C slave driver when
+ *   data has been received.  The received data will be checked against a
+ *   list of registers that can be requested from a smart battery.  If there
+ *   is a match the requested data will be put into the write buffer that is
+ *   used by the I2C slave driver when a bus master wants to read the data.
+ *
+ * Input Parameters:
+ *   arg - Pointer to the SBS device struct
+ *
+ * Returned Value:
+ *   OK if a new write buffer was succesfully registered in response to the
+ *   received command; A negated errno value is returned on any failure.
+ *
+ ****************************************************************************/
+
+static int sbs_callback(FAR void *arg)
+{
+  FAR struct sbs_dev_s *sbs_dev;
+  int buffer_length;
+  int i;
+
+  /* Retrieve the pointer to the SBS device struct */
+
+  sbs_dev = (FAR struct sbs_dev_s *)arg;
+  DEBUGASSERT(sbs_dev && sbs_dev->i2c_slave_dev);
+
+  /* Check which register was requested and prepare the write buffer */
+
+  switch (sbs_dev->read_buffer[0])
+    {
+      case SBS_TEMPERATURE:
+        {
+          sbs_dev->write_buffer[0] = LOBYTE(sbs_dev->data->temperature);
+          sbs_dev->write_buffer[1] = HIBYTE(sbs_dev->data->temperature);
+          buffer_length = 2;
+        }
+        break;
+
+      case SBS_VOLTAGE:
+        {
+          sbs_dev->write_buffer[0] = LOBYTE(sbs_dev->data->voltage);
+          sbs_dev->write_buffer[1] = HIBYTE(sbs_dev->data->voltage);
+          buffer_length = 2;
+        }
+        break;
+
+      case SBS_CURRENT:
+        {
+          sbs_dev->write_buffer[0] = LOBYTE(sbs_dev->data->current);
+          sbs_dev->write_buffer[1] = HIBYTE(sbs_dev->data->current);
+          buffer_length = 2;
+        }
+        break;
+
+      case SBS_AVERAGE_CURRENT:
+        {
+          sbs_dev->write_buffer[0] = LOBYTE(sbs_dev->data->average_current);
+          sbs_dev->write_buffer[1] = HIBYTE(sbs_dev->data->average_current);
+          buffer_length = 2;
+        }
+        break;
+
+      case SBS_MAX_ERROR:
+        {
+          sbs_dev->write_buffer[0] = LOBYTE(sbs_dev->data->max_error);
+          sbs_dev->write_buffer[1] = HIBYTE(sbs_dev->data->max_error);
+          buffer_length = 2;
+        }
+        break;
+
+      case SBS_RELATIVE_STATE_OF_CHARGE:
+        {
+          sbs_dev->write_buffer[0] =
+            LOBYTE(sbs_dev->data->relative_state_of_charge);
+          sbs_dev->write_buffer[1] =
+            HIBYTE(sbs_dev->data->relative_state_of_charge);
+          buffer_length = 2;
+        }
+        break;
+
+      case SBS_ABSOLUTE_STATE_OF_CHARGE:
+        {
+          sbs_dev->write_buffer[0] =
+            LOBYTE(sbs_dev->data->absolute_state_of_charge);
+          sbs_dev->write_buffer[1] =
+            HIBYTE(sbs_dev->data->absolute_state_of_charge);
+          buffer_length = 2;
+        }
+        break;
+
+      case SBS_REMAINING_CAPACITY:
+        {
+          sbs_dev->write_buffer[0] =
+            LOBYTE(sbs_dev->data->remaining_capacity);
+          sbs_dev->write_buffer[1] =
+            HIBYTE(sbs_dev->data->remaining_capacity);
+          buffer_length = 2;
+        }
+        break;
+
+      case SBS_FULL_CHARGE_CAPACITY:
+        {
+          sbs_dev->write_buffer[0] =
+            LOBYTE(sbs_dev->data->full_charge_capacity);
+          sbs_dev->write_buffer[1] =
+            HIBYTE(sbs_dev->data->full_charge_capacity);
+          buffer_length = 2;
+        }
+        break;
+
+      case SBS_RUN_TIME_TO_EMPTY:
+        {
+          sbs_dev->write_buffer[0] =
+            LOBYTE(sbs_dev->data->run_time_to_empty);
+          sbs_dev->write_buffer[1] =
+            HIBYTE(sbs_dev->data->run_time_to_empty);
+          buffer_length = 2;
+        }
+        break;
+
+      case SBS_AVERAGE_TIME_TO_EMPTY:
+        {
+          sbs_dev->write_buffer[0] =
+            LOBYTE(sbs_dev->data->average_time_to_empty);
+          sbs_dev->write_buffer[1] =
+            HIBYTE(sbs_dev->data->average_time_to_empty);
+          buffer_length = 2;
+        }
+        break;
+
+      case SBS_CYCLE_COUNT:
+        {
+          sbs_dev->write_buffer[0] = LOBYTE(sbs_dev->data->cycle_count);
+          sbs_dev->write_buffer[1] = HIBYTE(sbs_dev->data->cycle_count);
+          buffer_length = 2;
+        }
+        break;
+
+      case SBS_DESIGN_CAPACITY:
+        {
+          sbs_dev->write_buffer[0] = LOBYTE(sbs_dev->data->design_capacity);
+          sbs_dev->write_buffer[1] = HIBYTE(sbs_dev->data->design_capacity);
+          buffer_length = 2;
+        }
+        break;
+
+      case SBS_DESIGN_VOLTAGE:
+        {
+          sbs_dev->write_buffer[0] = LOBYTE(sbs_dev->data->design_voltage);
+          sbs_dev->write_buffer[1] = HIBYTE(sbs_dev->data->design_voltage);
+          buffer_length = 2;
+        }
+        break;
+
+      case SBS_MANUFACTURE_DATE:
+        {
+          sbs_dev->write_buffer[0] = LOBYTE(sbs_dev->data->manufacture_date);
+          sbs_dev->write_buffer[1] = HIBYTE(sbs_dev->data->manufacture_date);
+          buffer_length = 2;
+        }
+        break;
+
+      case SBS_SERIAL_NUMBER:
+        {
+          sbs_dev->write_buffer[0] = LOBYTE(sbs_dev->data->serial_number);
+          sbs_dev->write_buffer[1] = HIBYTE(sbs_dev->data->serial_number);
+          buffer_length = 2;
+        }
+        break;
+
+      case SBS_MANUFACTURER_NAME:
+        {
+          DEBUGASSERT(sbs_dev->data->manufacturer_name);
+
+          /* Determine how many characters to put into the write buffer, but
+           * it can be at most 15.  The buffer can hold 16 bytes, including
+           * the first byte that indicates the length of the string.
+           */
+
+          sbs_dev->write_buffer[0] =
+            strnlen(sbs_dev->data->manufacturer_name, 15);
+
+          /* Fill the write buffer */
+
+          for (i = 0; i < sbs_dev->write_buffer[0]; i++)
+            {
+              sbs_dev->write_buffer[i + 1] =
+                (uint8_t) sbs_dev->data->manufacturer_name[i];
+            }
+
+          buffer_length = (sbs_dev->write_buffer[0] + 1);
+        }
+        break;
+
+      case SBS_DEVICE_NAME:
+        {
+          DEBUGASSERT(sbs_dev->data->device_name);
+
+          /* Determine how many characters to put into the write buffer, but
+           * it can be at most 15.  The buffer can hold 16 bytes, including
+           * the first byte that indicates the length of the string.
+           */
+
+          sbs_dev->write_buffer[0] = strnlen(sbs_dev->data->device_name, 15);
+
+          /* Fill the write buffer */
+
+          for (i = 0; i < sbs_dev->write_buffer[0]; i++)
+            {
+              sbs_dev->write_buffer[i + 1] =
+                (uint8_t) sbs_dev->data->device_name[i];
+            }
+
+          buffer_length = (sbs_dev->write_buffer[0] + 1);
+        }
+        break;
+
+      case SBS_DEVICE_CHEMISTRY:
+        {
+          DEBUGASSERT(sbs_dev->data->device_chemistry);
+
+          /* Determine how many characters to put into the write buffer, but
+           * it can be at most 15.  The buffer can hold 16 bytes, including
+           * the first byte that indicates the length of the string.
+           */
+
+          sbs_dev->write_buffer[0] =
+            strnlen(sbs_dev->data->device_chemistry, 15);
+
+          /* Fill the write buffer */
+
+          for (i = 0; i < sbs_dev->write_buffer[0]; i++)
+            {
+              sbs_dev->write_buffer[i + 1] =
+                (uint8_t) sbs_dev->data->device_chemistry[i];
+            }
+
+          buffer_length = (sbs_dev->write_buffer[0] + 1);
+        }
+        break;
+
+      case SBS_MANUFACTURER_DATA:
+        {
+          DEBUGASSERT(sbs_dev->data->manufacturer_data);
+
+          /* Determine how many bytes to put into the write buffer */
+
+          sbs_dev->write_buffer[0] = sbs_dev->data->manufacturer_data_length;
+          if (sbs_dev->write_buffer[0] > 15)
+            {
+              sbs_dev->write_buffer[0] = 15;
+
+              /* The write buffer can only hold 16 bytes, including the first
+               * byte that indicates the length of the byte array.
+               * The array has to be limited to 15 bytes if it is longer.
+               */
+            }
+
+          /* Fill the write buffer */
+
+          for (i = 0; i < sbs_dev->write_buffer[0]; i++)
+            {
+              sbs_dev->write_buffer[i + 1] =
+                sbs_dev->data->manufacturer_data[i];
+            }
+
+          buffer_length = (sbs_dev->write_buffer[0] + 1);
+        }
+        break;
+
+      case SBS_CELL6_VOLTAGE:
+        {
+          sbs_dev->write_buffer[0] = LOBYTE(sbs_dev->data->cell6_voltage);
+          sbs_dev->write_buffer[1] = HIBYTE(sbs_dev->data->cell6_voltage);
+          buffer_length = 2;
+        }
+        break;
+
+      case SBS_CELL5_VOLTAGE:
+        {
+          sbs_dev->write_buffer[0] = LOBYTE(sbs_dev->data->cell5_voltage);
+          sbs_dev->write_buffer[1] = HIBYTE(sbs_dev->data->cell5_voltage);
+          buffer_length = 2;
+        }
+        break;
+
+      case SBS_CELL4_VOLTAGE:
+        {
+          sbs_dev->write_buffer[0] = LOBYTE(sbs_dev->data->cell4_voltage);
+          sbs_dev->write_buffer[1] = HIBYTE(sbs_dev->data->cell4_voltage);
+          buffer_length = 2;
+        }
+        break;
+
+      case SBS_CELL3_VOLTAGE:
+        {
+          sbs_dev->write_buffer[0] = LOBYTE(sbs_dev->data->cell3_voltage);
+          sbs_dev->write_buffer[1] = HIBYTE(sbs_dev->data->cell3_voltage);
+          buffer_length = 2;
+        }
+        break;
+
+      case SBS_CELL2_VOLTAGE:
+        {
+          sbs_dev->write_buffer[0] = LOBYTE(sbs_dev->data->cell2_voltage);
+          sbs_dev->write_buffer[1] = HIBYTE(sbs_dev->data->cell2_voltage);
+          buffer_length = 2;
+        }
+        break;
+
+      case SBS_CELL1_VOLTAGE:
+        {
+          sbs_dev->write_buffer[0] = LOBYTE(sbs_dev->data->cell1_voltage);
+          sbs_dev->write_buffer[1] = HIBYTE(sbs_dev->data->cell1_voltage);
+          buffer_length = 2;
+        }
+        break;
+
+      default:
+        {
+          /* Set an empty write buffer with zero length if the requested
+           * register does not exist (or is not yet supported).  The I2C
+           * slave will usually handle an empty buffer by sending zero bytes.
+           */
+
+          return I2CS_WRITE(sbs_dev->i2c_slave_dev, NULL, 0);
+        }
+        break;
+    }
+
+  /* Install the (re)filled write buffer.  Technically this buffer needs to
+   * be constant, but we want to be able to re-use the same buffer for the
+   * next request, so we just cast the buffer to const.  This should not
+   * cause any problems, because the write buffer is only changed when the
+   * I2C slave driver invokes this callback, which only happens when a new
+   * request has been received.
+   */
+
+  return I2CS_WRITE(sbs_dev->i2c_slave_dev,
+                    (const uint8_t *)sbs_dev->write_buffer, buffer_length);
+}
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: sbs_initialize
+ *
+ * Description:
+ *   Create and register a Smart Battery System character driver.
+ *
+ *   This "Simple SBS" character driver supports (a subset of) the Smart
+ *   Battery Data Specification, Revision 1.1.  This driver provides a buffer
+ *   to the I2C slave driver.  This buffer can be updated at regular
+ *   intervals by a user-space application.
+ *
+ * Input Parameters:
+ *   minor         - The SBS character device will be registered as
+ *                   /dev/sbsN where N is the minor number
+ *   i2c_slave_dev - An instance of the lower half I2C slave driver
+ *
+ * Returned Value:
+ *   OK if the driver was successfully registered; A negated errno value is
+ *   returned on any failure.
+ *
+ ****************************************************************************/
+
+int sbs_initialize(int minor, FAR struct i2c_slave_s *i2c_slave_dev)
+{
+  irqstate_t flags;
+  struct sbs_dev_s *sbs_dev;
+  char dev_name[16];
+  int ret;
+
+  /* Make sure the initialization is not interrupted */
+
+  flags = enter_critical_section();
+
+  /* Allocate an SBS device structure */
+
+  sbs_dev = (struct sbs_dev_s *)kmm_zalloc(sizeof(struct sbs_dev_s));
+  if (sbs_dev == NULL)
+    {
+      leave_critical_section(flags);
+      return -ENOMEM;
+    }
+  else
+    {
+      /* Create the device name string */
+
+      snprintf(dev_name, 16, "/dev/sbs%d", minor);
+
+      /* Register the driver.  The associated private data is a reference to
+       * the SBS device structure.
+       */
+
+      ret = register_driver(dev_name, &sbs_fops, 0, sbs_dev);
+      if (ret < 0)
+        {
+          ferr("register_driver failed: %d\n", -ret);
+          kmm_free(sbs_dev);
+
+          leave_critical_section(flags);
+          return ret;
+        }
+    }
+
+  /* Allocate the SBS data structure */
+
+  sbs_dev->data = (struct sbs_data_s *)kmm_zalloc(sizeof(struct sbs_data_s));
+  if (sbs_dev->data == NULL)
+    {
+      leave_critical_section(flags);
+      return -ENOMEM;
+    }
+
+  /* Set-up the I2C slave device.  Install a read-buffer as well as a
+   * callback, which will receive the SBS device structure as an argument.
+   */
+
+  DEBUGASSERT(i2c_slave_dev);
+  sbs_dev->i2c_slave_dev = i2c_slave_dev;
+
+  ret = I2CS_READ(sbs_dev->i2c_slave_dev, sbs_dev->read_buffer, 3);
+  if (ret < 0)
+    {
+      leave_critical_section(flags);
+      return ret;
+    }
+
+  ret = I2CS_REGISTERCALLBACK(sbs_dev->i2c_slave_dev, sbs_callback,
+                              (void *)sbs_dev);
+  if (ret < 0)
+    {
+      leave_critical_section(flags);
+      return ret;
+    }
+
+  leave_critical_section(flags);
+  return 0;
+}
+
+#endif /* CONFIG_SBS_DRIVER */
diff --git a/boards/arm/s32k1xx/drivers/smart_battery/simple_sbs.h b/boards/arm/s32k1xx/drivers/smart_battery/simple_sbs.h
new file mode 100644
index 0000000000..4f65fb2d0a
--- /dev/null
+++ b/boards/arm/s32k1xx/drivers/smart_battery/simple_sbs.h
@@ -0,0 +1,183 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/drivers/smart_battery/simple_sbs.h
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.  The
+ * ASF licenses this file to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ *
+ ****************************************************************************/
+
+#ifndef __BOARDS_ARM_S32K1XX_DRIVERS_SMART_BATTERY_SIMPLE_SBS_H
+#define __BOARDS_ARM_S32K1XX_DRIVERS_SMART_BATTERY_SIMPLE_SBS_H
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include <sys/types.h>
+#include <stdint.h>
+
+#ifdef CONFIG_SBS_DRIVER
+
+/****************************************************************************
+ * Pre-processor Definitions
+ ****************************************************************************/
+
+/* Smart Battery Data Specification v1.1 registers **************************/
+
+/* NOT YET IMPLEMENTED! */
+
+#if 0
+#define SBS_MANUFACTURER_ACCESS         0x00
+#define SBS_REMAINING_CAPACITY_ALARM    0x01
+#define SBS_REMAINING_TIME_ALARM        0x02
+#define SBS_BATTERY_MODE                0x03
+#define SBS_AT_RATE                     0x04
+#define SBS_AT_RATE_TIME_TO_FULL        0x05
+#define SBS_AT_RATE_TIME_TO_EMPTY       0x06
+#define SBS_AT_RATE_OK                  0x07
+#endif
+
+#define SBS_TEMPERATURE                 0x08
+#define SBS_VOLTAGE                     0x09
+#define SBS_CURRENT                     0x0a
+#define SBS_AVERAGE_CURRENT             0x0b
+#define SBS_MAX_ERROR                   0x0c
+#define SBS_RELATIVE_STATE_OF_CHARGE    0x0d
+#define SBS_ABSOLUTE_STATE_OF_CHARGE    0x0e
+#define SBS_REMAINING_CAPACITY          0x0f
+#define SBS_FULL_CHARGE_CAPACITY        0x10
+#define SBS_RUN_TIME_TO_EMPTY           0x11
+#define SBS_AVERAGE_TIME_TO_EMPTY       0x12
+
+/* NOT YET IMPLEMENTED! */
+
+#if 0
+#define SBS_AVERAGE_TIME_TO_FULL        0x13
+#define SBS_CHARGING_CURRENT            0x14
+#define SBS_CHARGING_VOLTAGE            0x15
+#define SBS_BATTERY_STATUS              0x16
+#endif
+
+#define SBS_CYCLE_COUNT                 0x17
+#define SBS_DESIGN_CAPACITY             0x18
+#define SBS_DESIGN_VOLTAGE              0x19
+
+/* NOT YET IMPLEMENTED! */
+
+#if 0
+#define SBS_SPECIFICATION_INFO          0x1a
+#endif
+
+#define SBS_MANUFACTURE_DATE            0x1b
+#define SBS_SERIAL_NUMBER               0x1c
+#define SBS_MANUFACTURER_NAME           0x20
+#define SBS_DEVICE_NAME                 0x21
+#define SBS_DEVICE_CHEMISTRY            0x22
+#define SBS_MANUFACTURER_DATA           0x23
+
+/* Non-standard registers ***************************************************/
+
+#define SBS_CELL6_VOLTAGE               0x3a
+#define SBS_CELL5_VOLTAGE               0x3b
+#define SBS_CELL4_VOLTAGE               0x3c
+#define SBS_CELL3_VOLTAGE               0x3d
+#define SBS_CELL2_VOLTAGE               0x3e
+#define SBS_CELL1_VOLTAGE               0x3f
+
+/****************************************************************************
+ * Public Type Definitions
+ ****************************************************************************/
+
+/* Battery data */
+
+struct sbs_data_s
+{
+  uint16_t temperature;              /* 0.1  K,       0 <->  6,553.5  K */
+  uint16_t voltage;                  /* 1.0 mV,       0 <-> 65,535.0 mV */
+  uint16_t current;                  /* 1.0 mA, -32,767 <-> 32,767.0 mA */
+  uint16_t average_current;          /* 1.0 mA, -32,767 <-> 32,767.0 mA */
+  uint16_t max_error;                /* 1.0  %,       0 <->    100.0  % */
+  uint16_t relative_state_of_charge; /* 1.0  %,       0 <->    100.0  % */
+  uint16_t absolute_state_of_charge; /* 1.0  %,       0 <->    100.0  % */
+  uint16_t remaining_capacity;       /* 1.0 mAh,      0 <-> 65,535.0 mAh */
+  uint16_t full_charge_capacity;     /* 1.0 mAh,      0 <-> 65,535.0 mAh */
+  uint16_t run_time_to_empty;        /* 1.0 min,      0 <-> 65,535.0 min */
+  uint16_t average_time_to_empty;    /* 1.0 min,      0 <-> 65,535.0 min */
+
+  uint16_t cycle_count;              /* 1 cycle, 0 <-> 65,535 cycles */
+  uint16_t design_capacity;          /* 1 mAh,   0 <-> 65,535 mAh */
+  uint16_t design_voltage;           /* 1 mV,    0 <-> 65,535 mV */
+  uint16_t manufacture_date;         /* (year-1980)*512 + month*32 + day */
+  uint16_t serial_number;
+  const char *manufacturer_name;
+  const char *device_name;
+  const char *device_chemistry;
+  const uint8_t *manufacturer_data;
+  uint8_t manufacturer_data_length;
+
+  uint16_t cell1_voltage;            /* 1.0 mV,       0 <-> 65,535.0 mV */
+  uint16_t cell2_voltage;            /* 1.0 mV,       0 <-> 65,535.0 mV */
+  uint16_t cell3_voltage;            /* 1.0 mV,       0 <-> 65,535.0 mV */
+  uint16_t cell4_voltage;            /* 1.0 mV,       0 <-> 65,535.0 mV */
+  uint16_t cell5_voltage;            /* 1.0 mV,       0 <-> 65,535.0 mV */
+  uint16_t cell6_voltage;            /* 1.0 mV,       0 <-> 65,535.0 mV */
+};
+
+/****************************************************************************
+ * Public Function Prototypes
+ ****************************************************************************/
+
+#undef EXTERN
+#if defined(__cplusplus)
+#define EXTERN extern "C"
+extern "C"
+{
+#else
+#define EXTERN extern
+#endif
+
+/****************************************************************************
+ * Name: sbs_initialize
+ *
+ * Description:
+ *   Create and register a Smart Battery System character driver.
+ *
+ *   This "Simple SBS" character driver supports (a subset of) the Smart
+ *   Battery Data Specification, Revision 1.1.  This driver provides a buffer
+ *   to the I2C slave driver.  This buffer can be updated at regular
+ *   intervals by a user-space application.
+ *
+ * Input Parameters:
+ *   minor         - The SBS character device will be registered as
+ *                   /dev/sbsN where N is the minor number
+ *   i2c_slave_dev - An instance of the lower half I2C slave driver
+ *
+ * Returned Value:
+ *   OK if the driver was successfully registered; A negated errno value is
+ *   returned on any failure.
+ *
+ ****************************************************************************/
+
+int sbs_initialize(int minor, FAR struct i2c_slave_s *i2c_slave_dev);
+
+#undef EXTERN
+#if defined(__cplusplus)
+}
+#endif
+
+#endif /* CONFIG_SBS_DRIVER */
+#endif /* __BOARDS_ARM_S32K1XX_DRIVERS_SMART_BATTERY_SIMPLE_SBS */
\ No newline at end of file
diff --git a/boards/arm/s32k1xx/rddrone-bms772/Kconfig b/boards/arm/s32k1xx/rddrone-bms772/Kconfig
new file mode 100644
index 0000000000..97585e1080
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/Kconfig
@@ -0,0 +1,189 @@
+#
+# For a description of the syntax of this configuration file,
+# see the file kconfig-language.txt in the NuttX tools repository.
+#
+
+if ARCH_BOARD_RDDRONE_BMS772
+
+menuconfig RESET_CAUSE_PROC_FS
+	bool "Enable reset cause as a proc fs"
+	default n
+	depends on FS_PROCFS
+	select FS_PROCFS_REGISTER
+	---help---
+		"Enable reset cause as a proc fs as /proc/resetcause to get the reset cause"
+
+menuconfig NRST_CHECK_PROC_FS
+	bool "Enable nrst check as a proc fs"
+	default y
+	depends on FS_PROCFS
+	select FS_PROCFS_REGISTER
+	---help---
+		"Enable nrst check as a proc fs as /proc/nrstcheck to check if the nrst connection is OK"
+
+menu "PM configuration"
+depends on PM
+	menu "PM configuration PM_STANDBY mode"
+		choice
+			prompt "MCU power mode"
+			default VLPR_STANDBY
+
+			config RUN_STANDBY
+				bool "RUN mode"
+				---help---
+					The MCU should be in RUN mode in the PM_STANDBY mode
+
+			config VLPR_STANDBY
+				bool "VLPR mode"
+				---help---
+					The MCU should be in VLPR (very low power run) mode in the PM_STANDBY mode
+
+		endchoice # MCU power mode
+
+		menuconfig PM_SPI_STANDBY
+			bool "enable SPI for PM_STANDBY mode"
+			default n
+			depends on SPI
+			---help---
+				Enable PM configuration for SPI 
+
+		if PM_SPI_STANDBY
+			menuconfig PM_SPI0_STANDBY
+				bool "Enable spi0 in PM_STANDBY"
+				default n
+				depends on S32K1XX_LPSPI0
+				---help---
+					Enable spi0 in power mode PM_STANDBY"
+					
+			menuconfig PM_SPI1_STANDBY
+				bool "Enable spi1 in PM_STANDBY"
+				default n
+				depends on S32K1XX_LPSPI1
+				---help---
+					Enable spi1 in power mode PM_STANDBY"
+		endif
+
+		menuconfig PM_SERIAL_STANDBY
+			bool "enable serial for PM_STANDBY mode"
+			default n
+			depends on SERIAL
+			---help---
+				Enable PM configuration for SERIAL 
+				
+		if PM_SERIAL_STANDBY
+			menuconfig PM_CONSOLE_STANDBY
+				bool "Enable the serial console in PM_STANDBY"
+				default n
+				depends on SERIAL_CONSOLE
+				select PM_SERIAL0_STANDBY if LPUART0_SERIAL_CONSOLE
+				select PM_SERIAL1_STANDBY if LPUART1_SERIAL_CONSOLE 
+				select PM_SERIAL2_STANDBY if LPUART2_SERIAL_CONSOLE 
+				---help---
+					Enable the console in power mode PM_STANDBY"
+
+			menuconfig PM_SERIAL0_STANDBY
+				bool "Enable SERIAL0 in PM_STANDBY"
+				default n
+				depends on S32K1XX_LPUART0
+				---help---
+					Enable SERIAL0 in power mode PM_STANDBY"
+
+			menuconfig PM_SERIAL1_STANDBY
+				bool "Enable SERIAL1 in PM_STANDBY"
+				default n
+				depends on S32K1XX_LPUART1
+				---help---
+					Enable SERIAL1 in power mode PM_STANDBY"
+
+			menuconfig PM_SERIAL2_STANDBY
+				bool "Enable SERIAL2 in PM_STANDBY"
+				default n
+				depends on S32K1XX_LPUART2
+				---help---
+					Enable SERIAL2 in power mode PM_STANDBY"
+		endif
+	endmenu
+
+	menu "PM configuration PM_SLEEP mode"
+		choice
+			prompt "MCU power mode"
+			default VLPR_SLEEP
+
+			config RUN_SLEEP
+				bool "RUN mode"
+				---help---
+					The MCU should be in RUN mode in the PM_SLEEP mode
+
+			config VLPR_SLEEP
+				bool "VLPR mode"
+				---help---
+					The MCU should be in VLPR (very low power run) mode in the PM_SLEEP mode
+
+		endchoice # MCU power mode
+
+		menuconfig PM_SPI_SLEEP
+			bool "enable SPI for PM_SLEEP mode"
+			default n
+			depends on SPI
+			---help---
+				Enable PM configuration for SPI 
+
+		if PM_SPI_SLEEP
+			menuconfig PM_SPI0_SLEEP
+				bool "Enable spi0 in PM_SLEEP"
+				default n
+				depends on S32K1XX_LPSPI0
+				---help---
+					Enable spi0 in power mode PM_SLEEP"
+			menuconfig PM_SPI1_SLEEP
+				bool "Enable spi1 in PM_SLEEP"
+				default n
+				depends on S32K1XX_LPSPI1
+				---help---
+					Enable spi1 in power mode PM_SLEEP"
+		endif
+
+		menuconfig PM_SERIAL_SLEEP
+			bool "enable serial for PM_SLEEP mode"
+			default n
+			depends on SERIAL
+			---help---
+				Enable PM configuration for SERIAL 
+				
+		if PM_SERIAL_SLEEP
+			menuconfig PM_CONSOLE_SLEEP
+				bool "Enable the serial console in PM_SLEEP"
+				default n
+				depends on SERIAL_CONSOLE
+				select PM_SERIAL0_SLEEP if LPUART0_SERIAL_CONSOLE
+				select PM_SERIAL1_SLEEP if LPUART1_SERIAL_CONSOLE 
+				select PM_SERIAL2_SLEEP if LPUART2_SERIAL_CONSOLE 
+				---help---
+					Enable the console in power mode PM_SLEEP"
+
+			menuconfig PM_SERIAL0_SLEEP
+				bool "Enable SERIAL0 in PM_SLEEP"
+				default n
+				depends on S32K1XX_LPUART0
+
+				---help---
+					Enable SERIAL0 in power mode PM_SLEEP"
+
+			menuconfig PM_SERIAL1_SLEEP
+				bool "Enable SERIAL1 in PM_SLEEP"
+				default n
+				depends on S32K1XX_LPUART1
+				---help---
+					Enable SERIAL1 in power mode PM_SLEEP"
+
+			menuconfig PM_SERIAL2_SLEEP
+				bool "Enable SERIAL2 in PM_SLEEP"
+				default n
+				depends on S32K1XX_LPUART2
+				---help---
+					Enable SERIAL2 in power mode PM_SLEEP"
+		endif
+	endmenu
+endmenu
+
+endif # ARCH_BOARD_RDDRONE_BMS772
diff --git a/boards/arm/s32k1xx/rddrone-bms772/README.txt b/boards/arm/s32k1xx/rddrone-bms772/README.txt
new file mode 100644
index 0000000000..8e0a75f186
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/README.txt
@@ -0,0 +1,15 @@
+README
+======
+
+This directory holds the port to the NXP RDDRONE-BMS772 board with S32K144 MCU.
+
+Contents
+========
+
+  o Status
+
+Status
+======
+
+  2020-02-11:  Configuration created (copy-paste from S32K146EVB).
+    Tested: -
\ No newline at end of file
diff --git a/boards/arm/s32k1xx/rddrone-bms772/configs/bms/.gitignore b/boards/arm/s32k1xx/rddrone-bms772/configs/bms/.gitignore
new file mode 100644
index 0000000000..aff67cd1fb
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/configs/bms/.gitignore
@@ -0,0 +1,2 @@
+old/
+/old
\ No newline at end of file
diff --git a/boards/arm/s32k1xx/rddrone-bms772/configs/bms/defconfig b/boards/arm/s32k1xx/rddrone-bms772/configs/bms/defconfig
new file mode 100644
index 0000000000..869cbedab6
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/configs/bms/defconfig
@@ -0,0 +1,122 @@
+#
+# This file is autogenerated: PLEASE DO NOT EDIT IT.
+#
+# You can use "make menuconfig" to make any modifications to the installed .config file.
+# You can then do "make savedefconfig" to generate a new defconfig file that includes your
+# modifications.
+#
+# CONFIG_ARCH_LEDS is not set
+# CONFIG_NET_ETHERNET is not set
+# CONFIG_NET_IPv4 is not set
+# CONFIG_NSH_ARGCAT is not set
+# CONFIG_NSH_CMDOPT_HEXDUMP is not set
+# CONFIG_NSH_CMDPARMS is not set
+CONFIG_ARCH="arm"
+CONFIG_ARCH_BOARD="rddrone-bms772"
+CONFIG_ARCH_BOARD_RDDRONE_BMS772=y
+CONFIG_ARCH_CHIP="s32k1xx"
+CONFIG_ARCH_CHIP_S32K144=y
+CONFIG_ARCH_CHIP_S32K14X=y
+CONFIG_ARCH_CHIP_S32K1XX=y
+CONFIG_ARCH_STACKDUMP=y
+CONFIG_ARMV7M_LIBM=y
+CONFIG_ARMV7M_MEMCPY=y
+CONFIG_BINFMT_DISABLE=y
+CONFIG_BOARDCTL_RESET=y
+CONFIG_BOARD_LOOPSPERMSEC=3997
+CONFIG_BUILTIN=y
+CONFIG_CANUTILS_LIBCANARDV1=y
+CONFIG_CAN_CONNS=1
+CONFIG_CLOCK_MONOTONIC=y
+CONFIG_DEBUG_ERROR=y
+CONFIG_DEBUG_FEATURES=y
+CONFIG_DEBUG_SYMBOLS=y
+CONFIG_DEV_GPIO=y
+CONFIG_EXAMPLES_HELLO=y
+CONFIG_FS_PROCFS=y
+CONFIG_FS_ROMFS=y
+CONFIG_I2C=y
+CONFIG_I2C_DRIVER=y
+CONFIG_I2C_SLAVE=y
+CONFIG_IOB_BUFSIZE=96
+CONFIG_LIBC_FLOATINGPOINT=y
+CONFIG_LIBM=y
+CONFIG_LPI2C0_SLAVE_BUS=y
+CONFIG_LPUART0_RXBUFSIZE=64
+CONFIG_LPUART0_TXBUFSIZE=64
+CONFIG_LPUART1_RXBUFSIZE=64
+CONFIG_LPUART1_SERIAL_CONSOLE=y
+CONFIG_LPUART1_TXBUFSIZE=64
+CONFIG_MAX_TASKS=16
+CONFIG_NET=y
+CONFIG_NETDEV_CAN_BITRATE_IOCTL=y
+CONFIG_NETDEV_IFINDEX=y
+CONFIG_NET_CAN=y
+CONFIG_NET_CAN_NOTIFIER=y
+CONFIG_NET_CAN_RAW_FILTER_MAX=0
+CONFIG_NET_CAN_RAW_TX_DEADLINE=y
+CONFIG_NET_CAN_SOCK_OPTS=y
+CONFIG_NET_TIMESTAMP=y
+CONFIG_NFILE_DESCRIPTORS=20
+CONFIG_NSH_ARCHINIT=y
+CONFIG_NSH_ARCHROMFS=y
+CONFIG_NSH_BUILTIN_APPS=y
+CONFIG_NSH_DISABLE_DATE=y
+CONFIG_NSH_FILEIOSIZE=512
+CONFIG_NSH_READLINE=y
+CONFIG_NSH_ROMFSETC=y
+CONFIG_NXP_BMS=y
+CONFIG_PATH_MAX=128
+CONFIG_PM=y
+CONFIG_PM_CONSOLE_SLEEP=y
+CONFIG_PM_CONSOLE_STANDBY=y
+CONFIG_PM_SERIAL_SLEEP=y
+CONFIG_PM_SERIAL_STANDBY=y
+CONFIG_PM_SPI0_SLEEP=y
+CONFIG_PM_SPI0_STANDBY=y
+CONFIG_PM_SPI1_STANDBY=y
+CONFIG_PM_SPI_SLEEP=y
+CONFIG_PM_SPI_STANDBY=y
+CONFIG_PREALLOC_TIMERS=4
+CONFIG_RAM_SIZE=61440
+CONFIG_RAM_START=0x1fff8000
+CONFIG_RAW_BINARY=y
+CONFIG_RESET_CAUSE_PROC_FS=y
+CONFIG_RR_INTERVAL=200
+CONFIG_RTC=y
+CONFIG_RTC_FREQUENCY=32768
+CONFIG_RTC_HIRES=y
+CONFIG_S32K1XX_EEEPROM=y
+CONFIG_S32K1XX_FLEXCAN0=y
+CONFIG_S32K1XX_GPIOIRQ=y
+CONFIG_S32K1XX_LPI2C0=y
+CONFIG_S32K1XX_LPSPI0=y
+CONFIG_S32K1XX_LPSPI1=y
+CONFIG_S32K1XX_LPUART0=y
+CONFIG_S32K1XX_LPUART1=y
+CONFIG_S32K1XX_PORTAINTS=y
+CONFIG_S32K1XX_PORTBINTS=y
+CONFIG_S32K1XX_PORTCINTS=y
+CONFIG_S32K1XX_PORTDINTS=y
+CONFIG_S32K1XX_PORTEINTS=y
+CONFIG_S32K1XX_RTC=y
+CONFIG_SBS_DRIVER=y
+CONFIG_SCHED_CPULOAD=y
+CONFIG_SCHED_LPWORK=y
+CONFIG_SCHED_LPWORKSTACKSIZE=1536
+CONFIG_SCHED_WAITPID=y
+CONFIG_SDCLONE_DISABLE=y
+CONFIG_SIG_DEFAULT=y
+CONFIG_SPECIFIC_DRIVERS=y
+CONFIG_SPI_DRIVER=y
+CONFIG_STACK_COLORATION=y
+CONFIG_START_DAY=18
+CONFIG_START_MONTH=8
+CONFIG_START_YEAR=2019
+CONFIG_STDIO_DISABLE_BUFFERING=y
+CONFIG_SYMTAB_ORDEREDBYNAME=y
+CONFIG_SYSLOG_CONSOLE=y
+CONFIG_SYSTEM_NSH=y
+CONFIG_USERLED=y
+CONFIG_USERLED_LOWER=y
+CONFIG_USER_ENTRYPOINT="nsh_main"
diff --git a/boards/arm/s32k1xx/rddrone-bms772/configs/bmsdebug/.gitignore b/boards/arm/s32k1xx/rddrone-bms772/configs/bmsdebug/.gitignore
new file mode 100644
index 0000000000..aff67cd1fb
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/configs/bmsdebug/.gitignore
@@ -0,0 +1,2 @@
+old/
+/old
\ No newline at end of file
diff --git a/boards/arm/s32k1xx/rddrone-bms772/configs/bmsdebug/defconfig b/boards/arm/s32k1xx/rddrone-bms772/configs/bmsdebug/defconfig
new file mode 100644
index 0000000000..47b38ed00d
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/configs/bmsdebug/defconfig
@@ -0,0 +1,123 @@
+#
+# This file is autogenerated: PLEASE DO NOT EDIT IT.
+#
+# You can use "make menuconfig" to make any modifications to the installed .config file.
+# You can then do "make savedefconfig" to generate a new defconfig file that includes your
+# modifications.
+#
+# CONFIG_ARCH_LEDS is not set
+# CONFIG_NET_ETHERNET is not set
+# CONFIG_NET_IPv4 is not set
+# CONFIG_NSH_ARGCAT is not set
+# CONFIG_NSH_CMDOPT_HEXDUMP is not set
+# CONFIG_NSH_CMDPARMS is not set
+CONFIG_ARCH="arm"
+CONFIG_ARCH_BOARD="rddrone-bms772"
+CONFIG_ARCH_BOARD_RDDRONE_BMS772=y
+CONFIG_ARCH_CHIP="s32k1xx"
+CONFIG_ARCH_CHIP_S32K144=y
+CONFIG_ARCH_CHIP_S32K14X=y
+CONFIG_ARCH_CHIP_S32K1XX=y
+CONFIG_ARCH_STACKDUMP=y
+CONFIG_ARMV7M_LIBM=y
+CONFIG_ARMV7M_MEMCPY=y
+CONFIG_BINFMT_DISABLE=y
+CONFIG_BOARDCTL_RESET=y
+CONFIG_BOARD_LOOPSPERMSEC=3997
+CONFIG_BUILTIN=y
+CONFIG_CANUTILS_LIBCANARDV1=y
+CONFIG_CAN_CONNS=1
+CONFIG_CLOCK_MONOTONIC=y
+CONFIG_DEBUG_ASSERTIONS=y
+CONFIG_DEBUG_ERROR=y
+CONFIG_DEBUG_FEATURES=y
+CONFIG_DEBUG_SYMBOLS=y
+CONFIG_DEV_GPIO=y
+CONFIG_EXAMPLES_HELLO=y
+CONFIG_FS_PROCFS=y
+CONFIG_FS_ROMFS=y
+CONFIG_I2C=y
+CONFIG_I2C_DRIVER=y
+CONFIG_I2C_SLAVE=y
+CONFIG_IOB_BUFSIZE=96
+CONFIG_LIBC_FLOATINGPOINT=y
+CONFIG_LIBM=y
+CONFIG_LPI2C0_SLAVE_BUS=y
+CONFIG_LPUART0_RXBUFSIZE=64
+CONFIG_LPUART0_TXBUFSIZE=64
+CONFIG_LPUART1_RXBUFSIZE=64
+CONFIG_LPUART1_SERIAL_CONSOLE=y
+CONFIG_LPUART1_TXBUFSIZE=64
+CONFIG_MAX_TASKS=16
+CONFIG_NET=y
+CONFIG_NETDEV_CAN_BITRATE_IOCTL=y
+CONFIG_NETDEV_IFINDEX=y
+CONFIG_NET_CAN=y
+CONFIG_NET_CAN_NOTIFIER=y
+CONFIG_NET_CAN_RAW_FILTER_MAX=0
+CONFIG_NET_CAN_RAW_TX_DEADLINE=y
+CONFIG_NET_CAN_SOCK_OPTS=y
+CONFIG_NET_TIMESTAMP=y
+CONFIG_NFILE_DESCRIPTORS=20
+CONFIG_NSH_ARCHINIT=y
+CONFIG_NSH_ARCHROMFS=y
+CONFIG_NSH_BUILTIN_APPS=y
+CONFIG_NSH_DISABLE_DATE=y
+CONFIG_NSH_FILEIOSIZE=512
+CONFIG_NSH_READLINE=y
+CONFIG_NSH_ROMFSETC=y
+CONFIG_NXP_BMS=y
+CONFIG_PATH_MAX=128
+CONFIG_PM=y
+CONFIG_PM_CONSOLE_SLEEP=y
+CONFIG_PM_CONSOLE_STANDBY=y
+CONFIG_PM_SERIAL_SLEEP=y
+CONFIG_PM_SERIAL_STANDBY=y
+CONFIG_PM_SPI0_SLEEP=y
+CONFIG_PM_SPI0_STANDBY=y
+CONFIG_PM_SPI1_STANDBY=y
+CONFIG_PM_SPI_SLEEP=y
+CONFIG_PM_SPI_STANDBY=y
+CONFIG_PREALLOC_TIMERS=4
+CONFIG_RAM_SIZE=61440
+CONFIG_RAM_START=0x1fff8000
+CONFIG_RAW_BINARY=y
+CONFIG_RESET_CAUSE_PROC_FS=y
+CONFIG_RR_INTERVAL=200
+CONFIG_RTC=y
+CONFIG_RTC_FREQUENCY=32768
+CONFIG_RTC_HIRES=y
+CONFIG_S32K1XX_EEEPROM=y
+CONFIG_S32K1XX_FLEXCAN0=y
+CONFIG_S32K1XX_GPIOIRQ=y
+CONFIG_S32K1XX_LPI2C0=y
+CONFIG_S32K1XX_LPSPI0=y
+CONFIG_S32K1XX_LPSPI1=y
+CONFIG_S32K1XX_LPUART0=y
+CONFIG_S32K1XX_LPUART1=y
+CONFIG_S32K1XX_PORTAINTS=y
+CONFIG_S32K1XX_PORTBINTS=y
+CONFIG_S32K1XX_PORTCINTS=y
+CONFIG_S32K1XX_PORTDINTS=y
+CONFIG_S32K1XX_PORTEINTS=y
+CONFIG_S32K1XX_RTC=y
+CONFIG_SBS_DRIVER=y
+CONFIG_SCHED_CPULOAD=y
+CONFIG_SCHED_LPWORK=y
+CONFIG_SCHED_LPWORKSTACKSIZE=1536
+CONFIG_SCHED_WAITPID=y
+CONFIG_SDCLONE_DISABLE=y
+CONFIG_SIG_DEFAULT=y
+CONFIG_SPECIFIC_DRIVERS=y
+CONFIG_SPI_DRIVER=y
+CONFIG_STACK_COLORATION=y
+CONFIG_START_DAY=18
+CONFIG_START_MONTH=8
+CONFIG_START_YEAR=2019
+CONFIG_STDIO_DISABLE_BUFFERING=y
+CONFIG_SYMTAB_ORDEREDBYNAME=y
+CONFIG_SYSLOG_CONSOLE=y
+CONFIG_SYSTEM_NSH=y
+CONFIG_USERLED=y
+CONFIG_USERLED_LOWER=y
+CONFIG_USER_ENTRYPOINT="nsh_main"
diff --git a/boards/arm/s32k1xx/rddrone-bms772/include/board.h b/boards/arm/s32k1xx/rddrone-bms772/include/board.h
new file mode 100644
index 0000000000..39649329bd
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/include/board.h
@@ -0,0 +1,167 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/rddrone-bms772/include/board.h
+ *
+ *   Copyright (C) 2019 Gregory Nutt. All rights reserved.
+ *   Author: Gregory Nutt <gnutt@nuttx.org>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+#ifndef __BOARDS_ARM_RDDRONE_BMS772_INCLUDE_BOARD_H
+#define __BOARDS_ARM_RDDRONE_BMS772_INCLUDE_BOARD_H
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#ifndef __ASSEMBLY__
+#  include <stdint.h>
+#  include <stdbool.h>
+#endif
+
+/****************************************************************************
+ * Pre-processor Definitions
+ ****************************************************************************/
+
+/* Clocking *****************************************************************/
+
+/* The RDDRONE-BMS772 is fitted with a 32 MHz Crystal */
+
+#define BOARD_XTAL_FREQUENCY 32000000
+
+/* The S32K144 will run at 80 MHz */
+
+/* LED definitions **********************************************************/
+
+/* The RDDRONE-BMS772 has one RGB LED:
+ *
+ *   RedLED   PTD16 (FTM0 CH1)
+ *   GreenLED PTB13 (FTM0 CH1)
+ *   BlueLED  PTD15 (FTM0 CH0)
+ *
+ * If CONFIG_ARCH_LEDS is not defined, then the user can control the LEDs in
+ * any way.  The following definitions are used to access individual RGB
+ * components.
+ *
+ * The RGB components could, alternatively be controlled through PWM using
+ * the common RGB LED driver.
+ */
+
+/* LED index values for use with board_userled() */
+
+#define BOARD_LED_R       0
+#define BOARD_LED_G       1
+#define BOARD_LED_B       2
+#define BOARD_NLEDS       3
+
+/* LED bits for use with board_userled_all() */
+
+#define BOARD_LED_R_BIT   (1 << BOARD_LED_R)
+#define BOARD_LED_G_BIT   (1 << BOARD_LED_G)
+#define BOARD_LED_B_BIT   (1 << BOARD_LED_B)
+
+/* If CONFIG_ARCH_LEDs is defined, then NuttX will control the LEDs on board
+ * the RDDRONE-BMS772.  The following definitions describe how NuttX
+ * controls the LEDs:
+ *
+ *   SYMBOL                Meaning                      LED state
+ *                                                      RED   GREEN  BLUE
+ *   -------------------  ----------------------------  -----------------
+ */
+
+#define LED_STARTED       1 /* NuttX has been started    OFF   OFF    OFF */
+#define LED_HEAPALLOCATE  2 /* Heap has been allocated   OFF   OFF    ON  */
+#define LED_IRQSENABLED   0 /* Interrupts enabled        OFF   OFF    ON  */
+#define LED_STACKCREATED  3 /* Idle stack created        OFF   ON     OFF */
+#define LED_INIRQ         0 /* In an interrupt          (no change)       */
+#define LED_SIGNAL        0 /* In a signal handler      (no change)       */
+#define LED_ASSERTION     0 /* An assertion failed      (no change)       */
+#define LED_PANIC         4 /* The system has crashed    FLASH OFF    OFF */
+#undef  LED_IDLE            /* RDDRONE-BMS772 in sleep mode (Not used)    */
+
+/* Button definitions *******************************************************/
+
+/* The rddrone-bms772 supports one button:
+ *
+ *   SW1  PTC14
+ */
+
+#define BUTTON_SW1         0
+
+#define NUM_BUTTONS        1
+
+#define BUTTON_SW1_BIT    (1 << BUTTON_SW1)
+
+/* Alternate function pin selections ****************************************/
+
+/* By default, the serial console will be provided on the OpenSDA VCOM port:
+ *
+ *   OpenSDA UART TX  PTC7 (LPUART1_TX)
+ *   OpenSDA UART RX  PTC6 (LPUART1_RX)
+ */
+
+/* optional UART on connector J21                   */
+#define PIN_LPUART0_RX    PIN_LPUART0_RX_1  /* PTB0 */
+#define PIN_LPUART0_TX    PIN_LPUART0_TX_1  /* PTB1 */
+
+/* NuttX console                                    */
+#define PIN_LPUART1_RX    PIN_LPUART1_RX_1  /* PTC6 */
+#define PIN_LPUART1_TX    PIN_LPUART1_TX_1  /* PTC7 */
+
+/* SPI selections ***********************************************************/
+
+/* SBC connection through SPI 0                     */
+#define PIN_LPSPI0_SCK   PIN_LPSPI0_SCK_2   /* PTB2 */
+#define PIN_LPSPI0_MISO  PIN_LPSPI0_SIN_2   /* PTB3 */
+#define PIN_LPSPI0_MOSI  PIN_LPSPI0_SOUT_3  /* PTB4 */
+#define PIN_LPSPI0_PCS   PIN_LPSPI0_PCS0_2 // don't make it a GPIO 
+
+/* BCC connection through SPI 1                     */
+#define PIN_LPSPI1_SCK   PIN_LPSPI1_SCK_2   /* PTD0 */
+#define PIN_LPSPI1_MISO  PIN_LPSPI1_SIN_2   /* PTD1 */
+#define PIN_LPSPI1_MOSI  PIN_LPSPI1_SOUT_2  /* PTD2 */
+#define PIN_LPSPI1_PCS   PIN_LPSPI1_PCS0_1 // don't make it a GPIO 
+
+/* I2C selections ***********************************************************/
+
+#define PIN_LPI2C0_SCL   PIN_LPI2C0_SCL_2   /* PTA3 */
+#define PIN_LPI2C0_SDA	 PIN_LPI2C0_SDA_2   /* PTA2 */
+
+/* I2C slave selections *****************************************************/
+
+#define PIN_LPI2C0S_SCL  PIN_LPI2C0_SCLS_1   /* PTA0 */
+#define PIN_LPI2C0S_SDA	 PIN_LPI2C0_SDAS_1   /* PTA1 */
+
+/* CAN selections ***********************************************************/
+#define PIN_CAN0_TX      PIN_CAN0_TX_3      /* PTE5 */
+#define PIN_CAN0_RX      PIN_CAN0_RX_3      /* PTE4 */
+
+#endif  /* __BOARDS_ARM_RDDRONE_BMS772_INCLUDE_BOARD_H */
diff --git a/boards/arm/s32k1xx/rddrone-bms772/include/nsh_romfsimg.h b/boards/arm/s32k1xx/rddrone-bms772/include/nsh_romfsimg.h
new file mode 100644
index 0000000000..5e3d107769
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/include/nsh_romfsimg.h
@@ -0,0 +1,89 @@
+const unsigned char romfs_img[] = {
+  0x2d, 0x72, 0x6f, 0x6d, 0x31, 0x66, 0x73, 0x2d, 0x00, 0x00, 0x02, 0x70,
+  0xe9, 0x59, 0x88, 0x5d, 0x4e, 0x53, 0x48, 0x49, 0x6e, 0x69, 0x74, 0x56,
+  0x6f, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x49,
+  0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0xd1, 0xff, 0xff, 0x97,
+  0x2e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x20,
+  0x00, 0x00, 0x00, 0x00, 0xd1, 0xd1, 0xff, 0x80, 0x2e, 0x2e, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00,
+  0x68, 0x2d, 0x96, 0x03, 0x69, 0x6e, 0x69, 0x74, 0x2e, 0x64, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3a,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x8b, 0x8d, 0x9c, 0xa9, 0x3b,
+  0x72, 0x63, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x23, 0x20, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65,
+  0x20, 0x72, 0x63, 0x53, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x3b, 0x20, 0x79,
+  0x6f, 0x75, 0x20, 0x6d, 0x75, 0x73, 0x74, 0x20, 0x72, 0x75, 0x6e, 0x20,
+  0x74, 0x6f, 0x6f, 0x6c, 0x73, 0x2f, 0x67, 0x65, 0x6e, 0x72, 0x6f, 0x6d,
+  0x66, 0x73, 0x20, 0x3c, 0x6e, 0x75, 0x74, 0x74, 0x78, 0x20, 0x64, 0x69,
+  0x72, 0x3e, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x77, 0x69, 0x74, 0x68,
+  0x69, 0x6e, 0x20, 0x74, 0x68, 0x69, 0x73, 0x0a, 0x23, 0x20, 0x6c, 0x6f,
+  0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x74, 0x6f, 0x20, 0x63, 0x6f,
+  0x6e, 0x76, 0x65, 0x72, 0x74, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x66,
+  0x69, 0x6c, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x6e, 0x73, 0x68, 0x5f, 0x72,
+  0x6f, 0x6d, 0x66, 0x73, 0x69, 0x6d, 0x67, 0x2e, 0x68, 0x20, 0x66, 0x6f,
+  0x72, 0x20, 0x69, 0x6e, 0x63, 0x6c, 0x75, 0x73, 0x69, 0x6f, 0x6e, 0x20,
+  0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x75, 0x69, 0x6c, 0x64,
+  0x0a, 0x23, 0x20, 0x65, 0x63, 0x68, 0x6f, 0x20, 0x22, 0x54, 0x68, 0x69,
+  0x73, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x74, 0x61,
+  0x72, 0x74, 0x75, 0x70, 0x20, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x22,
+  0x0a, 0x23, 0x20, 0x65, 0x63, 0x68, 0x6f, 0x20, 0x22, 0x43, 0x6f, 0x75,
+  0x6e, 0x74, 0x64, 0x6f, 0x77, 0x6e, 0x22, 0x0a, 0x23, 0x20, 0x73, 0x6c,
+  0x65, 0x65, 0x70, 0x20, 0x31, 0x0a, 0x23, 0x20, 0x65, 0x63, 0x68, 0x6f,
+  0x20, 0x22, 0x33, 0x22, 0x0a, 0x23, 0x20, 0x73, 0x6c, 0x65, 0x65, 0x70,
+  0x20, 0x31, 0x0a, 0x23, 0x20, 0x65, 0x63, 0x68, 0x6f, 0x20, 0x22, 0x32,
+  0x22, 0x0a, 0x23, 0x20, 0x73, 0x6c, 0x65, 0x65, 0x70, 0x20, 0x31, 0x0a,
+  0x23, 0x20, 0x65, 0x63, 0x68, 0x6f, 0x20, 0x22, 0x31, 0x22, 0x0a, 0x23,
+  0x20, 0x73, 0x6c, 0x65, 0x65, 0x70, 0x20, 0x31, 0x0a, 0x20, 0x65, 0x63,
+  0x68, 0x6f, 0x20, 0x22, 0x53, 0x74, 0x61, 0x72, 0x74, 0x69, 0x6e, 0x67,
+  0x20, 0x42, 0x4d, 0x53, 0x22, 0x0a, 0x20, 0x73, 0x6c, 0x65, 0x65, 0x70,
+  0x20, 0x31, 0x0a, 0x22, 0x66, 0x72, 0x65, 0x65, 0x22, 0x0a, 0x65, 0x63,
+  0x68, 0x6f, 0x20, 0x22, 0x53, 0x74, 0x61, 0x72, 0x74, 0x69, 0x6e, 0x67,
+  0x20, 0x63, 0x61, 0x6e, 0x30, 0x22, 0x0a, 0x22, 0x69, 0x66, 0x75, 0x70,
+  0x22, 0x20, 0x22, 0x63, 0x61, 0x6e, 0x30, 0x22, 0x0a, 0x22, 0x62, 0x6d,
+  0x73, 0x22, 0x0a, 0x20, 0x73, 0x6c, 0x65, 0x65, 0x70, 0x20, 0x31, 0x0a,
+  0x20, 0x65, 0x63, 0x68, 0x6f, 0x20, 0x22, 0x53, 0x74, 0x61, 0x72, 0x74,
+  0x65, 0x64, 0x22, 0x0a, 0x20, 0x23, 0x20, 0x73, 0x6c, 0x65, 0x65, 0x70,
+  0x20, 0x31, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x50,
+  0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0xd1, 0xd1, 0xfd, 0x90,
+  0x2e, 0x2e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60,
+  0x00, 0x00, 0x00, 0x00, 0xd1, 0xff, 0xff, 0xa0, 0x2e, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00
+};
+const unsigned int romfs_img_len = 1024;
diff --git a/boards/arm/s32k1xx/rddrone-bms772/include/rcS.template b/boards/arm/s32k1xx/rddrone-bms772/include/rcS.template
new file mode 100644
index 0000000000..749d48a926
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/include/rcS.template
@@ -0,0 +1,20 @@
+# sample rcS file; you must run tools/genromfs <nuttx dir> from within this
+# location to convert this file to nsh_romfsimg.h for inclusion in the build
+# echo "This is the startup script"
+# echo "Countdown"
+# sleep 1
+# echo "3"
+# sleep 1
+# echo "2"
+# sleep 1
+# echo "1"
+# sleep 1
+ echo "Starting BMS"
+ sleep 1
+"free"
+echo "Starting can0"
+"ifup" "can0"
+"bms"
+ sleep 1
+ echo "Started"
+ # sleep 1
diff --git a/boards/arm/s32k1xx/rddrone-bms772/scripts/Make.defs b/boards/arm/s32k1xx/rddrone-bms772/scripts/Make.defs
new file mode 100644
index 0000000000..ef6d67909e
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/scripts/Make.defs
@@ -0,0 +1,108 @@
+############################################################################
+# boards/arm/s32k1xx/rddrone-bms772/scripts/Make.defs
+#
+#   Copyright (C) 2018 Gregory Nutt. All rights reserved.
+#   Author: Gregory Nutt <gnutt@nuttx.org>
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in
+#    the documentation and/or other materials provided with the
+#    distribution.
+# 3. Neither the name NuttX nor the names of its contributors may be
+#    used to endorse or promote products derived from this software
+#    without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+# OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+# AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+############################################################################
+
+include $(TOPDIR)/.config
+include $(TOPDIR)/tools/Config.mk
+include $(TOPDIR)/arch/arm/src/armv7-m/Toolchain.defs
+
+ifeq ($(CONFIG_BOOT_RUNFROMFLASH),y)
+ LDSCRIPT = flash.ld
+else ifeq ($(CONFIG_BOOT_RUNFROMISRAM),y)
+ LDSCRIPT = sram.ld
+endif
+
+$(warning, LDSCRIPT is $(LDSCRIPT))
+CINCPATH := ${shell $(INCDIR) -s "$(CC)" $(TOPDIR)$(DELIM)include}
+CXXINCPATH := ${shell $(INCDIR) -s "$(CC)" $(TOPDIR)$(DELIM)include$(DELIM)cxx}
+
+ARCHINCLUDES += $(CINCPATH)
+ARCHXXINCLUDES += $(CINCPATH) $(CXXINCPATH)
+
+ifeq ($(CONFIG_CYGWIN_WINTOOL),y)
+  ARCHSCRIPT = -T "${shell cygpath -w $(BOARD_DIR)$(DELIM)scripts$(DELIM)$(LDSCRIPT)}"
+else
+  ARCHSCRIPT = -T$(BOARD_DIR)$(DELIM)scripts$(DELIM)$(LDSCRIPT)
+endif
+$(warning, LDSCRIPT is $(LDSCRIPT))
+$(warning, ARCHSCRIPT is $(ARCHSCRIPT))
+
+CC = $(CROSSDEV)gcc
+CXX = $(CROSSDEV)g++
+CPP = $(CROSSDEV)gcc -E
+LD = $(CROSSDEV)ld
+STRIP = $(CROSSDEV)strip --strip-unneeded
+AR = $(ARCROSSDEV)ar rcs
+NM = $(ARCROSSDEV)nm
+OBJCOPY = $(CROSSDEV)objcopy
+OBJDUMP = $(CROSSDEV)objdump
+
+ARCHCCVERSION = ${shell $(CC) -v 2>&1 | sed -n '/^gcc version/p' | sed -e 's/^gcc version \([0-9\.]\)/\1/g' -e 's/[-\ ].*//g' -e '1q'}
+ARCHCCMAJOR = ${shell echo $(ARCHCCVERSION) | cut -d'.' -f1}
+
+ifeq ($(CONFIG_DEBUG_SYMBOLS),y)
+  ARCHOPTIMIZATION = -g
+endif
+
+ifneq ($(CONFIG_DEBUG_NOOPT),y)
+  ARCHOPTIMIZATION += $(MAXOPTIMIZATION) -fno-strict-aliasing -fno-strength-reduce -fomit-frame-pointer
+endif
+
+ARCHCFLAGS = -fno-builtin
+ARCHCXXFLAGS = -fno-builtin -fno-exceptions -fcheck-new -fno-rtti
+ARCHWARNINGS = -Wall -Wstrict-prototypes -Wshadow -Wundef
+ARCHWARNINGSXX = -Wall -Wshadow -Wundef
+ARCHPICFLAGS = -fpic -msingle-pic-base -mpic-register=r10
+
+CFLAGS = $(ARCHCFLAGS) $(ARCHWARNINGS) $(ARCHOPTIMIZATION) $(ARCHCPUFLAGS) $(ARCHINCLUDES) $(ARCHDEFINES) $(EXTRAFLAGS) -pipe
+CPICFLAGS = $(ARCHPICFLAGS) $(CFLAGS)
+CXXFLAGS = $(ARCHCXXFLAGS) $(ARCHWARNINGSXX) $(ARCHOPTIMIZATION) $(ARCHCPUFLAGS) $(ARCHXXINCLUDES) $(ARCHDEFINES) $(EXTRAFLAGS) -pipe
+CXXPICFLAGS = $(ARCHPICFLAGS) $(CXXFLAGS)
+CPPFLAGS = $(ARCHINCLUDES) $(ARCHDEFINES) $(EXTRAFLAGS)
+AFLAGS = $(CFLAGS) -D__ASSEMBLY__
+
+NXFLATLDFLAGS1 = -r -d -warn-common
+NXFLATLDFLAGS2 = $(NXFLATLDFLAGS1) -T$(TOPDIR)/binfmt/libnxflat/gnu-nxflat-pcrel.ld -no-check-sections
+LDNXFLATFLAGS = -e main -s 2048
+
+ifneq ($(CROSSDEV),arm-nuttx-elf-)
+  LDFLAGS += -nostartfiles -nodefaultlibs
+endif
+ifeq ($(CONFIG_DEBUG_SYMBOLS),y)
+  LDFLAGS += -g
+endif
+
+
+HOSTCC = gcc
+HOSTCFLAGS = -Wall -Wstrict-prototypes -Wshadow -Wundef -g -pipe
diff --git a/boards/arm/s32k1xx/rddrone-bms772/scripts/flash.ld b/boards/arm/s32k1xx/rddrone-bms772/scripts/flash.ld
new file mode 100644
index 0000000000..83b003c887
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/scripts/flash.ld
@@ -0,0 +1,152 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/rddrone-bms772/scripts/flash.ld
+ *
+ *   Copyright (C) 2019 Gregory Nutt. All rights reserved.
+ *   Author: Gregory Nutt <gnutt@nuttx.org>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/* The S32K144 has 512Kb of FLASH beginning at address 0x0000:0000 and
+ * 60Kb of SRAM beginning at address 0x1fff:8000 (plus 4Kb of FlexRAM)
+ *
+ * The on-chip RAM is split in two regions: SRAM_L and SRAM_U. The RAM is
+ * implemented such that the SRAM_L and SRAM_U ranges form a contiguous
+ * block in the memory map
+ *
+ *   SRAM_L 1fff8000 - 1fffffff 32Kb
+ *   SRAM_U 20000000 - 20006fff 28Kb
+ */
+
+MEMORY
+{
+  vflash (rx) : ORIGIN = 0x00000000, LENGTH = 1K
+  pflash (rx) : ORIGIN = 0x00000400, LENGTH = 16
+  dflash (rx) : ORIGIN = 0x00000410, LENGTH = 511K-16
+  sram  (rwx) : ORIGIN = 0x1fff8000, LENGTH = 60K
+}
+
+OUTPUT_ARCH(arm)
+EXTERN(_vectors)
+EXTERN(g_flashcfg)
+ENTRY(_stext)
+
+SECTIONS
+{
+  .vectors :
+  {
+    _stext = ABSOLUTE(.);
+    *(.vectors)
+  } > vflash
+
+  .flashcfg :
+  {
+    *(.flashcfg)
+  } > pflash
+
+  .text :
+  {
+    *(.text .text.*)
+    *(.fixup)
+    *(.gnu.warning)
+    *(.rodata .rodata.*)
+    *(.gnu.linkonce.t.*)
+    *(.glue_7)
+    *(.glue_7t)
+    *(.got)
+    *(.gcc_except_table)
+    *(.gnu.linkonce.r.*)
+    _etext = ABSOLUTE(.);
+  } > dflash
+
+  .init_section :
+  {
+    _sinit = ABSOLUTE(.);
+    *(.init_array .init_array.*)
+    _einit = ABSOLUTE(.);
+  } > dflash
+
+  .ARM.extab :
+  {
+    *(.ARM.extab*)
+  } >dflash
+
+  .ARM.exidx :
+  {
+    __exidx_start = ABSOLUTE(.);
+    *(.ARM.exidx*)
+    __exidx_end = ABSOLUTE(.);
+  } >dflash
+
+  .data :
+  {
+    _sdata = ABSOLUTE(.);
+    *(.data .data.*)
+    *(.gnu.linkonce.d.*)
+    CONSTRUCTORS
+    . = ALIGN(4);
+    _edata = ABSOLUTE(.);
+  } > sram AT > dflash
+
+  _eronly = LOADADDR(.data);
+
+  .ramfunc ALIGN(4):
+  {
+    _sramfuncs = ABSOLUTE(.);
+    *(.ramfunc  .ramfunc.*)
+    _eramfuncs = ABSOLUTE(.);
+  } > sram AT > dflash
+
+  _framfuncs = LOADADDR(.ramfunc);
+
+  .bss :
+  {
+    _sbss = ABSOLUTE(.);
+    *(.bss .bss.*)
+    *(.gnu.linkonce.b.*)
+    *(COMMON)
+    . = ALIGN(4);
+    _ebss = ABSOLUTE(.);
+  } > sram
+
+  /* Stabs debugging sections. */
+
+  .stab 0 : { *(.stab) }
+  .stabstr 0 : { *(.stabstr) }
+  .stab.excl 0 : { *(.stab.excl) }
+  .stab.exclstr 0 : { *(.stab.exclstr) }
+  .stab.index 0 : { *(.stab.index) }
+  .stab.indexstr 0 : { *(.stab.indexstr) }
+  .comment 0 : { *(.comment) }
+  .debug_abbrev 0 : { *(.debug_abbrev) }
+  .debug_info 0 : { *(.debug_info) }
+  .debug_line 0 : { *(.debug_line) }
+  .debug_pubnames 0 : { *(.debug_pubnames) }
+  .debug_aranges 0 : { *(.debug_aranges) }
+}
diff --git a/boards/arm/s32k1xx/rddrone-bms772/scripts/s32k144.cfg b/boards/arm/s32k1xx/rddrone-bms772/scripts/s32k144.cfg
new file mode 100644
index 0000000000..7d30a9f05f
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/scripts/s32k144.cfg
@@ -0,0 +1,58 @@
+#
+# NXP S32K144 - 1x ARM Cortex-M4 @ up to 112 MHz
+#
+
+adapter_khz 4000
+transport select swd
+
+if { [info exists CHIPNAME] } {
+	set _CHIPNAME $CHIPNAME
+} else {
+	set _CHIPNAME s32k144
+}
+
+#
+# M4 JTAG mode TAP
+#
+if { [info exists M4_JTAG_TAPID] } {
+	set _M4_JTAG_TAPID $M4_JTAG_TAPID
+} else {
+	set _M4_JTAG_TAPID 0x4ba00477
+}
+
+#
+# M4 SWD mode TAP
+#
+if { [info exists M4_SWD_TAPID] } {
+	set _M4_SWD_TAPID $M4_SWD_TAPID
+} else {
+	set _M4_SWD_TAPID 0x2ba01477
+}
+
+source [find target/swj-dp.tcl]
+
+if { [using_jtag] } {
+	set _M4_TAPID $_M4_JTAG_TAPID
+} else {
+	set _M4_TAPID $_M4_SWD_TAPID
+}
+
+swj_newdap $_CHIPNAME m4 -irlen 4 -ircapture 0x1 -irmask 0xf \
+				-expected-id $_M4_TAPID
+
+target create $_CHIPNAME.m4 cortex_m -chain-position $_CHIPNAME.m4
+
+# S32K144 has 32+28 KB contiguous SRAM
+if { [info exists WORKAREASIZE] } {
+	set _WORKAREASIZE $WORKAREASIZE
+} else {
+	set _WORKAREASIZE 0xF000
+}
+$_CHIPNAME.m4 configure -work-area-phys 0x1FFF8000 \
+                        -work-area-size $_WORKAREASIZE -work-area-backup 0
+
+$_CHIPNAME.m4 configure -rtos nuttx
+
+if { ![using_hla] } {
+	cortex_m reset_config vectreset
+}
diff --git a/boards/arm/s32k1xx/rddrone-bms772/scripts/sram.ld b/boards/arm/s32k1xx/rddrone-bms772/scripts/sram.ld
new file mode 100644
index 0000000000..0c6b5867e0
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/scripts/sram.ld
@@ -0,0 +1,129 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/rddrone-bms772/scripts/sram.ld
+ *
+ *   Copyright (C) 2019 Gregory Nutt. All rights reserved.
+ *   Author: Gregory Nutt <gnutt@nuttx.org>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/* The S32K144 has 512Kb of FLASH beginning at address 0x0000:0000 and
+ * 60Kb of SRAM beginning at address 0x1fff:8000 (plus 4Kb of FlexRAM)
+ *
+ * The on-chip RAM is split in two regions: SRAM_L and SRAM_U. The RAM is
+ * implemented such that the SRAM_L and SRAM_U ranges form a contiguous
+ * block in the memory map
+ *
+ *   SRAM_L 1fff8000 - 1fffffff 32Kb
+ *   SRAM_U 20000000 - 20006fff 28Kb
+ */
+
+MEMORY
+{
+  flash (rx)  : ORIGIN = 0x00000000, LENGTH = 512K
+  sram  (rwx) : ORIGIN = 0x1fff8000, LENGTH = 60K
+}
+
+OUTPUT_ARCH(arm)
+EXTERN(_vectors)
+ENTRY(_stext)
+
+SECTIONS
+{
+  .text :
+  {
+    _stext = ABSOLUTE(.);
+    *(.vectors)
+    *(.text .text.*)
+    *(.fixup)
+    *(.gnu.warning)
+    *(.rodata .rodata.*)
+    *(.gnu.linkonce.t.*)
+    *(.glue_7)
+    *(.glue_7t)
+    *(.got)
+    *(.gcc_except_table)
+    *(.gnu.linkonce.r.*)
+    _etext = ABSOLUTE(.);
+  } > sram
+
+  .init_section :
+  {
+    _sinit = ABSOLUTE(.);
+    *(.init_array .init_array.*)
+    _einit = ABSOLUTE(.);
+  } > sram
+
+  .ARM.extab :
+  {
+    *(.ARM.extab*)
+  } >sram
+
+  .ARM.exidx :
+  {
+    __exidx_start = ABSOLUTE(.);
+    *(.ARM.exidx*)
+    __exidx_end = ABSOLUTE(.);
+  } >sram
+
+  .data :
+  {
+    _sdata = ABSOLUTE(.);
+    *(.data .data.*)
+    *(.gnu.linkonce.d.*)
+    CONSTRUCTORS
+    . = ALIGN(4);
+    _edata = ABSOLUTE(.);
+  } > sram
+
+  .bss :
+  {
+    _sbss = ABSOLUTE(.);
+    *(.bss .bss.*)
+    *(.gnu.linkonce.b.*)
+    *(COMMON)
+    . = ALIGN(4);
+    _ebss = ABSOLUTE(.);
+  } > sram
+
+  /* Stabs debugging sections. */
+
+  .stab 0 : { *(.stab) }
+  .stabstr 0 : { *(.stabstr) }
+  .stab.excl 0 : { *(.stab.excl) }
+  .stab.exclstr 0 : { *(.stab.exclstr) }
+  .stab.index 0 : { *(.stab.index) }
+  .stab.indexstr 0 : { *(.stab.indexstr) }
+  .comment 0 : { *(.comment) }
+  .debug_abbrev 0 : { *(.debug_abbrev) }
+  .debug_info 0 : { *(.debug_info) }
+  .debug_line 0 : { *(.debug_line) }
+  .debug_pubnames 0 : { *(.debug_pubnames) }
+  .debug_aranges 0 : { *(.debug_aranges) }
+}
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/.gitignore b/boards/arm/s32k1xx/rddrone-bms772/src/.gitignore
new file mode 100644
index 0000000000..726d936e1e
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/.gitignore
@@ -0,0 +1,2 @@
+/.depend
+/Make.dep
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/Makefile b/boards/arm/s32k1xx/rddrone-bms772/src/Makefile
new file mode 100644
index 0000000000..af105c0242
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/Makefile
@@ -0,0 +1,79 @@
+############################################################################
+# boards/arm/s32k1xx/rddrone-bms772/src/Makefile
+#
+#   Copyright (C) 2019 Gregory Nutt. All rights reserved.
+#   Author: Gregory Nutt <gnutt@nuttx.org>
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in
+#    the documentation and/or other materials provided with the
+#    distribution.
+# 3. Neither the name NuttX nor the names of its contributors may be
+#    used to endorse or promote products derived from this software
+#    without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+# OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+# AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+############################################################################
+
+include $(TOPDIR)/Make.defs
+
+CSRCS  = s32k1xx_boot.c s32k1xx_bringup.c s32k1xx_clockconfig.c
+CSRCS += s32k1xx_periphclocks.c
+
+ifeq ($(CONFIG_ARCH_LEDS),y)
+CSRCS += s32k1xx_autoleds.c
+else
+CSRCS += s32k1xx_userleds.c
+endif
+
+ifeq ($(CONFIG_ARCH_BUTTONS),y)
+CSRCS += s32k1xx_buttons.c
+endif
+
+ifeq ($(CONFIG_DEV_GPIO),y)
+CSRCS += s32k1xx_gpio.c
+endif
+
+ifeq ($(CONFIG_LIB_BOARDCTL),y)
+CSRCS += s32k1xx_appinit.c
+endif
+
+ifeq ($(CONFIG_PWM),y)
+CSRCS += s32k1xx_pwm.c
+endif
+
+ifeq ($(CONFIG_SBS_DRIVER),y)
+CSRCS += s32k1xx_smartbattery.c
+endif
+
+ifeq ($(CONFIG_S32K1XX_LPSPI),y)
+CSRCS += s32k1xx_spi.c
+endif
+
+ifeq ($(CONFIG_BOARDCTL_RESET),y)
+CSRCS += s32k1xx_reset.c
+endif
+
+ifeq ($(CONFIG_NRST_CHECK_PROC_FS),y)
+CSRCS += s32k1xx_nrstcheck.c
+endif
+
+include $(TOPDIR)/boards/Board.mk
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/rddrone-bms772.h b/boards/arm/s32k1xx/rddrone-bms772/src/rddrone-bms772.h
new file mode 100644
index 0000000000..4af5b400eb
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/rddrone-bms772.h
@@ -0,0 +1,217 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/rddrone-bms772/src/rddrone-bms772.h
+ *
+ *   Copyright (C) 2019 Gregory Nutt. All rights reserved.
+ *   Author: Gregory Nutt <gnutt@nuttx.org>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+#ifndef __BOARDS_ARM_S32K1XX_RDDRONE_BMS772_SRC_RDDRONE_BMS772_H
+#define __BOARDS_ARM_S32K1XX_RDDRONE_BMS772_SRC_RDDRONE_BMS772_H
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+#include <nuttx/compiler.h>
+
+#include <stdint.h>
+
+#include "hardware/s32k1xx_pinmux.h"
+#include "s32k1xx_periphclocks.h"
+#include "s32k1xx_pin.h"
+
+/****************************************************************************
+ * Pre-processor Definitions
+ ****************************************************************************/
+
+/* Configuration ************************************************************/
+
+/* RDDRONE-BMS772 GPIOs *****************************************************/
+
+/* LEDs.  The RDDRONE-BMS772 has one RGB LED:
+ *
+ *   RedLED   PTD16 (FTM0 CH1)
+ *   GreenLED PTB13 (FTM0 CH1)
+ *   BlueLED  PTD15 (FTM0 CH0)
+ *
+ * An output of '1' illuminates the LED.
+ */
+
+#define GPIO_LED_R     (PIN_PTD16 | GPIO_LOWDRIVE | GPIO_OUTPUT_ZERO)
+#define GPIO_LED_G     (PIN_PTB13 | GPIO_LOWDRIVE | GPIO_OUTPUT_ZERO)
+#define GPIO_LED_B     (PIN_PTD15 | GPIO_LOWDRIVE | GPIO_OUTPUT_ZERO)
+
+/* Buttons.  The rddrone-bms772 supports one button:
+ *
+ *   SW1  PTC14
+ */
+
+//#define GPIO_SW1       (PIN_PTC14 | PIN_INT_BOTH)    
+//#define GPIO_SW3       (PIN_PTC13 | PIN_INT_BOTH)
+
+/* GPIO pins to be registered to the GPIO driver: */
+
+/* WARNING IF THIS CHANGES CHANGE gpio.h 
+ *      and the NUM_OF_GPIO_x
+ *      and the array in s32k1xx_gpio.c 
+ */
+
+#define NUM_OF_GPIO_IN  0 /* Amount of GPIO input pins */
+#define NUM_OF_GPIO_OUT 5 /* Amount of GPIO output pins */
+#ifdef CONFIG_S32K1XX_GPIOIRQ
+#define NUM_OF_GPIO_INT 7 /* Amount of GPIO interrupt pins */
+#else
+#define NUM_OF_GPIO_INT 0 /* Amount of GPIO interrupt pins */
+#endif
+
+/* WARNING IF THIS CHANGES CHANGE gpio.h 
+ *      and the NUM_OF_GPIO_x
+ *      and the array in s32k1xx_gpio.c 
+ */
+
+/* #define GPIO_IN0   (PIN_PTA13 | GPIO_INPUT) // NFC_ED */
+/* #define GPIO_IN1   (PIN_PTC14 | GPIO_INPUT) // SBC Wake */
+/* #define GPIO_IN2   (PIN_PTC8  | GPIO_INPUT) // GATE_RS */
+/* #define GPIO_IN3   (PIN_PTA11 | GPIO_INPUT) // SBC_LIMP */
+/* #define GPIO_IN0   (PIN_PTC9  | GPIO_INPUT) // BCC_FAULT */
+
+/* #define GPIO_OUT1  (PIN_PTC1  | GPIO_OUTPUT) // GATE_CTRL_CP */
+/* #define GPIO_OUT2  (PIN_PTC2  | GPIO_OUTPUT) // GATE_CTRL_D */
+/* #define GPIO_OUT3  (PIN_PTD5  | GPIO_OUTPUT) // BCC_RESET */
+/* #define GPIO_OUT4  (PIN_PTA12 | GPIO_OUTPUT) // NFC_HPD */
+/* #define GPIO_OUT5  (PIN_PTC15 | GPIO_OUTPUT) // AUTH_WAKE */
+
+#define GPIO_OUT0   (PIN_PTC1  | GPIO_OUTPUT) /* GATE_CTRL_CP */
+#define GPIO_OUT1   (PIN_PTC2  | GPIO_OUTPUT) /* GATE_CTRL_D */
+#define GPIO_OUT2   (PIN_PTD5  | GPIO_OUTPUT) /* BCC_RESET */
+#define GPIO_OUT3   (PIN_PTA12 | GPIO_OUTPUT) /* NFC_HPD */
+#define GPIO_OUT4   (PIN_PTC15 | GPIO_OUTPUT) /* AUTH_WAKE */
+
+#define GPIO_INT5   (PIN_PTE8  | GPIO_INPUT | PIN_INT_BOTH) /* EXT_OUT1 To ext header */
+#define GPIO_INT6   (PIN_PTC3  | GPIO_INPUT | PIN_INT_BOTH) /* OVERCURRENT */
+#define GPIO_INT7   (PIN_PTC14 | GPIO_INPUT | PIN_INT_BOTH) /* SBC Wake  */
+#define GPIO_INT8   (PIN_PTC8  | GPIO_INPUT | PIN_INT_BOTH) /* GATE_RS */
+#define GPIO_INT9   (PIN_PTA11 | GPIO_INPUT | PIN_INT_BOTH) /* SBC_LIMP */
+#define GPIO_INT10  (PIN_PTC9  | GPIO_INPUT | PIN_INT_BOTH) /* BCC_FAULT */
+#define GPIO_INT11  (PIN_PTA13 | GPIO_INPUT | PIN_INT_BOTH) /* NFC_ED */
+
+/* SPI chip selects */
+
+/* Count of peripheral clock user configurations */
+
+#define NUM_OF_PERIPHERAL_CLOCKS_0 12
+
+/****************************************************************************
+ * Public Types
+ ****************************************************************************/
+
+/****************************************************************************
+ * Public Data
+ ****************************************************************************/
+
+#ifndef __ASSEMBLY__
+
+/* User peripheral configuration structure 0 */
+
+extern const struct peripheral_clock_config_s g_peripheral_clockconfig0[];
+
+/****************************************************************************
+ * Public Function Prototypes
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: s32k1xx_bringup
+ *
+ * Description:
+ *   Perform architecture-specific initialization
+ *
+ *   CONFIG_BOARD_LATE_INITIALIZE=y :
+ *     Called from board_late_initialize().
+ *
+ *   CONFIG_BOARD_LATE_INITIALIZE=y && CONFIG_LIB_BOARDCTL=y :
+ *     Called from the NSH library
+ *
+ ****************************************************************************/
+
+int s32k1xx_bringup(void);
+
+#ifdef CONFIG_DEV_GPIO
+/****************************************************************************
+ * Name: s32k1xx_gpio_initialize
+ *
+ * Description:
+ *   Initialize GPIO drivers for use with /apps/examples/gpio
+ *
+ ****************************************************************************/
+
+int s32k1xx_gpio_initialize(void);
+#endif
+
+#ifdef CONFIG_S32K1XX_LPI2C
+/****************************************************************************
+ * Name: s32k1xx_smartbattery_initialize
+ *
+ * Description:
+ *   Initialize smart battery SMBus (I2C slave) example.
+ *
+ ****************************************************************************/
+
+int s32k1xx_smartbattery_initialize(void);
+#endif
+
+/****************************************************************************
+ * Name: s32k1xx_spidev_initialize
+ *
+ * Description:
+ *   Called to configure SPI chip select GPIO pins for the RDDRONE-BMS772
+ *   board.
+ *
+ ****************************************************************************/
+
+#ifdef CONFIG_S32K1XX_LPSPI
+void s32k1xx_spidev_initialize(void);
+#endif
+
+/****************************************************************************
+ * Name: s32k1xx_nrstcheck
+ *
+ * Description:
+ *   It will make the NRST pin a pull-down GPIO input pin and check the state
+ *   This will be saved in a block device and the pin is configured as NRST.  
+ *
+ ****************************************************************************/
+#if defined(CONFIG_NRST_CHECK_PROC_FS) && defined(CONFIG_FS_PROCFS)
+int s32k1xx_nrstcheck(void);
+#endif
+
+#endif /* __ASSEMBLY__ */
+#endif /* __BOARDS_ARM_S32K1XX_RDDRONE_BMS772_SRC_RDDRONE_BMS772_H */
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_appinit.c b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_appinit.c
new file mode 100644
index 0000000000..145c8dd558
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_appinit.c
@@ -0,0 +1,94 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_appinit.c
+ *
+ *   Copyright (C) 2019 Gregory Nutt. All rights reserved.
+ *   Author: Gregory Nutt <gnutt@nuttx.org>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include <nuttx/board.h>
+
+#include "rddrone-bms772.h"
+
+/****************************************************************************
+ * Pre-processor Definitions
+ ****************************************************************************/
+
+#ifndef OK
+#  define OK 0
+#endif
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: board_app_initialize
+ *
+ * Description:
+ *   Perform application specific initialization.  This function is never
+ *   called directly from application code, but only indirectly via the
+ *   (non-standard) boardctl() interface using the command BOARDIOC_INIT.
+ *
+ * Input Parameters:
+ *   arg - The boardctl() argument is passed to the board_app_initialize()
+ *         implementation without modification.  The argument has no
+ *         meaning to NuttX; the meaning of the argument is a contract
+ *         between the board-specific initialization logic and the
+ *         matching application logic.  The value could be such things as a
+ *         mode enumeration value, a set of DIP switch switch settings, a
+ *         pointer to configuration data read from a file or serial FLASH,
+ *         or whatever you would like to do with it.  Every implementation
+ *         should accept zero/NULL as a default configuration.
+ *
+ * Returned Value:
+ *   Zero (OK) is returned on success; a negated errno value is returned on
+ *   any failure to indicate the nature of the failure.
+ *
+ ****************************************************************************/
+
+int board_app_initialize(uintptr_t arg)
+{
+#ifdef CONFIG_BOARD_LATE_INITIALIZE
+  /* Board initialization already performed by board_late_initialize() */
+
+  return OK;
+#else
+  /* Perform board-specific initialization */
+
+  return s32k1xx_bringup();
+#endif
+}
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_autoleds.c b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_autoleds.c
new file mode 100644
index 0000000000..3cda4ef8bd
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_autoleds.c
@@ -0,0 +1,165 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_autoleds.c
+ *
+ *   Copyright (C) 2019 Gregory Nutt. All rights reserved.
+ *   Author: Gregory Nutt <gnutt@nuttx.org>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/* The RDDRONE-BMS772 has one RGB LED:
+ *
+ *   RedLED   PTD16 (FTM0 CH1)
+ *   GreenLED PTB13 (FTM0 CH1)
+ *   BlueLED  PTD15 (FTM0 CH0)
+ *
+ * An output of '1' illuminates the LED.
+ *
+ * If CONFIG_ARCH_LEDs is defined, then NuttX will control the LED on board
+ * the Freedom K66F.  The following definitions describe how NuttX controls
+ * the LEDs:
+ *
+ *   SYMBOL                Meaning                 LED state
+ *                                                 RED   GREEN  BLUE
+ *   -------------------  -----------------------  -----------------
+ *   LED_STARTED          NuttX has been started    OFF  OFF  OFF
+ *   LED_HEAPALLOCATE     Heap has been allocated   OFF  OFF  ON
+ *   LED_IRQSENABLED      Interrupts enabled        OFF  OFF  ON
+ *   LED_STACKCREATED     Idle stack created        OFF  ON   OFF
+ *   LED_INIRQ            In an interrupt          (no change)
+ *   LED_SIGNAL           In a signal handler      (no change)
+ *   LED_ASSERTION        An assertion failed      (no change)
+ *   LED_PANIC            The system has crashed    FLASH OFF OFF
+ *   LED_IDLE             K66 is in sleep mode     (Optional, not used)
+ */
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include <stdint.h>
+#include <stdbool.h>
+#include <debug.h>
+
+#include <nuttx/board.h>
+#include <arch/board/board.h>
+
+#include "arm_arch.h"
+#include "arm_internal.h"
+
+#include "s32k1xx_pin.h"
+#include "rddrone-bms772.h"
+
+#include <arch/board/board.h>
+
+#ifdef CONFIG_ARCH_LEDS
+
+/****************************************************************************
+ * Pre-processor Definitions
+ ****************************************************************************/
+
+/* Summary of all possible settings */
+
+#define LED_NOCHANGE      0 /* LED_IRQSENABLED, LED_INIRQ, LED_SIGNAL, LED_ASSERTION */
+#define LED_OFF_OFF_OFF   1 /* LED_STARTED */
+#define LED_OFF_OFF_ON    2 /* LED_HEAPALLOCATE */
+#define LED_OFF_ON_OFF    3 /* LED_STACKCREATED */
+#define LED_ON_OFF_OFF    4 /* LED_PANIC */
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: board_autoled_initialize
+ ****************************************************************************/
+
+void board_autoled_initialize(void)
+{
+  /* Configure LED GPIOs for output */
+
+  s32k1xx_pinconfig(GPIO_LED_R);
+  s32k1xx_pinconfig(GPIO_LED_G);
+  s32k1xx_pinconfig(GPIO_LED_B);
+}
+
+/****************************************************************************
+ * Name: board_autoled_on
+ ****************************************************************************/
+
+void board_autoled_on(int led)
+{
+  if (led != LED_NOCHANGE)
+    {
+      bool redon   = false;
+      bool greenon = false;
+      bool blueon  = false;
+
+      switch (led)
+        {
+          default:
+          case LED_OFF_OFF_OFF:
+            break;
+
+          case LED_OFF_OFF_ON:
+            blueon = true;
+            break;
+
+          case LED_OFF_ON_OFF:
+            greenon = true;
+            break;
+
+          case LED_ON_OFF_OFF:
+            redon = true;
+            break;
+        }
+
+      s32k1xx_gpiowrite(GPIO_LED_R, redon);
+      s32k1xx_gpiowrite(GPIO_LED_G, greenon);
+      s32k1xx_gpiowrite(GPIO_LED_B, blueon);
+    }
+}
+
+/****************************************************************************
+ * Name: board_autoled_off
+ ****************************************************************************/
+
+void board_autoled_off(int led)
+{
+  if (led == LED_ON_OFF_OFF)
+    {
+      s32k1xx_gpiowrite(GPIO_LED_R, true);
+      s32k1xx_gpiowrite(GPIO_LED_G, false);
+      s32k1xx_gpiowrite(GPIO_LED_B, false);
+    }
+}
+
+#endif /* CONFIG_ARCH_LEDS */
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_boot.c b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_boot.c
new file mode 100644
index 0000000000..01fb4945bd
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_boot.c
@@ -0,0 +1,93 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_boot.c
+ *
+ *   Copyright (C) 2019 Gregory Nutt. All rights reserved.
+ *   Author: Gregory Nutt <gnutt@nuttx.org>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include <debug.h>
+
+#include <nuttx/board.h>
+
+#include "rddrone-bms772.h"
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: s32k1xx_board_initialize
+ *
+ * Description:
+ *   All S32K1XX architectures must provide the following entry point.  This
+ *   entry point is called early in the initialization -- after all memory
+ *   has been configured and mapped but before any devices have been
+ *   initialized.
+ *
+ ****************************************************************************/
+
+void s32k1xx_board_initialize(void)
+{
+#ifdef CONFIG_ARCH_LEDS
+  /* Configure on-board LEDs if LED support has been selected. */
+
+  board_autoled_initialize();
+#endif
+}
+
+/****************************************************************************
+ * Name: board_late_initialize
+ *
+ * Description:
+ *   If CONFIG_BOARD_LATE_INITIALIZE is selected, then an additional
+ *   initialization call will be performed in the boot-up sequence to a
+ *   function called board_late_initialize().  board_late_initialize() will
+ *   be called immediately after up_initialize() is called and just before
+ *   the initial application is started.  This additional initialization
+ *   phase may be used, for example, to initialize board-specific device
+ *   drivers.
+ *
+ ****************************************************************************/
+
+#ifdef CONFIG_BOARD_LATE_INITIALIZE
+void board_late_initialize(void)
+{
+  /* Perform board-specific initialization */
+
+  s32k1xx_bringup();
+}
+#endif
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_bringup.c b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_bringup.c
new file mode 100644
index 0000000000..8bd8268504
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_bringup.c
@@ -0,0 +1,216 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_bringup.c
+ *
+ *   Copyright (C) 2019 Gregory Nutt. All rights reserved.
+ *   Author: Gregory Nutt <gnutt@nuttx.org>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include <sys/types.h>
+#include <sys/mount.h>
+#include <syslog.h>
+
+#ifdef CONFIG_BUTTONS
+#  include <nuttx/input/buttons.h>
+#endif
+
+#ifdef CONFIG_USERLED
+#  include <nuttx/leds/userled.h>
+#endif
+
+#ifdef CONFIG_I2C_DRIVER
+#  include "s32k1xx_pin.h"
+#  include <nuttx/i2c/i2c_master.h>
+#  include "s32k1xx_lpi2c.h"
+#endif
+
+#ifdef CONFIG_S32K1XX_EEEPROM
+#  include "s32k1xx_eeeprom.h"
+#endif
+
+#include "rddrone-bms772.h"
+
+#include "s32k1xx_resetcause.h"
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: s32k1xx_bringup
+ *
+ * Description:
+ *   Perform architecture-specific initialization
+ *
+ *   CONFIG_BOARD_LATE_INITIALIZE=y :
+ *     Called from board_late_initialize().
+ *
+ *   CONFIG_BOARD_LATE_INITIALIZE=n && CONFIG_LIB_BOARDCTL=y :
+ *     Called from the NSH library
+ *
+ ****************************************************************************/
+
+int s32k1xx_bringup(void)
+{
+  int ret = OK;
+
+#ifdef CONFIG_BUTTONS
+  /* Register the BUTTON driver */
+
+  ret = btn_lower_initialize("/dev/buttons");
+  if (ret < 0)
+    {
+      syslog(LOG_ERR, "ERROR: btn_lower_initialize() failed: %d\n", ret);
+    }
+#endif
+
+#ifdef CONFIG_USERLED
+  /* Register the LED driver */
+
+  ret = userled_lower_initialize("/dev/userleds");
+  if (ret < 0)
+    {
+      syslog(LOG_ERR, "ERROR: userled_lower_initialize() failed: %d\n", ret);
+    }
+#endif
+
+#ifdef CONFIG_FS_PROCFS
+
+# ifdef CONFIG_RESET_CAUSE_PROC_FS
+  /* initialize the reset cause proc fs */
+
+  s32k1xx_resetcause_init();
+  /* registrate the reset cause proc fs */
+  
+  ret = s32k1xx_resetcause_initialize_procfs();
+  if (ret < 0)
+    {
+      syslog(LOG_ERR, "ERROR: Failed to mount reset cause procfs at /proc/: %d\n", ret);
+    }
+# endif
+
+# ifdef CONFIG_NRST_CHECK_PROC_FS
+  /* Check the NRST line and registrate the check nrst proc fs */
+
+  ret = s32k1xx_nrstcheck();
+  if (ret < 0)
+    {
+      syslog(LOG_ERR, "ERROR: Failed to mount check nrst procfs at /proc/: %d\n", ret);
+    }
+# endif
+  /* Mount the procfs file system */
+
+  ret = mount(NULL, "/proc", "procfs", 0, NULL);
+  if (ret < 0)
+    {
+      syslog(LOG_ERR, "ERROR: Failed to mount procfs at /proc: %d\n", ret);
+    }
+
+#endif
+
+#ifdef CONFIG_DEV_GPIO
+  ret = s32k1xx_gpio_initialize();
+  if (ret < 0)
+    {
+      syslog(LOG_ERR, "ERROR: Failed to initialize GPIO driver: %d\n", ret);
+    }
+#endif
+
+#ifdef CONFIG_PWM
+  /* Initialize PWM and register the PWM device. */
+
+  ret = s32k1xx_pwm_setup();
+  if (ret < 0)
+    {
+      syslog(LOG_ERR, "ERROR: s32k1xx_pwm_setup() failed: %d\n", ret);
+    }
+#endif
+
+#ifdef CONFIG_S32K1XX_LPSPI
+  /* Configure SPI chip selects if 1) SPI is not disabled, and 2) the weak
+   * function s32k1xx_spidev_initialize() has been brought into the link.
+   */
+
+  s32k1xx_spidev_initialize();
+#endif
+
+#if defined(CONFIG_S32K1XX_LPI2C0) && defined(CONFIG_I2C_DRIVER)
+  FAR struct i2c_master_s *i2c;
+
+  i2c = s32k1xx_i2cbus_initialize(0);
+  if (i2c == NULL)
+    {
+      serr("ERROR: Failed to get I2C%d interface\n", bus);
+    }
+  else
+    {
+      ret = i2c_register(i2c, 0);
+      if (ret < 0)
+        {
+          serr("ERROR: Failed to register I2C%d driver: %d\n", bus, ret);
+          s32k1xx_i2cbus_uninitialize(i2c);
+        }
+    }
+#endif
+
+#ifdef CONFIG_SBS_DRIVER
+  ret = s32k1xx_smartbattery_initialize();
+  if (ret < 0)
+    {
+      syslog(LOG_ERR,
+             "ERROR: Failed to initialize smart battery example: %d\n", ret);
+    }
+#endif    
+
+#ifdef CONFIG_S32K1XX_PROGMEM
+  FAR struct mtd_dev_s *mtd;
+  int minor = 0;
+
+  mtd = progmem_initialize();
+  if (!mtd)
+    {
+      syslog(LOG_ERR, "ERROR: progmem_initialize failed\n");
+    }
+#endif
+
+#ifdef CONFIG_S32K1XX_EEEPROM
+      /* Register EEEPROM block device */
+
+      s32k1xx_eeeprom_register(0, 4096);
+#endif
+
+  return ret;
+}
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_buttons.c b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_buttons.c
new file mode 100644
index 0000000000..e8c464ed63
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_buttons.c
@@ -0,0 +1,164 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_buttons.c
+ *
+ *   Copyright (C) 2019 Gregory Nutt. All rights reserved.
+ *   Author: Gregory Nutt <gnutt@nuttx.org>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/* The rddrone-bms772 supports one button:
+ *
+ *   SW1 PTC14
+ */
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include <stdint.h>
+#include <errno.h>
+
+#include <nuttx/arch.h>
+#include <nuttx/board.h>
+
+#include "s32k1xx_pin.h"
+#include "rddrone-bms772.h"
+
+#include <arch/board/board.h>
+
+#ifdef CONFIG_ARCH_BUTTONS
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: board_button_initialize
+ *
+ * Description:
+ *   board_button_initialize() must be called to initialize button resources.
+ *   After that, board_buttons() may be called to collect the current state
+ *   of all buttons or board_button_irq() may be called to register button
+ *   interrupt handlers.
+ *
+ ****************************************************************************/
+
+uint32_t board_button_initialize(void)
+{
+  /* Configure the GPIO pins as interrupting inputs. */
+
+  s32k1xx_pinconfig(GPIO_SW1);
+  return NUM_BUTTONS;
+}
+
+/****************************************************************************
+ * Name: board_buttons
+ ****************************************************************************/
+
+uint32_t board_buttons(void)
+{
+  uint32_t ret = 0;
+
+  if (s32k1xx_gpioread(GPIO_SW1))
+    {
+      ret |= BUTTON_SW1_BIT;
+    }
+
+  // if (s32k1xx_gpioread(GPIO_SW3))
+  //   {
+  //     ret |= BUTTON_SW3_BIT;
+  //   }
+
+  return ret;
+}
+
+/****************************************************************************
+ * Button support.
+ *
+ * Description:
+ *   board_button_initialize() must be called to initialize button resources.
+ *   After that, board_buttons() may be called to collect the current state
+ *   of all buttons or board_button_irq() may be called to register button
+ *   interrupt handlers.
+ *
+ *   After board_button_initialize() has been called, board_buttons() may be
+ *   called to collect the state of all buttons.  board_buttons() returns a
+ *   32-bit bit set with each bit associated with a button.  See the
+ *   BUTTON_*_BIT definitions in board.h for the meaning of each bit.
+ *
+ *   board_button_irq() may be called to register an interrupt handler that
+ *   will be called when a button is depressed or released.  The ID value is
+ *   a button enumeration value that uniquely identifies a button resource.
+ *   See the BUTTON_* definitions in board.h for the meaning of enumeration
+ *   value.
+ *
+ ****************************************************************************/
+
+#ifdef CONFIG_ARCH_IRQBUTTONS
+int board_button_irq(int id, xcpt_t irqhandler, FAR void *arg)
+{
+  uint32_t pinset;
+  int ret;
+
+  /* Map the button id to the GPIO bit set. */
+
+  if (id == BUTTON_SW1)
+    {
+      pinset = GPIO_SW1;
+    }
+  // else if (id == BUTTON_SW3)
+  //   {
+  //     pinset = GPIO_SW3;
+  //   }
+  else
+    {
+      return -EINVAL;
+    }
+
+  /* The button has already been configured as an interrupting input (by
+   * board_button_initialize() above).
+   *
+   * Attach the new button handler.
+   */
+
+  ret = s32k1xx_pinirqattach(pinset, irqhandler, NULL);
+  if (ret >= 0)
+    {
+      /* Then make sure that interrupts are enabled on the pin */
+
+      s32k1xx_pinirqenable(pinset);
+    }
+
+  return ret;
+}
+#endif
+#endif /* CONFIG_ARCH_BUTTONS */
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_clockconfig.c b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_clockconfig.c
new file mode 100644
index 0000000000..7f0bb54dc0
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_clockconfig.c
@@ -0,0 +1,217 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_clockconfig.c
+ *
+ *   Copyright (C) 2019 Gregory Nutt. All rights reserved.
+ *   Author: Gregory Nutt <gnutt@nuttx.org>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Most of the settings within this file derives from NXP sample code for
+ * the S32K1XX MCUs.  That sample code has this licensing information:
+ *
+ *   Copyright (c) 2013 - 2015, Freescale Semiconductor, Inc.
+ *   Copyright 2016-2018 NXP
+ *   All rights reserved.
+ *
+ * THIS SOFTWARE IS PROVIDED BY NXP "AS IS" AND ANY EXPRESSED OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL NXP OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include <stdint.h>
+#include <stdbool.h>
+
+#include "s32k1xx_clockconfig.h"
+#include "s32k1xx_start.h"
+#include "rddrone-bms772.h"
+
+/****************************************************************************
+ * Public Data
+ ****************************************************************************/
+
+/* Each S32K1XX board must provide the following initialized structure.
+ * This is needed to establish the initial board clocking.
+ */
+
+const struct clock_configuration_s g_initial_clkconfig =
+{
+  .scg =
+  {
+    .sirc          =
+    {
+      .range       = SCG_SIRC_RANGE_HIGH,      /* RANGE - High range (8 MHz) */
+      .div1        = SCG_ASYNC_CLOCK_DISABLE,  /* SIRCDIV1 */
+      .div2        = SCG_ASYNC_CLOCK_DIV_BY_4, //SCG_ASYNC_CLOCK_DIV_BY_4, /* SIRCDIV2 */
+      .initialize  = true,  /* Initialize */
+      .stopmode    = false, /* SIRCSTEN */
+      .lowpower    = true,  /* SIRCLPEN */
+      .locked      = false, /* LK */
+    },
+    .firc          =
+    {
+      .range       = SCG_FIRC_RANGE_48M,       /* RANGE */
+      .div1        = SCG_ASYNC_CLOCK_DISABLE,  /* FIRCDIV1 */
+      .div2        = SCG_ASYNC_CLOCK_DISABLE,  /* FIRCDIV2 */
+      .initialize  = false, /* Initialize */
+      .regulator   = false, /* FIRCREGOFF */
+      .locked      = false, /* LK */
+    },
+    .sosc          =
+    {
+      .mode        = SCG_SOSC_MONITOR_DISABLE, /* SOSCCM */
+      .gain        = SCG_SOSC_GAIN_LOW,        /* HGO */
+      .range       = SCG_SOSC_RANGE_HIGH,      /* RANGE */
+      .extref      = SCG_SOSC_REF_OSC,         /* EREFS */
+      .div1        = SCG_ASYNC_CLOCK_DISABLE,  /* SOSCDIV1 */
+      .div2        = SCG_ASYNC_CLOCK_DISABLE,  /* SOSCDIV2 */
+      .initialize  = true,  /* Initialize */
+      .locked      = false, /* LK */
+    },
+    .spll          =
+    {
+      .mode        = SCG_SPLL_MONITOR_DISABLE,  /* SPLLCM */
+      .div1        = SCG_ASYNC_CLOCK_DISABLE,   /* SPLLDIV1 */
+      .div2        = SCG_ASYNC_CLOCK_DIV_BY_8, /* SPLLDIV2 */
+      .prediv      = 4,     /* PREDIV */
+      .mult        = 40,    /* MULT */
+      .src         = 0,     /* SOURCE */
+      .initialize  = true,  /* Initialize */
+      .locked      = false, /* LK */
+    },
+    .rtc           =
+    {
+      .initialize  = true, /* Initialize */
+      .clkin       = 0,    /* RTC_CLKIN */
+    },
+    .clockout      =
+    {
+      .source      = SCG_CLOCKOUT_SRC_FIRC, /* SCG CLKOUTSEL */
+      .initialize  = false, /* Initialize */
+    },
+    .clockmode     =
+    {
+      .rccr        = /* RCCR - Run Clock Control Register */
+      {
+        .src       = SCG_SYSTEM_CLOCK_SRC_SYS_PLL, /* SCS */
+        .divslow   = 3, /* DIVSLOW, range 1..16 */
+        .divbus    = 2, /* DIVBUS, range 1..16 */
+        .divcore   = 2, /* DIVCORE, range 1..16 */
+      },
+      .vccr        = /* VCCR - VLPR Clock Control Register */
+      {
+        .src       = SCG_SYSTEM_CLOCK_SRC_SIRC, /* SCS */
+        .divslow   = 2, /* DIVSLOW, range 1..16 */
+        .divbus    = 1, /* DIVBUS, range 1..16 */
+        .divcore   = 4, /* DIVCORE, range 1..16 */
+      },
+      .hccr        =
+      {
+        .src       = SCG_SYSTEM_CLOCK_SRC_SYS_PLL, /* SCS */
+        .divslow   = 3, /* DIVSLOW, range 1..16 */
+        .divbus    = 2, /* DIVBUS, range 1..16 */
+        .divcore   = 2, /* DIVCORE, range 1..16 */
+      },
+      .initialize  = true, /* Initialize */
+    },
+  },
+  .sim             =
+  {
+    .clockout      = /* Clock Out configuration. */
+    {
+      .source      = SIM_CLKOUT_SEL_SYSTEM_SCG_CLKOUT, /* CLKOUTSEL */
+      .divider     = 1,     /* CLKOUTDIV, range 1..8 */
+      .initialize  = false, /* Initialize */
+      .enable      = false, /* CLKOUTEN */
+    },
+    .lpoclk        = /* Low Power Clock configuration. */
+    {
+      .rtc_source  = SIM_RTCCLK_SEL_LPO_32K,   /* RTCCLKSEL */
+      .lpo_source  = SIM_LPO_CLK_SEL_LPO_128K, /* LPOCLKSEL */
+      .initialize  = true, /* Initialize */
+      .lpo32k      = true, /* LPO32KCLKEN */
+      .lpo1k       = true, /* LPO1KCLKEN */
+    },
+    .tclk          = /* TCLK CLOCK configuration. */
+    {
+      .tclkfreq[0] = 0,    /* TCLK0 */
+      .tclkfreq[1] = 0,    /* TCLK1 */
+      .tclkfreq[2] = 0,    /* TCLK2 */
+      .initialize  = true, /* Initialize */
+    },
+    .platgate      = /* Platform Gate Clock configuration. */
+    {
+      .initialize  = true, /* Initialize */
+      .mscm        = true, /* CGCMSCM */
+      .mpu         = true, /* CGCMPU */
+      .dma         = true, /* CGCDMA */
+      .erm         = true, /* CGCERM */
+      .eim         = true, /* CGCEIM */
+    },
+    .traceclk      = /* Debug trace Clock Configuration. */
+    {
+      .source      = CLOCK_TRACE_SRC_CORE_CLK, /* TRACECLK_SEL */
+      .divider     = 1,     /* TRACEDIV, range 1..8 */
+      .initialize  = true,  /* Initialize */
+      .enable      = true,  /* TRACEDIVEN */
+      .fraction    = false, /* TRACEFRAC */
+    },
+  },
+  .pcc             =
+  {
+    .count         = NUM_OF_PERIPHERAL_CLOCKS_0, /* Number peripheral clock configurations */
+    .pclks         = g_peripheral_clockconfig0,  /* Peripheral clock configurations */
+  },
+  .pmc             =
+  {
+    .lpoclk        = /* Low Power Clock configuration. */
+    {
+      .trim        = 0,    /* Trimming value for LPO */
+      .initialize  = true, /* Initialize */
+      .enable      = true, /* Enable/disable LPO */
+    },
+  },
+};
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_gpio.c b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_gpio.c
new file mode 100644
index 0000000000..54acd7cff0
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_gpio.c
@@ -0,0 +1,549 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_gpio.c
+ *
+ *   Copyright (C) 2017-2018 Gregory Nutt. All rights reserved.
+ *   Copyright (C) 2017 Alan Carvalho de Assis. All rights reserved.
+ *   Author:  Alan Carvalho de Assis <acassis@gmail.com>
+ *
+ * Based on: boards/imxrt1050-evk/src/imxrt_gpio.c
+ *
+ *   Author:  Pavlina Koleva <pavlinaikoleva19@gmail.com>
+ *   Modified by: Ivan Ucherdzhiev <ivanucherdjiev@gmail.com>
+ *
+ * Also based on: boards/arm/stm32/stm32f103-minimum/src/stm32_gpio.c
+ *
+ *   Author:  Alan Carvalho de Assis <acassis@gmail.com>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include <stdbool.h>
+#include <assert.h>
+#include <debug.h>
+
+#include <nuttx/clock.h>
+#include <nuttx/wdog.h>
+#include <nuttx/ioexpander/gpio.h>
+
+#include <arch/board/board.h>
+
+#include "chip.h"
+
+#include <s32k1xx_pin.h>
+#include "rddrone-bms772.h"
+
+#if defined(CONFIG_DEV_GPIO) && !defined(CONFIG_GPIO_LOWER_HALF)
+
+/****************************************************************************
+ * Private Types
+ ****************************************************************************/
+
+struct s32k1xx_gpio_dev_s
+{
+  struct gpio_dev_s gpio;
+  uint8_t id;
+};
+
+struct s32k1xx_gpint_dev_s
+{
+  struct s32k1xx_gpio_dev_s s32k1xx_gpio;
+  pin_interrupt_t callback;
+};
+
+/****************************************************************************
+ * Private Function Prototypes
+ ****************************************************************************/
+#if NUM_OF_GPIO_IN > 0 
+static int gpin_read(FAR struct gpio_dev_s *dev, FAR bool *value);
+static int gpin_setpintype(FAR struct gpio_dev_s *dev,
+                            enum gpio_pintype_e pintype);
+#endif
+
+#if NUM_OF_GPIO_OUT > 0 
+static int gpout_read(FAR struct gpio_dev_s *dev, FAR bool *value);
+static int gpout_write(FAR struct gpio_dev_s *dev, bool value);
+#endif
+
+#if NUM_OF_GPIO_INT > 0 
+static int gpint_read(FAR struct gpio_dev_s *dev, FAR bool *value);
+static int gpint_attach(FAR struct gpio_dev_s *dev,
+                        pin_interrupt_t callback);
+static int gpint_enable(FAR struct gpio_dev_s *dev, bool enable);
+static int gpint_setpintype(FAR struct gpio_dev_s *dev,
+                            enum gpio_pintype_e pintype);
+#endif
+
+/****************************************************************************
+ * Private Data
+ ****************************************************************************/
+#if NUM_OF_GPIO_IN > 0 
+static const struct gpio_operations_s gpin_ops =
+{
+  .go_read   = gpin_read,
+  .go_write  = NULL,
+  .go_attach = NULL,
+  .go_enable = NULL,
+  .go_setpintype = gpin_setpintype,
+};
+#endif
+
+#if NUM_OF_GPIO_OUT > 0 
+static const struct gpio_operations_s gpout_ops =
+{
+  .go_read   = gpout_read,
+  .go_write  = gpout_write,
+  .go_attach = NULL,
+  .go_enable = NULL,
+  .go_setpintype = NULL,
+};
+#endif
+
+#if NUM_OF_GPIO_INT > 0 
+static const struct gpio_operations_s gpint_ops =
+{
+  .go_read   = gpint_read,
+  .go_write  = NULL,
+  .go_attach = gpint_attach,
+  .go_enable = gpint_enable,
+  .go_setpintype = gpint_setpintype,
+};
+#endif
+
+#if NUM_OF_GPIO_IN > 0 
+static struct s32k1xx_gpio_dev_s g_gpin[NUM_OF_GPIO_IN];
+
+/* WARNING IF THIS CHANGES CHANGE gpio.h 
+ *      and the NUM_OF_GPIO_x
+ *      and the array in s32k1xx_gpio.c 
+ */
+
+/* This array maps the GPIO pins used as INPUT */
+
+static const uint32_t g_gpioinputs[NUM_OF_GPIO_IN] =
+{
+  /* GPIO_IN0, GPIO_IN1, GPIO_IN2, GPIO_IN3, GPIO_IN4 */
+};
+#endif
+
+#if NUM_OF_GPIO_OUT > 0 
+static struct s32k1xx_gpio_dev_s g_gpout[NUM_OF_GPIO_OUT];
+
+/* WARNING IF THIS CHANGES CHANGE gpio.h 
+ *      and the NUM_OF_GPIO_x
+ *      and the array in s32k1xx_gpio.c 
+ */
+
+/* This array maps the GPIO pins used as OUTPUT */
+
+static const uint32_t g_gpiooutputs[NUM_OF_GPIO_OUT] =
+{
+  GPIO_OUT0, GPIO_OUT1, GPIO_OUT2, GPIO_OUT3, GPIO_OUT4 /* , GPIO_OUT5, GPIO_OUT6, GPIO_OUT7, GPIO_OUT8, GPIO_OUT9 */
+};
+#endif
+
+#if NUM_OF_GPIO_INT > 0 
+static struct s32k1xx_gpint_dev_s g_gpint[NUM_OF_GPIO_INT];
+
+/* WARNING IF THIS CHANGES CHANGE gpio.h 
+ *      and the NUM_OF_GPIO_x
+ *      and the array in s32k1xx_gpio.c 
+ */
+
+/* This array maps the GPIO pins used as OUTPUT */
+
+static const uint32_t g_gpiointinputs[NUM_OF_GPIO_INT] =
+{
+  GPIO_INT5, GPIO_INT6, GPIO_INT7, GPIO_INT8, GPIO_INT9, GPIO_INT10, GPIO_INT11 /* ,GPIO_INT12, GPIO_INT13, */
+};
+#endif
+
+/* #if NUM_OF_GPIO_IN > 0
+ * static const uint32_t g_gpioinputs[NUM_OF_GPIO_IN] =
+ * {
+ *   GPIO_IN1,
+ * };
+ * static struct s32k1xx_gpio_dev_s g_gpin[NUM_OF_GPIO_IN];
+ * #endif
+ */ 
+
+ /* This array maps the GPIO pins used as OUTPUT */
+
+/* #if NUM_OF_GPIO_OUT > 0
+ * static const uint32_t g_gpiooutputs[NUM_OF_GPIO_OUT] =
+ * {
+ *   GPIO_OUT1, GPIO_OUT2
+ * };
+ * static struct s32k1xx_gpio_dev_s g_gpout[NUM_OF_GPIO_OUT];
+ * #endif
+ */ 
+
+ /* This array maps the GPIO pins used as interrupt pins */
+
+/* #if NUM_OF_GPIO_INT > 0
+ * static const uint32_t g_gpiointinputs[NUM_OF_GPIO_INT] =
+ * {
+ *   GPIO_INT1,
+ * };
+ * static struct s32k1xx_gpint_dev_s g_gpint[NUM_OF_GPIO_INT];
+ * #endif
+ */
+
+/****************************************************************************
+ * Private Functions
+ ****************************************************************************/
+#if NUM_OF_GPIO_INT > 0 
+static int s32k1xx_gpio_interrupt(int irq, void *context, void *arg)
+{
+  FAR struct s32k1xx_gpint_dev_s *s32k1xx_gpint =
+    (FAR struct s32k1xx_gpint_dev_s *)arg;
+
+  DEBUGASSERT(s32k1xx_gpint != NULL && s32k1xx_gpint->callback != NULL);
+  gpioinfo("Interrupt! callback=%p\n", s32k1xx_gpint->callback);
+
+  s32k1xx_gpint->callback(&s32k1xx_gpint->s32k1xx_gpio.gpio,
+                           s32k1xx_gpint->s32k1xx_gpio.id);
+  return OK;
+}
+#endif
+
+#if NUM_OF_GPIO_IN > 0 
+static int gpin_read(FAR struct gpio_dev_s *dev, FAR bool *value)
+{
+  FAR struct s32k1xx_gpio_dev_s *s32k1xx_gpio =
+    (FAR struct s32k1xx_gpio_dev_s *)dev;
+
+  DEBUGASSERT(s32k1xx_gpio != NULL && value != NULL);
+  DEBUGASSERT(s32k1xx_gpio->id < NUM_OF_GPIO_IN);
+  gpioinfo("Reading...\n");
+
+  *value = s32k1xx_gpioread(g_gpioinputs[s32k1xx_gpio->id]);
+  return OK;
+}
+
+static int gpin_setpintype(FAR struct gpio_dev_s *dev,
+                            enum gpio_pintype_e pintype)
+{
+  int ret = !OK;
+  unsigned int pinconfig;
+
+  FAR struct s32k1xx_gpio_dev_s *s32k1xx_gpio =
+    (FAR struct s32k1xx_gpio_dev_s *)dev;
+
+  DEBUGASSERT(s32k1xx_gpio != NULL);
+  DEBUGASSERT(s32k1xx_gpio->id < NUM_OF_GPIO_IN);
+  gpioinfo("Setpintype...\n");
+
+  /* Clear the pinmode */
+
+  pinconfig = (g_gpioinputs[s32k1xx_gpio->id]) & (~(_PIN_MODE_MASK));
+
+  /* Add the correct new pintype the pintype */
+
+  switch(pintype)
+  {
+    case GPIO_INPUT_PIN:
+      /* Add the new pinmode */
+
+      pinconfig |= GPIO_INPUT;
+    break;
+    case GPIO_INPUT_PIN_PULLUP:
+      /* Add the new pinmode */
+
+      pinconfig |= GPIO_PULLUP;
+    break;
+    case GPIO_INPUT_PIN_PULLDOWN:
+      /* Add the new pinmode */
+
+      pinconfig |= GPIO_PULLDOWN;
+    break;
+    case GPIO_INTERRUPT_BOTH_PIN:
+      /* Add the new pinmode */
+
+      pinconfig |= (GPIO_INPUT | PIN_INT_BOTH);
+    break;
+    default: 
+      /* Not implemented yet */
+
+      DEBUGASSERT(NULL);
+
+      /* Set the pinconfig to 0 to trigger on */
+
+      pinconfig = 0;
+
+    break;
+  }
+
+  /* Check if the pinconfig is set */
+
+  if(pinconfig != 0)
+  {
+    /* Change the pintype */
+
+    ret = s32k1xx_pinconfig(pinconfig);
+  }
+
+  /* Return */
+
+  return ret;
+}
+#endif
+
+#if NUM_OF_GPIO_OUT > 0 
+static int gpout_read(FAR struct gpio_dev_s *dev, FAR bool *value)
+{
+  FAR struct s32k1xx_gpio_dev_s *s32k1xx_gpio =
+    (FAR struct s32k1xx_gpio_dev_s *)dev;
+
+  DEBUGASSERT(s32k1xx_gpio != NULL && value != NULL);
+  DEBUGASSERT(s32k1xx_gpio->id < NUM_OF_GPIO_OUT);
+  gpioinfo("Reading...\n");
+
+  *value = s32k1xx_gpioread(g_gpiooutputs[s32k1xx_gpio->id]);
+  return OK;
+}
+
+static int gpout_write(FAR struct gpio_dev_s *dev, bool value)
+{
+  FAR struct s32k1xx_gpio_dev_s *s32k1xx_gpio =
+    (FAR struct s32k1xx_gpio_dev_s *)dev;
+
+  DEBUGASSERT(s32k1xx_gpio != NULL);
+  DEBUGASSERT(s32k1xx_gpio->id < NUM_OF_GPIO_OUT);
+  gpioinfo("Writing %d\n", (int)value);
+
+  s32k1xx_gpiowrite(g_gpiooutputs[s32k1xx_gpio->id], value);
+  return OK;
+}
+
+#endif
+
+#if NUM_OF_GPIO_INT > 0 
+static int gpint_read(FAR struct gpio_dev_s *dev, FAR bool *value)
+{
+  FAR struct s32k1xx_gpint_dev_s *s32k1xx_gpint =
+    (FAR struct s32k1xx_gpint_dev_s *)dev;
+
+  DEBUGASSERT(s32k1xx_gpint != NULL && value != NULL);
+  DEBUGASSERT(s32k1xx_gpint->s32k1xx_gpio.id < NUM_OF_GPIO_INT);
+  gpioinfo("Reading int pin...\n");
+
+  *value = s32k1xx_gpioread(g_gpiointinputs[s32k1xx_gpint->s32k1xx_gpio.id]);
+  return OK;
+}
+
+static int gpint_attach(FAR struct gpio_dev_s *dev, pin_interrupt_t callback)
+{
+  FAR struct s32k1xx_gpint_dev_s *s32k1xx_gpint =
+    (FAR struct s32k1xx_gpint_dev_s *)dev;
+
+  gpioinfo("Attaching the callback\n");
+  s32k1xx_pinirqattach(g_gpiointinputs[s32k1xx_gpint->s32k1xx_gpio.id],
+                       s32k1xx_gpio_interrupt,
+                       &g_gpint[s32k1xx_gpint->s32k1xx_gpio.id]);
+
+  gpioinfo("Attach %p\n", callback);
+  s32k1xx_gpint->callback = callback;
+  return OK;
+}
+
+static int gpint_enable(FAR struct gpio_dev_s *dev, bool enable)
+{
+  FAR struct s32k1xx_gpint_dev_s *s32k1xx_gpint =
+    (FAR struct s32k1xx_gpint_dev_s *)dev;
+
+  if (enable)
+    {
+      if (s32k1xx_gpint->callback != NULL)
+        {
+          gpioinfo("Enabling the interrupt\n");
+          s32k1xx_pinirqenable(
+            g_gpiointinputs[s32k1xx_gpint->s32k1xx_gpio.id]);
+        }
+    }
+  else
+    {
+      gpioinfo("Disable the interrupt\n");
+      s32k1xx_pinirqdisable(g_gpiointinputs[s32k1xx_gpint->s32k1xx_gpio.id]);
+    }
+
+  return OK;
+}
+
+static int gpint_setpintype(FAR struct gpio_dev_s *dev,
+                            enum gpio_pintype_e pintype)
+{
+  int ret = !OK;
+  unsigned int pinconfig;
+
+  FAR struct s32k1xx_gpint_dev_s *s32k1xx_gpint =
+    (FAR struct s32k1xx_gpint_dev_s *)dev;
+
+  DEBUGASSERT(s32k1xx_gpint != NULL);
+  DEBUGASSERT(s32k1xx_gpint->s32k1xx_gpio.id < NUM_OF_GPIO_INT);
+  gpioinfo("Setpintype intpin...\n");
+
+  /* Clear the pinmode */
+
+  pinconfig = (g_gpiointinputs[s32k1xx_gpint->s32k1xx_gpio.id]) & (~(_PIN_MODE_MASK));
+
+  /* Add the correct new pintype the pintype */
+
+  switch(pintype)
+  {
+    case GPIO_INPUT_PIN:
+      /* Add the new pinmode */
+
+      pinconfig |= GPIO_INPUT;
+    break;
+    case GPIO_INPUT_PIN_PULLUP:
+      /* Add the new pinmode */
+
+      pinconfig |= GPIO_PULLUP;
+    break;
+    case GPIO_INPUT_PIN_PULLDOWN:
+      /* Add the new pinmode */
+
+      pinconfig |= GPIO_PULLDOWN;
+    break;
+    case GPIO_INTERRUPT_BOTH_PIN:
+      /* Add the new pinmode */
+
+      pinconfig |= (GPIO_INPUT | PIN_INT_BOTH);
+    break;
+    default: 
+      /* Not implemented yet */
+
+      DEBUGASSERT(NULL);
+
+      /* Set the pinconfig to 0 to trigger on */
+
+      pinconfig = 0;
+
+    break;
+  }
+
+  /* Check if the pinconfig is set */
+
+  if(pinconfig != 0)
+  {
+    /* Change the pintype */
+
+    ret = s32k1xx_pinconfig(pinconfig);
+  }
+
+  /* Return */
+
+  return ret;
+}
+#endif
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: s32k1xx_gpio_initialize
+ *
+ * Description:
+ *   Initialize GPIO drivers for use with /apps/examples/gpio
+ *
+ ****************************************************************************/
+
+int s32k1xx_gpio_initialize(void)
+{
+  int i;
+  int pincount = 0;
+
+#if NUM_OF_GPIO_IN > 0
+  for (i = 0; i < NUM_OF_GPIO_IN; i++)
+    {
+      /* Setup and register the GPIO pin */
+
+      g_gpin[i].gpio.gp_pintype = GPIO_INPUT_PIN;
+      g_gpin[i].gpio.gp_ops     = &gpin_ops;
+      g_gpin[i].id              = i;
+
+      gpio_pin_register(&g_gpin[i].gpio, pincount);
+
+      /* Configure the pin that will be used as input */
+
+      s32k1xx_pinconfig(g_gpioinputs[i]);
+
+      pincount++;
+    }
+#endif
+
+#if NUM_OF_GPIO_OUT > 0
+  for (i = 0; i < NUM_OF_GPIO_OUT; i++)
+    {
+      /* Setup and register the GPIO pin */
+
+      g_gpout[i].gpio.gp_pintype = GPIO_OUTPUT_PIN;
+      g_gpout[i].gpio.gp_ops     = &gpout_ops;
+      g_gpout[i].id              = i;
+
+      gpio_pin_register(&g_gpout[i].gpio, pincount);
+
+      /* Configure the pin that will be used as output */
+
+      s32k1xx_gpiowrite(g_gpiooutputs[i], 0);
+      s32k1xx_pinconfig(g_gpiooutputs[i]);
+
+      pincount++;
+    }
+#endif
+
+#if NUM_OF_GPIO_INT > 0
+  for (i = 0; i < NUM_OF_GPIO_INT; i++)
+    {
+      /* Setup and register the GPIO pin */
+
+      g_gpint[i].s32k1xx_gpio.gpio.gp_pintype = GPIO_INTERRUPT_PIN;
+      g_gpint[i].s32k1xx_gpio.gpio.gp_ops     = &gpint_ops;
+      g_gpint[i].s32k1xx_gpio.id              = i;
+
+      gpio_pin_register(&g_gpint[i].s32k1xx_gpio.gpio, pincount);
+
+      /* Configure the pin that will be used as interrupt input */
+
+      s32k1xx_pinconfig(g_gpiointinputs[i]);
+
+      pincount++;
+    }
+#endif
+
+  return 0;
+}
+#endif /* CONFIG_DEV_GPIO && !CONFIG_GPIO_LOWER_HALF */
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_nrstcheck.c b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_nrstcheck.c
new file mode 100644
index 0000000000..8af14ee397
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_nrstcheck.c
@@ -0,0 +1,390 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_nrstcheck.c
+ *
+ *   Copyright (C) 2019 Gregory Nutt. All rights reserved.
+ *   Author: Gregory Nutt <gnutt@nuttx.org>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+#include <nuttx/arch.h>
+#include <nuttx/board.h>
+#include <nuttx/fs/procfs.h>
+#include <nuttx/fs/dirent.h>
+#include <nuttx/kmalloc.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <stdint.h>
+#include <assert.h>
+#include <errno.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>
+#include <debug.h>
+#include <sys/mount.h>
+#include <syslog.h>
+
+#include "rddrone-bms772.h"
+#include "s32k1xx_pin.h"
+
+#include "arm_arch.h"
+
+/****************************************************************************
+ * Pre-processor Definitions
+ ****************************************************************************/
+
+/* Determines the size of an intermediate buffer that must be large enough
+ * to handle the longest line generated by this logic.
+ */
+#define NRSTCHECK_LINELEN 2
+
+/****************************************************************************
+ * Private Types
+ ****************************************************************************/
+
+/* This structure describes one open "file" */
+
+struct nrstcheck_file_s
+{
+  struct procfs_file_s  base;        /* Base open file structure */
+  unsigned int linesize;             /* Number of valid characters in line[] */
+  char line[NRSTCHECK_LINELEN];      /* Pre-allocated buffer for formatted lines */
+  bool nrstcheck;                    /* Variable representing value if the NRST line is OK */
+};
+
+static bool g_nrst_check = false;
+
+#if defined(CONFIG_NRST_CHECK_PROC_FS) && defined(CONFIG_FS_PROCFS)
+
+/****************************************************************************
+ * Private Function Prototypes
+ ****************************************************************************/
+
+/* File system methods */
+
+static int     nrstcheck_open(FAR struct file *filep,
+                FAR const char *relpath, int oflags, mode_t mode);
+static int     nrstcheck_close(FAR struct file *filep);
+static ssize_t nrstcheck_read(FAR struct file *filep, FAR char *buffer,
+                 size_t buflen);
+
+static int     nrstcheck_dup(FAR const struct file *oldp,
+                 FAR struct file *newp);
+
+static int     nrstcheck_stat(FAR const char *relpath, FAR struct stat *buf);
+
+/****************************************************************************
+ * Public Data
+ ****************************************************************************/
+
+const struct procfs_operations nrstcheck_operations =
+{
+  nrstcheck_open,   /* open */
+  nrstcheck_close,  /* close */
+  nrstcheck_read,   /* read */
+  NULL,             /* write */
+
+  nrstcheck_dup,    /* dup */
+
+  NULL,             /* opendir */
+  NULL,             /* closedir */
+  NULL,             /* readdir */
+  NULL,             /* rewinddir */
+
+  nrstcheck_stat    /* stat */
+};
+
+static const struct procfs_entry_s g_nrstcheck_procfs =
+{
+  "nrstcheck", &nrstcheck_operations
+};
+
+/****************************************************************************
+ * Private Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: nrstcheck_open
+ ****************************************************************************/
+
+static int nrstcheck_open(FAR struct file *filep, FAR const char *relpath,
+                      int oflags, mode_t mode)
+{
+  FAR struct nrstcheck_file_s *attr;
+
+  finfo("Open '%s'\n", relpath);
+
+  /* PROCFS is read-only.  Any attempt to open with any kind of write
+   * access is not permitted.
+   *
+   * REVISIT:  Write-able proc files could be quite useful.
+   */
+
+  if ((oflags & O_WRONLY) != 0 || (oflags & O_RDONLY) == 0)
+    {
+      ferr("ERROR: Only O_RDONLY supported\n");
+      return -EACCES;
+    }
+
+  /* "nrstcheck" is the only acceptable value for the relpath */
+
+  if (strcmp(relpath, "nrstcheck") != 0)
+    {
+      ferr("ERROR: relpath is '%s'\n", relpath);
+      return -ENOENT;
+    }
+
+  /* Allocate a container to hold the file attributes */
+
+  attr = kmm_zalloc(sizeof(struct nrstcheck_file_s));
+  if (!attr)
+    {
+      ferr("ERROR: Failed to allocate file attributes\n");
+      return -ENOMEM;
+    }
+
+  /* Save the attributes as the open-specific state in filep->f_priv */
+
+  filep->f_priv = (FAR void *)attr;
+  return OK;
+}
+
+/****************************************************************************
+ * Name: nrstcheck_close
+ ****************************************************************************/
+
+static int nrstcheck_close(FAR struct file *filep)
+{
+  FAR struct nrstcheck_file_s *attr;
+
+  /* Recover our private data from the struct file instance */
+
+  attr = (FAR struct nrstcheck_file_s *)filep->f_priv;
+  DEBUGASSERT(attr);
+
+  /* Release the file attributes structure */
+
+  kmm_free(attr);
+  filep->f_priv = NULL;
+  return OK;
+}
+
+/****************************************************************************
+ * Name: nrstcheck_read
+ ****************************************************************************/
+
+static ssize_t nrstcheck_read(FAR struct file *filep, FAR char *buffer,
+                           size_t buflen)
+{
+  FAR struct nrstcheck_file_s *attr;
+  size_t linesize;
+  ssize_t ret;
+
+  finfo("buffer=%p buflen=%d\n", buffer, (int)buflen);
+
+  /* Recover our private data from the struct file instance */
+
+  attr = (FAR struct nrstcheck_file_s *)filep->f_priv;
+  DEBUGASSERT(attr);
+
+  /* Get the nrstcheck value and store it */
+
+  attr->nrstcheck = g_nrst_check;
+
+  /* Convert the nrstcheck to a string */
+
+  linesize  = snprintf(attr->line, NRSTCHECK_LINELEN, "%d", attr->nrstcheck);
+
+  /* Save the linesize in case we are re-entered with f_pos > 0 */
+
+  attr->linesize = linesize;
+
+  /* Transfer the system reset cause to user receive buffer */
+
+  ret = procfs_memcpy(attr->line, attr->linesize, buffer, buflen,
+    &filep->f_pos);
+
+  return ret;
+}
+
+/****************************************************************************
+ * Name: nrstcheck_dup
+ *
+ * Description:
+ *   Duplicate open file data in the new file structure.
+ *
+ ****************************************************************************/
+
+static int nrstcheck_dup(FAR const struct file *oldp, FAR struct file *newp)
+{
+  FAR struct nrstcheck_file_s *oldattr;
+  FAR struct nrstcheck_file_s *newattr;
+
+  finfo("Dup %p->%p\n", oldp, newp);
+
+  /* Recover our private data from the old struct file instance */
+
+  oldattr = (FAR struct nrstcheck_file_s *)oldp->f_priv;
+  DEBUGASSERT(oldattr);
+
+  /* Allocate a new container to hold the task and attribute selection */
+
+  newattr = kmm_malloc(sizeof(struct nrstcheck_file_s));
+  if (!newattr)
+    {
+      ferr("ERROR: Failed to allocate file attributes\n");
+      return -ENOMEM;
+    }
+
+  /* The copy the file attributes from the old attributes to the new */
+
+  memcpy(newattr, oldattr, sizeof(struct nrstcheck_file_s));
+
+  /* Save the new attributes in the new file structure */
+
+  newp->f_priv = (FAR void *)newattr;
+  return OK;
+}
+
+/****************************************************************************
+ * Name: nrstcheck_stat
+ *
+ * Description: Return information about a file or directory
+ *
+ ****************************************************************************/
+
+static int nrstcheck_stat(FAR const char *relpath, FAR struct stat *buf)
+{
+  /* "nrstcheck" is the only acceptable value for the relpath */
+
+  if (strcmp(relpath, "nrstcheck") != 0)
+    {
+      ferr("ERROR: relpath is '%s'\n", relpath);
+      return -ENOENT;
+    }
+
+  /* "nrstcheck" is the name for a read-only file */
+
+  memset(buf, 0, sizeof(struct stat));
+  buf->st_mode = S_IFREG | S_IROTH | S_IRGRP | S_IRUSR;
+  return OK;
+}
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: s32k1xx_nrstcheck
+ *
+ * Description:
+ *   It will make the NRST pin a pull-down GPIO input pin and check the state
+ *   This will be saved in a block device and the pin is configured as NRST.
+ *
+ ****************************************************************************/
+
+int s32k1xx_nrstcheck(void)
+{
+  int ret = OK;
+
+  /* Configure the NRST pin as GPIO input with pull down */
+
+  ret |= s32k1xx_pinconfig(PIN_PTA5 | GPIO_PULLDOWN);
+
+  /* Check if it went OK */
+
+  if (ret == OK)
+    {
+      /* Check the value of the pin */
+
+      g_nrst_check = s32k1xx_gpioread(PIN_PTA5 | GPIO_PULLDOWN);
+
+      /* Make a nrstcheck blockdevice */
+
+      ret |= procfs_register(&g_nrstcheck_procfs);
+
+      /* Check if it went not OK */
+
+      if (ret != OK)
+        {
+          /* Error output */
+
+          ferr("ERROR: register of procfs went wrong: %d\n", ret);
+        }
+    }
+
+  /* if it went not OK */
+
+  else
+    {
+      /* Error output */
+
+      ferr("ERROR: setting NRST as GPIO input went wrong: %d\n", ret);
+    }
+
+  /* Configure the NRST pin as GPIO input with pull up
+   * (in order to not trigger the reset)
+   */
+
+  ret |= s32k1xx_pinconfig(PIN_PTA5 | GPIO_PULLUP);
+
+  /* Check if it went not OK */
+
+  if (ret != OK)
+    {
+      /* Error output */
+
+      ferr("ERROR: setting NRST as GPIO input with pull-up went wrong: %d\n",
+        ret);
+    }
+
+  /* Configure the NRST pin as NRST pin */
+
+  ret |= s32k1xx_pinconfig(PIN_RESET);
+
+  /* Check if it went not OK */
+
+  if (ret != OK)
+    {
+      /* Error output */
+
+      ferr("ERROR: setting NRST as NRST pin went wrong: %d\n", ret);
+    }
+
+  return ret;
+}
+
+#endif /* CONFIG_NRST_CHECK_PROC_FS && CONFIG_FS_PROCFS */
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_periphclocks.c b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_periphclocks.c
new file mode 100644
index 0000000000..63e6c5737e
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_periphclocks.c
@@ -0,0 +1,159 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_periphclks.c
+ *
+ *   Copyright (C) 2019 Gregory Nutt. All rights reserved.
+ *   Author: Gregory Nutt <gnutt@nuttx.org>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *  notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *  notice, this list of conditions and the following disclaimer in
+ *  the documentation and/or other materials provided with the
+ *  distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *  used to endorse or promote products derived from this software
+ *  without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Most of the settings within this file derives from NXP sample code for
+ * the S32K1XX MCUs.  That sample code has this licensing information:
+ *
+ *   Copyright (c) 2013 - 2015, Freescale Semiconductor, Inc.
+ *   Copyright 2016-2018 NXP
+ *   All rights reserved.
+ *
+ * THIS SOFTWARE IS PROVIDED BY NXP "AS IS" AND ANY EXPRESSED OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL NXP OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include "s32k1xx_periphclocks.h"
+#include "rddrone-bms772.h"
+
+/****************************************************************************
+ * Public Data
+ ****************************************************************************/
+
+/* Each S32K1XX board must provide the following initialized structure.
+ * This is needed to establish the initial peripheral clocking.
+ */
+
+const struct peripheral_clock_config_s g_peripheral_clockconfig0[] =
+{
+  {
+    .clkname = FLEXCAN0_CLK,
+#ifdef CONFIG_S32K1XX_FLEXCAN0
+    .clkgate = true,
+#else
+    .clkgate = false,
+#endif
+  },
+  {
+    .clkname = LPI2C0_CLK,
+#ifdef CONFIG_S32K1XX_LPI2C0
+    .clkgate = true,
+#else
+    .clkgate = false,
+#endif
+    .clksrc  = CLK_SRC_SPLL_DIV2,
+  },
+  {
+    .clkname = LPSPI0_CLK,
+#ifdef CONFIG_S32K1XX_LPSPI0
+    .clkgate = true,
+#else
+    .clkgate = false,
+#endif
+    .clksrc  = CLK_SRC_SPLL_DIV2,
+  },
+  {
+    .clkname = LPSPI1_CLK,
+#ifdef CONFIG_S32K1XX_LPSPI1
+    .clkgate = true,
+#else
+    .clkgate = false,
+#endif
+    .clksrc  = CLK_SRC_SPLL_DIV2,
+  },
+  {
+    .clkname = LPUART0_CLK,
+#ifdef CONFIG_S32K1XX_LPUART0
+    .clkgate = true,
+#else
+    .clkgate = false,
+#endif
+    .clksrc  = CLK_SRC_SPLL_DIV2,
+  },
+  {
+    .clkname = LPUART1_CLK,
+#ifdef CONFIG_S32K1XX_LPUART1
+    .clkgate = true,
+#else
+    .clkgate = false,
+#endif
+    .clksrc  = CLK_SRC_SPLL_DIV2,
+  },
+  {
+    .clkname = PORTA_CLK,
+    .clkgate = true,
+  },
+  {
+    .clkname = PORTB_CLK,
+    .clkgate = true,
+  },
+  {
+    .clkname = PORTC_CLK,
+    .clkgate = true,
+  },
+  {
+    .clkname = PORTD_CLK,
+    .clkgate = true,
+  },
+  {
+    .clkname = PORTE_CLK,
+    .clkgate = true,
+  },
+  {
+    .clkname = RTC0_CLK,
+#ifdef CONFIG_S32K1XX_RTC
+    .clkgate = true,
+#else
+    .clkgate = false,
+#endif
+  },
+};
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_reset.c b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_reset.c
new file mode 100644
index 0000000000..85bf55147b
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_reset.c
@@ -0,0 +1,77 @@
+/****************************************************************************
+ * boards/arm/kinetis/freedom-k66f/src/k66_reset.c
+ *
+ *   Copyright (C) 2019 Gregory Nutt. All rights reserved.
+ *   Author: Gregory Nutt <gnutt@nuttx.org>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include <nuttx/arch.h>
+#include <nuttx/board.h>
+
+#ifdef CONFIG_BOARDCTL_RESET
+
+/****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: board_reset
+ *
+ * Description:
+ *   Reset board.  Support for this function is required by board-level
+ *   logic if CONFIG_BOARDCTL_RESET is selected.
+ *
+ * Input Parameters:
+ *   status - Status information provided with the reset event.  This
+ *            meaning of this status information is board-specific.  If not
+ *            used by a board, the value zero may be provided in calls to
+ *            board_reset().
+ *
+ * Returned Value:
+ *   If this function returns, then it was not possible to power-off the
+ *   board due to some constraints.  The return value int this case is a
+ *   board-specific reason for the failure to shutdown.
+ *
+ ****************************************************************************/
+
+int board_reset(int status)
+{
+  up_systemreset();
+  return 0;
+}
+
+#endif /* CONFIG_BOARDCTL_RESET */
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_smartbattery.c b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_smartbattery.c
new file mode 100644
index 0000000000..a0c81cdd06
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_smartbattery.c
@@ -0,0 +1,229 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_smartbattery.c
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.  The
+ * ASF licenses this file to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ *
+ ****************************************************************************/
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include <stdint.h>
+#include <stdio.h>
+#include <errno.h>
+#include <fcntl.h>
+
+#include <nuttx/i2c/i2c_slave.h>
+
+#include "s32k1xx_lpi2c_slave.h"
+
+#include "../../drivers/smart_battery/simple_sbs.h"
+
+#if defined(CONFIG_S32K1XX_LPI2C) && defined(CONFIG_I2C_SLAVE) && defined(CONFIG_SBS_DRIVER)
+
+/****************************************************************************
+ * Private Function Prototypes
+ ****************************************************************************/
+
+int s32k1xx_smartbattery_update_example(void);
+
+/****************************************************************************
+ * Private Data
+ ****************************************************************************/
+
+/* Example of a smart battery data structure that can be written to the SBS
+ * driver.  This same data can then be requested from the SBS I2C slave.
+ */
+
+static const char manufacture_name[] = "NXP";
+static const char device_name[]      = "BMS772";
+static const char device_chemistry[] = "LiP";
+
+static const uint8_t manufacturer_data[] =
+{
+  0x0a,
+  0x0b,
+  0x0c,
+  0x0d,
+  0x0e,
+  0x0f,
+};
+
+static struct sbs_data_s sbs_data =
+{
+  .temperature              = 2932,  /* 0.1  K */
+  .voltage                  = 16000, /* 1.0 mV */
+  .current                  = 10000, /* 1.0 mA */
+  .average_current          = 5000,  /* 1.0 mA */
+  .max_error                = 10,    /* 1.0  % */
+  .relative_state_of_charge = 50,    /* 1.0  % */
+  .absolute_state_of_charge = 60,    /* 1.0  % */
+  .remaining_capacity       = 2000,  /* 1.0 mAh (or 10 mWh?) */
+  .full_charge_capacity     = 4200,  /* 1.0 mAh (or 10 mWh?) */
+  .run_time_to_empty        = 10,    /* 1.0  min */
+  .average_time_to_empty    = 12,    /* 1.0  min */
+
+  .cycle_count              = 20,    /* 1.0  cycle */
+  .design_capacity          = 4200,  /* 1.0 mAh (or 10 mWh?) */
+  .design_voltage           = 16800, /* 1.0 mV */
+
+  .manufacture_date         = ((1996 - 1980) * 512 + 12 * 32 + 24), /* (year - 1980) * 512 + month * 32 + day */
+  .serial_number            = 777,
+  .manufacturer_name        = manufacture_name,
+  .device_name              = device_name,
+  .device_chemistry         = device_chemistry,
+  .manufacturer_data        = manufacturer_data,
+  .manufacturer_data_length = 6,
+
+  .cell1_voltage            = 4000,  /* 1.0 mV */
+  .cell2_voltage            = 4000,  /* 1.0 mV */
+  .cell3_voltage            = 4000,  /* 1.0 mV */
+  .cell4_voltage            = 4000,  /* 1.0 mV */
+  .cell5_voltage            = 0,     /* 1.0 mV */
+  .cell6_voltage            = 0,     /* 1.0 mV */
+};
+
+/****************************************************************************
+ * Private Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: s32k1xx_smartbattery_update_example
+ *
+ * Description:
+ *   Updates the battery data that is known by the Simple SBS driver, which
+ *   provides the appropriate data to the I2C Slave when requested.
+ *
+ *   This is an example that shows how to open the SBS device and write a
+ *   struct containing the latest battery data.  In a continuously running
+ *   application the file can be kept open, while data is being written to it
+ *   at regular intervals.  This can be handled by a loop or a separate task.
+ *
+ * Returned Value:
+ *   0 if the SBS data was successfully updated; -1 on any failure.
+ *
+ ****************************************************************************/
+
+int s32k1xx_smartbattery_update_example(void)
+{
+  int fd;
+  int ret;
+
+  /* Open the Simple SBS driver that we registered at /dev/sbs0.  This only
+   * needs to be done once, there is no need to close the file after every
+   * write operation.  You can keep it open indefinitely.
+   */
+
+  fd = open("/dev/sbs0", O_WRONLY);
+  if (fd == ERROR)
+    {
+      /* Something went wrong.  You could try to handle the error here, pass
+       * it on to the calling function, or just ignore it.
+       */
+
+      return -1;
+    }
+
+  /* Write a prepared sbs_data_s struct to the SBS driver.  It needs to be
+   * converted to a constant character buffer and the buffer length has to be
+   * equal to the size of the sbs_dat_s struct.
+   *
+   * Note that this write operation can be performed as often as you like.
+   * The SBS driver will always provide the most recent data that it received
+   * when it receives a request for battery data.
+   */
+
+  ret = write(fd, (const char *)&sbs_data, sizeof(struct sbs_data_s));
+  if (ret != sizeof(struct sbs_data_s))
+    {
+      /* Something went wrong.  You could try to handle the error here, pass
+       * it on to the calling function, or just ignore it.
+       */
+
+      return -1;
+    }
+
+  /* Close the driver.  You only need to do this before a thread or the whole
+   * application exits, so in practice you can keep it open indefinitely.
+   */
+
+  ret = close(fd);
+  if (ret < 0)
+    {
+      /* Something went wrong.  You could try to handle the error here, pass
+       * it on to the calling function, or just ignore it.
+       */
+
+      return -1;
+    }
+
+  return 0;
+}
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: s32k1xx_smartbattery_initialize
+ *
+ * Description:
+ *   Initialize the I2C Slave and Simple SBS drivers.  After this is done the
+ *   user can provide battery data to the SBS driver, which will then be
+ *   available if requested by a I2C/SMBus bus master.
+ *
+ * Returned Value:
+ *   OK if the SBS driver was successfully initialized; A negated errno value
+ *   is returned on any failure.
+ *
+ ****************************************************************************/
+
+int s32k1xx_smartbattery_initialize(void)
+{
+  FAR struct i2c_slave_s *i2c_slave;
+  int ret;
+
+  /* Initialize I2C slave device */
+
+  i2c_slave = s32k1xx_i2cbus_slave_initialize(0);
+  if (i2c_slave == NULL)
+    {
+      return -ENODEV;
+    }
+
+  /* Initialize a new "Simple SBS" device as /dev/sbs0 */
+
+  ret = sbs_initialize(0, i2c_slave);
+  if (ret < 0)
+    {
+      return ret;
+    }
+
+  /* Initialization is done.  You only need to initialize once and there is
+   * currently no method to uninitialize the SBS device (and you should not
+   * need it).  You can now open the /dev/sbs0 device and write data to it.
+   * The function called below provides an example on how this can be done.
+   */
+
+  s32k1xx_smartbattery_update_example();
+
+  return OK;
+}
+
+#endif /* CONFIG_S32K1XX_LPI2C && CONFIG_I2C_SLAVE && CONFIG_SBS_DRIVER */
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_spi.c b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_spi.c
new file mode 100644
index 0000000000..cb3c0848e6
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_spi.c
@@ -0,0 +1,168 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_spi.c
+ *
+ *   Copyright (C) 2018 Gregory Nutt. All rights reserved.
+ *   Author: Ivan Ucherdzhiev <ivanucherdjiev@gmail.com>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include <stdint.h>
+#include <stdbool.h>
+#include <errno.h>
+#include <debug.h>
+
+#include <nuttx/spi/spi.h>
+#include <nuttx/spi/spi_transfer.h>
+#include <arch/board/board.h>
+
+#include "arm_arch.h"
+
+#include "s32k1xx_config.h"
+#include "s32k1xx_lpspi.h"
+#include "s32k1xx_pin.h"
+#include "rddrone-bms772.h"
+
+#if defined(CONFIG_S32K1XX_LPSPI0) || defined(CONFIG_S32K1XX_LPSPI1)
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: s32k1xx_spidev_initialize
+ *
+ * Description:
+ *   Called to configure SPI chip select GPIO pins for the RDDRONE-BMS772
+ *   board.
+ *
+ ****************************************************************************/
+
+void weak_function s32k1xx_spidev_initialize(void)
+{
+#ifdef CONFIG_S32K1XX_LPSPI0
+  s32k1xx_pinconfig(PIN_LPSPI0_PCS);
+
+#ifdef CONFIG_SPI_DRIVER
+  struct spi_dev_s *g_lpspi0;
+  g_lpspi0 = s32k1xx_lpspibus_initialize(0);
+
+  if (!g_lpspi0)
+    {
+      spierr("ERROR: [boot] FAILED to initialize LPSPI0\n");
+    }
+
+  spi_register(g_lpspi0, 0);
+#endif
+#endif
+
+#ifdef CONFIG_S32K1XX_LPSPI1
+  s32k1xx_pinconfig(PIN_LPSPI1_PCS);
+
+#ifdef CONFIG_SPI_DRIVER
+  struct spi_dev_s *g_lpspi1;
+  g_lpspi1 = s32k1xx_lpspibus_initialize(1);
+
+  if (!g_lpspi1)
+    {
+      spierr("ERROR: [boot] FAILED to initialize LPSPI1\n");
+    }
+
+  spi_register(g_lpspi1, 1);
+#endif
+#endif
+}
+
+/****************************************************************************
+ * Name:  s32k1xx_lpspi0/1select and s32k1xx_lpspi0/1status
+ *
+ * Description:
+ *   The external functions, s32k1xx_lpspi0/1select and
+ *   s32k1xx_lpspi0/1status must be provided by board-specific logic.
+ *   They are implementations of the select and status methods of the SPI
+ *   interface defined by struct spi_ops_s (see include/nuttx/spi/spi.h).
+ *   All other methods (including s32k1xx_lpspibus_initialize()) are provided
+ *   by common logic.  To use this common SPI logic on your board:
+ *
+ *   1. Provide logic in s32k1xx_boardinitialize() to configure SPI chip
+ *      select pins.
+ *   2. Provide s32k1xx_lpspi0/1select() and s32k1xx_lpspi0/1status()
+ *      functions in your board-specific logic.  These functions will perform
+ *      chip selection and status operations using GPIOs in the way your
+ *      board is configured.
+ *   3. Add a calls to s32k1xx_lpspibus_initialize() in your low level
+ *      application initialization logic
+ *   4. The handle returned by s32k1xx_lpspibus_initialize() may then be used
+ *      to bind the SPI driver to higher level logic (e.g., calling
+ *      mmcsd_spislotinitialize(), for example, will bind the SPI driver to
+ *      the SPI MMC/SD driver).
+ *
+ ****************************************************************************/
+
+#ifdef CONFIG_S32K1XX_LPSPI0
+void s32k1xx_lpspi0select(FAR struct spi_dev_s *dev, uint32_t devid,
+                        bool selected)
+{
+  spiinfo("devid: %d CS: %s\n", (int)devid,
+          selected ? "assert" : "de-assert");
+
+  // don't use gpiowrite since it is not configured as a GPIO but hardware CS is used
+  // s32k1xx_gpiowrite(PIN_LPSPI0_PCS, !selected);
+}
+
+uint8_t s32k1xx_lpspi0status(FAR struct spi_dev_s *dev, uint32_t devid)
+{
+  return 0;
+}
+#endif
+
+#ifdef CONFIG_S32K1XX_LPSPI1
+void s32k1xx_lpspi1select(FAR struct spi_dev_s *dev,
+                        uint32_t devid, bool selected)
+{
+  spiinfo("devid: %d CS: %s\n", (int)devid,
+          selected ? "assert" : "de-assert");
+
+  // don't use gpiowrite since it is not configured as a GPIO but hardware CS is used
+  // s32k1xx_gpiowrite(PIN_LPSPI1_PCS, !selected);
+}
+
+uint8_t s32k1xx_lpspi1status(FAR struct spi_dev_s *dev, uint32_t devid)
+{
+  return 0;
+}
+#endif
+
+#endif /* CONFIG_S32K1XX_LPSPI0 || CONFIG_S32K1XX_LPSPI01 */
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_userleds.c b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_userleds.c
new file mode 100644
index 0000000000..92607ccae9
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_userleds.c
@@ -0,0 +1,138 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_userleds.c
+ *
+ *   Copyright (C) 2019 Gregory Nutt. All rights reserved.
+ *   Author: Gregory Nutt <gnutt@nuttx.org>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include <stdint.h>
+#include <stdbool.h>
+#include <debug.h>
+
+#include <nuttx/board.h>
+
+#include "arm_arch.h"
+#include "arm_internal.h"
+
+#include "s32k1xx_pin.h"
+#include "rddrone-bms772.h"
+
+#include <arch/board/board.h>
+
+#ifndef CONFIG_ARCH_LEDS
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: board_userled_initialize
+ ****************************************************************************/
+
+uint32_t board_userled_initialize(void)
+{
+  /* Configure LED GPIOs for output */
+
+  s32k1xx_pinconfig(GPIO_LED_R);
+  s32k1xx_pinconfig(GPIO_LED_G);
+  s32k1xx_pinconfig(GPIO_LED_B);
+  return BOARD_NLEDS;
+}
+
+/****************************************************************************
+ * Name: board_userled
+ ****************************************************************************/
+
+void board_userled(int led, bool ledon)
+{
+  uint32_t ledcfg;
+
+  if (led == BOARD_LED_R)
+    {
+      ledcfg = GPIO_LED_R;
+    }
+  else if (led == BOARD_LED_G)
+    {
+      ledcfg = GPIO_LED_G;
+    }
+  else if (led == BOARD_LED_B)
+    {
+      ledcfg = GPIO_LED_B;
+    }
+  else
+    {
+      return;
+    }
+
+  s32k1xx_gpiowrite(ledcfg, !ledon); /* High illuminates */
+}
+
+/****************************************************************************
+ * Name: board_userled_all
+ ****************************************************************************/
+
+void board_userled_all(uint32_t ledset)
+{
+  /* Low illuminates */
+
+  s32k1xx_gpiowrite(GPIO_LED_R, (ledset & BOARD_LED_R_BIT) == 0);
+  s32k1xx_gpiowrite(GPIO_LED_G, (ledset & BOARD_LED_G_BIT) == 0);
+  s32k1xx_gpiowrite(GPIO_LED_B, (ledset & BOARD_LED_B_BIT) == 0);
+}
+
+/****************************************************************************
+ * Name: board_userled_checkall
+ ****************************************************************************/
+
+void board_userled_checkall(uint32_t *ledset)
+{
+  // check if not pointer
+  if(ledset)
+  {
+    /* Low illuminates */
+
+    // clear the LED bits
+    *ledset &= ~(BOARD_LED_R_BIT + BOARD_LED_G_BIT + BOARD_LED_B_BIT);
+
+    // set the bit led bit to 1 if the LED is on
+    *ledset |= (((!s32k1xx_gpioread(GPIO_LED_R)) & 1) << BOARD_LED_R);// & BOARD_LED_R_BIT;
+    *ledset |= (((!s32k1xx_gpioread(GPIO_LED_G)) & 1) << BOARD_LED_G);// & BOARD_LED_G_BIT;
+    *ledset |= (((!s32k1xx_gpioread(GPIO_LED_B)) & 1) << BOARD_LED_B);// & BOARD_LED_B_BIT;
+  }
+}
+
+#endif /* !CONFIG_ARCH_LEDS */
diff --git a/boards/boardctl.c b/boards/boardctl.c
index 6b949d7ce6..538d29d2cf 100644
--- a/boards/boardctl.c
+++ b/boards/boardctl.c
@@ -258,6 +258,14 @@ static inline int boardctl_pmctrl(FAR struct boardioc_pm_ctrl_s *ctrl)
         ctrl->state = pm_querystate(ctrl->domain);
         break;
 
+      case BOARDIOC_PM_CHANGESTATE:
+        ret = pm_changestate(ctrl->domain, ctrl->state);
+        break;
+
+      case BOARDIOC_PM_CHECKSTATE:
+        ctrl->state = pm_checkstate(ctrl->domain);
+        break;
+
       default:
         ret = -EINVAL;
     }
diff --git a/include/sys/boardctl.h b/include/sys/boardctl.h
index b388e3d2ad..6c5761ba01 100644
--- a/include/sys/boardctl.h
+++ b/include/sys/boardctl.h
@@ -240,7 +240,9 @@ enum boardioc_action_e
   BOARDIOC_PM_STAY,
   BOARDIOC_PM_RELAX,
   BOARDIOC_PM_STAYCOUNT,
-  BOARDIOC_PM_QUERYSTATE
+  BOARDIOC_PM_QUERYSTATE,
+  BOARDIOC_PM_CHANGESTATE,
+  BOARDIOC_PM_CHECKSTATE
 };
 
 struct boardioc_pm_ctrl_s
diff --git a/net/can/can_callback.c b/net/can/can_callback.c
index f8f0fae1d2..4a623e9fe4 100644
--- a/net/can/can_callback.c
+++ b/net/can/can_callback.c
@@ -137,7 +137,7 @@ uint16_t can_callback(FAR struct net_driver_s *dev,
 
       /* Try to lock the network when successfull send data to the listener */
 
-      if (net_trylock() == OK)
+      if (up_interrupt_context() == false && net_trylock() == OK)
         {
           flags = devif_conn_event(dev, conn, flags, conn->list);
           net_unlock();
@@ -234,7 +234,9 @@ uint16_t can_datahandler(FAR struct can_conn_s *conn, FAR uint8_t *buffer,
    * available.
    */
 
-  can_readahead_signal(conn);
+  if(up_interrupt_context() == false) {
+      can_readahead_signal(conn);
+  }
 #endif
   return buflen;
 }
diff --git a/net/can/can_setsockopt.c b/net/can/can_setsockopt.c
index b5c4576e87..3cc82a154b 100644
--- a/net/can/can_setsockopt.c
+++ b/net/can/can_setsockopt.c
@@ -76,7 +76,7 @@ int can_setsockopt(FAR struct socket *psock, int option,
   int ret = OK;
   int count = 0;
 
-  DEBUGASSERT(psock != NULL && value != NULL && psock->s_conn != NULL);
+  DEBUGASSERT(psock != NULL && (value_len == 0 || value != NULL) && psock->s_conn != NULL);
   conn = (FAR struct can_conn_s *)psock->s_conn;
 
   if (psock->s_type != SOCK_RAW)
diff --git a/net/devif/devif_poll.c b/net/devif/devif_poll.c
index ffffed463e..079ff85d39 100644
--- a/net/devif/devif_poll.c
+++ b/net/devif/devif_poll.c
@@ -260,11 +260,14 @@ static int devif_poll_can_connections(FAR struct net_driver_s *dev,
     {
       /* Perform the packet TX poll */
 
-      can_poll(dev, can_conn);
+      if(dev == can_conn->dev)
+        {
+          can_poll(dev, can_conn);
 
-      /* Call back into the driver */
+          /* Call back into the driver */
 
-      bstop = callback(dev);
+          bstop = callback(dev);
+        }
     }
 
   return bstop;
diff --git a/net/utils/net_lock.c b/net/utils/net_lock.c
index 645a5cc9be..478ae1d1bd 100644
--- a/net/utils/net_lock.c
+++ b/net/utils/net_lock.c
@@ -247,9 +247,7 @@ int net_lock(void)
 
 int net_trylock(void)
 {
-#ifdef CONFIG_SMP
   irqstate_t flags = enter_critical_section();
-#endif
   pid_t me = getpid();
   int ret = OK;
 
@@ -263,7 +261,23 @@ int net_trylock(void)
     }
   else
     {
-      ret = nxsem_trywait(&g_netlock);
+      if (g_netlock.semcount > 0)
+        {
+          /* Take a semaphore count.  Note that we cannot do this in
+           * in the orthodox way by calling nxsem_wait() or nxsem_trywait()
+           * because this function may be called from an interrupt
+           * handler. Fortunately we know that semephore is free thus we take it.
+           */
+
+          g_netlock.semcount--;
+          ret = OK;
+        }
+      else
+        {
+          /* Semaphore is not available */
+          ret = -EAGAIN;
+        }
+
       if (ret >= 0)
         {
           /* Now this thread holds the semaphore */
@@ -273,9 +287,7 @@ int net_trylock(void)
         }
     }
 
-#ifdef CONFIG_SMP
   leave_critical_section(flags);
-#endif
   return ret;
 }
 
diff --git a/sched/Makefile b/sched/Makefile
index 2ac0743056..e83223d8de 100644
--- a/sched/Makefile
+++ b/sched/Makefile
@@ -32,6 +32,7 @@ include pthread/Make.defs
 include sched/Make.defs
 include semaphore/Make.defs
 include signal/Make.defs
+include systemview/Make.defs
 include task/Make.defs
 include timer/Make.defs
 include wdog/Make.defs
diff --git a/sched/init/nx_start.c b/sched/init/nx_start.c
index 927f8ff954..91758be875 100644
--- a/sched/init/nx_start.c
+++ b/sched/init/nx_start.c
@@ -76,6 +76,8 @@
 #include "group/group.h"
 #include "init/init.h"
 
+#include "systemview/SEGGER_SYSVIEW_NuttX.h"
+
 /****************************************************************************
  * Pre-processor Definitions
  ****************************************************************************/
@@ -803,6 +805,8 @@ void nx_start(void)
 
 #endif /* CONFIG_SMP */
 
+  TRACE_INIT();
+
   /* Bring Up the System ****************************************************/
 
   /* The OS is fully initialized and we are beginning multi-tasking */
diff --git a/sched/irq/irq_dispatch.c b/sched/irq/irq_dispatch.c
index 49be385613..03ae04ca62 100644
--- a/sched/irq/irq_dispatch.c
+++ b/sched/irq/irq_dispatch.c
@@ -49,6 +49,9 @@
 #include "clock/clock.h"
 #include "sched/sched.h"
 
+
+#include "systemview/SEGGER_SYSVIEW_NuttX.h"
+
 /****************************************************************************
  * Pre-processor Definitions
  ****************************************************************************/
@@ -139,6 +142,9 @@ void irq_dispatch(int irq, FAR void *context)
   FAR void *arg = NULL;
   unsigned int ndx = irq;
 
+
+  TRACE_ISR_ENTER();
+
 #if NR_IRQS > 0
   if ((unsigned)irq < NR_IRQS)
     {
@@ -183,6 +189,13 @@ void irq_dispatch(int irq, FAR void *context)
   CALL_VECTOR(ndx, vector, irq, context, arg);
   UNUSED(ndx);
 
+  if (g_running_tasks[this_cpu()] != this_task()) {
+    TRACE_ISR_EXIT_TO_SCHEDULER();
+    TRACE_TASK_START(this_task()->pid);
+  } else {
+    TRACE_ISR_EXIT();
+  }
+
 #ifdef CONFIG_SCHED_INSTRUMENTATION_IRQHANDLER
   /* Notify that we are leaving from the interrupt handler */
 
diff --git a/sched/pthread/pthread_create.c b/sched/pthread/pthread_create.c
index 1b836f50a0..3d89995cc1 100644
--- a/sched/pthread/pthread_create.c
+++ b/sched/pthread/pthread_create.c
@@ -45,6 +45,8 @@
 #include "clock/clock.h"
 #include "pthread/pthread.h"
 
+#include "systemview/SEGGER_SYSVIEW_NuttX.h"
+
 /****************************************************************************
  * Public Data
  ****************************************************************************/
@@ -235,6 +237,8 @@ int pthread_create(FAR pthread_t *thread, FAR const pthread_attr_t *attr,
   int ret;
   bool group_joined = false;
 
+  TRACE_API_PTHREAD_CREATE(thread, attr, start_routine, arg);
+
   /* If attributes were not supplied, use the default attributes */
 
   if (!attr)
@@ -592,6 +596,10 @@ int pthread_create(FAR pthread_t *thread, FAR const pthread_attr_t *attr,
       goto errout_with_join;
     }
 
+  TRACE_TASK_CREATED(pid, ptcb->cmn.name, ptcb->cmn.base_priority, ptcb->cmn.adj_stack_ptr, ptcb->cmn.adj_stack_size);
+
+  TRACE_API_PTHREAD_CREATE_RETURN(ret);
+
   return ret;
 
 errout_with_join:
@@ -608,5 +616,8 @@ errout_with_tcb:
     }
 
   nxsched_release_tcb((FAR struct tcb_s *)ptcb, TCB_FLAG_TTYPE_PTHREAD);
+
+  TRACE_API_PTHREAD_CREATE_RETURN(errcode);
+
   return errcode;
 }
diff --git a/sched/pthread/pthread_exit.c b/sched/pthread/pthread_exit.c
index b77f2c8a5c..55955dea20 100644
--- a/sched/pthread/pthread_exit.c
+++ b/sched/pthread/pthread_exit.c
@@ -55,6 +55,8 @@
 #include "task/task.h"
 #include "pthread/pthread.h"
 
+#include "systemview/SEGGER_SYSVIEW_NuttX.h"
+
 /****************************************************************************
  * Public Functions
  ****************************************************************************/
@@ -136,6 +138,8 @@ void pthread_exit(FAR void *exit_value)
 
   nxtask_exithook(tcb, EXIT_SUCCESS, false);
 
+  TRACE_TASK_TERMINATE(tcb->pid);
+
   /* Then just exit, retaining all file descriptors and without
    * calling atexit() functions.
    */
diff --git a/sched/sched/sched_addblocked.c b/sched/sched/sched_addblocked.c
index 3965f61193..b3ed65d6c2 100644
--- a/sched/sched/sched_addblocked.c
+++ b/sched/sched/sched_addblocked.c
@@ -44,6 +44,8 @@
 
 #include "sched/sched.h"
 
+#include "systemview/SEGGER_SYSVIEW_NuttX.h"
+
 /****************************************************************************
  * Public Functions
  ****************************************************************************/
@@ -77,6 +79,14 @@ void nxsched_add_blocked(FAR struct tcb_s *btcb, tstate_t task_state)
   DEBUGASSERT(task_state >= FIRST_BLOCKED_STATE &&
               task_state <= LAST_BLOCKED_STATE);
 
+#ifdef CONFIG_SMP
+  /* Lock the tasklists before accessing */
+
+  irqstate_t lock = nxsched_lock_tasklist();
+#endif
+
+  TRACE_TASK_BLOCK(btcb->pid, task_state);
+
   /* Add the TCB to the blocked task list associated with this state. */
 
   tasklist = TLIST_BLOCKED(task_state);
@@ -96,6 +106,12 @@ void nxsched_add_blocked(FAR struct tcb_s *btcb, tstate_t task_state)
       dq_addlast((FAR dq_entry_t *)btcb, tasklist);
     }
 
+#ifdef CONFIG_SMP
+  /* Unlock the tasklists */
+
+  nxsched_unlock_tasklist(lock);
+#endif
+
   /* Make sure the TCB's state corresponds to the list */
 
   btcb->task_state = task_state;
diff --git a/sched/sched/sched_addreadytorun.c b/sched/sched/sched_addreadytorun.c
index 0d610b5315..e16e70fefd 100644
--- a/sched/sched/sched_addreadytorun.c
+++ b/sched/sched/sched_addreadytorun.c
@@ -47,6 +47,8 @@
 #include "irq/irq.h"
 #include "sched/sched.h"
 
+#include "systemview/SEGGER_SYSVIEW_NuttX.h"
+
 /****************************************************************************
  * Public Functions
  ****************************************************************************/
@@ -85,6 +87,8 @@ bool nxsched_add_readytorun(FAR struct tcb_s *btcb)
   FAR struct tcb_s *rtcb = this_task();
   bool ret;
 
+  TRACE_TASK_READY(btcb->pid);
+
   /* Check if pre-emption is disabled for the current running task and if
    * the new ready-to-run task would cause the current running task to be
    * pre-empted.  NOTE that IRQs disabled implies that pre-emption is
diff --git a/sched/sched/sched_resumescheduler.c b/sched/sched/sched_resumescheduler.c
index fc9fe26568..e377ec1696 100644
--- a/sched/sched/sched_resumescheduler.c
+++ b/sched/sched/sched_resumescheduler.c
@@ -48,6 +48,8 @@
 #include "irq/irq.h"
 #include "sched/sched.h"
 
+#include "systemview/SEGGER_SYSVIEW_NuttX.h"
+
 #if CONFIG_RR_INTERVAL > 0 || defined(CONFIG_SCHED_RESUMESCHEDULER)
 
 /****************************************************************************
diff --git a/sched/semaphore/sem_trywait.c b/sched/semaphore/sem_trywait.c
index 90ffcddabf..61012185f3 100644
--- a/sched/semaphore/sem_trywait.c
+++ b/sched/semaphore/sem_trywait.c
@@ -85,8 +85,12 @@ int nxsem_trywait(FAR sem_t *sem)
 
   /* This API should not be called from interrupt handlers */
 
-  DEBUGASSERT(sem != NULL && up_interrupt_context() == false);
+  DEBUGASSERT(sem != NULL);
+  
+  /* DEBUGASSERT(sem != NULL && up_interrupt_context() == false); */
 
+  /* To be discussed this call is non-blocking thus can be called from a ISR */
+ 
   if (sem != NULL)
     {
       /* The following operations must be performed with interrupts disabled
diff --git a/sched/systemview/Global.h b/sched/systemview/Global.h
new file mode 100644
index 0000000000..6e978bc92b
--- /dev/null
+++ b/sched/systemview/Global.h
@@ -0,0 +1,113 @@
+/*********************************************************************
+*                    SEGGER Microcontroller GmbH                     *
+*                        The Embedded Experts                        *
+**********************************************************************
+*                                                                    *
+*            (c) 1995 - 2019 SEGGER Microcontroller GmbH             *
+*                                                                    *
+*       www.segger.com     Support: support@segger.com               *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SEGGER SystemView * Real-time application analysis           *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+* All rights reserved.                                               *
+*                                                                    *
+* SEGGER strongly recommends to not make any changes                 *
+* to or modify the source code of this software in order to stay     *
+* compatible with the SystemView and RTT protocol, and J-Link.       *
+*                                                                    *
+* Redistribution and use in source and binary forms, with or         *
+* without modification, are permitted provided that the following    *
+* condition is met:                                                  *
+*                                                                    *
+* o Redistributions of source code must retain the above copyright   *
+*   notice, this condition and the following disclaimer.             *
+*                                                                    *
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
+* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
+* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
+* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
+* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
+* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
+* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
+* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
+* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
+* DAMAGE.                                                            *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SystemView version: V3.12                                    *
+*                                                                    *
+**********************************************************************
+----------------------------------------------------------------------
+File    : Global.h
+Purpose : Global types
+          In case your application already has a Global.h, you should
+          merge the files. In order to use Segger code, the types
+          U8, U16, U32, I8, I16, I32 need to be defined in Global.h;
+          additional definitions do not hurt.
+Revision: $Rev: 12501 $
+---------------------------END-OF-HEADER------------------------------
+*/
+
+#ifndef GLOBAL_H            // Guard against multiple inclusion
+#define GLOBAL_H
+
+#define U8    unsigned char
+#define I8    signed char
+#define U16   unsigned short
+#define I16   signed short
+#ifdef __x86_64__
+#define U32   unsigned
+#define I32   int
+#else
+#define U32   unsigned long
+#define I32   signed long
+#endif
+
+//
+// CC_NO_LONG_SUPPORT can be defined to compile test
+// without long support for compilers that do not
+// support C99 and its long type.
+//
+#ifdef CC_NO_LONG_SUPPORT
+  #define PTR_ADDR  U32
+#else  // Supports long type.
+#if defined(_WIN32) && !defined(__clang__) && !defined(__MINGW32__)
+  //
+  // Microsoft VC6 compiler related
+  //
+  #define U64   unsigned __int64
+  #define U128  unsigned __int128
+  #define I64   __int64
+  #define I128  __int128
+  #if _MSC_VER <= 1200
+    #define U64_C(x) x##UI64
+  #else
+    #define U64_C(x) x##ULL
+  #endif
+#else
+  //
+  // C99 compliant compiler
+  //
+  #define U64   unsigned long long
+  #define I64   signed long long
+  #define U64_C(x) x##ULL
+#endif
+
+#if (defined(_WIN64) || defined(__LP64__))  // 64-bit symbols used by Visual Studio and GCC, maybe others as well.
+  #define PTR_ADDR  U64
+#else
+  #define PTR_ADDR  U32
+#endif
+#endif  // Supports long type.
+
+#endif                      // Avoid multiple inclusion
+
+/*************************** End of file ****************************/
diff --git a/sched/systemview/Kconfig b/sched/systemview/Kconfig
new file mode 100644
index 0000000000..7d22459232
--- /dev/null
+++ b/sched/systemview/Kconfig
@@ -0,0 +1,66 @@
+#
+# For a description of the syntax of this configuration file,
+# see the file kconfig-language.txt in the NuttX tools repository.
+#
+
+menuconfig SYSTEMVIEW_ENABLE
+	bool "Enable SystemView Instrumentation"
+	default n
+    ---help---
+        Enable instrumentation of the scheduler using SEGGER SystemView.
+
+if SYSTEMVIEW_ENABLE
+config SYSTEMVIEW_APP_NAME
+    string "Application Name"
+    default "NuttX start project"
+config SYSTEMVIEW_DEVICE_NAME
+    string "Device Name"
+    default "Cortex-M3/M4/M7"
+config SYSTEMVIEW_CPU_FREQ
+    int "CPU Frequency [Hz]"
+    default 168000000
+config SYSTEMVIEW_TIMESTAMP_FREQ
+    int "Timestamp Frequency [Hz]"
+    default 168000000
+config SYSTEMVIEW_RES_ID_BASE
+    hex "Resource ID Base"
+    default 0x00000000
+config SYSTEMVIEW_RES_ID_SHIFT
+    int "Resource ID Shift"
+    default 0
+config SYSTEMVIEW_START_ON_INIT
+    bool "Start Recording on Init"
+    default n
+config SYSTEMVIEW_SYSDESC_0
+    string "System Description 0"
+    default "I#11=SVC,I#15=SysTick"
+config SYSTEMVIEW_SYSDESC_1
+    string "System Description 1"
+config SYSTEMVIEW_SYSDESC_2
+    string "System Description 2"
+config SYSTEMVIEW_RECORD_API
+    bool "Record APIs"
+    default y
+config SYSTEMVIEW_RECORD_ISR
+    bool "Record Interrupts"
+    default y
+config SYSTEMVIEW_BUFFER_SIZE
+    int "SystemView Buffer Size"
+    default 8192
+config SYSTEMVIEW_RTT_CHANNEL
+    int "SystemView RTT Channel"
+    default 1
+config SYSTEMVIEW_USE_STATIC_BUFFER
+    bool "Use static event buffer"
+    default y
+config SYSTEMVIEW_POST_MORTEM_MODE
+    bool "Enable Post-Mortem Mode"
+    default n
+config SYSTEMVIEW_MAX_NOF_TASKS
+    int "Maximum Number of Tasks"
+    default 16
+    ---help---
+        Maximum number of Tasks to be recorded by Systemview.
+        If more tasks are created, their information is not added to the list, i.e. not recorded.
+        
+endif # SYSTEMVIEW_ENABLE
diff --git a/sched/systemview/Make.defs b/sched/systemview/Make.defs
new file mode 100644
index 0000000000..2ab5602b29
--- /dev/null
+++ b/sched/systemview/Make.defs
@@ -0,0 +1,47 @@
+############################################################################
+# sched/systemview/Make.defs
+#
+#   Copyright (C) 2014, 2018 Gregory Nutt. All rights reserved.
+#   Author: Gregory Nutt <gnutt@nuttx.org>
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in
+#    the documentation and/or other materials provided with the
+#    distribution.
+# 3. Neither the name NuttX nor the names of its contributors may be
+#    used to endorse or promote products derived from this software
+#    without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+# OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+# AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+############################################################################
+
+ifeq ($(CONFIG_SYSTEMVIEW_ENABLE),y)
+
+ASRCS += SEGGER_RTT_ASM_ARMv7M.S
+
+CSRCS += SEGGER_RTT.c SEGGER_RTT_printf.c SEGGER_SYSVIEW.c SEGGER_SYSVIEW_Config_NuttX.c SEGGER_SYSVIEW_NuttX.c
+
+endif
+
+# Include systemview build support
+
+DEPPATH += --dep-path systemview
+VPATH += :systemview
diff --git a/sched/systemview/Makefile b/sched/systemview/Makefile
new file mode 100644
index 0000000000..95cb4439a4
--- /dev/null
+++ b/sched/systemview/Makefile
@@ -0,0 +1,76 @@
+############################################################################
+# systemview/Makefile
+##
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in
+#    the documentation and/or other materials provided with the
+#    distribution.
+# 3. Neither the name NuttX nor the names of its contributors may be
+#    used to endorse or promote products derived from this software
+#    without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+# OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+# AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+############################################################################
+
+-include $(TOPDIR)/Make.defs
+
+ASRCS = SEGGER_RTT_ASM_ARMv7M.S
+AOBJS = $(ASRCS:.S=$(OBJEXT))
+
+CSRCS = SEGGER_RTT.c SEGGER_RTT_printf.c SEGGER_SYSVIEW.c SEGGER_SYSVIEW_Config_NuttX.c SEGGER_SYSVIEW_NuttX.c
+
+DEPPATH = --dep-path .
+VPATH = .
+
+COBJS = $(CSRCS:.c=$(OBJEXT))
+
+SRCS = $(ASRCS) $(CSRCS)
+OBJS = $(AOBJS) $(COBJS)
+
+BIN = libsystemview$(LIBEXT)
+
+all: $(BIN)
+.PHONY: depend clean distclean
+
+$(AOBJS): %$(OBJEXT): %.S
+	$(call ASSEMBLE, $<, $@)
+
+$(COBJS): %$(OBJEXT): %.c
+	$(call COMPILE, $<, $@)
+
+$(BIN):	$(OBJS)
+	$(call ARCHIVE, $@, $(OBJS))
+
+.depend: Makefile $(SRCS)
+	$(Q) $(MKDEP) $(DEPPATH) "$(CC)" -- $(CFLAGS) -- $(SRCS) >Make.dep
+	$(Q) touch $@
+
+depend: .depend
+
+clean:
+	$(call DELFILE, $(BIN))
+	$(call CLEAN)
+
+distclean: clean
+	$(call DELFILE, Make.dep)
+	$(call DELFILE, .depend)
+
+-include Make.dep
diff --git a/sched/systemview/SEGGER.h b/sched/systemview/SEGGER.h
new file mode 100644
index 0000000000..a2b43065fd
--- /dev/null
+++ b/sched/systemview/SEGGER.h
@@ -0,0 +1,248 @@
+/*********************************************************************
+*                    SEGGER Microcontroller GmbH                     *
+*                        The Embedded Experts                        *
+**********************************************************************
+*                                                                    *
+*            (c) 1995 - 2019 SEGGER Microcontroller GmbH             *
+*                                                                    *
+*       www.segger.com     Support: support@segger.com               *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SEGGER SystemView * Real-time application analysis           *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+* All rights reserved.                                               *
+*                                                                    *
+* SEGGER strongly recommends to not make any changes                 *
+* to or modify the source code of this software in order to stay     *
+* compatible with the SystemView and RTT protocol, and J-Link.       *
+*                                                                    *
+* Redistribution and use in source and binary forms, with or         *
+* without modification, are permitted provided that the following    *
+* condition is met:                                                  *
+*                                                                    *
+* o Redistributions of source code must retain the above copyright   *
+*   notice, this condition and the following disclaimer.             *
+*                                                                    *
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
+* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
+* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
+* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
+* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
+* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
+* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
+* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
+* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
+* DAMAGE.                                                            *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SystemView version: V3.12                                    *
+*                                                                    *
+**********************************************************************
+----------------------------------------------------------------------
+File    : SEGGER.h
+Purpose : Global types etc & general purpose utility functions
+Revision: $Rev: 18102 $
+---------------------------END-OF-HEADER------------------------------
+*/
+
+#ifndef SEGGER_H            // Guard against multiple inclusion
+#define SEGGER_H
+
+#include <stdarg.h>         // For va_list.
+#include "Global.h"         // Type definitions: U8, U16, U32, I8, I16, I32
+
+#if defined(__cplusplus)
+extern "C" {     /* Make sure we have C-declarations in C++ programs */
+#endif
+
+/*********************************************************************
+*
+*       Keywords/specifiers
+*
+**********************************************************************
+*/
+
+#ifndef INLINE
+  #if (defined(__ICCARM__) || defined(__RX) || defined(__ICCRX__))
+    //
+    // Other known compilers.
+    //
+    #define INLINE  inline
+  #else
+    #if (defined(_WIN32) && !defined(__clang__))
+      //
+      // Microsoft VC6 and newer.
+      // Force inlining without cost checking.
+      //
+      #define INLINE  __forceinline
+    #elif defined(__GNUC__) || defined(__clang__)
+      //
+      // Force inlining with GCC + clang
+      //
+      #define INLINE inline __attribute__((always_inline))
+    #elif (defined(__CC_ARM))
+      //
+      // Force inlining with ARMCC (Keil)
+      //
+      #define INLINE  __inline
+    #else
+      //
+      // Unknown compilers.
+      //
+      #define INLINE
+    #endif
+  #endif
+#endif
+
+/*********************************************************************
+*
+*       Function-like macros
+*
+**********************************************************************
+*/
+
+#define SEGGER_COUNTOF(a)          (sizeof((a))/sizeof((a)[0]))
+#define SEGGER_MIN(a,b)            (((a) < (b)) ? (a) : (b))
+#define SEGGER_MAX(a,b)            (((a) > (b)) ? (a) : (b))
+
+#ifndef   SEGGER_USE_PARA                   // Some compiler complain about unused parameters.
+  #define SEGGER_USE_PARA(Para) (void)Para  // This works for most compilers.
+#endif
+
+#define SEGGER_ADDR2PTR(Type, Addr)  (/*lint -e(923) -e(9078)*/((Type*)((PTR_ADDR)(Addr))))    // Allow cast from address to pointer.
+#define SEGGER_PTR2ADDR(p)           (/*lint -e(923) -e(9078)*/((PTR_ADDR)(p)))                // Allow cast from pointer to address.
+#define SEGGER_PTR2PTR(Type, p)      (/*lint -e(740) -e(826) -e(9079) -e(9087)*/((Type*)(p)))  // Allow cast from one pointer type to another (ignore different size).
+#define SEGGER_PTR_DISTANCE(p0, p1)  (SEGGER_PTR2ADDR(p0) - SEGGER_PTR2ADDR(p1))
+
+/*********************************************************************
+*
+*       Defines
+*
+**********************************************************************
+*/
+
+#define SEGGER_PRINTF_FLAG_ADJLEFT    (1 << 0)
+#define SEGGER_PRINTF_FLAG_SIGNFORCE  (1 << 1)
+#define SEGGER_PRINTF_FLAG_SIGNSPACE  (1 << 2)
+#define SEGGER_PRINTF_FLAG_PRECEED    (1 << 3)
+#define SEGGER_PRINTF_FLAG_ZEROPAD    (1 << 4)
+#define SEGGER_PRINTF_FLAG_NEGATIVE   (1 << 5)
+
+/*********************************************************************
+*
+*       Types
+*
+**********************************************************************
+*/
+
+typedef struct {
+  char* pBuffer;
+  int   BufferSize;
+  int   Cnt;
+} SEGGER_BUFFER_DESC;
+
+typedef struct {
+  unsigned int CacheLineSize;                             // 0: No Cache. Most Systems such as ARM9 use a 32 bytes cache line size.
+  void (*pfDMB)       (void);                             // Optional DMB function for Data Memory Barrier to make sure all memory operations are completed.
+  void (*pfClean)     (void *p, unsigned long NumBytes);  // Optional clean function for cached memory.
+  void (*pfInvalidate)(void *p, unsigned long NumBytes);  // Optional invalidate function for cached memory.
+} SEGGER_CACHE_CONFIG;
+
+typedef struct SEGGER_SNPRINTF_CONTEXT_struct SEGGER_SNPRINTF_CONTEXT;
+
+struct SEGGER_SNPRINTF_CONTEXT_struct {
+  void*               pContext;                       // Application specific context.
+  SEGGER_BUFFER_DESC* pBufferDesc;                    // Buffer descriptor to use for output.
+  void (*pfFlush)(SEGGER_SNPRINTF_CONTEXT* pContext); // Callback executed once the buffer is full. Callback decides if the buffer gets cleared to store more or not.
+};
+
+typedef struct {
+  void (*pfStoreChar)       (SEGGER_BUFFER_DESC* pBufferDesc, SEGGER_SNPRINTF_CONTEXT* pContext, char c);
+  int  (*pfPrintUnsigned)   (SEGGER_BUFFER_DESC* pBufferDesc, SEGGER_SNPRINTF_CONTEXT* pContext, U32 v, unsigned Base, char Flags, int Width, int Precision);
+  int  (*pfPrintInt)        (SEGGER_BUFFER_DESC* pBufferDesc, SEGGER_SNPRINTF_CONTEXT* pContext, I32 v, unsigned Base, char Flags, int Width, int Precision);
+} SEGGER_PRINTF_API;
+
+typedef void (*SEGGER_pFormatter)(SEGGER_BUFFER_DESC* pBufferDesc, SEGGER_SNPRINTF_CONTEXT* pContext, const SEGGER_PRINTF_API* pApi, va_list* pParamList, char Lead, int Width, int Precision);
+
+typedef struct SEGGER_PRINTF_FORMATTER {
+  struct SEGGER_PRINTF_FORMATTER* pNext;              // Pointer to next formatter.
+  SEGGER_pFormatter               pfFormatter;        // Formatter function.
+  char                            Specifier;          // Format specifier.
+} SEGGER_PRINTF_FORMATTER;
+
+typedef struct {
+  U32 (*pfGetHPTimestamp)(void);          // Mandatory, pfGetHPTimestamp
+  int (*pfGetUID)        (U8 abUID[16]);  // Optional,  pfGetUID
+} SEGGER_BSP_API;
+
+/*********************************************************************
+*
+*       Utility functions
+*
+**********************************************************************
+*/
+
+//
+// Memory operations.
+//
+void SEGGER_ARM_memcpy(void* pDest, const void* pSrc, int NumBytes);
+void SEGGER_memcpy    (void* pDest, const void* pSrc, unsigned NumBytes);
+void SEGGER_memxor    (void* pDest, const void* pSrc, unsigned NumBytes);
+
+//
+// String functions.
+//
+int      SEGGER_atoi       (const char* s);
+int      SEGGER_isalnum    (int c);
+int      SEGGER_isalpha    (int c);
+unsigned SEGGER_strlen     (const char* s);
+int      SEGGER_tolower    (int c);
+int      SEGGER_strcasecmp (const char* sText1, const char* sText2);
+int      SEGGER_strncasecmp(const char *sText1, const char *sText2, unsigned Count);
+
+//
+// Buffer/printf related.
+//
+void SEGGER_StoreChar    (SEGGER_BUFFER_DESC* pBufferDesc, char c);
+void SEGGER_PrintUnsigned(SEGGER_BUFFER_DESC* pBufferDesc, U32 v, unsigned Base, int Precision);
+void SEGGER_PrintInt     (SEGGER_BUFFER_DESC* pBufferDesc, I32 v, unsigned Base, int Precision);
+int  SEGGER_snprintf     (char* pBuffer, int BufferSize, const char* sFormat, ...);
+int  SEGGER_vsnprintf    (char* pBuffer, int BufferSize, const char* sFormat, va_list ParamList);
+int  SEGGER_vsnprintfEx  (SEGGER_SNPRINTF_CONTEXT* pContext, const char* sFormat, va_list ParamList);
+
+int  SEGGER_PRINTF_AddFormatter       (SEGGER_PRINTF_FORMATTER* pFormatter, SEGGER_pFormatter pfFormatter, char c);
+void SEGGER_PRINTF_AddDoubleFormatter (void);
+void SEGGER_PRINTF_AddIPFormatter     (void);
+void SEGGER_PRINTF_AddBLUEFormatter   (void);
+void SEGGER_PRINTF_AddCONNECTFormatter(void);
+void SEGGER_PRINTF_AddSSLFormatter    (void);
+void SEGGER_PRINTF_AddSSHFormatter    (void);
+void SEGGER_PRINTF_AddHTMLFormatter   (void);
+
+//
+// BSP abstraction API.
+//
+int  SEGGER_BSP_GetUID  (U8 abUID[16]);
+int  SEGGER_BSP_GetUID32(U32* pUID);
+void SEGGER_BSP_SetAPI  (const SEGGER_BSP_API* pAPI);
+void SEGGER_BSP_SeedUID (void);
+
+//
+// Other API.
+//
+void SEGGER_VERSION_GetString(char acText[8], unsigned Version);
+
+#if defined(__cplusplus)
+}                /* Make sure we have C-declarations in C++ programs */
+#endif
+
+#endif                      // Avoid multiple inclusion
+
+/*************************** End of file ****************************/
diff --git a/sched/systemview/SEGGER_RTT.c b/sched/systemview/SEGGER_RTT.c
new file mode 100644
index 0000000000..b5a6eafc44
--- /dev/null
+++ b/sched/systemview/SEGGER_RTT.c
@@ -0,0 +1,2009 @@
+/*********************************************************************
+*                    SEGGER Microcontroller GmbH                     *
+*                        The Embedded Experts                        *
+**********************************************************************
+*                                                                    *
+*            (c) 1995 - 2019 SEGGER Microcontroller GmbH             *
+*                                                                    *
+*       www.segger.com     Support: support@segger.com               *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SEGGER SystemView * Real-time application analysis           *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+* All rights reserved.                                               *
+*                                                                    *
+* SEGGER strongly recommends to not make any changes                 *
+* to or modify the source code of this software in order to stay     *
+* compatible with the SystemView and RTT protocol, and J-Link.       *
+*                                                                    *
+* Redistribution and use in source and binary forms, with or         *
+* without modification, are permitted provided that the following    *
+* condition is met:                                                  *
+*                                                                    *
+* o Redistributions of source code must retain the above copyright   *
+*   notice, this condition and the following disclaimer.             *
+*                                                                    *
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
+* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
+* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
+* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
+* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
+* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
+* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
+* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
+* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
+* DAMAGE.                                                            *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SystemView version: V3.12                                    *
+*                                                                    *
+**********************************************************************
+---------------------------END-OF-HEADER------------------------------
+File    : SEGGER_RTT.c
+Purpose : Implementation of SEGGER real-time transfer (RTT) which
+          allows real-time communication on targets which support
+          debugger memory accesses while the CPU is running.
+Revision: $Rev: 17697 $
+
+Additional information:
+          Type "int" is assumed to be 32-bits in size
+          H->T    Host to target communication
+          T->H    Target to host communication
+
+          RTT channel 0 is always present and reserved for Terminal usage.
+          Name is fixed to "Terminal"
+
+          Effective buffer size: SizeOfBuffer - 1
+
+          WrOff == RdOff:       Buffer is empty
+          WrOff == (RdOff - 1): Buffer is full
+          WrOff >  RdOff:       Free space includes wrap-around
+          WrOff <  RdOff:       Used space includes wrap-around
+          (WrOff == (SizeOfBuffer - 1)) && (RdOff == 0):  
+                                Buffer full and wrap-around after next byte
+
+
+----------------------------------------------------------------------
+*/
+
+#include "SEGGER_RTT.h"
+
+#include <string.h>                 // for memcpy
+
+/*********************************************************************
+*
+*       Configuration, default values
+*
+**********************************************************************
+*/
+
+#ifndef   BUFFER_SIZE_UP
+  #define BUFFER_SIZE_UP                                  1024  // Size of the buffer for terminal output of target, up to host
+#endif
+
+#ifndef   BUFFER_SIZE_DOWN
+  #define BUFFER_SIZE_DOWN                                16    // Size of the buffer for terminal input to target from host (Usually keyboard input)
+#endif
+
+#ifndef   SEGGER_RTT_MAX_NUM_UP_BUFFERS
+  #define SEGGER_RTT_MAX_NUM_UP_BUFFERS                    2    // Number of up-buffers (T->H) available on this target
+#endif
+
+#ifndef   SEGGER_RTT_MAX_NUM_DOWN_BUFFERS
+  #define SEGGER_RTT_MAX_NUM_DOWN_BUFFERS                  2    // Number of down-buffers (H->T) available on this target
+#endif
+
+#ifndef SEGGER_RTT_BUFFER_SECTION
+  #if defined(SEGGER_RTT_SECTION)
+    #define SEGGER_RTT_BUFFER_SECTION SEGGER_RTT_SECTION
+  #endif
+#endif
+
+#ifndef   SEGGER_RTT_ALIGNMENT
+  #define SEGGER_RTT_ALIGNMENT                            0
+#endif
+
+#ifndef   SEGGER_RTT_BUFFER_ALIGNMENT
+  #define SEGGER_RTT_BUFFER_ALIGNMENT                     0
+#endif
+
+#ifndef   SEGGER_RTT_MODE_DEFAULT
+  #define SEGGER_RTT_MODE_DEFAULT                         SEGGER_RTT_MODE_NO_BLOCK_SKIP
+#endif
+
+#ifndef   SEGGER_RTT_LOCK
+  #define SEGGER_RTT_LOCK()
+#endif
+
+#ifndef   SEGGER_RTT_UNLOCK
+  #define SEGGER_RTT_UNLOCK()
+#endif
+
+#ifndef   STRLEN
+  #define STRLEN(a)                                       strlen((a))
+#endif
+
+#ifndef   STRCPY
+  #define STRCPY(pDest, pSrc, NumBytes)                   strcpy((pDest), (pSrc))
+#endif
+
+#ifndef   SEGGER_RTT_MEMCPY_USE_BYTELOOP
+  #define SEGGER_RTT_MEMCPY_USE_BYTELOOP                  0
+#endif
+
+#ifndef   SEGGER_RTT_MEMCPY
+  #ifdef  MEMCPY
+    #define SEGGER_RTT_MEMCPY(pDest, pSrc, NumBytes)      MEMCPY((pDest), (pSrc), (NumBytes))
+  #else
+    #define SEGGER_RTT_MEMCPY(pDest, pSrc, NumBytes)      memcpy((pDest), (pSrc), (NumBytes))
+  #endif
+#endif
+
+#ifndef   MIN
+  #define MIN(a, b)         (((a) < (b)) ? (a) : (b))
+#endif
+
+#ifndef   MAX
+  #define MAX(a, b)         (((a) > (b)) ? (a) : (b))
+#endif
+//
+// For some environments, NULL may not be defined until certain headers are included
+//
+#ifndef NULL
+  #define NULL 0
+#endif
+
+/*********************************************************************
+*
+*       Defines, fixed
+*
+**********************************************************************
+*/
+#if (defined __ICCARM__) || (defined __ICCRX__)
+  #define RTT_PRAGMA(P) _Pragma(#P)
+#endif
+
+#if SEGGER_RTT_ALIGNMENT || SEGGER_RTT_BUFFER_ALIGNMENT
+  #if (defined __GNUC__)
+    #define SEGGER_RTT_ALIGN(Var, Alignment) Var __attribute__ ((aligned (Alignment)))
+  #elif (defined __ICCARM__) || (defined __ICCRX__)
+    #define PRAGMA(A) _Pragma(#A)
+#define SEGGER_RTT_ALIGN(Var, Alignment) RTT_PRAGMA(data_alignment=Alignment) \
+                                  Var
+  #elif (defined __CC_ARM)
+    #define SEGGER_RTT_ALIGN(Var, Alignment) Var __attribute__ ((aligned (Alignment)))
+  #else
+    #error "Alignment not supported for this compiler."
+  #endif
+#else
+  #define SEGGER_RTT_ALIGN(Var, Alignment) Var
+#endif
+
+#if defined(SEGGER_RTT_SECTION) || defined (SEGGER_RTT_BUFFER_SECTION)
+  #if (defined __GNUC__)
+    #define SEGGER_RTT_PUT_SECTION(Var, Section) __attribute__ ((section (Section))) Var
+  #elif (defined __ICCARM__) || (defined __ICCRX__)
+#define SEGGER_RTT_PUT_SECTION(Var, Section) RTT_PRAGMA(location=Section) \
+                                        Var
+  #elif (defined __CC_ARM)
+    #define SEGGER_RTT_PUT_SECTION(Var, Section) __attribute__ ((section (Section), zero_init))  Var
+  #else
+    #error "Section placement not supported for this compiler."
+  #endif
+#else
+  #define SEGGER_RTT_PUT_SECTION(Var, Section) Var
+#endif
+
+
+#if SEGGER_RTT_ALIGNMENT
+  #define SEGGER_RTT_CB_ALIGN(Var)  SEGGER_RTT_ALIGN(Var, SEGGER_RTT_ALIGNMENT)
+#else
+  #define SEGGER_RTT_CB_ALIGN(Var)  Var
+#endif
+
+#if SEGGER_RTT_BUFFER_ALIGNMENT
+  #define SEGGER_RTT_BUFFER_ALIGN(Var)  SEGGER_RTT_ALIGN(Var, SEGGER_RTT_BUFFER_ALIGNMENT)
+#else
+  #define SEGGER_RTT_BUFFER_ALIGN(Var)  Var
+#endif
+
+
+#if defined(SEGGER_RTT_SECTION)
+  #define SEGGER_RTT_PUT_CB_SECTION(Var) SEGGER_RTT_PUT_SECTION(Var, SEGGER_RTT_SECTION)
+#else
+  #define SEGGER_RTT_PUT_CB_SECTION(Var) Var
+#endif
+
+#if defined(SEGGER_RTT_BUFFER_SECTION)
+  #define SEGGER_RTT_PUT_BUFFER_SECTION(Var) SEGGER_RTT_PUT_SECTION(Var, SEGGER_RTT_BUFFER_SECTION)
+#else
+  #define SEGGER_RTT_PUT_BUFFER_SECTION(Var) Var
+#endif
+
+/*********************************************************************
+*
+*       Static const data
+*
+**********************************************************************
+*/
+
+static unsigned char _aTerminalId[16] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
+
+/*********************************************************************
+*
+*       Static data
+*
+**********************************************************************
+*/
+//
+// RTT Control Block and allocate buffers for channel 0
+//
+SEGGER_RTT_PUT_CB_SECTION(SEGGER_RTT_CB_ALIGN(SEGGER_RTT_CB _SEGGER_RTT));
+
+SEGGER_RTT_PUT_BUFFER_SECTION(SEGGER_RTT_BUFFER_ALIGN(static char _acUpBuffer  [BUFFER_SIZE_UP]));
+SEGGER_RTT_PUT_BUFFER_SECTION(SEGGER_RTT_BUFFER_ALIGN(static char _acDownBuffer[BUFFER_SIZE_DOWN]));
+
+static unsigned char _ActiveTerminal;
+
+/*********************************************************************
+*
+*       Static functions
+*
+**********************************************************************
+*/
+
+/*********************************************************************
+*
+*       _DoInit()
+*
+*  Function description
+*    Initializes the control block an buffers.
+*    May only be called via INIT() to avoid overriding settings.
+*
+*/
+#define INIT()  do {                                            \
+                  if (_SEGGER_RTT.acID[0] == '\0') { _DoInit(); }  \
+                } while (0)
+static void _DoInit(void) {
+  SEGGER_RTT_CB* p;
+  //
+  // Initialize control block
+  //
+  p = &_SEGGER_RTT;
+  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
+  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
+  //
+  // Initialize up buffer 0
+  //
+  p->aUp[0].sName         = "Terminal";
+  p->aUp[0].pBuffer       = _acUpBuffer;
+  p->aUp[0].SizeOfBuffer  = sizeof(_acUpBuffer);
+  p->aUp[0].RdOff         = 0u;
+  p->aUp[0].WrOff         = 0u;
+  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
+  //
+  // Initialize down buffer 0
+  //
+  p->aDown[0].sName         = "Terminal";
+  p->aDown[0].pBuffer       = _acDownBuffer;
+  p->aDown[0].SizeOfBuffer  = sizeof(_acDownBuffer);
+  p->aDown[0].RdOff         = 0u;
+  p->aDown[0].WrOff         = 0u;
+  p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
+  //
+  // Finish initialization of the control block.
+  // Copy Id string in three steps to make sure "SEGGER RTT" is not found
+  // in initializer memory (usually flash) by J-Link
+  //
+  STRCPY(&p->acID[7], "RTT", 9);
+  STRCPY(&p->acID[0], "SEGGER", 7);
+  p->acID[6] = ' ';
+}
+
+/*********************************************************************
+*
+*       _WriteBlocking()
+*
+*  Function description
+*    Stores a specified number of characters in SEGGER RTT ring buffer
+*    and updates the associated write pointer which is periodically
+*    read by the host.
+*    The caller is responsible for managing the write chunk sizes as
+*    _WriteBlocking() will block until all data has been posted successfully.
+*
+*  Parameters
+*    pRing        Ring buffer to post to.
+*    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
+*    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
+*
+*  Return value
+*    >= 0 - Number of bytes written into buffer.
+*/
+static unsigned _WriteBlocking(SEGGER_RTT_BUFFER_UP* pRing, const char* pBuffer, unsigned NumBytes) {
+  unsigned NumBytesToWrite;
+  unsigned NumBytesWritten;
+  unsigned RdOff;
+  unsigned WrOff;
+#if SEGGER_RTT_MEMCPY_USE_BYTELOOP
+  char*    pDst;
+#endif
+  //
+  // Write data to buffer and handle wrap-around if necessary
+  //
+  NumBytesWritten = 0u;
+  WrOff = pRing->WrOff;
+  do {
+    RdOff = pRing->RdOff;                         // May be changed by host (debug probe) in the meantime
+    if (RdOff > WrOff) {
+      NumBytesToWrite = RdOff - WrOff - 1u;
+    } else {
+      NumBytesToWrite = pRing->SizeOfBuffer - (WrOff - RdOff + 1u);
+    }
+    NumBytesToWrite = MIN(NumBytesToWrite, (pRing->SizeOfBuffer - WrOff));      // Number of bytes that can be written until buffer wrap-around
+    NumBytesToWrite = MIN(NumBytesToWrite, NumBytes);
+#if SEGGER_RTT_MEMCPY_USE_BYTELOOP
+    pDst = pRing->pBuffer + WrOff;
+    NumBytesWritten += NumBytesToWrite;
+    NumBytes        -= NumBytesToWrite;
+    WrOff           += NumBytesToWrite;
+    while (NumBytesToWrite--) {
+      *pDst++ = *pBuffer++;
+    };
+#else
+    SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pBuffer, NumBytesToWrite);
+    NumBytesWritten += NumBytesToWrite;
+    pBuffer         += NumBytesToWrite;
+    NumBytes        -= NumBytesToWrite;
+    WrOff           += NumBytesToWrite;
+#endif
+    if (WrOff == pRing->SizeOfBuffer) {
+      WrOff = 0u;
+    }
+    pRing->WrOff = WrOff;
+  } while (NumBytes);
+  //
+  return NumBytesWritten;
+}
+
+/*********************************************************************
+*
+*       _WriteNoCheck()
+*
+*  Function description
+*    Stores a specified number of characters in SEGGER RTT ring buffer
+*    and updates the associated write pointer which is periodically
+*    read by the host.
+*    It is callers responsibility to make sure data actually fits in buffer.
+*
+*  Parameters
+*    pRing        Ring buffer to post to.
+*    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
+*    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
+*
+*  Notes
+*    (1) If there might not be enough space in the "Up"-buffer, call _WriteBlocking
+*/
+static void _WriteNoCheck(SEGGER_RTT_BUFFER_UP* pRing, const char* pData, unsigned NumBytes) {
+  unsigned NumBytesAtOnce;
+  unsigned WrOff;
+  unsigned Rem;
+#if SEGGER_RTT_MEMCPY_USE_BYTELOOP
+  char*    pDst;
+#endif
+
+  WrOff = pRing->WrOff;
+  Rem = pRing->SizeOfBuffer - WrOff;
+  if (Rem > NumBytes) {
+    //
+    // All data fits before wrap around
+    //
+#if SEGGER_RTT_MEMCPY_USE_BYTELOOP
+    pDst = pRing->pBuffer + WrOff;
+    WrOff += NumBytes;
+    while (NumBytes--) {
+      *pDst++ = *pData++;
+    };
+    pRing->WrOff = WrOff;
+#else
+    SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pData, NumBytes);
+    pRing->WrOff = WrOff + NumBytes;
+#endif
+  } else {
+    //
+    // We reach the end of the buffer, so need to wrap around
+    //
+#if SEGGER_RTT_MEMCPY_USE_BYTELOOP
+    pDst = pRing->pBuffer + WrOff;
+    NumBytesAtOnce = Rem;
+    while (NumBytesAtOnce--) {
+      *pDst++ = *pData++;
+    };
+    pDst = pRing->pBuffer;
+    NumBytesAtOnce = NumBytes - Rem;
+    while (NumBytesAtOnce--) {
+      *pDst++ = *pData++;
+    };
+    pRing->WrOff = NumBytes - Rem;
+#else
+    NumBytesAtOnce = Rem;
+    SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pData, NumBytesAtOnce);
+    NumBytesAtOnce = NumBytes - Rem;
+    SEGGER_RTT_MEMCPY(pRing->pBuffer, pData + Rem, NumBytesAtOnce);
+    pRing->WrOff = NumBytesAtOnce;
+#endif
+  }
+}
+
+/*********************************************************************
+*
+*       _PostTerminalSwitch()
+*
+*  Function description
+*    Switch terminal to the given terminal ID.  It is the caller's
+*    responsibility to ensure the terminal ID is correct and there is
+*    enough space in the buffer for this to complete successfully.
+*
+*  Parameters
+*    pRing        Ring buffer to post to.
+*    TerminalId   Terminal ID to switch to.
+*/
+static void _PostTerminalSwitch(SEGGER_RTT_BUFFER_UP* pRing, unsigned char TerminalId) {
+  unsigned char ac[2];
+
+  ac[0] = 0xFFu;
+  ac[1] = _aTerminalId[TerminalId];  // Caller made already sure that TerminalId does not exceed our terminal limit
+  _WriteBlocking(pRing, (const char*)ac, 2u);
+}
+
+/*********************************************************************
+*
+*       _GetAvailWriteSpace()
+*
+*  Function description
+*    Returns the number of bytes that can be written to the ring
+*    buffer without blocking.
+*
+*  Parameters
+*    pRing        Ring buffer to check.
+*
+*  Return value
+*    Number of bytes that are free in the buffer.
+*/
+static unsigned _GetAvailWriteSpace(SEGGER_RTT_BUFFER_UP* pRing) {
+  unsigned RdOff;
+  unsigned WrOff;
+  unsigned r;
+  //
+  // Avoid warnings regarding volatile access order.  It's not a problem
+  // in this case, but dampen compiler enthusiasm.
+  //
+  RdOff = pRing->RdOff;
+  WrOff = pRing->WrOff;
+  if (RdOff <= WrOff) {
+    r = pRing->SizeOfBuffer - 1u - WrOff + RdOff;
+  } else {
+    r = RdOff - WrOff - 1u;
+  }
+  return r;
+}
+
+/*********************************************************************
+*
+*       Public code
+*
+**********************************************************************
+*/
+/*********************************************************************
+*
+*       SEGGER_RTT_ReadUpBufferNoLock()
+*
+*  Function description
+*    Reads characters from SEGGER real-time-terminal control block
+*    which have been previously stored by the application.
+*    Do not lock against interrupts and multiple access.
+*    Used to do the same operation that J-Link does, to transfer 
+*    RTT data via other channels, such as TCP/IP or UART.
+*
+*  Parameters
+*    BufferIndex  Index of Up-buffer to be used.
+*    pBuffer      Pointer to buffer provided by target application, to copy characters from RTT-up-buffer to.
+*    BufferSize   Size of the target application buffer.
+*
+*  Return value
+*    Number of bytes that have been read.
+*
+*  Additional information
+*    This function must not be called when J-Link might also do RTT.
+*/
+unsigned SEGGER_RTT_ReadUpBufferNoLock(unsigned BufferIndex, void* pData, unsigned BufferSize) {
+  unsigned                NumBytesRem;
+  unsigned                NumBytesRead;
+  unsigned                RdOff;
+  unsigned                WrOff;
+  unsigned char*          pBuffer;
+  SEGGER_RTT_BUFFER_UP*   pRing;
+#if SEGGER_RTT_MEMCPY_USE_BYTELOOP
+  const char*             pSrc;
+#endif
+  //
+  INIT();
+  pRing = &_SEGGER_RTT.aUp[BufferIndex];
+  pBuffer = (unsigned char*)pData;
+  RdOff = pRing->RdOff;
+  WrOff = pRing->WrOff;
+  NumBytesRead = 0u;
+  //
+  // Read from current read position to wrap-around of buffer, first
+  //
+  if (RdOff > WrOff) {
+    NumBytesRem = pRing->SizeOfBuffer - RdOff;
+    NumBytesRem = MIN(NumBytesRem, BufferSize);
+#if SEGGER_RTT_MEMCPY_USE_BYTELOOP
+    pSrc = pRing->pBuffer + RdOff;
+    NumBytesRead += NumBytesRem;
+    BufferSize   -= NumBytesRem;
+    RdOff        += NumBytesRem;
+    while (NumBytesRem--) {
+      *pBuffer++ = *pSrc++;
+    };
+#else
+    SEGGER_RTT_MEMCPY(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
+    NumBytesRead += NumBytesRem;
+    pBuffer      += NumBytesRem;
+    BufferSize   -= NumBytesRem;
+    RdOff        += NumBytesRem;
+#endif
+    //
+    // Handle wrap-around of buffer
+    //
+    if (RdOff == pRing->SizeOfBuffer) {
+      RdOff = 0u;
+    }
+  }
+  //
+  // Read remaining items of buffer
+  //
+  NumBytesRem = WrOff - RdOff;
+  NumBytesRem = MIN(NumBytesRem, BufferSize);
+  if (NumBytesRem > 0u) {
+#if SEGGER_RTT_MEMCPY_USE_BYTELOOP
+    pSrc = pRing->pBuffer + RdOff;
+    NumBytesRead += NumBytesRem;
+    BufferSize   -= NumBytesRem;
+    RdOff        += NumBytesRem;
+    while (NumBytesRem--) {
+      *pBuffer++ = *pSrc++;
+    };
+#else
+    SEGGER_RTT_MEMCPY(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
+    NumBytesRead += NumBytesRem;
+    pBuffer      += NumBytesRem;
+    BufferSize   -= NumBytesRem;
+    RdOff        += NumBytesRem;
+#endif
+  }
+  //
+  // Update read offset of buffer
+  //
+  if (NumBytesRead) {
+    pRing->RdOff = RdOff;
+  }
+  //
+  return NumBytesRead;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_ReadNoLock()
+*
+*  Function description
+*    Reads characters from SEGGER real-time-terminal control block
+*    which have been previously stored by the host.
+*    Do not lock against interrupts and multiple access.
+*
+*  Parameters
+*    BufferIndex  Index of Down-buffer to be used (e.g. 0 for "Terminal").
+*    pBuffer      Pointer to buffer provided by target application, to copy characters from RTT-down-buffer to.
+*    BufferSize   Size of the target application buffer.
+*
+*  Return value
+*    Number of bytes that have been read.
+*/
+unsigned SEGGER_RTT_ReadNoLock(unsigned BufferIndex, void* pData, unsigned BufferSize) {
+  unsigned                NumBytesRem;
+  unsigned                NumBytesRead;
+  unsigned                RdOff;
+  unsigned                WrOff;
+  unsigned char*          pBuffer;
+  SEGGER_RTT_BUFFER_DOWN* pRing;
+#if SEGGER_RTT_MEMCPY_USE_BYTELOOP
+  const char*             pSrc;
+#endif
+  //
+  INIT();
+  pRing = &_SEGGER_RTT.aDown[BufferIndex];
+  pBuffer = (unsigned char*)pData;
+  RdOff = pRing->RdOff;
+  WrOff = pRing->WrOff;
+  NumBytesRead = 0u;
+  //
+  // Read from current read position to wrap-around of buffer, first
+  //
+  if (RdOff > WrOff) {
+    NumBytesRem = pRing->SizeOfBuffer - RdOff;
+    NumBytesRem = MIN(NumBytesRem, BufferSize);
+#if SEGGER_RTT_MEMCPY_USE_BYTELOOP
+    pSrc = pRing->pBuffer + RdOff;
+    NumBytesRead += NumBytesRem;
+    BufferSize   -= NumBytesRem;
+    RdOff        += NumBytesRem;
+    while (NumBytesRem--) {
+      *pBuffer++ = *pSrc++;
+    };
+#else
+    SEGGER_RTT_MEMCPY(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
+    NumBytesRead += NumBytesRem;
+    pBuffer      += NumBytesRem;
+    BufferSize   -= NumBytesRem;
+    RdOff        += NumBytesRem;
+#endif
+    //
+    // Handle wrap-around of buffer
+    //
+    if (RdOff == pRing->SizeOfBuffer) {
+      RdOff = 0u;
+    }
+  }
+  //
+  // Read remaining items of buffer
+  //
+  NumBytesRem = WrOff - RdOff;
+  NumBytesRem = MIN(NumBytesRem, BufferSize);
+  if (NumBytesRem > 0u) {
+#if SEGGER_RTT_MEMCPY_USE_BYTELOOP
+    pSrc = pRing->pBuffer + RdOff;
+    NumBytesRead += NumBytesRem;
+    BufferSize   -= NumBytesRem;
+    RdOff        += NumBytesRem;
+    while (NumBytesRem--) {
+      *pBuffer++ = *pSrc++;
+    };
+#else
+    SEGGER_RTT_MEMCPY(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
+    NumBytesRead += NumBytesRem;
+    pBuffer      += NumBytesRem;
+    BufferSize   -= NumBytesRem;
+    RdOff        += NumBytesRem;
+#endif
+  }
+  if (NumBytesRead) {
+    pRing->RdOff = RdOff;
+  }
+  //
+  return NumBytesRead;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_ReadUpBuffer
+*
+*  Function description
+*    Reads characters from SEGGER real-time-terminal control block
+*    which have been previously stored by the application.
+*    Used to do the same operation that J-Link does, to transfer 
+*    RTT data via other channels, such as TCP/IP or UART.
+*
+*  Parameters
+*    BufferIndex  Index of Up-buffer to be used.
+*    pBuffer      Pointer to buffer provided by target application, to copy characters from RTT-up-buffer to.
+*    BufferSize   Size of the target application buffer.
+*
+*  Return value
+*    Number of bytes that have been read.
+*
+*  Additional information
+*    This function must not be called when J-Link might also do RTT.
+*    This function locks against all other RTT operations. I.e. during
+*    the read operation, writing is also locked.
+*    If only one consumer reads from the up buffer, 
+*    call sEGGER_RTT_ReadUpBufferNoLock() instead.
+*/
+unsigned SEGGER_RTT_ReadUpBuffer(unsigned BufferIndex, void* pBuffer, unsigned BufferSize) {
+  unsigned NumBytesRead;
+  //
+  SEGGER_RTT_LOCK();
+  //
+  // Call the non-locking read function
+  //
+  NumBytesRead = SEGGER_RTT_ReadUpBufferNoLock(BufferIndex, pBuffer, BufferSize);
+  //
+  // Finish up.
+  //
+  SEGGER_RTT_UNLOCK();
+  //
+  return NumBytesRead;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_Read
+*
+*  Function description
+*    Reads characters from SEGGER real-time-terminal control block
+*    which have been previously stored by the host.
+*
+*  Parameters
+*    BufferIndex  Index of Down-buffer to be used (e.g. 0 for "Terminal").
+*    pBuffer      Pointer to buffer provided by target application, to copy characters from RTT-down-buffer to.
+*    BufferSize   Size of the target application buffer.
+*
+*  Return value
+*    Number of bytes that have been read.
+*/
+unsigned SEGGER_RTT_Read(unsigned BufferIndex, void* pBuffer, unsigned BufferSize) {
+  unsigned NumBytesRead;
+  //
+  SEGGER_RTT_LOCK();
+  //
+  // Call the non-locking read function
+  //
+  NumBytesRead = SEGGER_RTT_ReadNoLock(BufferIndex, pBuffer, BufferSize);
+  //
+  // Finish up.
+  //
+  SEGGER_RTT_UNLOCK();
+  //
+  return NumBytesRead;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_WriteWithOverwriteNoLock
+*
+*  Function description
+*    Stores a specified number of characters in SEGGER RTT
+*    control block.
+*    SEGGER_RTT_WriteWithOverwriteNoLock does not lock the application 
+*    and overwrites data if the data does not fit into the buffer.
+*
+*  Parameters
+*    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
+*    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
+*    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
+*
+*  Notes
+*    (1) If there is not enough space in the "Up"-buffer, data is overwritten.
+*    (2) For performance reasons this function does not call Init()
+*        and may only be called after RTT has been initialized.
+*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
+*    (3) Do not use SEGGER_RTT_WriteWithOverwriteNoLock if a J-Link 
+*        connection reads RTT data.
+*/
+void SEGGER_RTT_WriteWithOverwriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
+  const char*           pData;
+  SEGGER_RTT_BUFFER_UP* pRing;
+  unsigned              Avail;
+#if SEGGER_RTT_MEMCPY_USE_BYTELOOP
+  char*                 pDst;
+#endif
+
+  pData = (const char *)pBuffer;
+  //
+  // Get "to-host" ring buffer and copy some elements into local variables.
+  //
+  pRing = &_SEGGER_RTT.aUp[BufferIndex];
+  //
+  // Check if we will overwrite data and need to adjust the RdOff.
+  //
+  if (pRing->WrOff == pRing->RdOff) {
+    Avail = pRing->SizeOfBuffer - 1u;
+  } else if ( pRing->WrOff < pRing->RdOff) {
+    Avail = pRing->RdOff - pRing->WrOff - 1u;
+  } else {
+    Avail = pRing->RdOff - pRing->WrOff - 1u + pRing->SizeOfBuffer;
+  }
+  if (NumBytes > Avail) {
+    pRing->RdOff += (NumBytes - Avail);
+    while (pRing->RdOff >= pRing->SizeOfBuffer) {
+      pRing->RdOff -= pRing->SizeOfBuffer;
+    }
+  }
+  //
+  // Write all data, no need to check the RdOff, but possibly handle multiple wrap-arounds
+  //
+  Avail = pRing->SizeOfBuffer - pRing->WrOff;
+  do {
+    if (Avail > NumBytes) {
+      //
+      // Last round
+      //
+#if SEGGER_RTT_MEMCPY_USE_BYTELOOP
+      pDst = pRing->pBuffer + pRing->WrOff;
+      Avail = NumBytes;
+      while (NumBytes--) {
+        *pDst++ = *pData++;
+      };
+      pRing->WrOff += Avail;
+#else
+      SEGGER_RTT_MEMCPY(pRing->pBuffer + pRing->WrOff, pData, NumBytes);
+      pRing->WrOff += NumBytes;
+#endif
+      break;
+    } else {
+      //
+      //  Wrap-around necessary, write until wrap-around and reset WrOff
+      //
+#if SEGGER_RTT_MEMCPY_USE_BYTELOOP
+      pDst = pRing->pBuffer + pRing->WrOff;
+      NumBytes -= Avail;
+      while (Avail--) {
+        *pDst++ = *pData++;
+      };
+      pRing->WrOff = 0;
+#else
+      SEGGER_RTT_MEMCPY(pRing->pBuffer + pRing->WrOff, pData, Avail);
+      pData += Avail;
+      pRing->WrOff = 0;
+      NumBytes -= Avail;
+#endif
+      Avail = (pRing->SizeOfBuffer - 1);
+    }
+  } while (NumBytes);
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_WriteSkipNoLock
+*
+*  Function description
+*    Stores a specified number of characters in SEGGER RTT
+*    control block which is then read by the host.
+*    SEGGER_RTT_WriteSkipNoLock does not lock the application and
+*    skips all data, if the data does not fit into the buffer.
+*
+*  Parameters
+*    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
+*    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
+*    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
+*                 MUST be > 0!!!
+*                 This is done for performance reasons, so no initial check has do be done.
+*
+*  Return value
+*    1: Data has been copied
+*    0: No space, data has not been copied
+*
+*  Notes
+*    (1) If there is not enough space in the "Up"-buffer, all data is dropped.
+*    (2) For performance reasons this function does not call Init()
+*        and may only be called after RTT has been initialized.
+*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
+*/
+#if (RTT_USE_ASM == 0)
+unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
+  const char*           pData;
+  SEGGER_RTT_BUFFER_UP* pRing;
+  unsigned              Avail;
+  unsigned              RdOff;
+  unsigned              WrOff;
+  unsigned              Rem;
+  //
+  // Cases:
+  //   1) RdOff <= WrOff => Space until wrap-around is sufficient
+  //   2) RdOff <= WrOff => Space after wrap-around needed (copy in 2 chunks)
+  //   3) RdOff <  WrOff => No space in buf
+  //   4) RdOff >  WrOff => Space is sufficient
+  //   5) RdOff >  WrOff => No space in buf
+  //
+  // 1) is the most common case for large buffers and assuming that J-Link reads the data fast enough
+  //
+  pData = (const char *)pBuffer;
+  pRing = &_SEGGER_RTT.aUp[BufferIndex];
+  RdOff = pRing->RdOff;
+  WrOff = pRing->WrOff;
+  if (RdOff <= WrOff) {                                 // Case 1), 2) or 3)
+    Avail = pRing->SizeOfBuffer - WrOff - 1u;           // Space until wrap-around (assume 1 byte not usable for case that RdOff == 0)
+    if (Avail >= NumBytes) {                            // Case 1)?
+CopyStraight:
+      memcpy(pRing->pBuffer + WrOff, pData, NumBytes);
+      pRing->WrOff = WrOff + NumBytes;
+      return 1;
+    }
+    Avail += RdOff;                                     // Space incl. wrap-around
+    if (Avail >= NumBytes) {                            // Case 2? => If not, we have case 3) (does not fit)
+      Rem = pRing->SizeOfBuffer - WrOff;                // Space until end of buffer
+      memcpy(pRing->pBuffer + WrOff, pData, Rem);       // Copy 1st chunk
+      NumBytes -= Rem;
+      //
+      // Special case: First check that assumed RdOff == 0 calculated that last element before wrap-around could not be used
+      // But 2nd check (considering space until wrap-around and until RdOff) revealed that RdOff is not 0, so we can use the last element
+      // In this case, we may use a copy straight until buffer end anyway without needing to copy 2 chunks
+      // Therefore, check if 2nd memcpy is necessary at all
+      //
+      if (NumBytes) {
+        memcpy(pRing->pBuffer, pData + Rem, NumBytes);
+      }
+      pRing->WrOff = NumBytes;
+      return 1;
+    }
+  } else {                                             // Potential case 4)
+    Avail = RdOff - WrOff - 1u;
+    if (Avail >= NumBytes) {                           // Case 4)? => If not, we have case 5) (does not fit)
+      goto CopyStraight;
+    }
+  }
+  return 0;     // No space in buffer
+}
+#endif
+
+/*********************************************************************
+*
+*       SEGGER_RTT_WriteDownBufferNoLock
+*
+*  Function description
+*    Stores a specified number of characters in SEGGER RTT
+*    control block inside a <Down> buffer.
+*    SEGGER_RTT_WriteDownBufferNoLock does not lock the application.
+*    Used to do the same operation that J-Link does, to transfer 
+*    RTT data from other channels, such as TCP/IP or UART.
+*
+*  Parameters
+*    BufferIndex  Index of "Down"-buffer to be used.
+*    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
+*    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
+*
+*  Return value
+*    Number of bytes which have been stored in the "Down"-buffer.
+*
+*  Notes
+*    (1) Data is stored according to buffer flags.
+*    (2) For performance reasons this function does not call Init()
+*        and may only be called after RTT has been initialized.
+*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
+*
+*  Additional information
+*    This function must not be called when J-Link might also do RTT.
+*/
+unsigned SEGGER_RTT_WriteDownBufferNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
+  unsigned                Status;
+  unsigned                Avail;
+  const char*             pData;
+  SEGGER_RTT_BUFFER_UP*   pRing;
+
+  pData = (const char *)pBuffer;
+  //
+  // Get "to-target" ring buffer.
+  // It is save to cast that to a "to-host" buffer. Up and Down buffer differ in volatility of offsets that might be modified by J-Link.
+  //
+  pRing = (SEGGER_RTT_BUFFER_UP*)&_SEGGER_RTT.aDown[BufferIndex];
+  //
+  // How we output depends upon the mode...
+  //
+  switch (pRing->Flags) {
+  case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
+    //
+    // If we are in skip mode and there is no space for the whole
+    // of this output, don't bother.
+    //
+    Avail = _GetAvailWriteSpace(pRing);
+    if (Avail < NumBytes) {
+      Status = 0u;
+    } else {
+      Status = NumBytes;
+      _WriteNoCheck(pRing, pData, NumBytes);
+    }
+    break;
+  case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
+    //
+    // If we are in trim mode, trim to what we can output without blocking.
+    //
+    Avail = _GetAvailWriteSpace(pRing);
+    Status = Avail < NumBytes ? Avail : NumBytes;
+    _WriteNoCheck(pRing, pData, Status);
+    break;
+  case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
+    //
+    // If we are in blocking mode, output everything.
+    //
+    Status = _WriteBlocking(pRing, pData, NumBytes);
+    break;
+  default:
+    Status = 0u;
+    break;
+  }
+  //
+  // Finish up.
+  //
+  return Status;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_WriteNoLock
+*
+*  Function description
+*    Stores a specified number of characters in SEGGER RTT
+*    control block which is then read by the host.
+*    SEGGER_RTT_WriteNoLock does not lock the application.
+*
+*  Parameters
+*    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
+*    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
+*    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
+*
+*  Return value
+*    Number of bytes which have been stored in the "Up"-buffer.
+*
+*  Notes
+*    (1) Data is stored according to buffer flags.
+*    (2) For performance reasons this function does not call Init()
+*        and may only be called after RTT has been initialized.
+*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
+*/
+unsigned SEGGER_RTT_WriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
+  unsigned              Status;
+  unsigned              Avail;
+  const char*           pData;
+  SEGGER_RTT_BUFFER_UP* pRing;
+
+  pData = (const char *)pBuffer;
+  //
+  // Get "to-host" ring buffer.
+  //
+  pRing = &_SEGGER_RTT.aUp[BufferIndex];
+  //
+  // How we output depends upon the mode...
+  //
+  switch (pRing->Flags) {
+  case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
+    //
+    // If we are in skip mode and there is no space for the whole
+    // of this output, don't bother.
+    //
+    Avail = _GetAvailWriteSpace(pRing);
+    if (Avail < NumBytes) {
+      Status = 0u;
+    } else {
+      Status = NumBytes;
+      _WriteNoCheck(pRing, pData, NumBytes);
+    }
+    break;
+  case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
+    //
+    // If we are in trim mode, trim to what we can output without blocking.
+    //
+    Avail = _GetAvailWriteSpace(pRing);
+    Status = Avail < NumBytes ? Avail : NumBytes;
+    _WriteNoCheck(pRing, pData, Status);
+    break;
+  case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
+    //
+    // If we are in blocking mode, output everything.
+    //
+    Status = _WriteBlocking(pRing, pData, NumBytes);
+    break;
+  default:
+    Status = 0u;
+    break;
+  }
+  //
+  // Finish up.
+  //
+  return Status;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_WriteDownBuffer
+*
+*  Function description
+*    Stores a specified number of characters in SEGGER RTT control block in a <Down> buffer.
+*
+*  Parameters
+*    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
+*    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
+*    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
+*
+*  Return value
+*    Number of bytes which have been stored in the "Down"-buffer.
+*
+*  Notes
+*    (1) Data is stored according to buffer flags.
+*
+*  Additional information
+*    This function must not be called when J-Link might also do RTT.
+*    This function locks against all other RTT operations. I.e. during
+*    the write operation, writing from the application is also locked.
+*    If only one consumer writes to the down buffer, 
+*    call SEGGER_RTT_WriteDownBufferNoLock() instead.
+*/
+unsigned SEGGER_RTT_WriteDownBuffer(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
+  unsigned Status;
+  //
+  INIT();
+  SEGGER_RTT_LOCK();
+  //
+  // Call the non-locking write function
+  //
+  Status = SEGGER_RTT_WriteDownBufferNoLock(BufferIndex, pBuffer, NumBytes);
+  //
+  // Finish up.
+  //
+  SEGGER_RTT_UNLOCK();
+  //
+  return Status;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_Write
+*
+*  Function description
+*    Stores a specified number of characters in SEGGER RTT
+*    control block which is then read by the host.
+*
+*  Parameters
+*    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
+*    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
+*    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
+*
+*  Return value
+*    Number of bytes which have been stored in the "Up"-buffer.
+*
+*  Notes
+*    (1) Data is stored according to buffer flags.
+*/
+unsigned SEGGER_RTT_Write(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
+  unsigned Status;
+  //
+  INIT();
+  SEGGER_RTT_LOCK();
+  //
+  // Call the non-locking write function
+  //
+  Status = SEGGER_RTT_WriteNoLock(BufferIndex, pBuffer, NumBytes);
+  //
+  // Finish up.
+  //
+  SEGGER_RTT_UNLOCK();
+  //
+  return Status;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_WriteString
+*
+*  Function description
+*    Stores string in SEGGER RTT control block.
+*    This data is read by the host.
+*
+*  Parameters
+*    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
+*    s            Pointer to string.
+*
+*  Return value
+*    Number of bytes which have been stored in the "Up"-buffer.
+*
+*  Notes
+*    (1) Data is stored according to buffer flags.
+*    (2) String passed to this function has to be \0 terminated
+*    (3) \0 termination character is *not* stored in RTT buffer
+*/
+unsigned SEGGER_RTT_WriteString(unsigned BufferIndex, const char* s) {
+  unsigned Len;
+
+  Len = STRLEN(s);
+  return SEGGER_RTT_Write(BufferIndex, s, Len);
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_PutCharSkipNoLock
+*
+*  Function description
+*    Stores a single character/byte in SEGGER RTT buffer.
+*    SEGGER_RTT_PutCharSkipNoLock does not lock the application and
+*    skips the byte, if it does not fit into the buffer.
+*
+*  Parameters
+*    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
+*    c            Byte to be stored.
+*
+*  Return value
+*    Number of bytes which have been stored in the "Up"-buffer.
+*
+*  Notes
+*    (1) If there is not enough space in the "Up"-buffer, the character is dropped.
+*    (2) For performance reasons this function does not call Init()
+*        and may only be called after RTT has been initialized.
+*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
+*/
+
+unsigned SEGGER_RTT_PutCharSkipNoLock(unsigned BufferIndex, char c) {
+  SEGGER_RTT_BUFFER_UP* pRing;
+  unsigned              WrOff;
+  unsigned              Status;
+  //
+  // Get "to-host" ring buffer.
+  //
+  pRing = &_SEGGER_RTT.aUp[BufferIndex];
+  //
+  // Get write position and handle wrap-around if necessary
+  //
+  WrOff = pRing->WrOff + 1;
+  if (WrOff == pRing->SizeOfBuffer) {
+    WrOff = 0;
+  }
+  //
+  // Output byte if free space is available
+  //
+  if (WrOff != pRing->RdOff) {
+    pRing->pBuffer[pRing->WrOff] = c;
+    pRing->WrOff = WrOff;
+    Status = 1;
+  } else {
+    Status = 0;
+  }
+  //
+  return Status;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_PutCharSkip
+*
+*  Function description
+*    Stores a single character/byte in SEGGER RTT buffer.
+*
+*  Parameters
+*    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
+*    c            Byte to be stored.
+*
+*  Return value
+*    Number of bytes which have been stored in the "Up"-buffer.
+*
+*  Notes
+*    (1) If there is not enough space in the "Up"-buffer, the character is dropped.
+*/
+
+unsigned SEGGER_RTT_PutCharSkip(unsigned BufferIndex, char c) {
+  SEGGER_RTT_BUFFER_UP* pRing;
+  unsigned              WrOff;
+  unsigned              Status;
+  //
+  // Prepare
+  //
+  INIT();
+  SEGGER_RTT_LOCK();
+  //
+  // Get "to-host" ring buffer.
+  //
+  pRing = &_SEGGER_RTT.aUp[BufferIndex];
+  //
+  // Get write position and handle wrap-around if necessary
+  //
+  WrOff = pRing->WrOff + 1;
+  if (WrOff == pRing->SizeOfBuffer) {
+    WrOff = 0;
+  }
+  //
+  // Output byte if free space is available
+  //
+  if (WrOff != pRing->RdOff) {
+    pRing->pBuffer[pRing->WrOff] = c;
+    pRing->WrOff = WrOff;
+    Status = 1;
+  } else {
+    Status = 0;
+  }
+  //
+  // Finish up.
+  //
+  SEGGER_RTT_UNLOCK();
+  //
+  return Status;
+}
+
+ /*********************************************************************
+*
+*       SEGGER_RTT_PutChar
+*
+*  Function description
+*    Stores a single character/byte in SEGGER RTT buffer.
+*
+*  Parameters
+*    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
+*    c            Byte to be stored.
+*
+*  Return value
+*    Number of bytes which have been stored in the "Up"-buffer.
+*
+*  Notes
+*    (1) Data is stored according to buffer flags.
+*/
+
+unsigned SEGGER_RTT_PutChar(unsigned BufferIndex, char c) {
+  SEGGER_RTT_BUFFER_UP* pRing;
+  unsigned              WrOff;
+  unsigned              Status;
+  //
+  // Prepare
+  //
+  INIT();
+  SEGGER_RTT_LOCK();
+  //
+  // Get "to-host" ring buffer.
+  //
+  pRing = &_SEGGER_RTT.aUp[BufferIndex];
+  //
+  // Get write position and handle wrap-around if necessary
+  //
+  WrOff = pRing->WrOff + 1;
+  if (WrOff == pRing->SizeOfBuffer) {
+    WrOff = 0;
+  }
+  //
+  // Wait for free space if mode is set to blocking
+  //
+  if (pRing->Flags == SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL) {
+    while (WrOff == pRing->RdOff) {
+      ;
+    }
+  }
+  //
+  // Output byte if free space is available
+  //
+  if (WrOff != pRing->RdOff) {
+    pRing->pBuffer[pRing->WrOff] = c;
+    pRing->WrOff = WrOff;
+    Status = 1;
+  } else {
+    Status = 0;
+  }
+  //
+  // Finish up.
+  //
+  SEGGER_RTT_UNLOCK();
+  //
+  return Status;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_GetKey
+*
+*  Function description
+*    Reads one character from the SEGGER RTT buffer.
+*    Host has previously stored data there.
+*
+*  Return value
+*    <  0 -   No character available (buffer empty).
+*    >= 0 -   Character which has been read. (Possible values: 0 - 255)
+*
+*  Notes
+*    (1) This function is only specified for accesses to RTT buffer 0.
+*/
+int SEGGER_RTT_GetKey(void) {
+  char c;
+  int r;
+
+  r = (int)SEGGER_RTT_Read(0u, &c, 1u);
+  if (r == 1) {
+    r = (int)(unsigned char)c;
+  } else {
+    r = -1;
+  }
+  return r;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_WaitKey
+*
+*  Function description
+*    Waits until at least one character is avaible in the SEGGER RTT buffer.
+*    Once a character is available, it is read and this function returns.
+*
+*  Return value
+*    >=0 -   Character which has been read.
+*
+*  Notes
+*    (1) This function is only specified for accesses to RTT buffer 0
+*    (2) This function is blocking if no character is present in RTT buffer
+*/
+int SEGGER_RTT_WaitKey(void) {
+  int r;
+
+  do {
+    r = SEGGER_RTT_GetKey();
+  } while (r < 0);
+  return r;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_HasKey
+*
+*  Function description
+*    Checks if at least one character for reading is available in the SEGGER RTT buffer.
+*
+*  Return value
+*    == 0 -     No characters are available to read.
+*    == 1 -     At least one character is available.
+*
+*  Notes
+*    (1) This function is only specified for accesses to RTT buffer 0
+*/
+int SEGGER_RTT_HasKey(void) {
+  unsigned RdOff;
+  int r;
+
+  INIT();
+  RdOff = _SEGGER_RTT.aDown[0].RdOff;
+  if (RdOff != _SEGGER_RTT.aDown[0].WrOff) {
+    r = 1;
+  } else {
+    r = 0;
+  }
+  return r;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_HasData
+*
+*  Function description
+*    Check if there is data from the host in the given buffer.
+*
+*  Return value:
+*  ==0:  No data
+*  !=0:  Data in buffer
+*
+*/
+unsigned SEGGER_RTT_HasData(unsigned BufferIndex) {
+  SEGGER_RTT_BUFFER_DOWN* pRing;
+  unsigned                v;
+
+  pRing = &_SEGGER_RTT.aDown[BufferIndex];
+  v = pRing->WrOff;
+  return v - pRing->RdOff;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_HasDataUp
+*
+*  Function description
+*    Check if there is data remaining to be sent in the given buffer.
+*
+*  Return value:
+*  ==0:  No data
+*  !=0:  Data in buffer
+*
+*/
+unsigned SEGGER_RTT_HasDataUp(unsigned BufferIndex) {
+  SEGGER_RTT_BUFFER_UP* pRing;
+  unsigned                v;
+
+  pRing = &_SEGGER_RTT.aUp[BufferIndex];
+  v = pRing->RdOff;
+  return pRing->WrOff - v;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_AllocDownBuffer
+*
+*  Function description
+*    Run-time configuration of the next down-buffer (H->T).
+*    The next buffer, which is not used yet is configured.
+*    This includes: Buffer address, size, name, flags, ...
+*
+*  Parameters
+*    sName        Pointer to a constant name string.
+*    pBuffer      Pointer to a buffer to be used.
+*    BufferSize   Size of the buffer.
+*    Flags        Operating modes. Define behavior if buffer is full (not enough space for entire message).
+*
+*  Return value
+*    >= 0 - O.K. Buffer Index
+*     < 0 - Error
+*/
+int SEGGER_RTT_AllocDownBuffer(const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
+  int BufferIndex;
+
+  INIT();
+  SEGGER_RTT_LOCK();
+  BufferIndex = 0;
+  do {
+    if (_SEGGER_RTT.aDown[BufferIndex].pBuffer == NULL) {
+      break;
+    }
+    BufferIndex++;
+  } while (BufferIndex < _SEGGER_RTT.MaxNumDownBuffers);
+  if (BufferIndex < _SEGGER_RTT.MaxNumDownBuffers) {
+    _SEGGER_RTT.aDown[BufferIndex].sName        = sName;
+    _SEGGER_RTT.aDown[BufferIndex].pBuffer      = (char*)pBuffer;
+    _SEGGER_RTT.aDown[BufferIndex].SizeOfBuffer = BufferSize;
+    _SEGGER_RTT.aDown[BufferIndex].RdOff        = 0u;
+    _SEGGER_RTT.aDown[BufferIndex].WrOff        = 0u;
+    _SEGGER_RTT.aDown[BufferIndex].Flags        = Flags;
+  } else {
+    BufferIndex = -1;
+  }
+  SEGGER_RTT_UNLOCK();
+  return BufferIndex;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_AllocUpBuffer
+*
+*  Function description
+*    Run-time configuration of the next up-buffer (T->H).
+*    The next buffer, which is not used yet is configured.
+*    This includes: Buffer address, size, name, flags, ...
+*
+*  Parameters
+*    sName        Pointer to a constant name string.
+*    pBuffer      Pointer to a buffer to be used.
+*    BufferSize   Size of the buffer.
+*    Flags        Operating modes. Define behavior if buffer is full (not enough space for entire message).
+*
+*  Return value
+*    >= 0 - O.K. Buffer Index
+*     < 0 - Error
+*/
+int SEGGER_RTT_AllocUpBuffer(const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
+  int BufferIndex;
+
+  INIT();
+  SEGGER_RTT_LOCK();
+  BufferIndex = 0;
+  do {
+    if (_SEGGER_RTT.aUp[BufferIndex].pBuffer == NULL) {
+      break;
+    }
+    BufferIndex++;
+  } while (BufferIndex < _SEGGER_RTT.MaxNumUpBuffers);
+  if (BufferIndex < _SEGGER_RTT.MaxNumUpBuffers) {
+    _SEGGER_RTT.aUp[BufferIndex].sName        = sName;
+    _SEGGER_RTT.aUp[BufferIndex].pBuffer      = (char*)pBuffer;
+    _SEGGER_RTT.aUp[BufferIndex].SizeOfBuffer = BufferSize;
+    _SEGGER_RTT.aUp[BufferIndex].RdOff        = 0u;
+    _SEGGER_RTT.aUp[BufferIndex].WrOff        = 0u;
+    _SEGGER_RTT.aUp[BufferIndex].Flags        = Flags;
+  } else {
+    BufferIndex = -1;
+  }
+  SEGGER_RTT_UNLOCK();
+  return BufferIndex;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_ConfigUpBuffer
+*
+*  Function description
+*    Run-time configuration of a specific up-buffer (T->H).
+*    Buffer to be configured is specified by index.
+*    This includes: Buffer address, size, name, flags, ...
+*
+*  Parameters
+*    BufferIndex  Index of the buffer to configure.
+*    sName        Pointer to a constant name string.
+*    pBuffer      Pointer to a buffer to be used.
+*    BufferSize   Size of the buffer.
+*    Flags        Operating modes. Define behavior if buffer is full (not enough space for entire message).
+*
+*  Return value
+*    >= 0 - O.K.
+*     < 0 - Error
+*
+*  Additional information
+*    Buffer 0 is configured on compile-time.
+*    May only be called once per buffer.
+*    Buffer name and flags can be reconfigured using the appropriate functions.
+*/
+int SEGGER_RTT_ConfigUpBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
+  int r;
+
+  INIT();
+  if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumUpBuffers) {
+    SEGGER_RTT_LOCK();
+    if (BufferIndex > 0u) {
+      _SEGGER_RTT.aUp[BufferIndex].sName        = sName;
+      _SEGGER_RTT.aUp[BufferIndex].pBuffer      = (char*)pBuffer;
+      _SEGGER_RTT.aUp[BufferIndex].SizeOfBuffer = BufferSize;
+      _SEGGER_RTT.aUp[BufferIndex].RdOff        = 0u;
+      _SEGGER_RTT.aUp[BufferIndex].WrOff        = 0u;
+    }
+    _SEGGER_RTT.aUp[BufferIndex].Flags          = Flags;
+    SEGGER_RTT_UNLOCK();
+    r =  0;
+  } else {
+    r = -1;
+  }
+  return r;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_ConfigDownBuffer
+*
+*  Function description
+*    Run-time configuration of a specific down-buffer (H->T).
+*    Buffer to be configured is specified by index.
+*    This includes: Buffer address, size, name, flags, ...
+*
+*  Parameters
+*    BufferIndex  Index of the buffer to configure.
+*    sName        Pointer to a constant name string.
+*    pBuffer      Pointer to a buffer to be used.
+*    BufferSize   Size of the buffer.
+*    Flags        Operating modes. Define behavior if buffer is full (not enough space for entire message).
+*
+*  Return value
+*    >= 0  O.K.
+*     < 0  Error
+*
+*  Additional information
+*    Buffer 0 is configured on compile-time.
+*    May only be called once per buffer.
+*    Buffer name and flags can be reconfigured using the appropriate functions.
+*/
+int SEGGER_RTT_ConfigDownBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
+  int r;
+
+  INIT();
+  if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumDownBuffers) {
+    SEGGER_RTT_LOCK();
+    if (BufferIndex > 0u) {
+      _SEGGER_RTT.aDown[BufferIndex].sName        = sName;
+      _SEGGER_RTT.aDown[BufferIndex].pBuffer      = (char*)pBuffer;
+      _SEGGER_RTT.aDown[BufferIndex].SizeOfBuffer = BufferSize;
+      _SEGGER_RTT.aDown[BufferIndex].RdOff        = 0u;
+      _SEGGER_RTT.aDown[BufferIndex].WrOff        = 0u;
+    }
+    _SEGGER_RTT.aDown[BufferIndex].Flags          = Flags;
+    SEGGER_RTT_UNLOCK();
+    r =  0;
+  } else {
+    r = -1;
+  }
+  return r;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_SetNameUpBuffer
+*
+*  Function description
+*    Run-time configuration of a specific up-buffer name (T->H).
+*    Buffer to be configured is specified by index.
+*
+*  Parameters
+*    BufferIndex  Index of the buffer to renamed.
+*    sName        Pointer to a constant name string.
+*
+*  Return value
+*    >= 0  O.K.
+*     < 0  Error
+*/
+int SEGGER_RTT_SetNameUpBuffer(unsigned BufferIndex, const char* sName) {
+  int r;
+
+  INIT();
+  if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumUpBuffers) {
+    SEGGER_RTT_LOCK();
+    _SEGGER_RTT.aUp[BufferIndex].sName = sName;
+    SEGGER_RTT_UNLOCK();
+    r =  0;
+  } else {
+    r = -1;
+  }
+  return r;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_SetNameDownBuffer
+*
+*  Function description
+*    Run-time configuration of a specific Down-buffer name (T->H).
+*    Buffer to be configured is specified by index.
+*
+*  Parameters
+*    BufferIndex  Index of the buffer to renamed.
+*    sName        Pointer to a constant name string.
+*
+*  Return value
+*    >= 0  O.K.
+*     < 0  Error
+*/
+int SEGGER_RTT_SetNameDownBuffer(unsigned BufferIndex, const char* sName) {
+  int r;
+
+  INIT();
+  if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumDownBuffers) {
+    SEGGER_RTT_LOCK();
+    _SEGGER_RTT.aDown[BufferIndex].sName = sName;
+    SEGGER_RTT_UNLOCK();
+    r =  0;
+  } else {
+    r = -1;
+  }
+  return r;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_SetFlagsUpBuffer
+*
+*  Function description
+*    Run-time configuration of specific up-buffer flags (T->H).
+*    Buffer to be configured is specified by index.
+*
+*  Parameters
+*    BufferIndex  Index of the buffer.
+*    Flags        Flags to set for the buffer.
+*
+*  Return value
+*    >= 0  O.K.
+*     < 0  Error
+*/
+int SEGGER_RTT_SetFlagsUpBuffer(unsigned BufferIndex, unsigned Flags) {
+  int r;
+
+  INIT();
+  if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumUpBuffers) {
+    SEGGER_RTT_LOCK();
+    _SEGGER_RTT.aUp[BufferIndex].Flags = Flags;
+    SEGGER_RTT_UNLOCK();
+    r =  0;
+  } else {
+    r = -1;
+  }
+  return r;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_SetFlagsDownBuffer
+*
+*  Function description
+*    Run-time configuration of specific Down-buffer flags (T->H).
+*    Buffer to be configured is specified by index.
+*
+*  Parameters
+*    BufferIndex  Index of the buffer to renamed.
+*    Flags        Flags to set for the buffer.
+*
+*  Return value
+*    >= 0  O.K.
+*     < 0  Error
+*/
+int SEGGER_RTT_SetFlagsDownBuffer(unsigned BufferIndex, unsigned Flags) {
+  int r;
+
+  INIT();
+  if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumDownBuffers) {
+    SEGGER_RTT_LOCK();
+    _SEGGER_RTT.aDown[BufferIndex].Flags = Flags;
+    SEGGER_RTT_UNLOCK();
+    r =  0;
+  } else {
+    r = -1;
+  }
+  return r;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_Init
+*
+*  Function description
+*    Initializes the RTT Control Block.
+*    Should be used in RAM targets, at start of the application.
+*
+*/
+void SEGGER_RTT_Init (void) {
+  _DoInit();
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_SetTerminal
+*
+*  Function description
+*    Sets the terminal to be used for output on channel 0.
+*
+*  Parameters
+*    TerminalId  Index of the terminal.
+*
+*  Return value
+*    >= 0  O.K.
+*     < 0  Error (e.g. if RTT is configured for non-blocking mode and there was no space in the buffer to set the new terminal Id)
+*/
+int SEGGER_RTT_SetTerminal (unsigned char TerminalId) {
+  unsigned char         ac[2];
+  SEGGER_RTT_BUFFER_UP* pRing;
+  unsigned Avail;
+  int r;
+  //
+  INIT();
+  //
+  r = 0;
+  ac[0] = 0xFFu;
+  if (TerminalId < sizeof(_aTerminalId)) { // We only support a certain number of channels
+    ac[1] = _aTerminalId[TerminalId];
+    pRing = &_SEGGER_RTT.aUp[0];    // Buffer 0 is always reserved for terminal I/O, so we can use index 0 here, fixed
+    SEGGER_RTT_LOCK();    // Lock to make sure that no other task is writing into buffer, while we are and number of free bytes in buffer does not change downwards after checking and before writing
+    if ((pRing->Flags & SEGGER_RTT_MODE_MASK) == SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL) {
+      _ActiveTerminal = TerminalId;
+      _WriteBlocking(pRing, (const char*)ac, 2u);
+    } else {                                                                            // Skipping mode or trim mode? => We cannot trim this command so handling is the same for both modes
+      Avail = _GetAvailWriteSpace(pRing);
+      if (Avail >= 2) {
+        _ActiveTerminal = TerminalId;    // Only change active terminal in case of success
+        _WriteNoCheck(pRing, (const char*)ac, 2u);
+      } else {
+        r = -1;
+      }
+    }
+    SEGGER_RTT_UNLOCK();
+  } else {
+    r = -1;
+  }
+  return r;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_TerminalOut
+*
+*  Function description
+*    Writes a string to the given terminal
+*     without changing the terminal for channel 0.
+*
+*  Parameters
+*    TerminalId   Index of the terminal.
+*    s            String to be printed on the terminal.
+*
+*  Return value
+*    >= 0 - Number of bytes written.
+*     < 0 - Error.
+*
+*/
+int SEGGER_RTT_TerminalOut (unsigned char TerminalId, const char* s) {
+  int                   Status;
+  unsigned              FragLen;
+  unsigned              Avail;
+  SEGGER_RTT_BUFFER_UP* pRing;
+  //
+  INIT();
+  //
+  // Validate terminal ID.
+  //
+  if (TerminalId < (char)sizeof(_aTerminalId)) { // We only support a certain number of channels
+    //
+    // Get "to-host" ring buffer.
+    //
+    pRing = &_SEGGER_RTT.aUp[0];
+    //
+    // Need to be able to change terminal, write data, change back.
+    // Compute the fixed and variable sizes.
+    //
+    FragLen = STRLEN(s);
+    //
+    // How we output depends upon the mode...
+    //
+    SEGGER_RTT_LOCK();
+    Avail = _GetAvailWriteSpace(pRing);
+    switch (pRing->Flags & SEGGER_RTT_MODE_MASK) {
+    case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
+      //
+      // If we are in skip mode and there is no space for the whole
+      // of this output, don't bother switching terminals at all.
+      //
+      if (Avail < (FragLen + 4u)) {
+        Status = 0;
+      } else {
+        _PostTerminalSwitch(pRing, TerminalId);
+        Status = (int)_WriteBlocking(pRing, s, FragLen);
+        _PostTerminalSwitch(pRing, _ActiveTerminal);
+      }
+      break;
+    case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
+      //
+      // If we are in trim mode and there is not enough space for everything,
+      // trim the output but always include the terminal switch.  If no room
+      // for terminal switch, skip that totally.
+      //
+      if (Avail < 4u) {
+        Status = -1;
+      } else {
+        _PostTerminalSwitch(pRing, TerminalId);
+        Status = (int)_WriteBlocking(pRing, s, (FragLen < (Avail - 4u)) ? FragLen : (Avail - 4u));
+        _PostTerminalSwitch(pRing, _ActiveTerminal);
+      }
+      break;
+    case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
+      //
+      // If we are in blocking mode, output everything.
+      //
+      _PostTerminalSwitch(pRing, TerminalId);
+      Status = (int)_WriteBlocking(pRing, s, FragLen);
+      _PostTerminalSwitch(pRing, _ActiveTerminal);
+      break;
+    default:
+      Status = -1;
+      break;
+    }
+    //
+    // Finish up.
+    //
+    SEGGER_RTT_UNLOCK();
+  } else {
+    Status = -1;
+  }
+  return Status;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_GetAvailWriteSpace
+*
+*  Function description
+*    Returns the number of bytes available in the ring buffer.
+*
+*  Parameters
+*    BufferIndex  Index of the up buffer.
+*
+*  Return value
+*    Number of bytes that are free in the selected up buffer.
+*/
+unsigned SEGGER_RTT_GetAvailWriteSpace (unsigned BufferIndex){
+  return _GetAvailWriteSpace(&_SEGGER_RTT.aUp[BufferIndex]);
+}
+
+
+/*********************************************************************
+*
+*       SEGGER_RTT_GetBytesInBuffer()
+*
+*  Function description
+*    Returns the number of bytes currently used in the up buffer.
+*
+*  Parameters
+*    BufferIndex  Index of the up buffer.
+*
+*  Return value
+*    Number of bytes that are used in the buffer.
+*/
+unsigned SEGGER_RTT_GetBytesInBuffer(unsigned BufferIndex) {
+  unsigned RdOff;
+  unsigned WrOff;
+  unsigned r;
+  //
+  // Avoid warnings regarding volatile access order.  It's not a problem
+  // in this case, but dampen compiler enthusiasm.
+  //
+  RdOff = _SEGGER_RTT.aUp[BufferIndex].RdOff;
+  WrOff = _SEGGER_RTT.aUp[BufferIndex].WrOff;
+  if (RdOff <= WrOff) {
+    r = WrOff - RdOff;
+  } else {
+    r = _SEGGER_RTT.aUp[BufferIndex].SizeOfBuffer - (WrOff - RdOff);
+  }
+  return r;
+}
+
+/*************************** End of file ****************************/
diff --git a/sched/systemview/SEGGER_RTT.h b/sched/systemview/SEGGER_RTT.h
new file mode 100644
index 0000000000..f01651b364
--- /dev/null
+++ b/sched/systemview/SEGGER_RTT.h
@@ -0,0 +1,325 @@
+/*********************************************************************
+*                    SEGGER Microcontroller GmbH                     *
+*                        The Embedded Experts                        *
+**********************************************************************
+*                                                                    *
+*            (c) 1995 - 2019 SEGGER Microcontroller GmbH             *
+*                                                                    *
+*       www.segger.com     Support: support@segger.com               *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SEGGER SystemView * Real-time application analysis           *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+* All rights reserved.                                               *
+*                                                                    *
+* SEGGER strongly recommends to not make any changes                 *
+* to or modify the source code of this software in order to stay     *
+* compatible with the SystemView and RTT protocol, and J-Link.       *
+*                                                                    *
+* Redistribution and use in source and binary forms, with or         *
+* without modification, are permitted provided that the following    *
+* condition is met:                                                  *
+*                                                                    *
+* o Redistributions of source code must retain the above copyright   *
+*   notice, this condition and the following disclaimer.             *
+*                                                                    *
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
+* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
+* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
+* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
+* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
+* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
+* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
+* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
+* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
+* DAMAGE.                                                            *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SystemView version: V3.12                                    *
+*                                                                    *
+**********************************************************************
+---------------------------END-OF-HEADER------------------------------
+File    : SEGGER_RTT.h
+Purpose : Implementation of SEGGER real-time transfer which allows
+          real-time communication on targets which support debugger 
+          memory accesses while the CPU is running.
+Revision: $Rev: 17697 $
+----------------------------------------------------------------------
+*/
+
+#ifndef SEGGER_RTT_H
+#define SEGGER_RTT_H
+
+#include "SEGGER_RTT_Conf.h"
+
+
+
+/*********************************************************************
+*
+*       Defines, defaults
+*
+**********************************************************************
+*/
+#ifndef RTT_USE_ASM
+  #if (defined __SES_ARM)                       // SEGGER Embedded Studio
+    #define _CC_HAS_RTT_ASM_SUPPORT 1
+  #elif (defined __CROSSWORKS_ARM)              // Rowley Crossworks
+    #define _CC_HAS_RTT_ASM_SUPPORT 1
+  #elif (defined __GNUC__)                      // GCC
+    #define _CC_HAS_RTT_ASM_SUPPORT 1
+  #elif (defined __clang__)                     // Clang compiler
+    #define _CC_HAS_RTT_ASM_SUPPORT 1
+  #elif (defined __IASMARM__)                   // IAR assembler
+    #define _CC_HAS_RTT_ASM_SUPPORT 1
+  #elif (defined __ICCARM__)                    // IAR compiler
+    #define _CC_HAS_RTT_ASM_SUPPORT 1
+  #else
+    #define _CC_HAS_RTT_ASM_SUPPORT 0
+  #endif
+  #if (defined __ARM_ARCH_7M__)                 // Cortex-M3/4
+    #define _CORE_HAS_RTT_ASM_SUPPORT 1
+  #elif (defined __ARM_ARCH_7EM__)              // Cortex-M7
+    #define _CORE_HAS_RTT_ASM_SUPPORT 1
+  #elif (defined __ARM_ARCH_8M_MAIN__)          // Cortex-M33
+    #define _CORE_HAS_RTT_ASM_SUPPORT 1
+  #elif (defined __ARM7M__)                     // IAR Cortex-M3/4
+    #if (__CORE__ == __ARM7M__)
+      #define _CORE_HAS_RTT_ASM_SUPPORT 1
+    #else
+      #define _CORE_HAS_RTT_ASM_SUPPORT 0
+    #endif
+  #elif (defined __ARM7EM__)                    // IAR Cortex-M7
+    #if (__CORE__ == __ARM7EM__)
+      #define _CORE_HAS_RTT_ASM_SUPPORT 1
+    #else
+      #define _CORE_HAS_RTT_ASM_SUPPORT 0
+    #endif
+  #else
+    #define _CORE_HAS_RTT_ASM_SUPPORT 0
+  #endif
+  //
+  // If IDE and core support the ASM version, enable ASM version by default
+  //
+  #if (_CC_HAS_RTT_ASM_SUPPORT && _CORE_HAS_RTT_ASM_SUPPORT)
+    #define RTT_USE_ASM                           (1)
+  #else
+    #define RTT_USE_ASM                           (0)
+  #endif
+#endif
+
+#ifndef SEGGER_RTT_ASM  // defined when SEGGER_RTT.h is included from assembly file
+#include <stdlib.h>
+#include <stdarg.h>
+
+/*********************************************************************
+*
+*       Defines, fixed
+*
+**********************************************************************
+*/
+
+/*********************************************************************
+*
+*       Types
+*
+**********************************************************************
+*/
+
+//
+// Description for a circular buffer (also called "ring buffer")
+// which is used as up-buffer (T->H)
+//
+typedef struct {
+  const     char*    sName;         // Optional name. Standard names so far are: "Terminal", "SysView", "J-Scope_t4i4"
+            char*    pBuffer;       // Pointer to start of buffer
+            unsigned SizeOfBuffer;  // Buffer size in bytes. Note that one byte is lost, as this implementation does not fill up the buffer in order to avoid the problem of being unable to distinguish between full and empty.
+            unsigned WrOff;         // Position of next item to be written by either target.
+  volatile  unsigned RdOff;         // Position of next item to be read by host. Must be volatile since it may be modified by host.
+            unsigned Flags;         // Contains configuration flags
+} SEGGER_RTT_BUFFER_UP;
+
+//
+// Description for a circular buffer (also called "ring buffer")
+// which is used as down-buffer (H->T)
+//
+typedef struct {
+  const     char*    sName;         // Optional name. Standard names so far are: "Terminal", "SysView", "J-Scope_t4i4"
+            char*    pBuffer;       // Pointer to start of buffer
+            unsigned SizeOfBuffer;  // Buffer size in bytes. Note that one byte is lost, as this implementation does not fill up the buffer in order to avoid the problem of being unable to distinguish between full and empty.
+  volatile  unsigned WrOff;         // Position of next item to be written by host. Must be volatile since it may be modified by host.
+            unsigned RdOff;         // Position of next item to be read by target (down-buffer).
+            unsigned Flags;         // Contains configuration flags
+} SEGGER_RTT_BUFFER_DOWN;
+
+//
+// RTT control block which describes the number of buffers available
+// as well as the configuration for each buffer
+//
+//
+typedef struct {
+  char                    acID[16];                                 // Initialized to "SEGGER RTT"
+  int                     MaxNumUpBuffers;                          // Initialized to SEGGER_RTT_MAX_NUM_UP_BUFFERS (type. 2)
+  int                     MaxNumDownBuffers;                        // Initialized to SEGGER_RTT_MAX_NUM_DOWN_BUFFERS (type. 2)
+  SEGGER_RTT_BUFFER_UP    aUp[SEGGER_RTT_MAX_NUM_UP_BUFFERS];       // Up buffers, transferring information up from target via debug probe to host
+  SEGGER_RTT_BUFFER_DOWN  aDown[SEGGER_RTT_MAX_NUM_DOWN_BUFFERS];   // Down buffers, transferring information down from host via debug probe to target
+} SEGGER_RTT_CB;
+
+/*********************************************************************
+*
+*       Global data
+*
+**********************************************************************
+*/
+extern SEGGER_RTT_CB _SEGGER_RTT;
+
+/*********************************************************************
+*
+*       RTT API functions
+*
+**********************************************************************
+*/
+#ifdef __cplusplus
+  extern "C" {
+#endif
+int          SEGGER_RTT_AllocDownBuffer         (const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags);
+int          SEGGER_RTT_AllocUpBuffer           (const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags);
+int          SEGGER_RTT_ConfigUpBuffer          (unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags);
+int          SEGGER_RTT_ConfigDownBuffer        (unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags);
+int          SEGGER_RTT_GetKey                  (void);
+unsigned     SEGGER_RTT_HasData                 (unsigned BufferIndex);
+int          SEGGER_RTT_HasKey                  (void);
+unsigned     SEGGER_RTT_HasDataUp               (unsigned BufferIndex);
+void         SEGGER_RTT_Init                    (void);
+unsigned     SEGGER_RTT_Read                    (unsigned BufferIndex,       void* pBuffer, unsigned BufferSize);
+unsigned     SEGGER_RTT_ReadNoLock              (unsigned BufferIndex,       void* pData,   unsigned BufferSize);
+int          SEGGER_RTT_SetNameDownBuffer       (unsigned BufferIndex, const char* sName);
+int          SEGGER_RTT_SetNameUpBuffer         (unsigned BufferIndex, const char* sName);
+int          SEGGER_RTT_SetFlagsDownBuffer      (unsigned BufferIndex, unsigned Flags);
+int          SEGGER_RTT_SetFlagsUpBuffer        (unsigned BufferIndex, unsigned Flags);
+int          SEGGER_RTT_WaitKey                 (void);
+unsigned     SEGGER_RTT_Write                   (unsigned BufferIndex, const void* pBuffer, unsigned NumBytes);
+unsigned     SEGGER_RTT_WriteNoLock             (unsigned BufferIndex, const void* pBuffer, unsigned NumBytes);
+unsigned     SEGGER_RTT_WriteSkipNoLock         (unsigned BufferIndex, const void* pBuffer, unsigned NumBytes);
+unsigned     SEGGER_RTT_ASM_WriteSkipNoLock     (unsigned BufferIndex, const void* pBuffer, unsigned NumBytes);
+unsigned     SEGGER_RTT_WriteString             (unsigned BufferIndex, const char* s);
+void         SEGGER_RTT_WriteWithOverwriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes);
+unsigned     SEGGER_RTT_PutChar                 (unsigned BufferIndex, char c);
+unsigned     SEGGER_RTT_PutCharSkip             (unsigned BufferIndex, char c);
+unsigned     SEGGER_RTT_PutCharSkipNoLock       (unsigned BufferIndex, char c);
+unsigned     SEGGER_RTT_GetAvailWriteSpace      (unsigned BufferIndex);
+unsigned     SEGGER_RTT_GetBytesInBuffer        (unsigned BufferIndex);
+//
+// Function macro for performance optimization
+//
+#define      SEGGER_RTT_HASDATA(n)       (_SEGGER_RTT.aDown[n].WrOff - _SEGGER_RTT.aDown[n].RdOff)
+
+#if RTT_USE_ASM
+  #define SEGGER_RTT_WriteSkipNoLock  SEGGER_RTT_ASM_WriteSkipNoLock
+#endif
+
+/*********************************************************************
+*
+*       RTT transfer functions to send RTT data via other channels.
+*
+**********************************************************************
+*/
+unsigned     SEGGER_RTT_ReadUpBuffer            (unsigned BufferIndex, void* pBuffer, unsigned BufferSize);
+unsigned     SEGGER_RTT_ReadUpBufferNoLock      (unsigned BufferIndex, void* pData, unsigned BufferSize);
+unsigned     SEGGER_RTT_WriteDownBuffer         (unsigned BufferIndex, const void* pBuffer, unsigned NumBytes);
+unsigned     SEGGER_RTT_WriteDownBufferNoLock   (unsigned BufferIndex, const void* pBuffer, unsigned NumBytes);
+
+#define      SEGGER_RTT_HASDATA_UP(n)    (_SEGGER_RTT.aUp[n].WrOff - _SEGGER_RTT.aUp[n].RdOff)
+
+/*********************************************************************
+*
+*       RTT "Terminal" API functions
+*
+**********************************************************************
+*/
+int     SEGGER_RTT_SetTerminal        (unsigned char TerminalId);
+int     SEGGER_RTT_TerminalOut        (unsigned char TerminalId, const char* s);
+
+/*********************************************************************
+*
+*       RTT printf functions (require SEGGER_RTT_printf.c)
+*
+**********************************************************************
+*/
+int SEGGER_RTT_printf(unsigned BufferIndex, const char * sFormat, ...);
+int SEGGER_RTT_vprintf(unsigned BufferIndex, const char * sFormat, va_list * pParamList);
+
+#ifdef __cplusplus
+  }
+#endif
+
+#endif // ifndef(SEGGER_RTT_ASM)
+
+/*********************************************************************
+*
+*       Defines
+*
+**********************************************************************
+*/
+
+//
+// Operating modes. Define behavior if buffer is full (not enough space for entire message)
+//
+#define SEGGER_RTT_MODE_NO_BLOCK_SKIP         (0)     // Skip. Do not block, output nothing. (Default)
+#define SEGGER_RTT_MODE_NO_BLOCK_TRIM         (1)     // Trim: Do not block, output as much as fits.
+#define SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL    (2)     // Block: Wait until there is space in the buffer.
+#define SEGGER_RTT_MODE_MASK                  (3)
+
+//
+// Control sequences, based on ANSI.
+// Can be used to control color, and clear the screen
+//
+#define RTT_CTRL_RESET                "\x1B[0m"         // Reset to default colors
+#define RTT_CTRL_CLEAR                "\x1B[2J"         // Clear screen, reposition cursor to top left
+
+#define RTT_CTRL_TEXT_BLACK           "\x1B[2;30m"
+#define RTT_CTRL_TEXT_RED             "\x1B[2;31m"
+#define RTT_CTRL_TEXT_GREEN           "\x1B[2;32m"
+#define RTT_CTRL_TEXT_YELLOW          "\x1B[2;33m"
+#define RTT_CTRL_TEXT_BLUE            "\x1B[2;34m"
+#define RTT_CTRL_TEXT_MAGENTA         "\x1B[2;35m"
+#define RTT_CTRL_TEXT_CYAN            "\x1B[2;36m"
+#define RTT_CTRL_TEXT_WHITE           "\x1B[2;37m"
+
+#define RTT_CTRL_TEXT_BRIGHT_BLACK    "\x1B[1;30m"
+#define RTT_CTRL_TEXT_BRIGHT_RED      "\x1B[1;31m"
+#define RTT_CTRL_TEXT_BRIGHT_GREEN    "\x1B[1;32m"
+#define RTT_CTRL_TEXT_BRIGHT_YELLOW   "\x1B[1;33m"
+#define RTT_CTRL_TEXT_BRIGHT_BLUE     "\x1B[1;34m"
+#define RTT_CTRL_TEXT_BRIGHT_MAGENTA  "\x1B[1;35m"
+#define RTT_CTRL_TEXT_BRIGHT_CYAN     "\x1B[1;36m"
+#define RTT_CTRL_TEXT_BRIGHT_WHITE    "\x1B[1;37m"
+
+#define RTT_CTRL_BG_BLACK             "\x1B[24;40m"
+#define RTT_CTRL_BG_RED               "\x1B[24;41m"
+#define RTT_CTRL_BG_GREEN             "\x1B[24;42m"
+#define RTT_CTRL_BG_YELLOW            "\x1B[24;43m"
+#define RTT_CTRL_BG_BLUE              "\x1B[24;44m"
+#define RTT_CTRL_BG_MAGENTA           "\x1B[24;45m"
+#define RTT_CTRL_BG_CYAN              "\x1B[24;46m"
+#define RTT_CTRL_BG_WHITE             "\x1B[24;47m"
+
+#define RTT_CTRL_BG_BRIGHT_BLACK      "\x1B[4;40m"
+#define RTT_CTRL_BG_BRIGHT_RED        "\x1B[4;41m"
+#define RTT_CTRL_BG_BRIGHT_GREEN      "\x1B[4;42m"
+#define RTT_CTRL_BG_BRIGHT_YELLOW     "\x1B[4;43m"
+#define RTT_CTRL_BG_BRIGHT_BLUE       "\x1B[4;44m"
+#define RTT_CTRL_BG_BRIGHT_MAGENTA    "\x1B[4;45m"
+#define RTT_CTRL_BG_BRIGHT_CYAN       "\x1B[4;46m"
+#define RTT_CTRL_BG_BRIGHT_WHITE      "\x1B[4;47m"
+
+
+#endif
+
+/*************************** End of file ****************************/
diff --git a/sched/systemview/SEGGER_RTT_ASM_ARMv7M.S b/sched/systemview/SEGGER_RTT_ASM_ARMv7M.S
new file mode 100644
index 0000000000..0c0eae1c25
--- /dev/null
+++ b/sched/systemview/SEGGER_RTT_ASM_ARMv7M.S
@@ -0,0 +1,235 @@
+/*********************************************************************
+*                   (c) SEGGER Microcontroller GmbH                  *
+*                        The Embedded Experts                        *
+*                           www.segger.com                           *
+**********************************************************************
+
+-------------------------- END-OF-HEADER -----------------------------
+
+File    : SEGGER_RTT_ASM_ARMv7M.S
+Purpose : Assembler implementation of RTT functions for ARMv7M
+
+Additional information:
+  This module is written to be assembler-independent and works with
+  GCC and clang (Embedded Studio) and IAR.
+*/
+
+#define SEGGER_RTT_ASM      // Used to control processed input from header file
+#include "SEGGER_RTT.h"
+
+/*********************************************************************
+*
+*       Defines, fixed
+*
+**********************************************************************
+*/
+#define _CCIAR   0
+#define _CCCLANG 1
+
+#if (defined __SES_ARM) || (defined __GNUC__) || (defined __clang__)
+  #define _CC_TYPE             _CCCLANG
+  #define _PUB_SYM             .global
+  #define _EXT_SYM             .extern
+  #define _END                 .end
+  #define _WEAK                .weak
+  #define _THUMB_FUNC          .thumb_func
+  #define _THUMB_CODE          .code 16
+  #define _WORD                .word
+  #define _SECTION(Sect, Type, AlignExp) .section Sect ##, "ax"
+  #define _ALIGN(Exp)          .align Exp 
+  #define _PLACE_LITS          .ltorg
+  #define _DATA_SECT_START 
+  #define _C_STARTUP           _start
+  #define _STACK_END           __stack_end__
+  #define _RAMFUNC
+  //
+  // .text     => Link to flash
+  // .fast     => Link to RAM
+  // OtherSect => Usually link to RAM
+  // Alignment is 2^x
+  //
+#elif defined (__IASMARM__)
+  #define _CC_TYPE             _CCIAR
+  #define _PUB_SYM             PUBLIC
+  #define _EXT_SYM             EXTERN
+  #define _END                 END
+  #define _WEAK                _WEAK
+  #define _THUMB_FUNC
+  #define _THUMB_CODE          THUMB
+  #define _WORD                DCD
+  #define _SECTION(Sect, Type, AlignExp) SECTION Sect ## : ## Type ## :REORDER:NOROOT ## (AlignExp)
+  #define _ALIGN(Exp)          alignrom Exp 
+  #define _PLACE_LITS
+  #define _DATA_SECT_START     DATA
+  #define _C_STARTUP           __iar_program_start
+  #define _STACK_END           sfe(CSTACK)
+  #define _RAMFUNC             SECTION_TYPE SHT_PROGBITS, SHF_WRITE | SHF_EXECINSTR
+  //
+  // .text     => Link to flash
+  // .textrw   => Link to RAM
+  // OtherSect => Usually link to RAM
+  // NOROOT    => Allows linker to throw away the function, if not referenced
+  // Alignment is 2^x
+  //
+#endif
+
+#if (_CC_TYPE == _CCIAR)
+        NAME SEGGER_RTT_ASM_ARMv7M
+#else
+        .syntax unified
+#endif
+
+#if defined (RTT_USE_ASM) && (RTT_USE_ASM == 1)
+        #define SHT_PROGBITS 0x1
+
+/*********************************************************************
+*
+*       Public / external symbols
+*
+**********************************************************************
+*/
+
+        _EXT_SYM __aeabi_memcpy
+        _EXT_SYM __aeabi_memcpy4
+        _EXT_SYM _SEGGER_RTT
+
+        _PUB_SYM SEGGER_RTT_ASM_WriteSkipNoLock
+
+/*********************************************************************
+*
+*       SEGGER_RTT_WriteSkipNoLock
+*
+*  Function description
+*    Stores a specified number of characters in SEGGER RTT
+*    control block which is then read by the host.
+*    SEGGER_RTT_WriteSkipNoLock does not lock the application and
+*    skips all data, if the data does not fit into the buffer.
+*
+*  Parameters
+*    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
+*    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
+*    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
+*                 MUST be > 0!!!
+*                 This is done for performance reasons, so no initial check has do be done.
+*
+*  Return value
+*    1: Data has been copied
+*    0: No space, data has not been copied
+*
+*  Notes
+*    (1) If there is not enough space in the "Up"-buffer, all data is dropped.
+*    (2) For performance reasons this function does not call Init()
+*        and may only be called after RTT has been initialized.
+*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
+*/
+        _SECTION(.text, CODE, 2)
+        _ALIGN(2)
+        _THUMB_FUNC
+SEGGER_RTT_ASM_WriteSkipNoLock:   // unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pData, unsigned NumBytes) {
+        //
+        // Cases:
+        //   1) RdOff <= WrOff => Space until wrap-around is sufficient
+        //   2) RdOff <= WrOff => Space after wrap-around needed (copy in 2 chunks)
+        //   3) RdOff <  WrOff => No space in buf
+        //   4) RdOff >  WrOff => Space is sufficient
+        //   5) RdOff >  WrOff => No space in buf
+        //
+        // 1) is the most common case for large buffers and assuming that J-Link reads the data fast enough
+        //
+        // Register usage:
+        //   R0 Temporary needed as RdOff, <Tmp> register later on
+        //   R1 pData
+        //   R2 <NumBytes>
+        //   R3 <Tmp> register. Hold free for subroutine calls
+        //   R4 <Rem>
+        //   R5 pRing->pBuffer
+        //   R6 pRing (Points to active struct SEGGER_RTT_BUFFER_DOWN)
+        //   R7 WrOff
+        //
+        PUSH     {R4-R7}
+        ADD      R3,R0,R0, LSL #+1
+        LDR.W    R0,=_SEGGER_RTT                 // pRing = &_SEGGER_RTT.aUp[BufferIndex];
+        ADD      R0,R0,R3, LSL #+3
+        ADD      R6,R0,#+24
+        LDR      R0,[R6, #+16]                   // RdOff = pRing->RdOff;
+        LDR      R7,[R6, #+12]                   // WrOff = pRing->WrOff;
+        LDR      R5,[R6, #+4]                    // pRing->pBuffer
+        CMP      R7,R0
+        BCC.N    _CheckCase4                     // if (RdOff <= WrOff) {                           => Case 1), 2) or 3)
+        //
+        // Handling for case 1, later on identical to case 4
+        //
+        LDR      R3,[R6, #+8]                    //  Avail = pRing->SizeOfBuffer - WrOff - 1u;      => Space until wrap-around (assume 1 byte not usable for case that RdOff == 0)
+        SUBS     R4,R3,R7                        // <Rem> (Used in case we jump into case 2 afterwards)
+        SUBS     R3,R4,#+1                       // <Avail>
+        CMP      R3,R2
+        BCC.N    _CheckCase2                     // if (Avail >= NumBytes) {  => Case 1)?
+_Case4:
+        ADDS     R5,R7,R5                        // pBuffer += WrOff
+        ADDS     R0,R2,R7                        // v = WrOff + NumBytes
+        //
+        // 2x unrolling for the copy loop that is used most of the time
+        // This is a special optimization for small SystemView packets and makes them even faster
+        //
+        _ALIGN(2)
+_LoopCopyStraight:                               // memcpy(pRing->pBuffer + WrOff, pData, NumBytes);
+        LDRB     R3,[R1], #+1
+        STRB     R3,[R5], #+1                    // *pDest++ = *pSrc++
+        SUBS     R2,R2,#+1
+        BEQ      _CSDone
+        LDRB     R3,[R1], #+1
+        STRB     R3,[R5], #+1                    // *pDest++ = *pSrc++
+        SUBS     R2,R2,#+1
+        BNE      _LoopCopyStraight
+_CSDone:
+        STR      R0,[R6, #+12]                   // pRing->WrOff = WrOff + NumBytes;
+        MOVS     R0,#+1
+        POP      {R4-R7}
+        BX       LR                              // Return 1
+_CheckCase2:
+        ADDS     R0,R0,R3                        // Avail += RdOff; => Space incl. wrap-around
+        CMP      R0,R2
+        BCC.N    _Case3                          // if (Avail >= NumBytes) {           => Case 2? => If not, we have case 3) (does not fit)
+        //
+        // Handling for case 2
+        //
+        ADDS     R0,R7,R5                        // v = pRing->pBuffer + WrOff => Do not change pRing->pBuffer here because 2nd chunk needs org. value
+        SUBS     R2,R2,R4                        // NumBytes -= Rem;  (Rem = pRing->SizeOfBuffer - WrOff; => Space until end of buffer)
+_LoopCopyBeforeWrapAround:                       // memcpy(pRing->pBuffer + WrOff, pData, Rem); => Copy 1st chunk
+        LDRB     R3,[R1], #+1
+        STRB     R3,[R0], #+1                    // *pDest++ = *pSrc++
+        SUBS     R4,R4,#+1
+        BNE      _LoopCopyBeforeWrapAround
+        //
+        // Special case: First check that assumed RdOff == 0 calculated that last element before wrap-around could not be used
+        // But 2nd check (considering space until wrap-around and until RdOff) revealed that RdOff is not 0, so we can use the last element
+        // In this case, we may use a copy straight until buffer end anyway without needing to copy 2 chunks
+        // Therefore, check if 2nd memcpy is necessary at all
+        //
+        ADDS     R4,R2,#+0                       // Save <NumBytes> (needed as counter in loop but must be written to <WrOff> after the loop). Also use this inst to update the flags to skip 2nd loop if possible
+        BEQ.N    _No2ChunkNeeded                 // if (NumBytes) {
+_LoopCopyAfterWrapAround:                        // memcpy(pRing->pBuffer, pData + Rem, NumBytes);
+        LDRB     R3,[R1], #+1                    // pData already points to the next src byte due to copy loop increment before this loop
+        STRB     R3,[R5], #+1                    // *pDest++ = *pSrc++
+        SUBS     R2,R2,#+1
+        BNE      _LoopCopyAfterWrapAround
+_No2ChunkNeeded:
+        STR      R4,[R6, #+12]                   // pRing->WrOff = NumBytes; => Must be written after copying data because J-Link may read control block asynchronously while writing into buffer
+        MOVS     R0,#+1
+        POP      {R4-R7}
+        BX       LR                              // Return 1
+_CheckCase4:
+        SUBS     R0,R0,R7
+        SUBS     R0,R0,#+1                       // Avail = RdOff - WrOff - 1u;
+        CMP      R0,R2
+        BCS.N    _Case4                          // if (Avail >= NumBytes) {      => Case 4) == 1) ? => If not, we have case 5) == 3) (does not fit)
+_Case3:
+        MOVS     R0,#+0
+        POP      {R4-R7}
+        BX       LR                              // Return 0
+        _PLACE_LITS
+
+#endif  // defined (RTT_USE_ASM) && (RTT_USE_ASM == 1)
+        _END
+
+/*************************** End of file ****************************/
diff --git a/sched/systemview/SEGGER_RTT_Conf.h b/sched/systemview/SEGGER_RTT_Conf.h
new file mode 100644
index 0000000000..03804c8c62
--- /dev/null
+++ b/sched/systemview/SEGGER_RTT_Conf.h
@@ -0,0 +1,388 @@
+/*********************************************************************
+*                    SEGGER Microcontroller GmbH                     *
+*                        The Embedded Experts                        *
+**********************************************************************
+*                                                                    *
+*            (c) 1995 - 2019 SEGGER Microcontroller GmbH             *
+*                                                                    *
+*       www.segger.com     Support: support@segger.com               *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SEGGER SystemView * Real-time application analysis           *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+* All rights reserved.                                               *
+*                                                                    *
+* SEGGER strongly recommends to not make any changes                 *
+* to or modify the source code of this software in order to stay     *
+* compatible with the SystemView and RTT protocol, and J-Link.       *
+*                                                                    *
+* Redistribution and use in source and binary forms, with or         *
+* without modification, are permitted provided that the following    *
+* condition is met:                                                  *
+*                                                                    *
+* o Redistributions of source code must retain the above copyright   *
+*   notice, this condition and the following disclaimer.             *
+*                                                                    *
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
+* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
+* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
+* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
+* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
+* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
+* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
+* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
+* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
+* DAMAGE.                                                            *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SystemView version: V3.12                                    *
+*                                                                    *
+**********************************************************************
+---------------------------END-OF-HEADER------------------------------
+File    : SEGGER_RTT_Conf.h
+Purpose : Implementation of SEGGER real-time transfer (RTT) which
+          allows real-time communication on targets which support
+          debugger memory accesses while the CPU is running.
+Revision: $Rev: 18601 $
+
+*/
+
+#ifndef SEGGER_RTT_CONF_H
+#define SEGGER_RTT_CONF_H
+
+#ifdef __IAR_SYSTEMS_ICC__
+  #include <intrinsics.h>
+#endif
+
+/*********************************************************************
+*
+*       Defines, configurable
+*
+**********************************************************************
+*/
+#ifndef   SEGGER_RTT_MAX_NUM_UP_BUFFERS
+  #define SEGGER_RTT_MAX_NUM_UP_BUFFERS             (3)     // Max. number of up-buffers (T->H) available on this target    (Default: 3)
+#endif
+
+#ifndef   SEGGER_RTT_MAX_NUM_DOWN_BUFFERS
+  #define SEGGER_RTT_MAX_NUM_DOWN_BUFFERS           (3)     // Max. number of down-buffers (H->T) available on this target  (Default: 3)
+#endif
+
+#ifndef   BUFFER_SIZE_UP
+  #define BUFFER_SIZE_UP                            (1024)  // Size of the buffer for terminal output of target, up to host (Default: 1k)
+#endif
+
+#ifndef   BUFFER_SIZE_DOWN
+  #define BUFFER_SIZE_DOWN                          (16)    // Size of the buffer for terminal input to target from host (Usually keyboard input) (Default: 16)
+#endif
+
+#ifndef   SEGGER_RTT_PRINTF_BUFFER_SIZE
+  #define SEGGER_RTT_PRINTF_BUFFER_SIZE             (64u)    // Size of buffer for RTT printf to bulk-send chars via RTT     (Default: 64)
+#endif
+
+#ifndef   SEGGER_RTT_MODE_DEFAULT
+  #define SEGGER_RTT_MODE_DEFAULT                   SEGGER_RTT_MODE_NO_BLOCK_SKIP // Mode for pre-initialized terminal channel (buffer 0)
+#endif
+
+/*********************************************************************
+*
+*       RTT memcpy configuration
+*
+*       memcpy() is good for large amounts of data, 
+*       but the overhead is big for small amounts, which are usually stored via RTT.
+*       With SEGGER_RTT_MEMCPY_USE_BYTELOOP a simple byte loop can be used instead.
+*
+*       SEGGER_RTT_MEMCPY() can be used to replace standard memcpy() in RTT functions.
+*       This is may be required with memory access restrictions, 
+*       such as on Cortex-A devices with MMU.
+*/
+#ifndef   SEGGER_RTT_MEMCPY_USE_BYTELOOP
+  #define SEGGER_RTT_MEMCPY_USE_BYTELOOP              0 // 0: Use memcpy/SEGGER_RTT_MEMCPY, 1: Use a simple byte-loop
+#endif
+//
+// Example definition of SEGGER_RTT_MEMCPY to external memcpy with GCC toolchains and Cortex-A targets
+//
+//#if ((defined __SES_ARM) || (defined __CROSSWORKS_ARM) || (defined __GNUC__)) && (defined (__ARM_ARCH_7A__))  
+//  #define SEGGER_RTT_MEMCPY(pDest, pSrc, NumBytes)      SEGGER_memcpy((pDest), (pSrc), (NumBytes))
+//#endif
+
+//
+// Target is not allowed to perform other RTT operations while string still has not been stored completely.
+// Otherwise we would probably end up with a mixed string in the buffer.
+// If using  RTT from within interrupts, multiple tasks or multi processors, define the SEGGER_RTT_LOCK() and SEGGER_RTT_UNLOCK() function here.
+//
+// SEGGER_RTT_MAX_INTERRUPT_PRIORITY can be used in the sample lock routines on Cortex-M3/4.
+// Make sure to mask all interrupts which can send RTT data, i.e. generate SystemView events, or cause task switches.
+// When high-priority interrupts must not be masked while sending RTT data, SEGGER_RTT_MAX_INTERRUPT_PRIORITY needs to be adjusted accordingly.
+// (Higher priority = lower priority number)
+// Default value for embOS: 128u
+// Default configuration in FreeRTOS: configMAX_SYSCALL_INTERRUPT_PRIORITY: ( configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY << (8 - configPRIO_BITS) )
+// In case of doubt mask all interrupts: 1 << (8 - BASEPRI_PRIO_BITS) i.e. 1 << 5 when 3 bits are implemented in NVIC
+// or define SEGGER_RTT_LOCK() to completely disable interrupts.
+//
+#ifndef   SEGGER_RTT_MAX_INTERRUPT_PRIORITY
+  #define SEGGER_RTT_MAX_INTERRUPT_PRIORITY         (0x20)   // Interrupt priority to lock on SEGGER_RTT_LOCK on Cortex-M3/4 (Default: 0x20)
+#endif
+
+/*********************************************************************
+*
+*       RTT lock configuration for SEGGER Embedded Studio,
+*       Rowley CrossStudio and GCC
+*/
+#if ((defined(__SES_ARM) || defined(__SES_RISCV) || defined(__CROSSWORKS_ARM) || defined(__GNUC__) || defined(__clang__)) && !defined (__CC_ARM) && !defined(WIN32))
+  #if (defined(__ARM_ARCH_6M__) || defined(__ARM_ARCH_8M_BASE__))
+    #define SEGGER_RTT_LOCK()   {                                                                   \
+                                    unsigned int LockState;                                         \
+                                  __asm volatile ("mrs   %0, primask  \n\t"                         \
+                                                  "movs  r1, $1       \n\t"                         \
+                                                  "msr   primask, r1  \n\t"                         \
+                                                  : "=r" (LockState)                                \
+                                                  :                                                 \
+                                                  : "r1"                                            \
+                                                  );
+
+    #define SEGGER_RTT_UNLOCK()   __asm volatile ("msr   primask, %0  \n\t"                         \
+                                                  :                                                 \
+                                                  : "r" (LockState)                                 \
+                                                  :                                                 \
+                                                  );                                                \
+                                }
+  #elif (defined(__ARM_ARCH_7M__) || defined(__ARM_ARCH_7EM__) || defined(__ARM_ARCH_8M_MAIN__))
+    #ifndef   SEGGER_RTT_MAX_INTERRUPT_PRIORITY
+      #define SEGGER_RTT_MAX_INTERRUPT_PRIORITY   (0x20)
+    #endif
+    #define SEGGER_RTT_LOCK()   {                                                                   \
+                                    unsigned int LockState;                                         \
+                                  __asm volatile ("mrs   %0, basepri  \n\t"                         \
+                                                  "mov   r1, %1       \n\t"                         \
+                                                  "msr   basepri, r1  \n\t"                         \
+                                                  : "=r" (LockState)                                \
+                                                  : "i"(SEGGER_RTT_MAX_INTERRUPT_PRIORITY)          \
+                                                  : "r1"                                            \
+                                                  );
+
+    #define SEGGER_RTT_UNLOCK()   __asm volatile ("msr   basepri, %0  \n\t"                         \
+                                                  :                                                 \
+                                                  : "r" (LockState)                                 \
+                                                  :                                                 \
+                                                  );                                                \
+                                }
+
+  #elif defined(__ARM_ARCH_7A__)
+    #define SEGGER_RTT_LOCK() {                                                \
+                                 unsigned int LockState;                       \
+                                 __asm volatile ("mrs r1, CPSR \n\t"           \
+                                                 "mov %0, r1 \n\t"             \
+                                                 "orr r1, r1, #0xC0 \n\t"      \
+                                                 "msr CPSR_c, r1 \n\t"         \
+                                                 : "=r" (LockState)            \
+                                                 :                             \
+                                                 : "r1"                        \
+                                                 );
+
+    #define SEGGER_RTT_UNLOCK() __asm volatile ("mov r0, %0 \n\t"              \
+                                                "mrs r1, CPSR \n\t"            \
+                                                "bic r1, r1, #0xC0 \n\t"       \
+                                                "and r0, r0, #0xC0 \n\t"       \
+                                                "orr r1, r1, r0 \n\t"          \
+                                                "msr CPSR_c, r1 \n\t"          \
+                                                :                              \
+                                                : "r" (LockState)              \
+                                                : "r0", "r1"                   \
+                                                );                             \
+                            }
+  #elif defined(__riscv) || defined(__riscv_xlen)
+    #define SEGGER_RTT_LOCK()  {                                               \
+                                 unsigned int LockState;                       \
+                                 __asm volatile ("csrr  %0, mstatus  \n\t"     \
+                                                 "csrci mstatus, 8   \n\t"     \
+                                                 "andi  %0, %0,  8   \n\t"     \
+                                                 : "=r" (LockState)            \
+                                                 :                             \
+                                                 :                             \
+                                                );
+                               
+  #define SEGGER_RTT_UNLOCK()    __asm volatile ("csrr  a1, mstatus  \n\t"     \
+                                                 "or    %0, %0, a1   \n\t"     \
+                                                 "csrs  mstatus, %0  \n\t"     \
+                                                 :                             \
+                                                 : "r"  (LockState)            \
+                                                 : "a1"                        \
+                                                );                             \
+                               }
+  #else
+    #define SEGGER_RTT_LOCK()
+    #define SEGGER_RTT_UNLOCK()
+  #endif
+#endif
+
+/*********************************************************************
+*
+*       RTT lock configuration for IAR EWARM
+*/
+#ifdef __ICCARM__
+  #if (defined (__ARM6M__)          && (__CORE__ == __ARM6M__))             ||                      \
+      (defined (__ARM8M_BASELINE__) && (__CORE__ == __ARM8M_BASELINE__))
+    #define SEGGER_RTT_LOCK()   {                                                                   \
+                                  unsigned int LockState;                                           \
+                                  LockState = __get_PRIMASK();                                      \
+                                  __set_PRIMASK(1);
+
+    #define SEGGER_RTT_UNLOCK()   __set_PRIMASK(LockState);                                         \
+                                }
+  #elif (defined (__ARM7EM__)         && (__CORE__ == __ARM7EM__))          ||                      \
+        (defined (__ARM7M__)          && (__CORE__ == __ARM7M__))           ||                      \
+        (defined (__ARM8M_MAINLINE__) && (__CORE__ == __ARM8M_MAINLINE__))  ||                      \
+        (defined (__ARM8M_MAINLINE__) && (__CORE__ == __ARM8M_MAINLINE__))
+    #ifndef   SEGGER_RTT_MAX_INTERRUPT_PRIORITY
+      #define SEGGER_RTT_MAX_INTERRUPT_PRIORITY   (0x20)
+    #endif
+    #define SEGGER_RTT_LOCK()   {                                                                   \
+                                  unsigned int LockState;                                           \
+                                  LockState = __get_BASEPRI();                                      \
+                                  __set_BASEPRI(SEGGER_RTT_MAX_INTERRUPT_PRIORITY);
+
+    #define SEGGER_RTT_UNLOCK()   __set_BASEPRI(LockState);                                         \
+                                }
+  #endif
+#endif
+
+/*********************************************************************
+*
+*       RTT lock configuration for IAR RX
+*/
+#ifdef __ICCRX__
+  #define SEGGER_RTT_LOCK()   {                                                                     \
+                                unsigned long LockState;                                            \
+                                LockState = __get_interrupt_state();                                \
+                                __disable_interrupt();
+
+  #define SEGGER_RTT_UNLOCK()   __set_interrupt_state(LockState);                                   \
+                              }
+#endif
+
+/*********************************************************************
+*
+*       RTT lock configuration for IAR RL78
+*/
+#ifdef __ICCRL78__
+  #define SEGGER_RTT_LOCK()   {                                                                     \
+                                __istate_t LockState;                                               \
+                                LockState = __get_interrupt_state();                                \
+                                __disable_interrupt();
+
+  #define SEGGER_RTT_UNLOCK()   __set_interrupt_state(LockState);                                   \
+                              }
+#endif
+
+/*********************************************************************
+*
+*       RTT lock configuration for KEIL ARM
+*/
+#ifdef __CC_ARM
+  #if (defined __TARGET_ARCH_6S_M)
+    #define SEGGER_RTT_LOCK()   {                                                                   \
+                                  unsigned int LockState;                                           \
+                                  register unsigned char PRIMASK __asm( "primask");                 \
+                                  LockState = PRIMASK;                                              \
+                                  PRIMASK = 1u;                                                     \
+                                  __schedule_barrier();
+
+    #define SEGGER_RTT_UNLOCK()   PRIMASK = LockState;                                              \
+                                  __schedule_barrier();                                             \
+                                }
+  #elif (defined(__TARGET_ARCH_7_M) || defined(__TARGET_ARCH_7E_M))
+    #ifndef   SEGGER_RTT_MAX_INTERRUPT_PRIORITY
+      #define SEGGER_RTT_MAX_INTERRUPT_PRIORITY   (0x20)
+    #endif
+    #define SEGGER_RTT_LOCK()   {                                                                   \
+                                  unsigned int LockState;                                           \
+                                  register unsigned char BASEPRI __asm( "basepri");                 \
+                                  LockState = BASEPRI;                                              \
+                                  BASEPRI = SEGGER_RTT_MAX_INTERRUPT_PRIORITY;                      \
+                                  __schedule_barrier();
+
+    #define SEGGER_RTT_UNLOCK()   BASEPRI = LockState;                                              \
+                                  __schedule_barrier();                                             \
+                                }
+  #endif
+#endif
+
+/*********************************************************************
+*
+*       RTT lock configuration for TI ARM
+*/
+#ifdef __TI_ARM__
+  #if defined (__TI_ARM_V6M0__)
+    #define SEGGER_RTT_LOCK()   {                                                                   \
+                                  unsigned int LockState;                                           \
+                                  LockState = __get_PRIMASK();                                      \
+                                  __set_PRIMASK(1);
+
+    #define SEGGER_RTT_UNLOCK()   __set_PRIMASK(LockState);                                         \
+                                }
+  #elif (defined (__TI_ARM_V7M3__) || defined (__TI_ARM_V7M4__))
+    #ifndef   SEGGER_RTT_MAX_INTERRUPT_PRIORITY
+      #define SEGGER_RTT_MAX_INTERRUPT_PRIORITY   (0x20)
+    #endif
+    #define SEGGER_RTT_LOCK()   {                                                                   \
+                                  unsigned int LockState;                                           \
+                                  LockState = _set_interrupt_priority(SEGGER_RTT_MAX_INTERRUPT_PRIORITY);
+
+    #define SEGGER_RTT_UNLOCK()   _set_interrupt_priority(LockState);                               \
+                                }
+  #endif
+#endif
+
+/*********************************************************************
+*
+*       RTT lock configuration for CCRX
+*/
+#ifdef __RX
+  #define SEGGER_RTT_LOCK()   {                                                                     \
+                                unsigned long LockState;                                            \
+                                LockState = get_psw() & 0x010000;                                   \
+                                clrpsw_i();                           
+                                    
+  #define SEGGER_RTT_UNLOCK()   set_psw(get_psw() | LockState);                                     \
+                              }
+#endif
+
+/*********************************************************************
+*
+*       RTT lock configuration for embOS Simulation on Windows
+*       (Can also be used for generic RTT locking with embOS)
+*/
+#if defined(WIN32) || defined(SEGGER_RTT_LOCK_EMBOS)
+
+void OS_SIM_EnterCriticalSection(void);
+void OS_SIM_LeaveCriticalSection(void);
+
+#define SEGGER_RTT_LOCK()       {                                                                   \
+                                  OS_SIM_EnterCriticalSection();
+
+#define SEGGER_RTT_UNLOCK()       OS_SIM_LeaveCriticalSection();                                    \
+                                }
+#endif
+
+/*********************************************************************
+*
+*       RTT lock configuration fallback
+*/
+#ifndef   SEGGER_RTT_LOCK
+  #define SEGGER_RTT_LOCK()                // Lock RTT (nestable)   (i.e. disable interrupts)
+#endif
+
+#ifndef   SEGGER_RTT_UNLOCK
+  #define SEGGER_RTT_UNLOCK()              // Unlock RTT (nestable) (i.e. enable previous interrupt lock state)
+#endif
+
+#endif
+/*************************** End of file ****************************/
diff --git a/sched/systemview/SEGGER_RTT_printf.c b/sched/systemview/SEGGER_RTT_printf.c
new file mode 100644
index 0000000000..85ab7eca3b
--- /dev/null
+++ b/sched/systemview/SEGGER_RTT_printf.c
@@ -0,0 +1,504 @@
+/*********************************************************************
+*                    SEGGER Microcontroller GmbH                     *
+*                        The Embedded Experts                        *
+**********************************************************************
+*                                                                    *
+*            (c) 1995 - 2019 SEGGER Microcontroller GmbH             *
+*                                                                    *
+*       www.segger.com     Support: support@segger.com               *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SEGGER SystemView * Real-time application analysis           *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+* All rights reserved.                                               *
+*                                                                    *
+* SEGGER strongly recommends to not make any changes                 *
+* to or modify the source code of this software in order to stay     *
+* compatible with the SystemView and RTT protocol, and J-Link.       *
+*                                                                    *
+* Redistribution and use in source and binary forms, with or         *
+* without modification, are permitted provided that the following    *
+* condition is met:                                                  *
+*                                                                    *
+* o Redistributions of source code must retain the above copyright   *
+*   notice, this condition and the following disclaimer.             *
+*                                                                    *
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
+* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
+* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
+* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
+* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
+* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
+* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
+* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
+* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
+* DAMAGE.                                                            *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SystemView version: V3.12                                    *
+*                                                                    *
+**********************************************************************
+---------------------------END-OF-HEADER------------------------------
+File    : SEGGER_RTT_printf.c
+Purpose : Replacement for printf to write formatted data via RTT
+Revision: $Rev: 17697 $
+----------------------------------------------------------------------
+*/
+#include "SEGGER_RTT.h"
+#include "SEGGER_RTT_Conf.h"
+
+/*********************************************************************
+*
+*       Defines, configurable
+*
+**********************************************************************
+*/
+
+#ifndef SEGGER_RTT_PRINTF_BUFFER_SIZE
+  #define SEGGER_RTT_PRINTF_BUFFER_SIZE (64)
+#endif
+
+#include <stdlib.h>
+#include <stdarg.h>
+
+
+#define FORMAT_FLAG_LEFT_JUSTIFY   (1u << 0)
+#define FORMAT_FLAG_PAD_ZERO       (1u << 1)
+#define FORMAT_FLAG_PRINT_SIGN     (1u << 2)
+#define FORMAT_FLAG_ALTERNATE      (1u << 3)
+
+/*********************************************************************
+*
+*       Types
+*
+**********************************************************************
+*/
+
+typedef struct {
+  char*     pBuffer;
+  unsigned  BufferSize;
+  unsigned  Cnt;
+
+  int   ReturnValue;
+
+  unsigned RTTBufferIndex;
+} SEGGER_RTT_PRINTF_DESC;
+
+/*********************************************************************
+*
+*       Function prototypes
+*
+**********************************************************************
+*/
+
+/*********************************************************************
+*
+*       Static code
+*
+**********************************************************************
+*/
+/*********************************************************************
+*
+*       _StoreChar
+*/
+static void _StoreChar(SEGGER_RTT_PRINTF_DESC * p, char c) {
+  unsigned Cnt;
+
+  Cnt = p->Cnt;
+  if ((Cnt + 1u) <= p->BufferSize) {
+    *(p->pBuffer + Cnt) = c;
+    p->Cnt = Cnt + 1u;
+    p->ReturnValue++;
+  }
+  //
+  // Write part of string, when the buffer is full
+  //
+  if (p->Cnt == p->BufferSize) {
+    if (SEGGER_RTT_Write(p->RTTBufferIndex, p->pBuffer, p->Cnt) != p->Cnt) {
+      p->ReturnValue = -1;
+    } else {
+      p->Cnt = 0u;
+    }
+  }
+}
+
+/*********************************************************************
+*
+*       _PrintUnsigned
+*/
+static void _PrintUnsigned(SEGGER_RTT_PRINTF_DESC * pBufferDesc, unsigned v, unsigned Base, unsigned NumDigits, unsigned FieldWidth, unsigned FormatFlags) {
+  static const char _aV2C[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
+  unsigned Div;
+  unsigned Digit;
+  unsigned Number;
+  unsigned Width;
+  char c;
+
+  Number = v;
+  Digit = 1u;
+  //
+  // Get actual field width
+  //
+  Width = 1u;
+  while (Number >= Base) {
+    Number = (Number / Base);
+    Width++;
+  }
+  if (NumDigits > Width) {
+    Width = NumDigits;
+  }
+  //
+  // Print leading chars if necessary
+  //
+  if ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u) {
+    if (FieldWidth != 0u) {
+      if (((FormatFlags & FORMAT_FLAG_PAD_ZERO) == FORMAT_FLAG_PAD_ZERO) && (NumDigits == 0u)) {
+        c = '0';
+      } else {
+        c = ' ';
+      }
+      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
+        FieldWidth--;
+        _StoreChar(pBufferDesc, c);
+        if (pBufferDesc->ReturnValue < 0) {
+          break;
+        }
+      }
+    }
+  }
+  if (pBufferDesc->ReturnValue >= 0) {
+    //
+    // Compute Digit.
+    // Loop until Digit has the value of the highest digit required.
+    // Example: If the output is 345 (Base 10), loop 2 times until Digit is 100.
+    //
+    while (1) {
+      if (NumDigits > 1u) {       // User specified a min number of digits to print? => Make sure we loop at least that often, before checking anything else (> 1 check avoids problems with NumDigits being signed / unsigned)
+        NumDigits--;
+      } else {
+        Div = v / Digit;
+        if (Div < Base) {        // Is our divider big enough to extract the highest digit from value? => Done
+          break;
+        }
+      }
+      Digit *= Base;
+    }
+    //
+    // Output digits
+    //
+    do {
+      Div = v / Digit;
+      v -= Div * Digit;
+      _StoreChar(pBufferDesc, _aV2C[Div]);
+      if (pBufferDesc->ReturnValue < 0) {
+        break;
+      }
+      Digit /= Base;
+    } while (Digit);
+    //
+    // Print trailing spaces if necessary
+    //
+    if ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == FORMAT_FLAG_LEFT_JUSTIFY) {
+      if (FieldWidth != 0u) {
+        while ((FieldWidth != 0u) && (Width < FieldWidth)) {
+          FieldWidth--;
+          _StoreChar(pBufferDesc, ' ');
+          if (pBufferDesc->ReturnValue < 0) {
+            break;
+          }
+        }
+      }
+    }
+  }
+}
+
+/*********************************************************************
+*
+*       _PrintInt
+*/
+static void _PrintInt(SEGGER_RTT_PRINTF_DESC * pBufferDesc, int v, unsigned Base, unsigned NumDigits, unsigned FieldWidth, unsigned FormatFlags) {
+  unsigned Width;
+  int Number;
+
+  Number = (v < 0) ? -v : v;
+
+  //
+  // Get actual field width
+  //
+  Width = 1u;
+  while (Number >= (int)Base) {
+    Number = (Number / (int)Base);
+    Width++;
+  }
+  if (NumDigits > Width) {
+    Width = NumDigits;
+  }
+  if ((FieldWidth > 0u) && ((v < 0) || ((FormatFlags & FORMAT_FLAG_PRINT_SIGN) == FORMAT_FLAG_PRINT_SIGN))) {
+    FieldWidth--;
+  }
+
+  //
+  // Print leading spaces if necessary
+  //
+  if ((((FormatFlags & FORMAT_FLAG_PAD_ZERO) == 0u) || (NumDigits != 0u)) && ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u)) {
+    if (FieldWidth != 0u) {
+      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
+        FieldWidth--;
+        _StoreChar(pBufferDesc, ' ');
+        if (pBufferDesc->ReturnValue < 0) {
+          break;
+        }
+      }
+    }
+  }
+  //
+  // Print sign if necessary
+  //
+  if (pBufferDesc->ReturnValue >= 0) {
+    if (v < 0) {
+      v = -v;
+      _StoreChar(pBufferDesc, '-');
+    } else if ((FormatFlags & FORMAT_FLAG_PRINT_SIGN) == FORMAT_FLAG_PRINT_SIGN) {
+      _StoreChar(pBufferDesc, '+');
+    } else {
+
+    }
+    if (pBufferDesc->ReturnValue >= 0) {
+      //
+      // Print leading zeros if necessary
+      //
+      if (((FormatFlags & FORMAT_FLAG_PAD_ZERO) == FORMAT_FLAG_PAD_ZERO) && ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u) && (NumDigits == 0u)) {
+        if (FieldWidth != 0u) {
+          while ((FieldWidth != 0u) && (Width < FieldWidth)) {
+            FieldWidth--;
+            _StoreChar(pBufferDesc, '0');
+            if (pBufferDesc->ReturnValue < 0) {
+              break;
+            }
+          }
+        }
+      }
+      if (pBufferDesc->ReturnValue >= 0) {
+        //
+        // Print number without sign
+        //
+        _PrintUnsigned(pBufferDesc, (unsigned)v, Base, NumDigits, FieldWidth, FormatFlags);
+      }
+    }
+  }
+}
+
+/*********************************************************************
+*
+*       Public code
+*
+**********************************************************************
+*/
+/*********************************************************************
+*
+*       SEGGER_RTT_vprintf
+*
+*  Function description
+*    Stores a formatted string in SEGGER RTT control block.
+*    This data is read by the host.
+*
+*  Parameters
+*    BufferIndex  Index of "Up"-buffer to be used. (e.g. 0 for "Terminal")
+*    sFormat      Pointer to format string
+*    pParamList   Pointer to the list of arguments for the format string
+*
+*  Return values
+*    >= 0:  Number of bytes which have been stored in the "Up"-buffer.
+*     < 0:  Error
+*/
+int SEGGER_RTT_vprintf(unsigned BufferIndex, const char * sFormat, va_list * pParamList) {
+  char c;
+  SEGGER_RTT_PRINTF_DESC BufferDesc;
+  int v;
+  unsigned NumDigits;
+  unsigned FormatFlags;
+  unsigned FieldWidth;
+  char acBuffer[SEGGER_RTT_PRINTF_BUFFER_SIZE];
+
+  BufferDesc.pBuffer        = acBuffer;
+  BufferDesc.BufferSize     = SEGGER_RTT_PRINTF_BUFFER_SIZE;
+  BufferDesc.Cnt            = 0u;
+  BufferDesc.RTTBufferIndex = BufferIndex;
+  BufferDesc.ReturnValue    = 0;
+
+  do {
+    c = *sFormat;
+    sFormat++;
+    if (c == 0u) {
+      break;
+    }
+    if (c == '%') {
+      //
+      // Filter out flags
+      //
+      FormatFlags = 0u;
+      v = 1;
+      do {
+        c = *sFormat;
+        switch (c) {
+        case '-': FormatFlags |= FORMAT_FLAG_LEFT_JUSTIFY; sFormat++; break;
+        case '0': FormatFlags |= FORMAT_FLAG_PAD_ZERO;     sFormat++; break;
+        case '+': FormatFlags |= FORMAT_FLAG_PRINT_SIGN;   sFormat++; break;
+        case '#': FormatFlags |= FORMAT_FLAG_ALTERNATE;    sFormat++; break;
+        default:  v = 0; break;
+        }
+      } while (v);
+      //
+      // filter out field with
+      //
+      FieldWidth = 0u;
+      do {
+        c = *sFormat;
+        if ((c < '0') || (c > '9')) {
+          break;
+        }
+        sFormat++;
+        FieldWidth = (FieldWidth * 10u) + ((unsigned)c - '0');
+      } while (1);
+
+      //
+      // Filter out precision (number of digits to display)
+      //
+      NumDigits = 0u;
+      c = *sFormat;
+      if (c == '.') {
+        sFormat++;
+        do {
+          c = *sFormat;
+          if ((c < '0') || (c > '9')) {
+            break;
+          }
+          sFormat++;
+          NumDigits = NumDigits * 10u + ((unsigned)c - '0');
+        } while (1);
+      }
+      //
+      // Filter out length modifier
+      //
+      c = *sFormat;
+      do {
+        if ((c == 'l') || (c == 'h')) {
+          sFormat++;
+          c = *sFormat;
+        } else {
+          break;
+        }
+      } while (1);
+      //
+      // Handle specifiers
+      //
+      switch (c) {
+      case 'c': {
+        char c0;
+        v = va_arg(*pParamList, int);
+        c0 = (char)v;
+        _StoreChar(&BufferDesc, c0);
+        break;
+      }
+      case 'd':
+        v = va_arg(*pParamList, int);
+        _PrintInt(&BufferDesc, v, 10u, NumDigits, FieldWidth, FormatFlags);
+        break;
+      case 'u':
+        v = va_arg(*pParamList, int);
+        _PrintUnsigned(&BufferDesc, (unsigned)v, 10u, NumDigits, FieldWidth, FormatFlags);
+        break;
+      case 'x':
+      case 'X':
+        v = va_arg(*pParamList, int);
+        _PrintUnsigned(&BufferDesc, (unsigned)v, 16u, NumDigits, FieldWidth, FormatFlags);
+        break;
+      case 's':
+        {
+          const char * s = va_arg(*pParamList, const char *);
+          do {
+            c = *s;
+            s++;
+            if (c == '\0') {
+              break;
+            }
+           _StoreChar(&BufferDesc, c);
+          } while (BufferDesc.ReturnValue >= 0);
+        }
+        break;
+      case 'p':
+        v = va_arg(*pParamList, int);
+        _PrintUnsigned(&BufferDesc, (unsigned)v, 16u, 8u, 8u, 0u);
+        break;
+      case '%':
+        _StoreChar(&BufferDesc, '%');
+        break;
+      default:
+        break;
+      }
+      sFormat++;
+    } else {
+      _StoreChar(&BufferDesc, c);
+    }
+  } while (BufferDesc.ReturnValue >= 0);
+
+  if (BufferDesc.ReturnValue > 0) {
+    //
+    // Write remaining data, if any
+    //
+    if (BufferDesc.Cnt != 0u) {
+      SEGGER_RTT_Write(BufferIndex, acBuffer, BufferDesc.Cnt);
+    }
+    BufferDesc.ReturnValue += (int)BufferDesc.Cnt;
+  }
+  return BufferDesc.ReturnValue;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_printf
+*
+*  Function description
+*    Stores a formatted string in SEGGER RTT control block.
+*    This data is read by the host.
+*
+*  Parameters
+*    BufferIndex  Index of "Up"-buffer to be used. (e.g. 0 for "Terminal")
+*    sFormat      Pointer to format string, followed by the arguments for conversion
+*
+*  Return values
+*    >= 0:  Number of bytes which have been stored in the "Up"-buffer.
+*     < 0:  Error
+*
+*  Notes
+*    (1) Conversion specifications have following syntax:
+*          %[flags][FieldWidth][.Precision]ConversionSpecifier
+*    (2) Supported flags:
+*          -: Left justify within the field width
+*          +: Always print sign extension for signed conversions
+*          0: Pad with 0 instead of spaces. Ignored when using '-'-flag or precision
+*        Supported conversion specifiers:
+*          c: Print the argument as one char
+*          d: Print the argument as a signed integer
+*          u: Print the argument as an unsigned integer
+*          x: Print the argument as an hexadecimal integer
+*          s: Print the string pointed to by the argument
+*          p: Print the argument as an 8-digit hexadecimal integer. (Argument shall be a pointer to void.)
+*/
+int SEGGER_RTT_printf(unsigned BufferIndex, const char * sFormat, ...) {
+  int r;
+  va_list ParamList;
+
+  va_start(ParamList, sFormat);
+  r = SEGGER_RTT_vprintf(BufferIndex, sFormat, &ParamList);
+  va_end(ParamList);
+  return r;
+}
+/*************************** End of file ****************************/
diff --git a/sched/systemview/SEGGER_SYSVIEW.c b/sched/systemview/SEGGER_SYSVIEW.c
new file mode 100644
index 0000000000..e2f3657a30
--- /dev/null
+++ b/sched/systemview/SEGGER_SYSVIEW.c
@@ -0,0 +1,2945 @@
+/*********************************************************************
+*                    SEGGER Microcontroller GmbH                     *
+*                        The Embedded Experts                        *
+**********************************************************************
+*                                                                    *
+*            (c) 1995 - 2019 SEGGER Microcontroller GmbH             *
+*                                                                    *
+*       www.segger.com     Support: support@segger.com               *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SEGGER SystemView * Real-time application analysis           *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+* All rights reserved.                                               *
+*                                                                    *
+* SEGGER strongly recommends to not make any changes                 *
+* to or modify the source code of this software in order to stay     *
+* compatible with the SystemView and RTT protocol, and J-Link.       *
+*                                                                    *
+* Redistribution and use in source and binary forms, with or         *
+* without modification, are permitted provided that the following    *
+* condition is met:                                                  *
+*                                                                    *
+* o Redistributions of source code must retain the above copyright   *
+*   notice, this condition and the following disclaimer.             *
+*                                                                    *
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
+* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
+* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
+* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
+* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
+* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
+* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
+* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
+* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
+* DAMAGE.                                                            *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SystemView version: V3.12                                    *
+*                                                                    *
+**********************************************************************
+-------------------------- END-OF-HEADER -----------------------------
+
+File    : SEGGER_SYSVIEW.c
+Purpose : System visualization API implementation.
+Revision: $Rev: 17331 $
+
+Additional information:
+  Packet format:
+    Packets with IDs 0..23 are standard packets with known structure.
+    For efficiency, they do *NOT* contain a length field.
+    <ID><Data><TimeStampDelta>
+
+    Packets with IDs 24..31 are standard packets with extendible
+    structure and contain a length field.
+    <ID><Lenght><Data><TimeStampDelta>
+    
+    Packet ID 31 is used for SystemView extended events.
+    <ID><Lenght><ID_EX><Data><TimeStampDelta>
+
+    Packets with IDs >= 32 always contain a length field.
+    <ID><Length><Data><TimeStampDelta>
+
+  Packet IDs:
+       0..  31 : Standard packets, known by SystemView.
+      32..1023 : OS-definable packets, described in a SystemView description file.
+    1024..2047 : User-definable packets, described in a SystemView description file.
+    2048..32767: Undefined.
+
+  Data encoding:
+    Basic types (int, short, char, ...):
+      Basic types are encoded little endian with most-significant bit variant
+      encoding.
+      Each encoded byte contains 7 data bits [6:0] and the MSB continuation bit.
+      The continuation bit indicates whether the next byte belongs to the data
+      (bit set) or this is the last byte (bit clear).
+      The most significant bits of data are encoded first, proceeding to the
+      least significant bits in the final byte (little endian).
+
+      Example encoding:
+        Data: 0x1F4 (500)
+        Encoded: 0xF4 (First 7 data bits 74 | Continuation bit)
+                 0x03 (Second 7 data bits 03, no continuation)
+
+        Data: 0xFFFFFFFF
+        Encoded: 0xFF 0xFF 0xFF 0xFF 0x0F
+
+        Data: 0xA2 (162),   0x03 (3), 0x7000
+        Encoded: 0xA2 0x01  0x03      0x80 0xE0 0x01
+
+    Byte arrays and strings:
+      Byte arrays and strings are encoded as <NumBytes> followed by the raw data.
+      NumBytes is encoded as a basic type with a theoretical maximum of 4G.
+
+      Example encoding:
+        Data: "Hello World\0" (0x48 0x65 0x6C 0x6C 0x6F 0x20 0x57 0x6F 0x72 0x6C 0x64 0x00)
+        Encoded: 0x0B 0x48 0x65 0x6C 0x6C 0x6F 0x20 0x57 0x6F 0x72 0x6C 0x64
+
+  Examples packets:
+  01 F4 03 80 80 10 // Overflow packet. Data is a single U32.
+                       This packet means: 500 packets lost, Timestamp is 0x40000
+
+  02 0F 50          // ISR(15) Enter. Timestamp 80 (0x50)
+
+  03 20             // ISR Exit. Timestamp 32 (0x20) (Shortest possible packet.)
+
+  Sample code for user defined Packets:
+    #define MY_ID   0x400                // Any value between 0x400 and 0x7FF
+    void SendMyPacket(unsigned Para0, unsigned Para1, const char* s) {
+      U8  aPacket[SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32 + MAX_STR_LEN + 1];
+      U8* pPayload;
+      //
+      pPayload = SEGGER_SYSVIEW_PPREPARE_PACKET(aPacket);               // Prepare the packet for SystemView
+      pPayload = SEGGER_SYSVIEW_EncodeU32(pPayload, Para0);             // Add the first parameter to the packet
+      pPayload = SEGGER_SYSVIEW_EncodeU32(pPayload, Para1);             // Add the second parameter to the packet
+      pPayload = SEGGER_SYSVIEW_EncodeString(pPayload, s, MAX_STR_LEN); // Add the string to the packet
+      //
+      SEGGER_SYSVIEW_SendPacket(&aPacket[0], pPayload, MY_ID);          // Send the packet with EventId = MY_ID
+    }
+
+    #define MY_ID_1 0x401
+    void SendOnePara(unsigned Para0) {
+      SEGGER_SYSVIEW_RecordU32(MY_ID_1, Para0);
+    }
+
+*/
+
+/*********************************************************************
+*
+*       #include section
+*
+**********************************************************************
+*/
+
+#include "SEGGER_SYSVIEW_Int.h"
+#include "SEGGER_RTT.h"
+#include <string.h>
+#include <stdlib.h>
+#include <stdarg.h>
+
+/*********************************************************************
+*
+*       Defines, fixed
+*
+**********************************************************************
+*/
+#if SEGGER_SYSVIEW_ID_SHIFT
+  #define SHRINK_ID(Id)   (((Id) - _SYSVIEW_Globals.RAMBaseAddress) >> SEGGER_SYSVIEW_ID_SHIFT)
+#else
+  #define SHRINK_ID(Id)   ((Id) - _SYSVIEW_Globals.RAMBaseAddress)
+#endif
+
+#if SEGGER_SYSVIEW_RTT_CHANNEL > 0
+  #define CHANNEL_ID_UP   SEGGER_SYSVIEW_RTT_CHANNEL
+  #define CHANNEL_ID_DOWN SEGGER_SYSVIEW_RTT_CHANNEL
+#else
+  #define CHANNEL_ID_UP   _SYSVIEW_Globals.UpChannel
+  #define CHANNEL_ID_DOWN _SYSVIEW_Globals.DownChannel
+#endif
+
+/*********************************************************************
+*
+*       Defines, configurable
+*
+**********************************************************************
+*/
+// Timestamps may be less than full 32-bits, in which case we need to zero
+// the unused bits to properly handle overflows.
+// Note that this is a quite common scenario, as a 32-bit time such as
+// SysTick might be scaled down to reduce bandwith
+// or a 16-bit hardware time might be used.
+#if SEGGER_SYSVIEW_TIMESTAMP_BITS < 32  // Eliminate unused bits in case hardware timestamps are less than 32 bits
+  #define MAKE_DELTA_32BIT(Delta) Delta <<= 32 - SEGGER_SYSVIEW_TIMESTAMP_BITS; \
+                                  Delta >>= 32 - SEGGER_SYSVIEW_TIMESTAMP_BITS;
+#else
+  #define MAKE_DELTA_32BIT(Delta)
+#endif
+
+
+/*********************************************************************
+*
+*       Defines, fixed
+*
+**********************************************************************
+*/
+#define ENABLE_STATE_OFF        0
+#define ENABLE_STATE_ON         1
+#define ENABLE_STATE_DROPPING   2
+
+#define FORMAT_FLAG_LEFT_JUSTIFY   (1u << 0)
+#define FORMAT_FLAG_PAD_ZERO       (1u << 1)
+#define FORMAT_FLAG_PRINT_SIGN     (1u << 2)
+#define FORMAT_FLAG_ALTERNATE      (1u << 3)
+
+#define MODULE_EVENT_OFFSET        (512)
+
+/*********************************************************************
+*
+*       Types, local
+*
+**********************************************************************
+*/
+typedef struct {
+  U8*       pBuffer;
+  U8*       pPayload;
+  U8*       pPayloadStart;
+  U32       Options;
+  unsigned  Cnt;
+} SEGGER_SYSVIEW_PRINTF_DESC;
+
+typedef struct {
+        U8                      EnableState;   // 0: Disabled, 1: Enabled, (2: Dropping)
+        U8                      UpChannel;
+        U8                      RecursionCnt;
+        U32                     SysFreq;
+        U32                     CPUFreq;
+        U32                     LastTxTimeStamp;
+        U32                     RAMBaseAddress;
+#if (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
+        U32                     PacketCount;
+#else
+        U32                     DropCount;
+        U8                      DownChannel;
+#endif
+        U32                     DisabledEvents;
+  const SEGGER_SYSVIEW_OS_API*  pOSAPI;
+        SEGGER_SYSVIEW_SEND_SYS_DESC_FUNC*   pfSendSysDesc;
+} SEGGER_SYSVIEW_GLOBALS;
+
+/*********************************************************************
+*
+*       Function prototypes, required
+*
+**********************************************************************
+*/
+static void _SendPacket(U8* pStartPacket, U8* pEndPacket, unsigned int EventId);
+
+/*********************************************************************
+*
+*       Static data
+*
+**********************************************************************
+*/
+static const U8 _abSync[10] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+
+#ifdef SEGGER_SYSVIEW_SECTION
+  #if (defined __GNUC__)
+    __attribute__ ((section (SEGGER_SYSVIEW_SECTION))) static char _UpBuffer  [SEGGER_SYSVIEW_RTT_BUFFER_SIZE];
+    #if (SEGGER_SYSVIEW_POST_MORTEM_MODE != 1)
+    __attribute__ ((section (SEGGER_SYSVIEW_SECTION))) static char _DownBuffer[8];  // Small, fixed-size buffer, for back-channel comms
+    #endif
+  #elif (defined __ICCARM__) || (defined __ICCRX__)
+    #pragma location=SEGGER_SYSVIEW_SECTION
+    static char _UpBuffer  [SEGGER_SYSVIEW_RTT_BUFFER_SIZE];
+    #pragma location=SEGGER_SYSVIEW_SECTION
+    static char _DownBuffer[8];  // Small, fixed-size buffer, for back-channel comms
+  #elif (defined __CC_ARM)
+    __attribute__ ((section (SEGGER_SYSVIEW_SECTION), zero_init)) static char _UpBuffer  [SEGGER_SYSVIEW_RTT_BUFFER_SIZE];
+    #if (SEGGER_SYSVIEW_POST_MORTEM_MODE != 1)
+    __attribute__ ((section (SEGGER_SYSVIEW_SECTION), zero_init)) static char _DownBuffer[8];  // Small, fixed-size buffer, for back-channel comms
+    #endif
+  #else
+    static char _UpBuffer  [SEGGER_SYSVIEW_RTT_BUFFER_SIZE];
+    #if (SEGGER_SYSVIEW_POST_MORTEM_MODE != 1)
+    static char _DownBuffer[8];  // Small, fixed-size buffer, for back-channel comms
+    #endif
+  #endif
+#else
+    static char _UpBuffer  [SEGGER_SYSVIEW_RTT_BUFFER_SIZE];
+    #if (SEGGER_SYSVIEW_POST_MORTEM_MODE != 1)
+    static char _DownBuffer[8];  // Small, fixed-size buffer, for back-channel comms
+    #endif
+#endif
+
+static SEGGER_SYSVIEW_GLOBALS _SYSVIEW_Globals;
+
+static SEGGER_SYSVIEW_MODULE* _pFirstModule;
+static U8                     _NumModules;
+
+/*********************************************************************
+*
+*       Static code
+*
+**********************************************************************
+*/
+
+#define ENCODE_U32(pDest, Value) {                                                  \
+                                   U8* pSysviewPointer;                             \
+                                   U32 SysViewData;                                 \
+                                   pSysviewPointer = pDest;                         \
+                                   SysViewData = Value;                             \
+                                   while(SysViewData > 0x7F) {                      \
+                                     *pSysviewPointer++ = (U8)(SysViewData | 0x80); \
+                                     SysViewData >>= 7;                             \
+                                   };                                               \
+                                   *pSysviewPointer++ = (U8)SysViewData;            \
+                                   pDest = pSysviewPointer;                         \
+                                 };
+
+
+
+#if (SEGGER_SYSVIEW_USE_STATIC_BUFFER == 1)
+static U8 _aPacket[SEGGER_SYSVIEW_MAX_PACKET_SIZE];
+
+#define RECORD_START(PacketSize)  SEGGER_SYSVIEW_LOCK();                            \
+                                  pPayloadStart = _PreparePacket(_aPacket);
+
+#define RECORD_END()              SEGGER_SYSVIEW_UNLOCK()
+
+#else
+
+#define RECORD_START(PacketSize)  U8 aPacket[(PacketSize)];                         \
+                                  pPayloadStart = _PreparePacket(aPacket);          \
+
+#define RECORD_END()
+
+#endif
+
+/*********************************************************************
+*
+*       _EncodeData()
+*
+*  Function description
+*    Encode a byte buffer in variable-length format.
+*
+*  Parameters
+*    pPayload - Pointer to where string will be encoded.
+*    pSrc     - Pointer to data buffer to be encoded.
+*    NumBytes - Number of bytes in the buffer to be encoded.
+*
+*  Return value
+*    Pointer to the byte following the value, i.e. the first free
+*    byte in the payload and the next position to store payload
+*    content.
+*
+*  Additional information
+*    The data is encoded as a count byte followed by the contents
+*    of the data buffer.
+*    Make sure NumBytes + 1 bytes are free for the payload.
+*/
+static U8* _EncodeData(U8* pPayload, const char* pSrc, unsigned int NumBytes) {
+  unsigned int n;
+  //
+  n = 0;
+  *pPayload++ = NumBytes;
+  while (n < NumBytes) {
+    *pPayload++ = *pSrc++;
+    n++;
+  }
+  return pPayload;
+}
+
+/*********************************************************************
+*
+*       _EncodeStr()
+*
+*  Function description
+*    Encode a string in variable-length format.
+*
+*  Parameters
+*    pPayload - Pointer to where string will be encoded.
+*    pText    - String to encode.
+*    Limit    - Maximum number of characters to encode from string.
+*
+*  Return value
+*    Pointer to the byte following the value, i.e. the first free
+*    byte in the payload and the next position to store payload
+*    content.
+*
+*  Additional information
+*    The string is encoded as a count byte followed by the contents
+*    of the string.
+*    No more than 1 + Limit bytes will be encoded to the payload.
+*/
+static U8 *_EncodeStr(U8 *pPayload, const char *pText, unsigned int Limit) {
+  unsigned int n;
+  unsigned int Len;
+  //
+  // Compute string len
+  //
+  Len = 0;
+  while(*(pText + Len) != 0) {
+    Len++;
+  }
+  if (Len > Limit) {
+    Len = Limit;
+  }
+  //
+  // Write Len
+  //
+  if (Len < 255)  {
+    *pPayload++ = Len; 
+  } else {
+    *pPayload++ = 255;
+    *pPayload++ = (Len & 255);
+    *pPayload++ = ((Len >> 8) & 255);
+  }
+  //
+  // copy string
+  //
+  n = 0;
+  while (n < Len) {
+    *pPayload++ = *pText++;
+    n++;
+  }
+  return pPayload;
+}
+
+/*********************************************************************
+*
+*       _PreparePacket()
+*
+*  Function description
+*    Prepare a SystemView event packet header.
+*
+*  Parameters
+*    pPacket - Pointer to start of packet to initialize.
+*
+*  Return value
+*    Pointer to first byte of packet payload.
+*
+*  Additional information
+*    The payload length and evnetId are not initialized.
+*    PreparePacket only reserves space for them and they are
+*    computed and filled in by the sending function.
+*/
+static U8* _PreparePacket(U8* pPacket) {
+  return pPacket + 4;
+}
+
+/*********************************************************************
+*
+*       _HandleIncomingPacket()
+*
+*  Function description
+*    Read an incoming command from the down channel and process it.
+*
+*  Additional information
+*    This function is called each time after sending a packet.
+*    Processing incoming packets is done asynchronous. SystemView might
+*    already have sent event packets after the host has sent a command.
+*/
+#if (SEGGER_SYSVIEW_POST_MORTEM_MODE != 1)
+static void _HandleIncomingPacket(void) {
+  U8  Cmd;
+  int Status;
+  //
+  Status = SEGGER_RTT_ReadNoLock(CHANNEL_ID_DOWN, &Cmd, 1);
+  if (Status > 0) {
+    switch (Cmd) {
+    case SEGGER_SYSVIEW_COMMAND_ID_START:
+      SEGGER_SYSVIEW_Start();
+      break;
+    case SEGGER_SYSVIEW_COMMAND_ID_STOP:
+      SEGGER_SYSVIEW_Stop();
+      break;
+    case SEGGER_SYSVIEW_COMMAND_ID_GET_SYSTIME:
+      SEGGER_SYSVIEW_RecordSystime();
+      break;
+    case SEGGER_SYSVIEW_COMMAND_ID_GET_TASKLIST:
+      SEGGER_SYSVIEW_SendTaskList();
+      break;
+    case SEGGER_SYSVIEW_COMMAND_ID_GET_SYSDESC:
+      SEGGER_SYSVIEW_GetSysDesc();
+      break;
+    case SEGGER_SYSVIEW_COMMAND_ID_GET_NUMMODULES:
+      SEGGER_SYSVIEW_SendNumModules();
+      break;
+    case SEGGER_SYSVIEW_COMMAND_ID_GET_MODULEDESC:
+      SEGGER_SYSVIEW_SendModuleDescription();
+      break;
+    case SEGGER_SYSVIEW_COMMAND_ID_GET_MODULE:
+      Status = SEGGER_RTT_ReadNoLock(CHANNEL_ID_DOWN, &Cmd, 1);
+      if (Status > 0) {
+        SEGGER_SYSVIEW_SendModule(Cmd);
+      }
+      break;
+    default:
+      if (Cmd >= 128) { // Unknown extended command. Dummy read its parameter.
+        SEGGER_RTT_ReadNoLock(CHANNEL_ID_DOWN, &Cmd, 1);
+      }
+      break;
+    }
+  }
+}
+#endif // (SEGGER_SYSVIEW_POST_MORTEM_MODE != 1)
+
+/*********************************************************************
+*
+*       _TrySendOverflowPacket()
+*
+*  Function description
+*    Try to transmit an SystemView Overflow packet containing the
+*    number of dropped packets.
+*
+*  Additional information
+*    Format as follows:
+*      01 <DropCnt><TimeStamp>  Max. packet len is 1 + 5 + 5 = 11
+*
+*    Example packets sent
+*      01 20 40
+*
+*  Return value
+*    !=0:  Success, Message sent (stored in RTT-Buffer)
+*    ==0:  Buffer full, Message *NOT* stored
+*
+*/
+#if (SEGGER_SYSVIEW_POST_MORTEM_MODE != 1)
+static int _TrySendOverflowPacket(void) {
+  U32 TimeStamp;
+  I32 Delta;
+  int Status;
+  U8  aPacket[11];
+  U8* pPayload;
+
+  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
+  pPayload   = &aPacket[1];
+  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
+  //
+  // Compute time stamp delta and append it to packet.
+  //
+  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
+  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
+  MAKE_DELTA_32BIT(Delta);
+  ENCODE_U32(pPayload, Delta);
+  //
+  // Try to store packet in RTT buffer and update time stamp when this was successful
+  //
+  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
+  SEGGER_SYSVIEW_ON_EVENT_RECORDED(pPayload - aPacket);
+  if (Status) {
+    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
+    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
+  } else {
+    _SYSVIEW_Globals.DropCount++;
+  }
+  //
+  return Status;
+}
+#endif  // (SEGGER_SYSVIEW_POST_MORTEM_MODE != 1)
+
+/*********************************************************************
+*
+*       _SendSyncInfo()
+*
+*  Function description
+*    Send SystemView sync packet and system information in 
+*    post mortem mode.
+*
+*  Additional information
+*    Sync is 10 * 0x00 without timestamp
+*/
+#if (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
+static void _SendSyncInfo(void) {
+  //
+  // Add sync packet ( 10 * 0x00)
+  // Send system description
+  // Send system time
+  // Send task list
+  // Send module description
+  // Send module information
+  //
+  SEGGER_RTT_WriteWithOverwriteNoLock(CHANNEL_ID_UP, _abSync, 10);
+  SEGGER_SYSVIEW_ON_EVENT_RECORDED(10);
+  SEGGER_SYSVIEW_RecordVoid(SYSVIEW_EVTID_TRACE_START);
+  {
+    U8* pPayload;
+    U8* pPayloadStart;
+    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 4 * SEGGER_SYSVIEW_QUANTA_U32);
+    //
+    pPayload = pPayloadStart;
+    ENCODE_U32(pPayload, _SYSVIEW_Globals.SysFreq);
+    ENCODE_U32(pPayload, _SYSVIEW_Globals.CPUFreq);
+    ENCODE_U32(pPayload, _SYSVIEW_Globals.RAMBaseAddress);
+    ENCODE_U32(pPayload, SEGGER_SYSVIEW_ID_SHIFT);
+    _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_INIT);
+    RECORD_END();
+  }
+  if (_SYSVIEW_Globals.pfSendSysDesc) {
+    _SYSVIEW_Globals.pfSendSysDesc();
+  }
+  SEGGER_SYSVIEW_RecordSystime();
+  SEGGER_SYSVIEW_SendTaskList();
+  if (_NumModules > 0) {
+    int n;
+    SEGGER_SYSVIEW_SendNumModules();
+    for (n = 0; n < _NumModules; n++) {
+      SEGGER_SYSVIEW_SendModule(n);
+    }
+    SEGGER_SYSVIEW_SendModuleDescription();
+  }
+}
+#endif  // (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
+
+/*********************************************************************
+*
+*       _SendPacket()
+*
+*  Function description
+*    Send a SystemView packet over RTT. RTT channel and mode are
+*    configured by macros when the SystemView component is initialized.
+*    This function takes care of maintaining the packet drop count
+*    and sending overflow packets when necessary.
+*    The packet must be passed without Id and Length because this
+*    function prepends it to the packet before transmission.
+*
+*  Parameters
+*    pStartPacket - Pointer to start of packet payload.
+*                   There must be at least 4 bytes free to prepend Id and Length.
+*    pEndPacket   - Pointer to end of packet payload.
+*    EventId      - Id of the event to send.
+*
+*/
+static void _SendPacket(U8* pStartPacket, U8* pEndPacket, unsigned int EventId) {
+  unsigned int  NumBytes;
+  U32           TimeStamp;
+  U32           Delta;
+#if (SEGGER_SYSVIEW_POST_MORTEM_MODE != 1)
+  int           Status;
+#endif
+
+#if (SEGGER_SYSVIEW_USE_STATIC_BUFFER == 0)
+  SEGGER_SYSVIEW_LOCK();
+#endif
+
+#if (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
+  if (_SYSVIEW_Globals.EnableState == 0) {
+    goto SendDone;
+  }
+#else
+  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
+    goto Send;
+  }
+  if (_SYSVIEW_Globals.EnableState == 0) {
+    goto SendDone;
+  }
+  //
+  // Handle buffer full situations:
+  // Have packets been dropped before because buffer was full?
+  // In this case try to send and overflow packet.
+  //
+  if (_SYSVIEW_Globals.EnableState == 2) {
+    _TrySendOverflowPacket();
+    if (_SYSVIEW_Globals.EnableState != 1) {
+      goto SendDone;
+    }
+  }
+Send:
+#endif
+  //
+  // Check if event is disabled from being recorded.
+  //
+  if (EventId < 32) {
+    if (_SYSVIEW_Globals.DisabledEvents & ((U32)1u << EventId)) {
+      goto SendDone;
+    }
+  }
+  //
+  // Prepare actual packet.
+  // If it is a known packet, prepend eventId only,
+  // otherwise prepend packet length and eventId.
+  //
+  if (EventId < 24) {
+    *--pStartPacket = EventId;
+  } else {
+    NumBytes = pEndPacket - pStartPacket;
+    if (NumBytes > 127) {
+      *--pStartPacket = (NumBytes >> 7);
+      *--pStartPacket = NumBytes | 0x80;
+    } else {
+      *--pStartPacket = NumBytes;
+    }
+    if (EventId > 127) {
+      *--pStartPacket = (EventId >> 7);
+      *--pStartPacket = EventId | 0x80;
+    } else {
+      *--pStartPacket = EventId;
+    }
+  }
+  //
+  // Compute time stamp delta and append it to packet.
+  //
+  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
+  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
+  MAKE_DELTA_32BIT(Delta);
+  ENCODE_U32(pEndPacket, Delta);
+#if (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
+  //
+  // Store packet in RTT buffer by overwriting old data and update time stamp
+  //
+  SEGGER_RTT_WriteWithOverwriteNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
+  SEGGER_SYSVIEW_ON_EVENT_RECORDED(pEndPacket - pStartPacket);
+  _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
+#else
+  //
+  // Try to store packet in RTT buffer and update time stamp when this was successful
+  //
+  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
+  SEGGER_SYSVIEW_ON_EVENT_RECORDED(pEndPacket - pStartPacket);
+  if (Status) {
+    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
+  } else {
+    _SYSVIEW_Globals.EnableState++; // EnableState has been 1, will be 2. Always.
+  }
+#endif
+
+#if (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
+  //
+  // Add sync and system information periodically if we are in post mortem mode
+  //
+  if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
+    _SYSVIEW_Globals.RecursionCnt = 1;
+    if (_SYSVIEW_Globals.PacketCount++ & (1 << SEGGER_SYSVIEW_SYNC_PERIOD_SHIFT)) {
+      _SendSyncInfo();
+      _SYSVIEW_Globals.PacketCount = 0;
+    }
+    _SYSVIEW_Globals.RecursionCnt = 0;
+  }
+SendDone:
+  ; // Avoid "label at end of compound statement" error when using static buffer
+#else
+SendDone:
+  //
+  // Check if host is sending data which needs to be processed.
+  // Note that since this code is called for every packet, it is very time critical, so we do
+  // only what is really needed here, which is checking if there is any data
+  //
+  if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
+    if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
+      _SYSVIEW_Globals.RecursionCnt = 1;
+      _HandleIncomingPacket();
+      _SYSVIEW_Globals.RecursionCnt = 0;
+    }
+  }
+#endif
+  //
+#if (SEGGER_SYSVIEW_USE_STATIC_BUFFER == 0)
+  SEGGER_SYSVIEW_UNLOCK();  // We are done. Unlock and return
+#endif
+}
+
+#ifndef SEGGER_SYSVIEW_EXCLUDE_PRINTF // Define in project to avoid warnings about variable parameter list
+/*********************************************************************
+*
+*       _VPrintHost()
+*
+*  Function description
+*    Send a format string and its parameters to the host.
+*
+*  Parameters
+*    s            Pointer to format string.
+*    Options      Options to be sent to the host.
+*    pParamList   Pointer to the list of arguments for the format string.
+*/
+static int _VPrintHost(const char* s, U32 Options, va_list* pParamList) {
+  U32         aParas[SEGGER_SYSVIEW_MAX_ARGUMENTS];
+  U32*        pParas;
+  U32         NumArguments;
+  const char* p;
+  char        c;
+  U8*         pPayload;
+  U8*         pPayloadStart;
+#if SEGGER_SYSVIEW_PRINTF_IMPLICIT_FORMAT
+  U8 HasNonScalar;
+  
+  HasNonScalar = 0;
+#endif  
+  //
+  // Count number of arguments by counting '%' characters in string.
+  // If enabled, check for non-scalar modifier flags to format string on the target.
+  //
+  p = s;
+  NumArguments = 0;
+  for (;;) {
+    c = *p++;
+    if (c == 0) {
+      break;
+    }
+    if (c == '%') {
+      c = *p;
+#if SEGGER_SYSVIEW_PRINTF_IMPLICIT_FORMAT == 0
+      aParas[NumArguments++] = va_arg(*pParamList, int);
+      if (NumArguments == SEGGER_SYSVIEW_MAX_ARGUMENTS) {
+        break;
+      }
+#else
+      if (c == 's') {
+        HasNonScalar = 1;
+        break;
+      } else {
+        aParas[NumArguments++] = va_arg(*pParamList, int);
+        if (NumArguments == SEGGER_SYSVIEW_MAX_ARGUMENTS) {
+          break;
+        }
+      }
+#endif
+    }
+  }
+
+#if SEGGER_SYSVIEW_PRINTF_IMPLICIT_FORMAT
+  if (HasNonScalar) {
+    return -1;
+  }
+#endif
+  //
+  // Send string and parameters to host
+  //
+  {
+    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_MAX_STRING_LEN + 2 * SEGGER_SYSVIEW_QUANTA_U32 + SEGGER_SYSVIEW_MAX_ARGUMENTS * SEGGER_SYSVIEW_QUANTA_U32);
+    pPayload = _EncodeStr(pPayloadStart, s, SEGGER_SYSVIEW_MAX_STRING_LEN);
+    ENCODE_U32(pPayload, Options);
+    ENCODE_U32(pPayload, NumArguments);
+    pParas = aParas;
+    while (NumArguments--) {
+      ENCODE_U32(pPayload, (*pParas));
+      pParas++;
+    }
+    _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
+    RECORD_END();
+  }
+  return 0;
+}
+
+/*********************************************************************
+*
+*       _StoreChar()
+*
+*  Function description
+*    Stores a character in the printf-buffer and sends the buffer when
+*     it is filled.
+*
+*  Parameters
+*    p            Pointer to the buffer description.
+*    c            Character to be printed.
+*/
+static void _StoreChar(SEGGER_SYSVIEW_PRINTF_DESC * p, char c) {
+  unsigned int  Cnt;
+  U8*           pPayload;
+  U32           Options;
+
+  Cnt = p->Cnt;
+  if ((Cnt + 1u) <= SEGGER_SYSVIEW_MAX_STRING_LEN) {
+    *(p->pPayload++) = c;
+    p->Cnt = Cnt + 1u;
+  }
+  //
+  // Write part of string, when the buffer is full
+  //
+  if (p->Cnt == SEGGER_SYSVIEW_MAX_STRING_LEN) {
+    *(p->pPayloadStart) = p->Cnt;
+    pPayload = p->pPayload;
+    Options = p->Options;
+    ENCODE_U32(pPayload, Options);
+    ENCODE_U32(pPayload, 0);
+    _SendPacket(p->pPayloadStart, pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
+    p->pPayloadStart = _PreparePacket(p->pBuffer);
+    p->pPayload = p->pPayloadStart + 1u;
+    p->Cnt = 0u;
+  }
+}
+
+/*********************************************************************
+*
+*       _PrintUnsigned()
+*
+*  Function description
+*    Print an unsigned integer with the given formatting into the 
+*     formatted string.
+*
+*  Parameters
+*    pBufferDesc  Pointer to the buffer description.
+*    v            Value to be printed.
+*    Base         Base of the value.
+*    NumDigits    Number of digits to be printed.
+*    FieldWidth   Width of the printed field.
+*    FormatFlags  Flags for formatting the value.
+*/
+static void _PrintUnsigned(SEGGER_SYSVIEW_PRINTF_DESC * pBufferDesc, unsigned int v, unsigned int Base, unsigned int NumDigits, unsigned int FieldWidth, unsigned int FormatFlags) {
+  static const char _aV2C[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
+  unsigned int      Div;
+  unsigned int      Digit;
+  unsigned int      Number;
+  unsigned int      Width;
+  char              c;
+
+  Number = v;
+  Digit = 1u;
+  //
+  // Get actual field width
+  //
+  Width = 1u;
+  while (Number >= Base) {
+    Number = (Number / Base);
+    Width++;
+  }
+  if (NumDigits > Width) {
+    Width = NumDigits;
+  }
+  //
+  // Print leading chars if necessary
+  //
+  if ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u) {
+    if (FieldWidth != 0u) {
+      if (((FormatFlags & FORMAT_FLAG_PAD_ZERO) == FORMAT_FLAG_PAD_ZERO) && (NumDigits == 0u)) {
+        c = '0';
+      } else {
+        c = ' ';
+      }
+      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
+        FieldWidth--;
+        _StoreChar(pBufferDesc, c);
+      }
+    }
+  }
+  //
+  // Compute Digit.
+  // Loop until Digit has the value of the highest digit required.
+  // Example: If the output is 345 (Base 10), loop 2 times until Digit is 100.
+  //
+  while (1) {
+    if (NumDigits > 1u) {       // User specified a min number of digits to print? => Make sure we loop at least that often, before checking anything else (> 1 check avoids problems with NumDigits being signed / unsigned)
+      NumDigits--;
+    } else {
+      Div = v / Digit;
+      if (Div < Base) {        // Is our divider big enough to extract the highest digit from value? => Done
+        break;
+      }
+    }
+    Digit *= Base;
+  }
+  //
+  // Output digits
+  //
+  do {
+    Div = v / Digit;
+    v -= Div * Digit;
+    _StoreChar(pBufferDesc, _aV2C[Div]);
+    Digit /= Base;
+  } while (Digit);
+  //
+  // Print trailing spaces if necessary
+  //
+  if ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == FORMAT_FLAG_LEFT_JUSTIFY) {
+    if (FieldWidth != 0u) {
+      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
+        FieldWidth--;
+        _StoreChar(pBufferDesc, ' ');
+      }
+    }
+  }
+}
+
+/*********************************************************************
+*
+*       _PrintInt()
+*
+*  Function description
+*    Print a signed integer with the given formatting into the 
+*     formatted string.
+*
+*  Parameters
+*    pBufferDesc  Pointer to the buffer description.
+*    v            Value to be printed.
+*    Base         Base of the value.
+*    NumDigits    Number of digits to be printed.
+*    FieldWidth   Width of the printed field.
+*    FormatFlags  Flags for formatting the value.
+*/
+static void _PrintInt(SEGGER_SYSVIEW_PRINTF_DESC * pBufferDesc, int v, unsigned int Base, unsigned int NumDigits, unsigned int FieldWidth, unsigned int FormatFlags) {
+  unsigned int  Width;
+  int           Number;
+
+  Number = (v < 0) ? -v : v;
+
+  //
+  // Get actual field width
+  //
+  Width = 1u;
+  while (Number >= (int)Base) {
+    Number = (Number / (int)Base);
+    Width++;
+  }
+  if (NumDigits > Width) {
+    Width = NumDigits;
+  }
+  if ((FieldWidth > 0u) && ((v < 0) || ((FormatFlags & FORMAT_FLAG_PRINT_SIGN) == FORMAT_FLAG_PRINT_SIGN))) {
+    FieldWidth--;
+  }
+
+  //
+  // Print leading spaces if necessary
+  //
+  if ((((FormatFlags & FORMAT_FLAG_PAD_ZERO) == 0u) || (NumDigits != 0u)) && ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u)) {
+    if (FieldWidth != 0u) {
+      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
+        FieldWidth--;
+        _StoreChar(pBufferDesc, ' ');
+      }
+    }
+  }
+  //
+  // Print sign if necessary
+  //
+  if (v < 0) {
+    v = -v;
+    _StoreChar(pBufferDesc, '-');
+  } else if ((FormatFlags & FORMAT_FLAG_PRINT_SIGN) == FORMAT_FLAG_PRINT_SIGN) {
+    _StoreChar(pBufferDesc, '+');
+  } else {
+
+  }
+  //
+  // Print leading zeros if necessary
+  //
+  if (((FormatFlags & FORMAT_FLAG_PAD_ZERO) == FORMAT_FLAG_PAD_ZERO) && ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u) && (NumDigits == 0u)) {
+    if (FieldWidth != 0u) {
+      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
+        FieldWidth--;
+        _StoreChar(pBufferDesc, '0');
+      }
+    }
+  }
+  //
+  // Print number without sign
+  //
+  _PrintUnsigned(pBufferDesc, (unsigned int)v, Base, NumDigits, FieldWidth, FormatFlags);
+}
+
+/*********************************************************************
+*
+*       _VPrintTarget()
+*
+*  Function description
+*    Stores a formatted string.
+*    This data is read by the host.
+*
+*  Parameters
+*    sFormat      Pointer to format string.
+*    Options      Options to be sent to the host.
+*    pParamList   Pointer to the list of arguments for the format string.
+*/
+static void _VPrintTarget(const char* sFormat, U32 Options, va_list* pParamList) {
+  SEGGER_SYSVIEW_PRINTF_DESC BufferDesc;
+  char          c;
+  int           v;
+  unsigned int  NumDigits;
+  unsigned int  FormatFlags;
+  unsigned int  FieldWidth;
+  U8*           pPayloadStart;
+#if SEGGER_SYSVIEW_USE_STATIC_BUFFER == 0
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_MAX_STRING_LEN + 1 + 2 * SEGGER_SYSVIEW_QUANTA_U32);
+  SEGGER_SYSVIEW_LOCK();
+#else
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_MAX_STRING_LEN + 1 + 2 * SEGGER_SYSVIEW_QUANTA_U32);
+#endif
+
+#if SEGGER_SYSVIEW_USE_STATIC_BUFFER == 0
+  BufferDesc.pBuffer        = aPacket;
+#else
+  BufferDesc.pBuffer        = _aPacket;
+#endif
+  BufferDesc.Cnt            = 0u;
+  BufferDesc.pPayloadStart  = pPayloadStart;
+  BufferDesc.pPayload       = BufferDesc.pPayloadStart + 1u;
+  BufferDesc.Options        =  Options;
+
+  do {
+    c = *sFormat;
+    sFormat++;
+    if (c == 0u) {
+      break;
+    }
+    if (c == '%') {
+      //
+      // Filter out flags
+      //
+      FormatFlags = 0u;
+      v = 1;
+      do {
+        c = *sFormat;
+        switch (c) {
+        case '-': FormatFlags |= FORMAT_FLAG_LEFT_JUSTIFY; sFormat++; break;
+        case '0': FormatFlags |= FORMAT_FLAG_PAD_ZERO;     sFormat++; break;
+        case '+': FormatFlags |= FORMAT_FLAG_PRINT_SIGN;   sFormat++; break;
+        case '#': FormatFlags |= FORMAT_FLAG_ALTERNATE;    sFormat++; break;
+        default:  v = 0; break;
+        }
+      } while (v);
+      //
+      // filter out field with
+      //
+      FieldWidth = 0u;
+      do {
+        c = *sFormat;
+        if ((c < '0') || (c > '9')) {
+          break;
+        }
+        sFormat++;
+        FieldWidth = (FieldWidth * 10u) + ((unsigned int)c - '0');
+      } while (1);
+
+      //
+      // Filter out precision (number of digits to display)
+      //
+      NumDigits = 0u;
+      c = *sFormat;
+      if (c == '.') {
+        sFormat++;
+        do {
+          c = *sFormat;
+          if ((c < '0') || (c > '9')) {
+            break;
+          }
+          sFormat++;
+          NumDigits = NumDigits * 10u + ((unsigned int)c - '0');
+        } while (1);
+      }
+      //
+      // Filter out length modifier
+      //
+      c = *sFormat;
+      do {
+        if ((c == 'l') || (c == 'h')) {
+          c = *sFormat;
+          sFormat++;
+        } else {
+          break;
+        }
+      } while (1);
+      //
+      // Handle specifiers
+      //
+      switch (c) {
+      case 'c': {
+        char c0;
+        v = va_arg(*pParamList, int);
+        c0 = (char)v;
+        _StoreChar(&BufferDesc, c0);
+        break;
+      }
+      case 'd':
+        v = va_arg(*pParamList, int);
+        _PrintInt(&BufferDesc, v, 10u, NumDigits, FieldWidth, FormatFlags);
+        break;
+      case 'u':
+        v = va_arg(*pParamList, int);
+        _PrintUnsigned(&BufferDesc, (unsigned int)v, 10u, NumDigits, FieldWidth, FormatFlags);
+        break;
+      case 'x':
+      case 'X':
+        v = va_arg(*pParamList, int);
+        _PrintUnsigned(&BufferDesc, (unsigned int)v, 16u, NumDigits, FieldWidth, FormatFlags);
+        break;
+      case 'p':
+        v = va_arg(*pParamList, int);
+        _PrintUnsigned(&BufferDesc, (unsigned int)v, 16u, 8u, 8u, 0u);
+        break;
+      case '%':
+        _StoreChar(&BufferDesc, '%');
+        break;
+      default:
+        break;
+      }
+      sFormat++;
+    } else {
+      _StoreChar(&BufferDesc, c);
+    }
+  } while (*sFormat);
+
+  //
+  // Write remaining data, if any
+  //
+  if (BufferDesc.Cnt != 0u) {
+    *(BufferDesc.pPayloadStart) = BufferDesc.Cnt;
+    ENCODE_U32(BufferDesc.pPayload, BufferDesc.Options);
+    ENCODE_U32(BufferDesc.pPayload, 0);
+    _SendPacket(BufferDesc.pPayloadStart, BufferDesc.pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
+  }
+#if SEGGER_SYSVIEW_USE_STATIC_BUFFER == 0
+  SEGGER_SYSVIEW_UNLOCK();
+  RECORD_END();
+#else
+  RECORD_END();
+#endif
+}
+#endif // SEGGER_SYSVIEW_EXCLUDE_PRINTF
+
+/*********************************************************************
+*
+*       Public code
+*
+**********************************************************************
+*/
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_Init()
+*
+*  Function description
+*    Initializes the SYSVIEW module.
+*    Must be called before the Systemview Application connects to 
+*    the system.
+*
+*  Parameters
+*    SysFreq        - Frequency of timestamp, usually CPU core clock frequency.
+*    CPUFreq        - CPU core clock frequency.
+*    pOSAPI         - Pointer to the API structure for OS-specific functions.
+*    pfSendSysDesc  - Pointer to record system description callback function.
+*
+*  Additional information
+*    This function initializes the RTT channel used to transport 
+*    SEGGER SystemView packets. 
+*    The channel is assigned the label "SysView" for client software 
+*    to identify the SystemView channel.
+*
+*    The channel is configured with the macro SEGGER_SYSVIEW_RTT_CHANNEL.
+*/
+void SEGGER_SYSVIEW_Init(U32 SysFreq, U32 CPUFreq, const SEGGER_SYSVIEW_OS_API *pOSAPI, SEGGER_SYSVIEW_SEND_SYS_DESC_FUNC pfSendSysDesc) {
+#ifdef SEGGER_RTT_SECTION
+  //
+  // Explicitly initialize the RTT Control Block if it is in its dedicated section.
+  //
+  SEGGER_RTT_Init();
+#endif
+#if (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
+#if SEGGER_SYSVIEW_RTT_CHANNEL > 0
+  SEGGER_RTT_ConfigUpBuffer(SEGGER_SYSVIEW_RTT_CHANNEL, "SysView", &_UpBuffer[0],   sizeof(_UpBuffer),   SEGGER_RTT_MODE_NO_BLOCK_SKIP);
+#else
+  _SYSVIEW_Globals.UpChannel = SEGGER_RTT_AllocUpBuffer  ("SysView", &_UpBuffer[0],   sizeof(_UpBuffer),   SEGGER_RTT_MODE_NO_BLOCK_SKIP);
+#endif
+  _SYSVIEW_Globals.RAMBaseAddress   = SEGGER_SYSVIEW_ID_BASE;
+  _SYSVIEW_Globals.LastTxTimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
+  _SYSVIEW_Globals.pOSAPI           = pOSAPI;
+  _SYSVIEW_Globals.SysFreq          = SysFreq;
+  _SYSVIEW_Globals.CPUFreq          = CPUFreq;
+  _SYSVIEW_Globals.pfSendSysDesc    = pfSendSysDesc;
+  _SYSVIEW_Globals.EnableState      = 0;
+  _SYSVIEW_Globals.PacketCount      = 0;
+#else // (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
+#if SEGGER_SYSVIEW_RTT_CHANNEL > 0
+  SEGGER_RTT_ConfigUpBuffer   (SEGGER_SYSVIEW_RTT_CHANNEL, "SysView", &_UpBuffer[0],   sizeof(_UpBuffer),   SEGGER_RTT_MODE_NO_BLOCK_SKIP);
+  SEGGER_RTT_ConfigDownBuffer (SEGGER_SYSVIEW_RTT_CHANNEL, "SysView", &_DownBuffer[0], sizeof(_DownBuffer), SEGGER_RTT_MODE_NO_BLOCK_SKIP);
+#else
+  _SYSVIEW_Globals.UpChannel = SEGGER_RTT_AllocUpBuffer  ("SysView", &_UpBuffer[0],   sizeof(_UpBuffer),   SEGGER_RTT_MODE_NO_BLOCK_SKIP);
+  _SYSVIEW_Globals.DownChannel = _SYSVIEW_Globals.UpChannel;
+  SEGGER_RTT_ConfigDownBuffer (_SYSVIEW_Globals.DownChannel, "SysView", &_DownBuffer[0], sizeof(_DownBuffer), SEGGER_RTT_MODE_NO_BLOCK_SKIP);
+#endif
+  _SYSVIEW_Globals.RAMBaseAddress   = SEGGER_SYSVIEW_ID_BASE;
+  _SYSVIEW_Globals.LastTxTimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
+  _SYSVIEW_Globals.pOSAPI           = pOSAPI;
+  _SYSVIEW_Globals.SysFreq          = SysFreq;
+  _SYSVIEW_Globals.CPUFreq          = CPUFreq;
+  _SYSVIEW_Globals.pfSendSysDesc    = pfSendSysDesc;
+  _SYSVIEW_Globals.EnableState      = 0;
+#endif  // (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_SetRAMBase()
+*
+*  Function description
+*    Sets the RAM base address, which is subtracted from IDs in order
+*     to save bandwidth.
+*
+*  Parameters
+*    RAMBaseAddress - Lowest RAM Address. (i.e. 0x20000000 on most Cortex-M)
+*/
+void SEGGER_SYSVIEW_SetRAMBase(U32 RAMBaseAddress) {
+  _SYSVIEW_Globals.RAMBaseAddress = RAMBaseAddress;
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordVoid()
+*
+*  Function description
+*    Formats and sends a SystemView packet with an empty payload.
+*
+*  Parameters
+*    EventID - SystemView event ID.
+*/
+void SEGGER_SYSVIEW_RecordVoid(unsigned int EventID) {
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
+  //
+  _SendPacket(pPayloadStart, pPayloadStart, EventID);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordU32()
+*
+*  Function description
+*    Formats and sends a SystemView packet containing a single U32
+*    parameter payload.
+*
+*  Parameters
+*    EventID - SystemView event ID.
+*    Value   - The 32-bit parameter encoded to SystemView packet payload.
+*/
+void SEGGER_SYSVIEW_RecordU32(unsigned int EventID, U32 Value) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, Value);
+  _SendPacket(pPayloadStart, pPayload, EventID);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordU32x2()
+*
+*  Function description
+*    Formats and sends a SystemView packet containing 2 U32 parameter payload.
+*
+*  Parameters
+*    EventID - SystemView event ID.
+*    Para0   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para1   - The 32-bit parameter encoded to SystemView packet payload.
+*/
+void SEGGER_SYSVIEW_RecordU32x2(unsigned int EventID, U32 Para0, U32 Para1) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, Para0);
+  ENCODE_U32(pPayload, Para1);
+  _SendPacket(pPayloadStart, pPayload, EventID);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordU32x3()
+*
+*  Function description
+*    Formats and sends a SystemView packet containing 3 U32 parameter payload.
+*
+*  Parameters
+*    EventID - SystemView event ID.
+*    Para0   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para1   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para2   - The 32-bit parameter encoded to SystemView packet payload.
+*/
+void SEGGER_SYSVIEW_RecordU32x3(unsigned int EventID, U32 Para0, U32 Para1, U32 Para2) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 3 * SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, Para0);
+  ENCODE_U32(pPayload, Para1);
+  ENCODE_U32(pPayload, Para2);
+  _SendPacket(pPayloadStart, pPayload, EventID);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordU32x4()
+*
+*  Function description
+*    Formats and sends a SystemView packet containing 4 U32 parameter payload.
+*
+*  Parameters
+*    EventID - SystemView event ID.
+*    Para0   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para1   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para2   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para3   - The 32-bit parameter encoded to SystemView packet payload.
+*/
+void SEGGER_SYSVIEW_RecordU32x4(unsigned int EventID, U32 Para0, U32 Para1, U32 Para2, U32 Para3) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 4 * SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, Para0);
+  ENCODE_U32(pPayload, Para1);
+  ENCODE_U32(pPayload, Para2);
+  ENCODE_U32(pPayload, Para3);
+  _SendPacket(pPayloadStart, pPayload, EventID);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordU32x5()
+*
+*  Function description
+*    Formats and sends a SystemView packet containing 5 U32 parameter payload.
+*
+*  Parameters
+*    EventID - SystemView event ID.
+*    Para0   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para1   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para2   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para3   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para4   - The 32-bit parameter encoded to SystemView packet payload.
+*/
+void SEGGER_SYSVIEW_RecordU32x5(unsigned int EventID, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 5 * SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, Para0);
+  ENCODE_U32(pPayload, Para1);
+  ENCODE_U32(pPayload, Para2);
+  ENCODE_U32(pPayload, Para3);
+  ENCODE_U32(pPayload, Para4);
+  _SendPacket(pPayloadStart, pPayload, EventID);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordU32x6()
+*
+*  Function description
+*    Formats and sends a SystemView packet containing 6 U32 parameter payload.
+*
+*  Parameters
+*    EventID - SystemView event ID.
+*    Para0   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para1   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para2   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para3   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para4   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para5   - The 32-bit parameter encoded to SystemView packet payload.
+*/
+void SEGGER_SYSVIEW_RecordU32x6(unsigned int EventID, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4, U32 Para5) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 6 * SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, Para0);
+  ENCODE_U32(pPayload, Para1);
+  ENCODE_U32(pPayload, Para2);
+  ENCODE_U32(pPayload, Para3);
+  ENCODE_U32(pPayload, Para4);
+  ENCODE_U32(pPayload, Para5);
+  _SendPacket(pPayloadStart, pPayload, EventID);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordU32x7()
+*
+*  Function description
+*    Formats and sends a SystemView packet containing 7 U32 parameter payload.
+*
+*  Parameters
+*    EventID - SystemView event ID.
+*    Para0   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para1   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para2   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para3   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para4   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para5   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para6   - The 32-bit parameter encoded to SystemView packet payload.
+*/
+void SEGGER_SYSVIEW_RecordU32x7(unsigned int EventID, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4, U32 Para5, U32 Para6) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 7 * SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, Para0);
+  ENCODE_U32(pPayload, Para1);
+  ENCODE_U32(pPayload, Para2);
+  ENCODE_U32(pPayload, Para3);
+  ENCODE_U32(pPayload, Para4);
+  ENCODE_U32(pPayload, Para5);
+  ENCODE_U32(pPayload, Para6);
+  _SendPacket(pPayloadStart, pPayload, EventID);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordU32x8()
+*
+*  Function description
+*    Formats and sends a SystemView packet containing 8 U32 parameter payload.
+*
+*  Parameters
+*    EventID - SystemView event ID.
+*    Para0   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para1   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para2   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para3   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para4   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para5   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para6   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para7   - The 32-bit parameter encoded to SystemView packet payload.
+*/
+void SEGGER_SYSVIEW_RecordU32x8(unsigned int EventID, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4, U32 Para5, U32 Para6, U32 Para7) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 8 * SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, Para0);
+  ENCODE_U32(pPayload, Para1);
+  ENCODE_U32(pPayload, Para2);
+  ENCODE_U32(pPayload, Para3);
+  ENCODE_U32(pPayload, Para4);
+  ENCODE_U32(pPayload, Para5);
+  ENCODE_U32(pPayload, Para6);
+  ENCODE_U32(pPayload, Para7);
+  _SendPacket(pPayloadStart, pPayload, EventID);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordU32x9()
+*
+*  Function description
+*    Formats and sends a SystemView packet containing 9 U32 parameter payload.
+*
+*  Parameters
+*    EventID - SystemView event ID.
+*    Para0   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para1   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para2   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para3   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para4   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para5   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para6   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para7   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para8   - The 32-bit parameter encoded to SystemView packet payload.
+*/
+void SEGGER_SYSVIEW_RecordU32x9(unsigned int EventID, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4, U32 Para5, U32 Para6, U32 Para7, U32 Para8) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 9 * SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, Para0);
+  ENCODE_U32(pPayload, Para1);
+  ENCODE_U32(pPayload, Para2);
+  ENCODE_U32(pPayload, Para3);
+  ENCODE_U32(pPayload, Para4);
+  ENCODE_U32(pPayload, Para5);
+  ENCODE_U32(pPayload, Para6);
+  ENCODE_U32(pPayload, Para7);
+  ENCODE_U32(pPayload, Para8);
+  _SendPacket(pPayloadStart, pPayload, EventID);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordU32x10()
+*
+*  Function description
+*    Formats and sends a SystemView packet containing 10 U32 parameter payload.
+*
+*  Parameters
+*    EventID - SystemView event ID.
+*    Para0   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para1   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para2   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para3   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para4   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para5   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para6   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para7   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para8   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para9   - The 32-bit parameter encoded to SystemView packet payload.
+*/
+void SEGGER_SYSVIEW_RecordU32x10(unsigned int EventID, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4, U32 Para5, U32 Para6, U32 Para7, U32 Para8, U32 Para9) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 10 * SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, Para0);
+  ENCODE_U32(pPayload, Para1);
+  ENCODE_U32(pPayload, Para2);
+  ENCODE_U32(pPayload, Para3);
+  ENCODE_U32(pPayload, Para4);
+  ENCODE_U32(pPayload, Para5);
+  ENCODE_U32(pPayload, Para6);
+  ENCODE_U32(pPayload, Para7);
+  ENCODE_U32(pPayload, Para8);
+  ENCODE_U32(pPayload, Para9);
+  _SendPacket(pPayloadStart, pPayload, EventID);
+  RECORD_END();
+}
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordString()
+*
+*  Function description
+*    Formats and sends a SystemView packet containing a string.
+*
+*  Parameters
+*    EventID - SystemView event ID.
+*    pString - The string to be sent in the SystemView packet payload.
+*
+*  Additional information
+*    The string is encoded as a count byte followed by the contents
+*    of the string.
+*    No more than SEGGER_SYSVIEW_MAX_STRING_LEN bytes will be encoded to the payload.
+*/
+void SEGGER_SYSVIEW_RecordString(unsigned int EventID, const char* pString) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 1 + SEGGER_SYSVIEW_MAX_STRING_LEN);
+  //
+  pPayload = _EncodeStr(pPayloadStart, pString, SEGGER_SYSVIEW_MAX_STRING_LEN);
+  _SendPacket(pPayloadStart, pPayload, EventID);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_Start()
+*
+*  Function description
+*    Start recording SystemView events.
+*
+*    This function is triggered by the SystemView Application on connect.
+*    For single-shot or post-mortem mode recording, it needs to be called
+*    by the application.
+*
+*  Additional information
+*    This function enables transmission of SystemView packets recorded
+*    by subsequent trace calls and records a SystemView Start event.
+*
+*    As part of start, a SystemView Init packet is sent, containing the system
+*    frequency. The list of current tasks, the current system time and the
+*    system description string is sent, too.
+*
+*  Notes
+*    SEGGER_SYSVIEW_Start and SEGGER_SYSVIEW_Stop do not nest.
+*    When SEGGER_SYSVIEW_CAN_RESTART is 1, each received start command
+*    records the system information. This is required to enable restart
+*    of recordings when SystemView unexpectedly disconnects without sending
+*    a stop command before.
+*/
+void SEGGER_SYSVIEW_Start(void) {
+#if (SEGGER_SYSVIEW_CAN_RESTART == 0)
+  if (_SYSVIEW_Globals.EnableState == 0) {
+#endif
+    _SYSVIEW_Globals.EnableState = 1;
+#if (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
+    _SendSyncInfo();
+#else
+    SEGGER_SYSVIEW_LOCK();
+    SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, _abSync, 10);
+    SEGGER_SYSVIEW_UNLOCK();
+    SEGGER_SYSVIEW_ON_EVENT_RECORDED(10);
+    SEGGER_SYSVIEW_RecordVoid(SYSVIEW_EVTID_TRACE_START);
+    {
+      U8* pPayload;
+      U8* pPayloadStart;
+      RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 4 * SEGGER_SYSVIEW_QUANTA_U32);
+      //
+      pPayload = pPayloadStart;
+      ENCODE_U32(pPayload, _SYSVIEW_Globals.SysFreq);
+      ENCODE_U32(pPayload, _SYSVIEW_Globals.CPUFreq);
+      ENCODE_U32(pPayload, _SYSVIEW_Globals.RAMBaseAddress);
+      ENCODE_U32(pPayload, SEGGER_SYSVIEW_ID_SHIFT);
+      _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_INIT);
+      RECORD_END();
+    }
+    if (_SYSVIEW_Globals.pfSendSysDesc) {
+      _SYSVIEW_Globals.pfSendSysDesc();
+    }
+    SEGGER_SYSVIEW_RecordSystime();
+    SEGGER_SYSVIEW_SendTaskList();
+    SEGGER_SYSVIEW_SendNumModules();
+#endif
+#if (SEGGER_SYSVIEW_CAN_RESTART == 0)
+  }
+#endif
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_Stop()
+*
+*  Function description
+*    Stop recording SystemView events.
+*
+*    This function is triggered by the SystemView Application on disconnect.
+*    For single-shot or post-mortem mode recording, it can be called
+*    by the application.
+*
+*  Additional information
+*    This function disables transmission of SystemView packets recorded
+*    by subsequent trace calls.  If transmission is enabled when
+*    this function is called, a single SystemView Stop event is recorded
+*    to the trace, send, and then trace transmission is halted.
+*/
+void SEGGER_SYSVIEW_Stop(void) {
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
+  //
+  if (_SYSVIEW_Globals.EnableState) {
+    _SendPacket(pPayloadStart, pPayloadStart, SYSVIEW_EVTID_TRACE_STOP);
+    _SYSVIEW_Globals.EnableState = 0;
+  }
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_GetChannelID()
+*
+*  Function description
+*    Returns the RTT <Up> / <Down> channel ID used by SystemView.
+*/
+int SEGGER_SYSVIEW_GetChannelID(void) {
+  return CHANNEL_ID_UP;
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_GetSysDesc()
+*
+*  Function description
+*    Triggers a send of the system information and description.
+*
+*/
+void SEGGER_SYSVIEW_GetSysDesc(void) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 4 * SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, _SYSVIEW_Globals.SysFreq);
+  ENCODE_U32(pPayload, _SYSVIEW_Globals.CPUFreq);
+  ENCODE_U32(pPayload, _SYSVIEW_Globals.RAMBaseAddress);
+  ENCODE_U32(pPayload, SEGGER_SYSVIEW_ID_SHIFT);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_INIT);
+  RECORD_END();
+  if (_SYSVIEW_Globals.pfSendSysDesc) {
+    _SYSVIEW_Globals.pfSendSysDesc();
+  }
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_SendTaskInfo()
+*
+*  Function description
+*    Send a Task Info Packet, containing TaskId for identification,
+*    task priority and task name.
+*
+*  Parameters
+*    pInfo - Pointer to task information to send.
+*/
+void SEGGER_SYSVIEW_SendTaskInfo(const SEGGER_SYSVIEW_TASKINFO *pInfo) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32 + 1 + 32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, SHRINK_ID(pInfo->TaskID));
+  ENCODE_U32(pPayload, pInfo->Prio);
+  pPayload = _EncodeStr(pPayload, pInfo->sName, 32);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_INFO);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, SHRINK_ID(pInfo->TaskID));
+  ENCODE_U32(pPayload, pInfo->StackBase);
+  ENCODE_U32(pPayload, pInfo->StackSize);
+  ENCODE_U32(pPayload, 0); // Stack End, future use
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_STACK_INFO);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_SendTaskList()
+*
+*  Function description
+*    Send all tasks descriptors to the host.
+*/
+void SEGGER_SYSVIEW_SendTaskList(void) {
+  if (_SYSVIEW_Globals.pOSAPI && _SYSVIEW_Globals.pOSAPI->pfSendTaskList) {
+    _SYSVIEW_Globals.pOSAPI->pfSendTaskList();
+  }
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_SendSysDesc()
+*
+*  Function description
+*    Send the system description string to the host.
+*    The system description is used by the Systemview Application
+*    to identify the current application and handle events accordingly.
+*
+*    The system description is usually called by the system description
+*    callback, to ensure it is only sent when the SystemView Application
+*    is connected.  
+*
+*  Parameters
+*    sSysDesc - Pointer to the 0-terminated system description string.
+*
+*  Additional information
+*    One system description string may not exceed SEGGER_SYSVIEW_MAX_STRING_LEN characters.
+*    Multiple description strings can be recorded.
+*
+*    The Following items can be described in a system description string.
+*    Each item is identified by its identifier, followed by '=' and the value.
+*    Items are separated by ','.
+*/
+void SEGGER_SYSVIEW_SendSysDesc(const char *sSysDesc) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 1 + SEGGER_SYSVIEW_MAX_STRING_LEN);
+  //
+  pPayload = _EncodeStr(pPayloadStart, sSysDesc, SEGGER_SYSVIEW_MAX_STRING_LEN);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_SYSDESC);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordSystime()
+*
+*  Function description
+*    Formats and sends a SystemView Systime containing a single U64 or U32
+*    parameter payload.
+*/
+void SEGGER_SYSVIEW_RecordSystime(void) {
+  U64 Systime;
+
+  if (_SYSVIEW_Globals.pOSAPI && _SYSVIEW_Globals.pOSAPI->pfGetTime) {
+    Systime = _SYSVIEW_Globals.pOSAPI->pfGetTime();
+    SEGGER_SYSVIEW_RecordU32x2(SYSVIEW_EVTID_SYSTIME_US,
+                               (U32)(Systime),
+                               (U32)(Systime >> 32));
+  } else {
+    SEGGER_SYSVIEW_RecordU32(SYSVIEW_EVTID_SYSTIME_CYCLES, SEGGER_SYSVIEW_GET_TIMESTAMP());
+  }
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordEnterISR()
+*
+*  Function description
+*    Format and send an ISR entry event.
+*
+*  Additional information
+*    Example packets sent
+*      02 0F 50              // ISR(15) Enter. Timestamp is 80 (0x50)
+*/
+void SEGGER_SYSVIEW_RecordEnterISR(void) {
+  unsigned v;
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  v = SEGGER_SYSVIEW_GET_INTERRUPT_ID();
+  ENCODE_U32(pPayload, v);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_ISR_ENTER);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordExitISR()
+*
+*  Function description
+*    Format and send an ISR exit event.
+*
+*  Additional information
+*    Format as follows:
+*      03 <TimeStamp>        // Max. packet len is 6
+*
+*    Example packets sent
+*      03 20                // ISR Exit. Timestamp is 32 (0x20)
+*/
+void SEGGER_SYSVIEW_RecordExitISR(void) {
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
+  //
+  _SendPacket(pPayloadStart, pPayloadStart, SYSVIEW_EVTID_ISR_EXIT);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordExitISRToScheduler()
+*
+*  Function description
+*    Format and send an ISR exit into scheduler event.
+*
+*  Additional information
+*    Format as follows:
+*      18 <TimeStamp>        // Max. packet len is 6
+*
+*    Example packets sent
+*      18 20                // ISR Exit to Scheduler. Timestamp is 32 (0x20)
+*/
+void SEGGER_SYSVIEW_RecordExitISRToScheduler(void) {
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
+  //
+  _SendPacket(pPayloadStart, pPayloadStart, SYSVIEW_EVTID_ISR_TO_SCHEDULER);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordEnterTimer()
+*
+*  Function description
+*    Format and send a Timer entry event.
+*  
+*  Parameters
+*    TimerId - Id of the timer which starts.
+*/
+void SEGGER_SYSVIEW_RecordEnterTimer(U32 TimerId) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, SHRINK_ID(TimerId));
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TIMER_ENTER);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordExitTimer()
+*
+*  Function description
+*    Format and send a Timer exit event.
+*/
+void SEGGER_SYSVIEW_RecordExitTimer(void) {
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
+  //
+  _SendPacket(pPayloadStart, pPayloadStart, SYSVIEW_EVTID_TIMER_EXIT);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordEndCall()
+*
+*  Function description
+*    Format and send an End API Call event without return value.
+*  
+*  Parameters
+*    EventID - Id of API function which ends.
+*/
+void SEGGER_SYSVIEW_RecordEndCall(unsigned int EventID) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, EventID);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_END_CALL);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordEndCallU32()
+*
+*  Function description
+*    Format and send an End API Call event with return value.
+*  
+*  Parameters
+*    EventID      - Id of API function which ends.
+*    Para0        - Return value which will be returned by the API function.
+*/
+void SEGGER_SYSVIEW_RecordEndCallU32(unsigned int EventID, U32 Para0) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, EventID);
+  ENCODE_U32(pPayload, Para0);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_END_CALL);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_OnIdle()
+*
+*  Function description
+*    Record an Idle event.
+*/
+void SEGGER_SYSVIEW_OnIdle(void) {
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
+  //
+  _SendPacket(pPayloadStart, pPayloadStart, SYSVIEW_EVTID_IDLE);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_OnTaskCreate()
+*
+*  Function description
+*    Record a Task Create event.  The Task Create event corresponds
+*    to creating a task in the OS.
+*
+*  Parameters
+*    TaskId        - Task ID of created task.
+*/
+void SEGGER_SYSVIEW_OnTaskCreate(U32 TaskId) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  TaskId = SHRINK_ID(TaskId);
+  ENCODE_U32(pPayload, TaskId);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_CREATE);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_OnTaskTerminate()
+*
+*  Function description
+*    Record a Task termination event.  
+*    The Task termination event corresponds to terminating a task in 
+*    the OS. If the TaskId is the currently active task, 
+*    SEGGER_SYSVIEW_OnTaskStopExec may be used, either.
+*
+*  Parameters
+*    TaskId        - Task ID of terminated task.
+*/
+void SEGGER_SYSVIEW_OnTaskTerminate(U32 TaskId) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  TaskId = SHRINK_ID(TaskId);
+  ENCODE_U32(pPayload, TaskId);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_TERMINATE);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_OnTaskStartExec()
+*
+*  Function description
+*    Record a Task Start Execution event.  The Task Start event
+*    corresponds to when a task has started to execute rather than
+*    when it is ready to execute.
+*
+*  Parameters
+*    TaskId - Task ID of task that started to execute.
+*/
+void SEGGER_SYSVIEW_OnTaskStartExec(U32 TaskId) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  TaskId = SHRINK_ID(TaskId);
+  ENCODE_U32(pPayload, TaskId);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_START_EXEC);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_OnTaskStopExec()
+*
+*  Function description
+*    Record a Task Stop Execution event.  The Task Stop event
+*    corresponds to when a task stops executing and terminates.
+*/
+void SEGGER_SYSVIEW_OnTaskStopExec(void) {
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
+  //
+  _SendPacket(pPayloadStart, pPayloadStart, SYSVIEW_EVTID_TASK_STOP_EXEC);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_OnTaskStartReady()
+*
+*  Function description
+*    Record a Task Start Ready event.
+*
+*  Parameters
+*    TaskId - Task ID of task that started to execute.
+*/
+void SEGGER_SYSVIEW_OnTaskStartReady(U32 TaskId) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  TaskId = SHRINK_ID(TaskId);
+  ENCODE_U32(pPayload, TaskId);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_START_READY);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_OnTaskStopReady()
+*
+*  Function description
+*    Record a Task Stop Ready event.
+*
+*  Parameters
+*    TaskId - Task ID of task that completed execution.
+*    Cause  - Reason for task to stop (i.e. Idle/Sleep)
+*/
+void SEGGER_SYSVIEW_OnTaskStopReady(U32 TaskId, unsigned int Cause) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  TaskId = SHRINK_ID(TaskId);
+  ENCODE_U32(pPayload, TaskId);
+  ENCODE_U32(pPayload, Cause);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_STOP_READY);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_MarkStart()
+*
+*  Function description
+*    Record a Performance Marker Start event to start measuring runtime.
+*
+*  Parameters
+*    MarkerId  - User defined ID for the marker.
+*/
+void SEGGER_SYSVIEW_MarkStart(unsigned MarkerId) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, MarkerId);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_MARK_START);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_MarkStop()
+*
+*  Function description
+*    Record a Performance Marker Stop event to stop measuring runtime.
+*
+*  Parameters
+*    MarkerId  - User defined ID for the marker.
+*/
+void SEGGER_SYSVIEW_MarkStop(unsigned MarkerId) {
+  U8 * pPayload;
+  U8 * pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, MarkerId);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_MARK_STOP);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_Mark()
+*
+*  Function description
+*    Record a Performance Marker intermediate event.
+*
+*  Parameters
+*    MarkerId  - User defined ID for the marker.
+*/
+void SEGGER_SYSVIEW_Mark(unsigned int MarkerId) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, SYSVIEW_EVTID_EX_MARK);
+  ENCODE_U32(pPayload, MarkerId);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_EX);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_NameMarker()
+*
+*  Function description
+*    Send the name of a Performance Marker to be displayed in SystemView.
+*
+*    Marker names are usually set in the system description
+*    callback, to ensure it is only sent when the SystemView Application
+*    is connected.  
+*
+*  Parameters
+*    MarkerId   - User defined ID for the marker.
+*    sName      - Pointer to the marker name. (Max. SEGGER_SYSVIEW_MAX_STRING_LEN Bytes)
+*/
+void SEGGER_SYSVIEW_NameMarker(unsigned int MarkerId, const char* sName) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32 + 1 + SEGGER_SYSVIEW_MAX_STRING_LEN);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, SYSVIEW_EVTID_EX_NAME_MARKER);
+  ENCODE_U32(pPayload, MarkerId);
+  pPayload = _EncodeStr(pPayload, sName, SEGGER_SYSVIEW_MAX_STRING_LEN);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_EX);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_NameResource()
+*
+*  Function description
+*    Send the name of a resource to be displayed in SystemView.
+*
+*    Marker names are usually set in the system description
+*    callback, to ensure it is only sent when the SystemView Application
+*    is connected.  
+*
+*  Parameters
+*    ResourceId - Id of the resource to be named. i.e. its address.
+*    sName      - Pointer to the resource name. (Max. SEGGER_SYSVIEW_MAX_STRING_LEN Bytes)
+*/
+void SEGGER_SYSVIEW_NameResource(U32 ResourceId, const char* sName) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32 + 1 + SEGGER_SYSVIEW_MAX_STRING_LEN);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, SHRINK_ID(ResourceId));
+  pPayload = _EncodeStr(pPayload, sName, SEGGER_SYSVIEW_MAX_STRING_LEN);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_NAME_RESOURCE);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_SendPacket()
+*
+*  Function description
+*    Send an event packet.
+*
+*  Parameters
+*    pPacket      - Pointer to the start of the packet.
+*    pPayloadEnd  - Pointer to the end of the payload.
+*                   Make sure there are at least 5 bytes free after the payload.
+*    EventId      - Id of the event packet.
+*
+*  Return value
+*    !=0:  Success, Message sent.
+*    ==0:  Buffer full, Message *NOT* sent.
+*/
+int SEGGER_SYSVIEW_SendPacket(U8* pPacket, U8* pPayloadEnd, unsigned int EventId) {
+#if (SEGGER_SYSVIEW_USE_STATIC_BUFFER == 1)
+  SEGGER_SYSVIEW_LOCK();
+#endif
+  _SendPacket(pPacket + 4, pPayloadEnd, EventId);
+#if (SEGGER_SYSVIEW_USE_STATIC_BUFFER == 1)
+  SEGGER_SYSVIEW_UNLOCK();
+#endif
+  return 0;
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_EncodeU32()
+*
+*  Function description
+*    Encode a U32 in variable-length format.
+*
+*  Parameters
+*    pPayload - Pointer to where U32 will be encoded.
+*    Value    - The 32-bit value to be encoded.
+*
+*  Return value
+*    Pointer to the byte following the value, i.e. the first free
+*    byte in the payload and the next position to store payload
+*    content.
+*/
+U8* SEGGER_SYSVIEW_EncodeU32(U8* pPayload, U32 Value) {
+  ENCODE_U32(pPayload, Value);
+  return pPayload;
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_EncodeString()
+*
+*  Function description
+*    Encode a string in variable-length format.
+*
+*  Parameters
+*    pPayload - Pointer to where string will be encoded.
+*    s        - String to encode.
+*    MaxLen   - Maximum number of characters to encode from string.
+*
+*  Return value
+*    Pointer to the byte following the value, i.e. the first free
+*    byte in the payload and the next position to store payload
+*    content.
+*
+*  Additional information
+*    The string is encoded as a count byte followed by the contents
+*    of the string.
+*    No more than 1 + MaxLen bytes will be encoded to the payload.
+*/
+U8* SEGGER_SYSVIEW_EncodeString(U8* pPayload, const char* s, unsigned int MaxLen) {
+  return _EncodeStr(pPayload, s, MaxLen);
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_EncodeData()
+*
+*  Function description
+*    Encode a byte buffer in variable-length format.
+*
+*  Parameters
+*    pPayload - Pointer to where string will be encoded.
+*    pSrc     - Pointer to data buffer to be encoded.
+*    NumBytes - Number of bytes in the buffer to be encoded.
+*
+*  Return value
+*    Pointer to the byte following the value, i.e. the first free
+*    byte in the payload and the next position to store payload
+*    content.
+*
+*  Additional information
+*    The data is encoded as a count byte followed by the contents
+*    of the data buffer.
+*    Make sure NumBytes + 1 bytes are free for the payload.
+*/
+U8* SEGGER_SYSVIEW_EncodeData(U8 *pPayload, const char* pSrc, unsigned int NumBytes) {
+  return _EncodeData(pPayload, pSrc, NumBytes);
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_EncodeId()
+*
+*  Function description
+*    Encode a 32-bit Id in shrunken variable-length format.
+*
+*  Parameters
+*    pPayload - Pointer to where the Id will be encoded.
+*    Id       - The 32-bit value to be encoded.
+*
+*  Return value
+*    Pointer to the byte following the value, i.e. the first free
+*    byte in the payload and the next position to store payload
+*    content.
+*
+*  Additional information
+*    The parameters to shrink an Id can be configured in
+*    SEGGER_SYSVIEW_Conf.h and via SEGGER_SYSVIEW_SetRAMBase().
+*     SEGGER_SYSVIEW_ID_BASE: Lowest Id reported by the application.
+*       (i.e. 0x20000000 when all Ids are an address in this RAM)
+*     SEGGER_SYSVIEW_ID_SHIFT: Number of bits to shift the Id to
+*       save bandwidth. (i.e. 2 when Ids are 4 byte aligned)
+*/
+U8* SEGGER_SYSVIEW_EncodeId(U8* pPayload, U32 Id) {
+  Id = SHRINK_ID(Id);
+  ENCODE_U32(pPayload, Id);
+  return pPayload;
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_ShrinkId()
+*
+*  Function description
+*    Get the shrunken value of an Id for further processing like in
+*    SEGGER_SYSVIEW_NameResource().
+*
+*  Parameters
+*    Id       - The 32-bit value to be shrunken.
+*
+*  Return value
+*    Shrunken Id.
+*
+*  Additional information
+*    The parameters to shrink an Id can be configured in
+*    SEGGER_SYSVIEW_Conf.h and via SEGGER_SYSVIEW_SetRAMBase().
+*     SEGGER_SYSVIEW_ID_BASE: Lowest Id reported by the application.
+*       (i.e. 0x20000000 when all Ids are an address in this RAM)
+*     SEGGER_SYSVIEW_ID_SHIFT: Number of bits to shift the Id to
+*       save bandwidth. (i.e. 2 when Ids are 4 byte aligned)
+*/
+U32 SEGGER_SYSVIEW_ShrinkId(U32 Id) {
+  return SHRINK_ID(Id);
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RegisterModule()
+*
+*  Function description
+*    Register a middleware module for recording its events.
+*
+*  Parameters
+*    pModule  - The middleware module information.
+*
+*  Additional information
+*    SEGGER_SYSVIEW_MODULE elements:
+*      sDescription      - Pointer to a string containing the module name and optionally the module event description.
+*      NumEvents         - Number of events the module wants to register.
+*      EventOffset       - Offset to be added to the event Ids. Out parameter, set by this function. Do not modify after calling this function.
+*      pfSendModuleDesc  - Callback function pointer to send more detailed module description to SystemView Application.
+*      pNext             - Pointer to next registered module. Out parameter, set by this function. Do not modify after calling this function.
+*/
+void SEGGER_SYSVIEW_RegisterModule(SEGGER_SYSVIEW_MODULE* pModule) {
+  SEGGER_SYSVIEW_LOCK();
+  if (_pFirstModule == 0) {
+    //
+    // No module registered, yet.
+    // Start list with new module.
+    // EventOffset is the base offset for modules
+    //
+    pModule->EventOffset = MODULE_EVENT_OFFSET;
+    pModule->pNext = 0;
+    _pFirstModule = pModule;
+    _NumModules = 1;
+  } else {
+    //
+    // Registreded module(s) present.
+    // Prepend new module in list.
+    // EventOffset set from number of events and offset of previous module.
+    //
+    pModule->EventOffset = _pFirstModule->EventOffset + _pFirstModule->NumEvents;
+    pModule->pNext = _pFirstModule;
+    _pFirstModule = pModule;
+    _NumModules++;
+  }
+  SEGGER_SYSVIEW_SendModule(0);
+  if (pModule->pfSendModuleDesc) {
+    pModule->pfSendModuleDesc();
+  }
+  SEGGER_SYSVIEW_UNLOCK();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordModuleDescription()
+*
+*  Function description
+*    Sends detailed information of a registered module to the host.
+*
+*  Parameters
+*    pModule      - Pointer to the described module.
+*    sDescription - Pointer to a description string.
+*/
+void SEGGER_SYSVIEW_RecordModuleDescription(const SEGGER_SYSVIEW_MODULE* pModule, const char* sDescription) {
+  U8  ModuleId;
+  SEGGER_SYSVIEW_MODULE* p;
+
+  p = _pFirstModule;
+  ModuleId = 0;
+  do {
+    if (p == pModule) {
+      break;
+    }
+    ModuleId++;
+    p = p->pNext;
+  } while (p);
+  {
+    U8* pPayload;
+    U8* pPayloadStart;
+    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32 + 1 + SEGGER_SYSVIEW_MAX_STRING_LEN);
+    //
+    pPayload = pPayloadStart;
+    //
+    // Send module description
+    // Send event offset and number of events
+    //
+    ENCODE_U32(pPayload, ModuleId);
+    ENCODE_U32(pPayload, (pModule->EventOffset));
+    pPayload = _EncodeStr(pPayload, sDescription, SEGGER_SYSVIEW_MAX_STRING_LEN);
+    _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_MODULEDESC);
+    RECORD_END();
+  }
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_SendModule()
+*
+*  Function description
+*    Sends the information of a registered module to the host.
+*
+*  Parameters
+*    ModuleId   - Id of the requested module.
+*/
+void SEGGER_SYSVIEW_SendModule(U8 ModuleId) {
+  SEGGER_SYSVIEW_MODULE* pModule;
+  U32 n;
+
+  if (_pFirstModule != 0) {
+    pModule = _pFirstModule;
+    for (n = 0; n < ModuleId; n++) {
+      pModule = pModule->pNext;
+      if (pModule == 0) {
+        break;
+      }
+    }
+    if (pModule != 0) {
+      U8* pPayload;
+      U8* pPayloadStart;
+      RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32 + 1 + SEGGER_SYSVIEW_MAX_STRING_LEN);
+      //
+      pPayload = pPayloadStart;
+      //
+      // Send module description
+      // Send event offset and number of events
+      //
+      ENCODE_U32(pPayload, ModuleId);
+      ENCODE_U32(pPayload, (pModule->EventOffset));
+      pPayload = _EncodeStr(pPayload, pModule->sModule, SEGGER_SYSVIEW_MAX_STRING_LEN);
+      _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_MODULEDESC);
+      RECORD_END();
+    }
+  }
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_SendModuleDescription()
+*
+*  Function description
+*    Triggers a send of the registered module descriptions.
+*
+*/
+void SEGGER_SYSVIEW_SendModuleDescription(void) {
+  SEGGER_SYSVIEW_MODULE* pModule;
+
+  if (_pFirstModule != 0) {
+    pModule = _pFirstModule;
+    do {
+      if (pModule->pfSendModuleDesc) {
+        pModule->pfSendModuleDesc();
+      }
+      pModule = pModule->pNext;
+    } while (pModule);
+  }
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_SendNumModules()
+*
+*  Function description
+*    Send the number of registered modules to the host.
+*/
+void SEGGER_SYSVIEW_SendNumModules(void) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2*SEGGER_SYSVIEW_QUANTA_U32);
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, _NumModules);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_NUMMODULES);
+  RECORD_END();
+}
+
+#ifndef SEGGER_SYSVIEW_EXCLUDE_PRINTF // Define in project to avoid warnings about variable parameter list
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_PrintfHostEx()
+*
+*  Function description
+*    Print a string which is formatted on the host by the SystemView Application
+*    with Additional information.
+*
+*  Parameters
+*    s        - String to be formatted.
+*    Options  - Options for the string. i.e. Log level.
+*
+*  Additional information
+*    All format arguments are treated as 32-bit scalar values.
+*/
+void SEGGER_SYSVIEW_PrintfHostEx(const char* s, U32 Options, ...) {
+  va_list ParamList;
+#if SEGGER_SYSVIEW_PRINTF_IMPLICIT_FORMAT
+  int r;
+
+  va_start(ParamList, Options);
+  r = _VPrintHost(s, Options, &ParamList);
+  va_end(ParamList);
+
+  if (r == -1) {
+    va_start(ParamList, Options);
+    _VPrintTarget(s, Options, &ParamList);
+    va_end(ParamList);
+  }
+#else
+  va_start(ParamList, Options);
+  _VPrintHost(s, Options, &ParamList);
+  va_end(ParamList);
+#endif
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_PrintfHost()
+*
+*  Function description
+*    Print a string which is formatted on the host by the SystemView Application.
+*
+*  Parameters
+*    s        - String to be formatted.
+*
+*  Additional information
+*    All format arguments are treated as 32-bit scalar values.
+*/
+void SEGGER_SYSVIEW_PrintfHost(const char* s, ...) {
+  va_list ParamList;
+#if SEGGER_SYSVIEW_PRINTF_IMPLICIT_FORMAT
+  int r;
+
+  va_start(ParamList, s);
+  r = _VPrintHost(s, SEGGER_SYSVIEW_LOG, &ParamList);
+  va_end(ParamList);
+
+  if (r == -1) {
+    va_start(ParamList, s);
+    _VPrintTarget(s, SEGGER_SYSVIEW_LOG, &ParamList);
+    va_end(ParamList);
+  }
+#else
+  va_start(ParamList, s);
+  _VPrintHost(s, SEGGER_SYSVIEW_LOG, &ParamList);
+  va_end(ParamList);
+#endif
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_WarnfHost()
+*
+*  Function description
+*    Print a warnin string which is formatted on the host by 
+*    the SystemView Application.
+*
+*  Parameters
+*    s        - String to be formatted.
+*
+*  Additional information
+*    All format arguments are treated as 32-bit scalar values.
+*/
+void SEGGER_SYSVIEW_WarnfHost(const char* s, ...) {
+  va_list ParamList;
+#if SEGGER_SYSVIEW_PRINTF_IMPLICIT_FORMAT
+  int r;
+
+  va_start(ParamList, s);
+  r = _VPrintHost(s, SEGGER_SYSVIEW_WARNING, &ParamList);
+  va_end(ParamList);
+
+  if (r == -1) {
+    va_start(ParamList, s);
+    _VPrintTarget(s, SEGGER_SYSVIEW_WARNING, &ParamList);
+    va_end(ParamList);
+  }
+#else
+  va_start(ParamList, s);
+  _VPrintHost(s, SEGGER_SYSVIEW_WARNING, &ParamList);
+  va_end(ParamList);
+#endif
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_ErrorfHost()
+*
+*  Function description
+*    Print an error string which is formatted on the host by 
+*    the SystemView Application.
+*
+*  Parameters
+*    s        - String to be formatted.
+*
+*  Additional information
+*    All format arguments are treated as 32-bit scalar values.
+*/
+void SEGGER_SYSVIEW_ErrorfHost(const char* s, ...) {
+  va_list ParamList;
+#if SEGGER_SYSVIEW_PRINTF_IMPLICIT_FORMAT
+  int r;
+
+  va_start(ParamList, s);
+  r = _VPrintHost(s, SEGGER_SYSVIEW_ERROR, &ParamList);
+  va_end(ParamList);
+
+  if (r == -1) {
+    va_start(ParamList, s);
+    _VPrintTarget(s, SEGGER_SYSVIEW_ERROR, &ParamList);
+    va_end(ParamList);
+  }
+#else
+  va_start(ParamList, s);
+  _VPrintHost(s, SEGGER_SYSVIEW_ERROR, &ParamList);
+  va_end(ParamList);
+#endif
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_PrintfTargetEx()
+*
+*  Function description
+*    Print a string which is formatted on the target before sent to 
+*    the host with Additional information.
+*
+*  Parameters
+*    s        - String to be formatted.
+*    Options  - Options for the string. i.e. Log level.
+*/
+void SEGGER_SYSVIEW_PrintfTargetEx(const char* s, U32 Options, ...) {
+  va_list ParamList;
+
+  va_start(ParamList, Options);
+  _VPrintTarget(s, Options, &ParamList);
+  va_end(ParamList);
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_PrintfTarget()
+*
+*  Function description
+*    Print a string which is formatted on the target before sent to 
+*    the host.
+*
+*  Parameters
+*    s        - String to be formatted.
+*/
+void SEGGER_SYSVIEW_PrintfTarget(const char* s, ...) {
+  va_list ParamList;
+
+  va_start(ParamList, s);
+  _VPrintTarget(s, SEGGER_SYSVIEW_LOG, &ParamList);
+  va_end(ParamList);
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_WarnfTarget()
+*
+*  Function description
+*    Print a warning string which is formatted on the target before
+*    sent to the host.
+*
+*  Parameters
+*    s        - String to be formatted.
+*/
+void SEGGER_SYSVIEW_WarnfTarget(const char* s, ...) {
+  va_list ParamList;
+
+  va_start(ParamList, s);
+  _VPrintTarget(s, SEGGER_SYSVIEW_WARNING, &ParamList);
+  va_end(ParamList);
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_ErrorfTarget()
+*
+*  Function description
+*    Print an error string which is formatted on the target before
+*    sent to the host.
+*
+*  Parameters
+*    s        - String to be formatted.
+*/
+void SEGGER_SYSVIEW_ErrorfTarget(const char* s, ...) {
+  va_list ParamList;
+
+  va_start(ParamList, s);
+  _VPrintTarget(s, SEGGER_SYSVIEW_ERROR, &ParamList);
+  va_end(ParamList);
+}
+#endif // SEGGER_SYSVIEW_EXCLUDE_PRINTF
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_Print()
+*
+*  Function description
+*    Print a string to the host.
+*
+*  Parameters
+*    s        - String to sent.
+*/
+void SEGGER_SYSVIEW_Print(const char* s) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32 + SEGGER_SYSVIEW_MAX_STRING_LEN);
+  //
+  pPayload = _EncodeStr(pPayloadStart, s, SEGGER_SYSVIEW_MAX_STRING_LEN);
+  ENCODE_U32(pPayload, SEGGER_SYSVIEW_LOG);
+  ENCODE_U32(pPayload, 0);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_Warn()
+*
+*  Function description
+*    Print a warning string to the host.
+*
+*  Parameters
+*    s        - String to sent.
+*/
+void SEGGER_SYSVIEW_Warn(const char* s) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32 + SEGGER_SYSVIEW_MAX_STRING_LEN);
+  //
+  pPayload = _EncodeStr(pPayloadStart, s, SEGGER_SYSVIEW_MAX_STRING_LEN);
+  ENCODE_U32(pPayload, SEGGER_SYSVIEW_WARNING);
+  ENCODE_U32(pPayload, 0);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_Error()
+*
+*  Function description
+*    Print an error string to the host.
+*
+*  Parameters
+*    s        - String to sent.
+*/
+void SEGGER_SYSVIEW_Error(const char* s) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32 + SEGGER_SYSVIEW_MAX_STRING_LEN);
+  //
+  pPayload = _EncodeStr(pPayloadStart, s, SEGGER_SYSVIEW_MAX_STRING_LEN);
+  ENCODE_U32(pPayload, SEGGER_SYSVIEW_ERROR);
+  ENCODE_U32(pPayload, 0);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_EnableEvents()
+*
+*  Function description
+*    Enable standard SystemView events to be generated.
+*
+*  Parameters
+*    EnableMask   - Events to be enabled.
+*/
+void SEGGER_SYSVIEW_EnableEvents(U32 EnableMask) {
+  _SYSVIEW_Globals.DisabledEvents &= ~EnableMask;
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_DisableEvents()
+*
+*  Function description
+*    Disable standard SystemView events to not be generated.
+*
+*  Parameters
+*    DisableMask  - Events to be disabled.
+*/
+void SEGGER_SYSVIEW_DisableEvents(U32 DisableMask) {
+  _SYSVIEW_Globals.DisabledEvents |= DisableMask;
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_IsStarted()
+*
+*  Function description
+*    Handle incoming packets if any and check if recording is started.
+*
+*  Return value
+*      0: Recording not started.
+*    > 0: Recording started.
+*/
+int SEGGER_SYSVIEW_IsStarted(void) {
+#if (SEGGER_SYSVIEW_POST_MORTEM_MODE != 1)
+  //
+  // Check if host is sending data which needs to be processed.
+  //
+  if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
+    if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
+      _SYSVIEW_Globals.RecursionCnt = 1;
+      _HandleIncomingPacket();
+      _SYSVIEW_Globals.RecursionCnt = 0;
+    }
+  }
+#endif
+  return _SYSVIEW_Globals.EnableState;
+}
+
+
+/*************************** End of file ****************************/
diff --git a/sched/systemview/SEGGER_SYSVIEW.h b/sched/systemview/SEGGER_SYSVIEW.h
new file mode 100644
index 0000000000..26f98dbc06
--- /dev/null
+++ b/sched/systemview/SEGGER_SYSVIEW.h
@@ -0,0 +1,346 @@
+/*********************************************************************
+*                    SEGGER Microcontroller GmbH                     *
+*                        The Embedded Experts                        *
+**********************************************************************
+*                                                                    *
+*            (c) 1995 - 2019 SEGGER Microcontroller GmbH             *
+*                                                                    *
+*       www.segger.com     Support: support@segger.com               *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SEGGER SystemView * Real-time application analysis           *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+* All rights reserved.                                               *
+*                                                                    *
+* SEGGER strongly recommends to not make any changes                 *
+* to or modify the source code of this software in order to stay     *
+* compatible with the SystemView and RTT protocol, and J-Link.       *
+*                                                                    *
+* Redistribution and use in source and binary forms, with or         *
+* without modification, are permitted provided that the following    *
+* condition is met:                                                  *
+*                                                                    *
+* o Redistributions of source code must retain the above copyright   *
+*   notice, this condition and the following disclaimer.             *
+*                                                                    *
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
+* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
+* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
+* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
+* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
+* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
+* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
+* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
+* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
+* DAMAGE.                                                            *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SystemView version: V3.12                                    *
+*                                                                    *
+**********************************************************************
+-------------------------- END-OF-HEADER -----------------------------
+File    : SEGGER_SYSVIEW.h
+Purpose : System visualization API.
+Revision: $Rev: 17331 $
+*/
+
+#ifndef SEGGER_SYSVIEW_H
+#define SEGGER_SYSVIEW_H
+
+/*********************************************************************
+*
+*       #include Section
+*
+**********************************************************************
+*/
+
+#include "SEGGER.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/*********************************************************************
+*
+*       Defines, fixed
+*
+**********************************************************************
+*/
+
+#define SEGGER_SYSVIEW_MAJOR          3
+#define SEGGER_SYSVIEW_MINOR          10
+#define SEGGER_SYSVIEW_REV            0
+#define SEGGER_SYSVIEW_VERSION        ((SEGGER_SYSVIEW_MAJOR * 10000) + (SEGGER_SYSVIEW_MINOR * 100) + SEGGER_SYSVIEW_REV)
+
+#define SEGGER_SYSVIEW_INFO_SIZE      9   // Minimum size, which has to be reserved for a packet. 1-2 byte of message type, 0-2  byte of payload length, 1-5 bytes of timestamp.
+#define SEGGER_SYSVIEW_QUANTA_U32     5   // Maximum number of bytes to encode a U32, should be reserved for each 32-bit value in a packet.
+
+#define SEGGER_SYSVIEW_LOG            (0u)
+#define SEGGER_SYSVIEW_WARNING        (1u)
+#define SEGGER_SYSVIEW_ERROR          (2u)
+#define SEGGER_SYSVIEW_FLAG_APPEND    (1u << 6)
+
+#define SEGGER_SYSVIEW_PREPARE_PACKET(p)  (p) + 4
+//
+// SystemView events. First 32 IDs from 0 .. 31 are reserved for these
+//
+#define   SYSVIEW_EVTID_NOP                0  // Dummy packet.
+#define   SYSVIEW_EVTID_OVERFLOW           1
+#define   SYSVIEW_EVTID_ISR_ENTER          2
+#define   SYSVIEW_EVTID_ISR_EXIT           3
+#define   SYSVIEW_EVTID_TASK_START_EXEC    4
+#define   SYSVIEW_EVTID_TASK_STOP_EXEC     5
+#define   SYSVIEW_EVTID_TASK_START_READY   6
+#define   SYSVIEW_EVTID_TASK_STOP_READY    7
+#define   SYSVIEW_EVTID_TASK_CREATE        8
+#define   SYSVIEW_EVTID_TASK_INFO          9
+#define   SYSVIEW_EVTID_TRACE_START       10
+#define   SYSVIEW_EVTID_TRACE_STOP        11
+#define   SYSVIEW_EVTID_SYSTIME_CYCLES    12
+#define   SYSVIEW_EVTID_SYSTIME_US        13
+#define   SYSVIEW_EVTID_SYSDESC           14
+#define   SYSVIEW_EVTID_MARK_START        15
+#define   SYSVIEW_EVTID_MARK_STOP         16
+#define   SYSVIEW_EVTID_IDLE              17
+#define   SYSVIEW_EVTID_ISR_TO_SCHEDULER  18
+#define   SYSVIEW_EVTID_TIMER_ENTER       19
+#define   SYSVIEW_EVTID_TIMER_EXIT        20
+#define   SYSVIEW_EVTID_STACK_INFO        21
+#define   SYSVIEW_EVTID_MODULEDESC        22
+
+#define   SYSVIEW_EVTID_INIT              24
+#define   SYSVIEW_EVTID_NAME_RESOURCE     25
+#define   SYSVIEW_EVTID_PRINT_FORMATTED   26
+#define   SYSVIEW_EVTID_NUMMODULES        27
+#define   SYSVIEW_EVTID_END_CALL          28
+#define   SYSVIEW_EVTID_TASK_TERMINATE    29
+
+#define   SYSVIEW_EVTID_EX                31
+//
+// SystemView extended events. Sent with ID 31.
+//
+#define   SYSVIEW_EVTID_EX_MARK            0
+#define   SYSVIEW_EVTID_EX_NAME_MARKER     1
+//
+// Event masks to disable/enable events
+//
+#define   SYSVIEW_EVTMASK_NOP               (1 << SYSVIEW_EVTID_NOP)
+#define   SYSVIEW_EVTMASK_OVERFLOW          (1 << SYSVIEW_EVTID_OVERFLOW)
+#define   SYSVIEW_EVTMASK_ISR_ENTER         (1 << SYSVIEW_EVTID_ISR_ENTER)
+#define   SYSVIEW_EVTMASK_ISR_EXIT          (1 << SYSVIEW_EVTID_ISR_EXIT)
+#define   SYSVIEW_EVTMASK_TASK_START_EXEC   (1 << SYSVIEW_EVTID_TASK_START_EXEC)
+#define   SYSVIEW_EVTMASK_TASK_STOP_EXEC    (1 << SYSVIEW_EVTID_TASK_STOP_EXEC)
+#define   SYSVIEW_EVTMASK_TASK_START_READY  (1 << SYSVIEW_EVTID_TASK_START_READY)
+#define   SYSVIEW_EVTMASK_TASK_STOP_READY   (1 << SYSVIEW_EVTID_TASK_STOP_READY)
+#define   SYSVIEW_EVTMASK_TASK_CREATE       (1 << SYSVIEW_EVTID_TASK_CREATE)
+#define   SYSVIEW_EVTMASK_TASK_INFO         (1 << SYSVIEW_EVTID_TASK_INFO)
+#define   SYSVIEW_EVTMASK_TRACE_START       (1 << SYSVIEW_EVTID_TRACE_START)
+#define   SYSVIEW_EVTMASK_TRACE_STOP        (1 << SYSVIEW_EVTID_TRACE_STOP)
+#define   SYSVIEW_EVTMASK_SYSTIME_CYCLES    (1 << SYSVIEW_EVTID_SYSTIME_CYCLES)
+#define   SYSVIEW_EVTMASK_SYSTIME_US        (1 << SYSVIEW_EVTID_SYSTIME_US)
+#define   SYSVIEW_EVTMASK_SYSDESC           (1 << SYSVIEW_EVTID_SYSDESC)
+#define   SYSVIEW_EVTMASK_USER_START        (1 << SYSVIEW_EVTID_USER_START)
+#define   SYSVIEW_EVTMASK_USER_STOP         (1 << SYSVIEW_EVTID_USER_STOP)
+#define   SYSVIEW_EVTMASK_IDLE              (1 << SYSVIEW_EVTID_IDLE)
+#define   SYSVIEW_EVTMASK_ISR_TO_SCHEDULER  (1 << SYSVIEW_EVTID_ISR_TO_SCHEDULER)
+#define   SYSVIEW_EVTMASK_TIMER_ENTER       (1 << SYSVIEW_EVTID_TIMER_ENTER)
+#define   SYSVIEW_EVTMASK_TIMER_EXIT        (1 << SYSVIEW_EVTID_TIMER_EXIT)
+#define   SYSVIEW_EVTMASK_STACK_INFO        (1 << SYSVIEW_EVTID_STACK_INFO)
+#define   SYSVIEW_EVTMASK_MODULEDESC        (1 << SYSVIEW_EVTID_MODULEDESC)
+
+#define   SYSVIEW_EVTMASK_INIT              (1 << SYSVIEW_EVTID_INIT)
+#define   SYSVIEW_EVTMASK_NAME_RESOURCE     (1 << SYSVIEW_EVTID_NAME_RESOURCE)
+#define   SYSVIEW_EVTMASK_PRINT_FORMATTED   (1 << SYSVIEW_EVTID_PRINT_FORMATTED)
+#define   SYSVIEW_EVTMASK_NUMMODULES        (1 << SYSVIEW_EVTID_NUMMODULES)
+#define   SYSVIEW_EVTMASK_END_CALL          (1 << SYSVIEW_EVTID_END_CALL)
+#define   SYSVIEW_EVTMASK_TASK_TERMINATE    (1 << SYSVIEW_EVTID_TASK_TERMINATE)
+
+#define   SYSVIEW_EVTMASK_EX                (1 << SYSVIEW_EVTID_EX)
+
+#define   SYSVIEW_EVTMASK_ALL_INTERRUPTS    ( SYSVIEW_EVTMASK_ISR_ENTER           \
+                                            | SYSVIEW_EVTMASK_ISR_EXIT            \
+                                            | SYSVIEW_EVTMASK_ISR_TO_SCHEDULER)
+#define   SYSVIEW_EVTMASK_ALL_TASKS         ( SYSVIEW_EVTMASK_TASK_START_EXEC     \
+                                            | SYSVIEW_EVTMASK_TASK_STOP_EXEC      \
+                                            | SYSVIEW_EVTMASK_TASK_START_READY    \
+                                            | SYSVIEW_EVTMASK_TASK_STOP_READY     \
+                                            | SYSVIEW_EVTMASK_TASK_CREATE         \
+                                            | SYSVIEW_EVTMASK_TASK_INFO           \
+                                            | SYSVIEW_EVTMASK_STACK_INFO          \
+                                            | SYSVIEW_EVTMASK_TASK_TERMINATE)
+
+/*********************************************************************
+*
+*       Structures
+*
+**********************************************************************
+*/
+
+typedef struct {
+  U32          TaskID;
+  const char*  sName;
+  U32          Prio;
+  U32          StackBase;
+  U32          StackSize;
+} SEGGER_SYSVIEW_TASKINFO;
+
+typedef struct SEGGER_SYSVIEW_MODULE_STRUCT SEGGER_SYSVIEW_MODULE;
+
+struct SEGGER_SYSVIEW_MODULE_STRUCT {
+  const char*                   sModule;
+        U32                     NumEvents;
+        U32                     EventOffset;
+        void                    (*pfSendModuleDesc)(void);
+        SEGGER_SYSVIEW_MODULE*  pNext;
+};
+
+typedef void (SEGGER_SYSVIEW_SEND_SYS_DESC_FUNC)(void);
+
+/*********************************************************************
+*
+*       API functions
+*
+**********************************************************************
+*/
+
+typedef struct {
+  U64  (*pfGetTime)      (void);
+  void (*pfSendTaskList) (void);
+} SEGGER_SYSVIEW_OS_API;
+
+/*********************************************************************
+*
+*       Control and initialization functions
+*/
+void SEGGER_SYSVIEW_Init                          (U32 SysFreq, U32 CPUFreq, const SEGGER_SYSVIEW_OS_API *pOSAPI, SEGGER_SYSVIEW_SEND_SYS_DESC_FUNC pfSendSysDesc);
+void SEGGER_SYSVIEW_SetRAMBase                    (U32 RAMBaseAddress);
+void SEGGER_SYSVIEW_Start                         (void);
+void SEGGER_SYSVIEW_Stop                          (void);
+void SEGGER_SYSVIEW_GetSysDesc                    (void);
+void SEGGER_SYSVIEW_SendTaskList                  (void);
+void SEGGER_SYSVIEW_SendTaskInfo                  (const SEGGER_SYSVIEW_TASKINFO* pInfo);
+void SEGGER_SYSVIEW_SendSysDesc                   (const char* sSysDesc);
+int  SEGGER_SYSVIEW_IsStarted                     (void);
+int  SEGGER_SYSVIEW_GetChannelID                  (void);
+
+/*********************************************************************
+*
+*       Event recording functions
+*/
+void SEGGER_SYSVIEW_RecordVoid                    (unsigned int EventId);
+void SEGGER_SYSVIEW_RecordU32                     (unsigned int EventId, U32 Para0);
+void SEGGER_SYSVIEW_RecordU32x2                   (unsigned int EventId, U32 Para0, U32 Para1);
+void SEGGER_SYSVIEW_RecordU32x3                   (unsigned int EventId, U32 Para0, U32 Para1, U32 Para2);
+void SEGGER_SYSVIEW_RecordU32x4                   (unsigned int EventId, U32 Para0, U32 Para1, U32 Para2, U32 Para3);
+void SEGGER_SYSVIEW_RecordU32x5                   (unsigned int EventId, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4);
+void SEGGER_SYSVIEW_RecordU32x6                   (unsigned int EventId, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4, U32 Para5);
+void SEGGER_SYSVIEW_RecordU32x7                   (unsigned int EventId, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4, U32 Para5, U32 Para6);
+void SEGGER_SYSVIEW_RecordU32x8                   (unsigned int EventId, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4, U32 Para5, U32 Para6, U32 Para7);
+void SEGGER_SYSVIEW_RecordU32x9                   (unsigned int EventId, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4, U32 Para5, U32 Para6, U32 Para7, U32 Para8);
+void SEGGER_SYSVIEW_RecordU32x10                  (unsigned int EventId, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4, U32 Para5, U32 Para6, U32 Para7, U32 Para8, U32 Para9);
+void SEGGER_SYSVIEW_RecordString                  (unsigned int EventId, const char* pString);
+void SEGGER_SYSVIEW_RecordSystime                 (void);
+void SEGGER_SYSVIEW_RecordEnterISR                (void);
+void SEGGER_SYSVIEW_RecordExitISR                 (void);
+void SEGGER_SYSVIEW_RecordExitISRToScheduler      (void);
+void SEGGER_SYSVIEW_RecordEnterTimer              (U32 TimerId);
+void SEGGER_SYSVIEW_RecordExitTimer               (void);
+void SEGGER_SYSVIEW_RecordEndCall                 (unsigned int EventID);
+void SEGGER_SYSVIEW_RecordEndCallU32              (unsigned int EventID, U32 Para0);
+
+void SEGGER_SYSVIEW_OnIdle                        (void);
+void SEGGER_SYSVIEW_OnTaskCreate                  (U32 TaskId);
+void SEGGER_SYSVIEW_OnTaskTerminate               (U32 TaskId);
+void SEGGER_SYSVIEW_OnTaskStartExec               (U32 TaskId);
+void SEGGER_SYSVIEW_OnTaskStopExec                (void);
+void SEGGER_SYSVIEW_OnTaskStartReady              (U32 TaskId);
+void SEGGER_SYSVIEW_OnTaskStopReady               (U32 TaskId, unsigned int Cause);
+void SEGGER_SYSVIEW_MarkStart                     (unsigned int MarkerId);
+void SEGGER_SYSVIEW_MarkStop                      (unsigned int MarkerId);
+void SEGGER_SYSVIEW_Mark                          (unsigned int MarkerId);
+void SEGGER_SYSVIEW_NameMarker                    (unsigned int MarkerId, const char* sName);
+
+void SEGGER_SYSVIEW_NameResource                  (U32 ResourceId, const char* sName);
+
+int  SEGGER_SYSVIEW_SendPacket                    (U8* pPacket, U8* pPayloadEnd, unsigned int EventId);
+
+/*********************************************************************
+*
+*       Event parameter encoding functions
+*/
+U8*  SEGGER_SYSVIEW_EncodeU32                     (U8* pPayload, U32 Value);
+U8*  SEGGER_SYSVIEW_EncodeData                    (U8* pPayload, const char* pSrc, unsigned int Len);
+U8*  SEGGER_SYSVIEW_EncodeString                  (U8* pPayload, const char* s, unsigned int MaxLen);
+U8*  SEGGER_SYSVIEW_EncodeId                      (U8* pPayload, U32 Id);
+U32  SEGGER_SYSVIEW_ShrinkId                      (U32 Id);
+
+
+/*********************************************************************
+*
+*       Middleware module registration
+*/
+void SEGGER_SYSVIEW_RegisterModule                (SEGGER_SYSVIEW_MODULE* pModule);
+void SEGGER_SYSVIEW_RecordModuleDescription       (const SEGGER_SYSVIEW_MODULE* pModule, const char* sDescription);
+void SEGGER_SYSVIEW_SendModule                    (U8 ModuleId);
+void SEGGER_SYSVIEW_SendModuleDescription         (void);
+void SEGGER_SYSVIEW_SendNumModules                (void);
+
+/*********************************************************************
+*
+*       printf-Style functions
+*/
+#ifndef SEGGER_SYSVIEW_EXCLUDE_PRINTF // Define in project to avoid warnings about variable parameter list
+void SEGGER_SYSVIEW_PrintfHostEx                  (const char* s, U32 Options, ...);
+void SEGGER_SYSVIEW_PrintfTargetEx                (const char* s, U32 Options, ...);
+void SEGGER_SYSVIEW_PrintfHost                    (const char* s, ...);
+void SEGGER_SYSVIEW_PrintfTarget                  (const char* s, ...);
+void SEGGER_SYSVIEW_WarnfHost                     (const char* s, ...);
+void SEGGER_SYSVIEW_WarnfTarget                   (const char* s, ...);
+void SEGGER_SYSVIEW_ErrorfHost                    (const char* s, ...);
+void SEGGER_SYSVIEW_ErrorfTarget                  (const char* s, ...);
+#endif
+
+void SEGGER_SYSVIEW_Print                         (const char* s);
+void SEGGER_SYSVIEW_Warn                          (const char* s);
+void SEGGER_SYSVIEW_Error                         (const char* s);
+
+/*********************************************************************
+*
+*       Run-time configuration functions
+*/
+void SEGGER_SYSVIEW_EnableEvents                  (U32 EnableMask);
+void SEGGER_SYSVIEW_DisableEvents                 (U32 DisableMask);
+
+/*********************************************************************
+*
+*       Application-provided functions
+*/
+void SEGGER_SYSVIEW_Conf                          (void);
+U32  SEGGER_SYSVIEW_X_GetTimestamp                (void);
+U32  SEGGER_SYSVIEW_X_GetInterruptId              (void);
+
+void SEGGER_SYSVIEW_X_StartComm                   (void);
+void SEGGER_SYSVIEW_X_OnEventRecorded             (unsigned NumBytes);
+
+#ifdef __cplusplus
+}
+#endif
+
+/*********************************************************************
+*
+*       Compatibility API defines
+*/
+#define SEGGER_SYSVIEW_OnUserStart      SEGGER_SYSVIEW_MarkStart
+#define SEGGER_SYSVIEW_OnUserStop       SEGGER_SYSVIEW_MarkStop
+
+#endif
+
+/*************************** End of file ****************************/
diff --git a/sched/systemview/SEGGER_SYSVIEW_Conf.h b/sched/systemview/SEGGER_SYSVIEW_Conf.h
new file mode 100644
index 0000000000..58bc46709f
--- /dev/null
+++ b/sched/systemview/SEGGER_SYSVIEW_Conf.h
@@ -0,0 +1,203 @@
+/*********************************************************************
+*                    SEGGER Microcontroller GmbH                     *
+*                        The Embedded Experts                        *
+**********************************************************************
+*                                                                    *
+*            (c) 1995 - 2019 SEGGER Microcontroller GmbH             *
+*                                                                    *
+*       www.segger.com     Support: support@segger.com               *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SEGGER SystemView * Real-time application analysis           *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+* All rights reserved.                                               *
+*                                                                    *
+* SEGGER strongly recommends to not make any changes                 *
+* to or modify the source code of this software in order to stay     *
+* compatible with the SystemView and RTT protocol, and J-Link.       *
+*                                                                    *
+* Redistribution and use in source and binary forms, with or         *
+* without modification, are permitted provided that the following    *
+* condition is met:                                                  *
+*                                                                    *
+* o Redistributions of source code must retain the above copyright   *
+*   notice, this condition and the following disclaimer.             *
+*                                                                    *
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
+* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
+* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
+* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
+* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
+* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
+* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
+* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
+* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
+* DAMAGE.                                                            *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SystemView version: V3.12                                    *
+*                                                                    *
+**********************************************************************
+-------------------------- END-OF-HEADER -----------------------------
+
+File    : SEGGER_SYSVIEW_Conf.h
+Purpose : SEGGER SystemView configuration.
+Revision: $Rev: 17066 $
+*/
+
+#include <nuttx/config.h>
+
+#ifndef SEGGER_SYSVIEW_CONF_H
+#define SEGGER_SYSVIEW_CONF_H
+
+/*********************************************************************
+*
+*       Defines, fixed
+*
+**********************************************************************
+*/
+//
+// Constants for known core configuration
+//
+#define SEGGER_SYSVIEW_CORE_OTHER   0
+#define SEGGER_SYSVIEW_CORE_CM0     1 // Cortex-M0/M0+/M1
+#define SEGGER_SYSVIEW_CORE_CM3     2 // Cortex-M3/M4/M7
+#define SEGGER_SYSVIEW_CORE_RX      3 // Renesas RX
+
+#if (defined __SES_ARM) || (defined __CROSSWORKS_ARM) || (defined __GNUC__) || (defined __clang__)
+  #if (defined __ARM_ARCH_6M__) || (defined __ARM_ARCH_8M_BASE__)
+    #define SEGGER_SYSVIEW_CORE SEGGER_SYSVIEW_CORE_CM0
+  #elif (defined(__ARM_ARCH_7M__) || defined(__ARM_ARCH_7EM__) || defined(__ARM_ARCH_8M_MAIN__))
+    #define SEGGER_SYSVIEW_CORE SEGGER_SYSVIEW_CORE_CM3
+  #endif
+#elif defined(__ICCARM__)
+  #if (defined (__ARM6M__)          && (__CORE__ == __ARM6M__))          \
+   || (defined (__ARM8M_BASELINE__) && (__CORE__ == __ARM8M_BASELINE__))
+    #define SEGGER_SYSVIEW_CORE SEGGER_SYSVIEW_CORE_CM0
+  #elif (defined (__ARM7EM__)         && (__CORE__ == __ARM7EM__))         \
+     || (defined (__ARM7M__)          && (__CORE__ == __ARM7M__))          \
+     || (defined (__ARM8M_MAINLINE__) && (__CORE__ == __ARM8M_MAINLINE__)) \
+     || (defined (__ARM8M_MAINLINE__) && (__CORE__ == __ARM8M_MAINLINE__))
+    #define SEGGER_SYSVIEW_CORE SEGGER_SYSVIEW_CORE_CM3
+  #endif
+#elif defined(__CC_ARM)
+  #if (defined(__TARGET_ARCH_6S_M))
+    #define SEGGER_SYSVIEW_CORE SEGGER_SYSVIEW_CORE_CM0
+  #elif (defined(__TARGET_ARCH_7_M) || defined(__TARGET_ARCH_7E_M))
+    #define SEGGER_SYSVIEW_CORE SEGGER_SYSVIEW_CORE_CM3
+  #endif
+#elif defined(__TI_ARM__)
+  #ifdef __TI_ARM_V6M0__
+    #define SEGGER_SYSVIEW_CORE SEGGER_SYSVIEW_CORE_CM0
+  #elif (defined(__TI_ARM_V7M3__) || defined(__TI_ARM_V7M4__))
+    #define SEGGER_SYSVIEW_CORE SEGGER_SYSVIEW_CORE_CM3
+  #endif
+#elif defined(__ICCRX__)
+  #define SEGGER_SYSVIEW_CORE SEGGER_SYSVIEW_CORE_RX
+#elif defined(__RX)
+  #define SEGGER_SYSVIEW_CORE SEGGER_SYSVIEW_CORE_RX
+#endif
+
+#ifndef   SEGGER_SYSVIEW_CORE
+  #define SEGGER_SYSVIEW_CORE SEGGER_SYSVIEW_CORE_OTHER
+#endif
+
+#ifndef   SEGGER_SYSVIEW_ON_EVENT_RECORDED
+  #define SEGGER_SYSVIEW_ON_EVENT_RECORDED(NumBytes)                            // Needed for SystemView via non-J-Link Recorder. Macro to enable the UART or notify IP task.
+#endif
+
+/*********************************************************************
+*
+*       Defines, configurable
+*
+**********************************************************************
+*/
+/*********************************************************************
+*
+*       SystemView buffer configuration
+*/
+#ifndef   SEGGER_SYSVIEW_RTT_BUFFER_SIZE
+  #define SEGGER_SYSVIEW_RTT_BUFFER_SIZE        CONFIG_SYSTEMVIEW_BUFFER_SIZE   // Number of bytes that SystemView uses for the buffer.
+#endif
+
+#ifndef   SEGGER_SYSVIEW_RTT_CHANNEL
+  #define SEGGER_SYSVIEW_RTT_CHANNEL            CONFIG_SYSTEMVIEW_RTT_CHANNEL   // The RTT channel that SystemView will use. 0: Auto selection
+#endif
+
+#ifndef   SEGGER_SYSVIEW_USE_STATIC_BUFFER
+#ifdef CONFIG_SYSTEMVIEW_USE_STATIC_BUFFER
+  #define SEGGER_SYSVIEW_USE_STATIC_BUFFER      1                               // Use a static buffer to generate events instead of a buffer on the stack
+#else
+  #define SEGGER_SYSVIEW_USE_STATIC_BUFFER      0                               // Use a static buffer to generate events instead of a buffer on the stack
+#endif
+#endif
+
+#ifndef   SEGGER_SYSVIEW_POST_MORTEM_MODE
+#ifdef   CONFIG_SYSTEMVIEW_POST_MORTEM_MODE
+  #define SEGGER_SYSVIEW_POST_MORTEM_MODE       1                               // 1: Enable post mortem analysis mode
+#else
+  #define SEGGER_SYSVIEW_POST_MORTEM_MODE       0                               // 1: Enable post mortem analysis mode
+#endif
+#endif
+
+#ifndef   SEGGER_SYSVIEW_CAN_RESTART
+  #define SEGGER_SYSVIEW_CAN_RESTART            1                               // 1: Send the SystemView start sequence on every start command, not just on the first. Enables restart when SystemView Application disconnected unexpectedly.
+#endif
+
+/*********************************************************************
+*
+*       SystemView timestamp configuration
+*/
+#if !defined(SEGGER_SYSVIEW_GET_TIMESTAMP) && !defined(SEGGER_SYSVIEW_TIMESTAMP_BITS)
+  #if SEGGER_SYSVIEW_CORE == SEGGER_SYSVIEW_CORE_CM3
+    #define SEGGER_SYSVIEW_GET_TIMESTAMP()      (*(U32 *)(0xE0001004))          // Retrieve a system timestamp. Cortex-M cycle counter.
+    #define SEGGER_SYSVIEW_TIMESTAMP_BITS       32                              // Define number of valid bits low-order delivered by clock source
+  #else
+    #define SEGGER_SYSVIEW_GET_TIMESTAMP()      SEGGER_SYSVIEW_X_GetTimestamp() // Retrieve a system timestamp via user-defined function
+    #define SEGGER_SYSVIEW_TIMESTAMP_BITS       32                              // Define number of valid bits low-order delivered by SEGGER_SYSVIEW_X_GetTimestamp()
+  #endif
+#endif
+
+/*********************************************************************
+*
+*       SystemView Id configuration
+*/
+#ifndef   SEGGER_SYSVIEW_ID_BASE
+  #define SEGGER_SYSVIEW_ID_BASE                CONFIG_SYSTEMVIEW_RES_ID_BASE                      // Default value for the lowest Id reported by the application. Can be overridden by the application via SEGGER_SYSVIEW_SetRAMBase(). (i.e. 0x20000000 when all Ids are an address in this RAM)
+#endif
+
+#ifndef   SEGGER_SYSVIEW_ID_SHIFT
+  #define SEGGER_SYSVIEW_ID_SHIFT               CONFIG_SYSTEMVIEW_RES_ID_SHIFT                               // Number of bits to shift the Id to save bandwidth. (i.e. 2 when Ids are 4 byte aligned)
+#endif
+/*********************************************************************
+*
+*       SystemView interrupt configuration
+*/
+#ifndef SEGGER_SYSVIEW_GET_INTERRUPT_ID
+  #if SEGGER_SYSVIEW_CORE == SEGGER_SYSVIEW_CORE_CM3
+    #define SEGGER_SYSVIEW_GET_INTERRUPT_ID()      ((*(U32*)(0xE000ED04)) & 0x1FF)    // Get the currently active interrupt Id. (i.e. read Cortex-M ICSR[8:0] = active vector)
+  #elif SEGGER_SYSVIEW_CORE == SEGGER_SYSVIEW_CORE_CM0
+    #if defined(__ICCARM__)
+      #if (__VER__ > 6010000)
+        #define SEGGER_SYSVIEW_GET_INTERRUPT_ID()  (__get_IPSR())                     // Workaround for IAR, which might do a byte-access to 0xE000ED04. Read IPSR instead.
+      #else
+        #define SEGGER_SYSVIEW_GET_INTERRUPT_ID()  ((*(U32*)(0xE000ED04)) & 0x3F)     // Older versions of IAR do not include __get_IPSR, but might also not optimize to byte-access.
+      #endif
+    #else
+      #define SEGGER_SYSVIEW_GET_INTERRUPT_ID()    ((*(U32*)(0xE000ED04)) & 0x3F)     // Get the currently active interrupt Id. (i.e. read Cortex-M ICSR[5:0] = active vector)
+    #endif
+  #else
+    #define SEGGER_SYSVIEW_GET_INTERRUPT_ID()      SEGGER_SYSVIEW_X_GetInterruptId()  // Get the currently active interrupt Id from the user-provided function.
+  #endif
+#endif
+
+#endif  // SEGGER_SYSVIEW_CONF_H
+
+/*************************** End of file ****************************/
diff --git a/sched/systemview/SEGGER_SYSVIEW_ConfDefaults.h b/sched/systemview/SEGGER_SYSVIEW_ConfDefaults.h
new file mode 100644
index 0000000000..0196fbd446
--- /dev/null
+++ b/sched/systemview/SEGGER_SYSVIEW_ConfDefaults.h
@@ -0,0 +1,172 @@
+/*********************************************************************
+*                    SEGGER Microcontroller GmbH                     *
+*                        The Embedded Experts                        *
+**********************************************************************
+*                                                                    *
+*            (c) 1995 - 2019 SEGGER Microcontroller GmbH             *
+*                                                                    *
+*       www.segger.com     Support: support@segger.com               *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SEGGER SystemView * Real-time application analysis           *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+* All rights reserved.                                               *
+*                                                                    *
+* SEGGER strongly recommends to not make any changes                 *
+* to or modify the source code of this software in order to stay     *
+* compatible with the SystemView and RTT protocol, and J-Link.       *
+*                                                                    *
+* Redistribution and use in source and binary forms, with or         *
+* without modification, are permitted provided that the following    *
+* condition is met:                                                  *
+*                                                                    *
+* o Redistributions of source code must retain the above copyright   *
+*   notice, this condition and the following disclaimer.             *
+*                                                                    *
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
+* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
+* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
+* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
+* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
+* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
+* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
+* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
+* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
+* DAMAGE.                                                            *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SystemView version: V3.12                                    *
+*                                                                    *
+**********************************************************************
+-------------------------- END-OF-HEADER -----------------------------
+File    : SEGGER_SYSVIEW_ConfDefaults.h
+Purpose : Defines defaults for configurable defines used in
+          SEGGER SystemView.
+Revision: $Rev: 9599 $
+*/
+
+#ifndef SEGGER_SYSVIEW_CONFDEFAULTS_H
+#define SEGGER_SYSVIEW_CONFDEFAULTS_H
+
+/*********************************************************************
+*
+*       #include Section
+*
+**********************************************************************
+*/
+
+#include "SEGGER_SYSVIEW_Conf.h"
+#include "SEGGER_RTT_Conf.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*********************************************************************
+*
+*       Configuration defaults
+*
+**********************************************************************
+*/
+
+// Number of bytes that SystemView uses for a buffer.
+#ifndef   SEGGER_SYSVIEW_RTT_BUFFER_SIZE
+  #define SEGGER_SYSVIEW_RTT_BUFFER_SIZE    1024
+#endif
+
+// The RTT channel that SystemView will use.
+#ifndef   SEGGER_SYSVIEW_RTT_CHANNEL
+  #define SEGGER_SYSVIEW_RTT_CHANNEL        0
+#endif
+// Sanity check of RTT channel
+#if (SEGGER_SYSVIEW_RTT_CHANNEL == 0) && (SEGGER_RTT_MAX_NUM_UP_BUFFERS < 2)
+  #error "SEGGER_RTT_MAX_NUM_UP_BUFFERS in SEGGER_RTT_Conf.h has to be > 1!"
+#elif (SEGGER_SYSVIEW_RTT_CHANNEL >= SEGGER_RTT_MAX_NUM_UP_BUFFERS)
+  #error "SEGGER_RTT_MAX_NUM_UP_BUFFERS  in SEGGER_RTT_Conf.h has to be > SEGGER_SYSVIEW_RTT_CHANNEL!"
+#endif
+
+// Place the SystemView buffer into its own/the RTT section
+#if !(defined SEGGER_SYSVIEW_BUFFER_SECTION) && (defined SEGGER_RTT_SECTION)
+  #define SEGGER_SYSVIEW_BUFFER_SECTION            SEGGER_RTT_SECTION
+#endif
+
+// Retrieve a system timestamp.  This gets the Cortex-M cycle counter.
+#ifndef   SEGGER_SYSVIEW_GET_TIMESTAMP
+  #error "SEGGER_SYSVIEW_GET_TIMESTAMP has to be defined in SEGGER_SYSVIEW_Conf.h!"
+#endif
+
+// Define number of valid bits low-order delivered by clock source.
+#ifndef   SEGGER_SYSVIEW_TIMESTAMP_BITS
+  #define SEGGER_SYSVIEW_TIMESTAMP_BITS     32
+#endif
+
+// Lowest Id reported by the Application.
+#ifndef   SEGGER_SYSVIEW_ID_BASE 
+  #define SEGGER_SYSVIEW_ID_BASE            0
+#endif
+
+// Number of bits to shift Ids to save bandwidth
+#ifndef   SEGGER_SYSVIEW_ID_SHIFT
+  #define SEGGER_SYSVIEW_ID_SHIFT           0
+#endif
+
+#ifndef   SEGGER_SYSVIEW_GET_INTERRUPT_ID
+  #error "SEGGER_SYSVIEW_GET_INTERRUPT_ID has to be defined in SEGGER_SYSVIEW_Conf.h!"
+#endif
+
+#ifndef   SEGGER_SYSVIEW_MAX_ARGUMENTS
+  #define SEGGER_SYSVIEW_MAX_ARGUMENTS      16
+#endif
+
+#ifndef   SEGGER_SYSVIEW_MAX_STRING_LEN
+  #define SEGGER_SYSVIEW_MAX_STRING_LEN     128
+#endif
+
+#ifndef   SEGGER_SYSVIEW_PRINTF_IMPLICIT_FORMAT
+  #define SEGGER_SYSVIEW_PRINTF_IMPLICIT_FORMAT 0
+#endif
+
+// Use a static buffer instead of a buffer on the stack for packets
+#ifndef   SEGGER_SYSVIEW_USE_STATIC_BUFFER
+  #define SEGGER_SYSVIEW_USE_STATIC_BUFFER  1
+#endif
+
+// Maximum packet size used by SystemView for the static buffer
+#ifndef   SEGGER_SYSVIEW_MAX_PACKET_SIZE
+  #define SEGGER_SYSVIEW_MAX_PACKET_SIZE   SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_MAX_STRING_LEN + 2 * SEGGER_SYSVIEW_QUANTA_U32 + SEGGER_SYSVIEW_MAX_ARGUMENTS * SEGGER_SYSVIEW_QUANTA_U32
+#endif
+
+// Use post-mortem analysis instead of real-time analysis
+#ifndef   SEGGER_SYSVIEW_POST_MORTEM_MODE
+  #define SEGGER_SYSVIEW_POST_MORTEM_MODE   0
+#endif
+
+// Configure how frequently syncronization is sent
+#ifndef   SEGGER_SYSVIEW_SYNC_PERIOD_SHIFT
+  #define SEGGER_SYSVIEW_SYNC_PERIOD_SHIFT  8
+#endif
+
+// Lock SystemView (nestable)
+#ifndef   SEGGER_SYSVIEW_LOCK
+  #define SEGGER_SYSVIEW_LOCK()             SEGGER_RTT_LOCK()
+#endif
+
+// Unlock SystemView (nestable)
+#ifndef   SEGGER_SYSVIEW_UNLOCK
+  #define SEGGER_SYSVIEW_UNLOCK()           SEGGER_RTT_UNLOCK()
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+/*************************** End of file ****************************/
diff --git a/sched/systemview/SEGGER_SYSVIEW_Config_NuttX.c b/sched/systemview/SEGGER_SYSVIEW_Config_NuttX.c
new file mode 100644
index 0000000000..95244fd7e9
--- /dev/null
+++ b/sched/systemview/SEGGER_SYSVIEW_Config_NuttX.c
@@ -0,0 +1,194 @@
+/*********************************************************************
+*                    SEGGER Microcontroller GmbH                     *
+*                        The Embedded Experts                        *
+**********************************************************************
+*                                                                    *
+*            (c) 1995 - 2019 SEGGER Microcontroller GmbH             *
+*                                                                    *
+*       www.segger.com     Support: support@segger.com               *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SEGGER SystemView * Real-time application analysis           *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+* All rights reserved.                                               *
+*                                                                    *
+* SEGGER strongly recommends to not make any changes                 *
+* to or modify the source code of this software in order to stay     *
+* compatible with the SystemView and RTT protocol, and J-Link.       *
+*                                                                    *
+* Redistribution and use in source and binary forms, with or         *
+* without modification, are permitted provided that the following    *
+* condition is met:                                                  *
+*                                                                    *
+* o Redistributions of source code must retain the above copyright   *
+*   notice, this condition and the following disclaimer.             *
+*                                                                    *
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
+* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
+* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
+* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
+* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
+* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
+* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
+* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
+* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
+* DAMAGE.                                                            *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SystemView version: V3.12                                    *
+*                                                                    *
+**********************************************************************
+-------------------------- END-OF-HEADER -----------------------------
+
+File    : SEGGER_SYSVIEW_Config_NuttX.c
+Purpose : Sample setup configuration of SystemView with NuttX.
+Revision: $Rev$
+*/
+#include "SEGGER_SYSVIEW.h"
+#include "SEGGER_SYSVIEW_Conf.h"
+#include "SEGGER_SYSVIEW_NuttX.h"
+
+
+/*********************************************************************
+*
+*       Defines, configurable
+*
+**********************************************************************
+*/
+#ifndef CONFIG_SYSTEMVIEW_APP_NAME
+#error CONFIG_SYSTEMVIEW_APP_NAME undefined!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+#endif
+// The application name to be displayed in SystemViewer
+#ifndef   SYSVIEW_APP_NAME
+  #define SYSVIEW_APP_NAME        CONFIG_SYSTEMVIEW_APP_NAME
+#endif
+
+// The target device name
+#ifndef   SYSVIEW_DEVICE_NAME
+  #define SYSVIEW_DEVICE_NAME     CONFIG_SYSTEMVIEW_DEVICE_NAME
+#endif
+
+// Frequency of the timestamp. Must match SEGGER_SYSVIEW_Conf.h
+#ifndef   SYSVIEW_TIMESTAMP_FREQ
+  #define SYSVIEW_TIMESTAMP_FREQ  (CONFIG_SYSTEMVIEW_TIMESTAMP_FREQ)
+#endif
+
+// System Frequency. SystemcoreClock is used in most CMSIS compatible projects.
+#ifndef   SYSVIEW_CPU_FREQ
+  #define SYSVIEW_CPU_FREQ        (CONFIG_SYSTEMVIEW_CPU_FREQ)
+#endif
+
+// The lowest RAM address used for IDs (pointers)
+#ifndef   SYSVIEW_RAM_BASE
+  #define SYSVIEW_RAM_BASE        (CONFIG_SYSTEMVIEW_RES_ID_BASE)
+#endif
+
+#ifndef   SYSVIEW_SYSDESC0
+  #define SYSVIEW_SYSDESC0        CONFIG_SYSTEMVIEW_SYSDESC_0
+#endif
+
+// Define as 1 if the Cortex-M cycle counter is used as SystemView timestamp. Must match SEGGER_SYSVIEW_Conf.h
+#ifndef   USE_CYCCNT_TIMESTAMP
+  #define USE_CYCCNT_TIMESTAMP    1
+#endif
+
+// Define as 1 if the Cortex-M cycle counter is used and there might be no debugger attached while recording,
+// for example in post-mortem mode, or when recording via IP.
+#ifndef   ENABLE_DWT_CYCCNT
+  #define ENABLE_DWT_CYCCNT       (USE_CYCCNT_TIMESTAMP & SEGGER_SYSVIEW_POST_MORTEM_MODE)
+#endif
+
+// Define as 1 to immediately start recording after initialization to catch system initialization.
+#ifndef   SYSVIEW_START_ON_INIT
+#ifdef CONFIG_SYSTEMVIEW_START_ON_INIT
+  #define SYSVIEW_START_ON_INIT   1
+#else
+  #define SYSVIEW_START_ON_INIT   0
+#endif
+#endif
+
+//#ifndef   SYSVIEW_SYSDESC1
+//  #define SYSVIEW_SYSDESC1      ""
+//#endif
+
+//#ifndef   SYSVIEW_SYSDESC2
+//  #define SYSVIEW_SYSDESC2      ""
+//#endif
+
+/*********************************************************************
+*
+*       Defines, fixed
+*
+**********************************************************************
+*/
+#define DEMCR         (*(volatile U32*) (0xE000EDFCuL))  // Debug Exception and Monitor Control Register
+#define TRACEENA_BIT  (1uL << 24)                        // Trace enable bit
+#define DWT_CTRL      (*(volatile U32*) (0xE0001000uL))  // DWT Control Register
+#define NOCYCCNT_BIT  (1uL << 25)                        // Cycle counter support bit
+#define CYCCNTENA_BIT (1uL << 0)                         // Cycle counter enable bit
+
+/*********************************************************************
+*
+*       _cbSendSystemDesc()
+*
+*  Function description
+*    Sends SystemView description strings.
+*/
+static void _cbSendSystemDesc(void) {
+  SEGGER_SYSVIEW_SendSysDesc("N=" SYSVIEW_APP_NAME ",O=NuttX,D=" SYSVIEW_DEVICE_NAME );
+#ifdef SYSVIEW_SYSDESC0
+  SEGGER_SYSVIEW_SendSysDesc(SYSVIEW_SYSDESC0);
+#endif
+#ifdef SYSVIEW_SYSDESC1
+  SEGGER_SYSVIEW_SendSysDesc(SYSVIEW_SYSDESC1);
+#endif
+#ifdef SYSVIEW_SYSDESC2
+  SEGGER_SYSVIEW_SendSysDesc(SYSVIEW_SYSDESC2);
+#endif
+}
+
+/*********************************************************************
+*
+*       Global functions
+*
+**********************************************************************
+*/
+void SEGGER_SYSVIEW_Conf(void) {
+#if USE_CYCCNT_TIMESTAMP
+#if ENABLE_DWT_CYCCNT
+  //
+  // If no debugger is connected, the DWT must be enabled by the application
+  //
+  if ((DEMCR & TRACEENA_BIT) == 0) {
+    DEMCR |= TRACEENA_BIT;
+  }
+#endif
+  //
+  //  The cycle counter must be activated in order
+  //  to use time related functions.
+  //
+  if ((DWT_CTRL & NOCYCCNT_BIT) == 0) {       // Cycle counter supported?
+    if ((DWT_CTRL & CYCCNTENA_BIT) == 0) {    // Cycle counter not enabled?
+      DWT_CTRL |= CYCCNTENA_BIT;              // Enable Cycle counter
+    }
+  }
+#endif
+  SEGGER_SYSVIEW_Init(SYSVIEW_TIMESTAMP_FREQ, SYSVIEW_CPU_FREQ,
+                      &SYSVIEW_X_OS_TraceAPI, _cbSendSystemDesc);
+  SEGGER_SYSVIEW_SetRAMBase(SYSVIEW_RAM_BASE);
+
+  SYSVIEW_InitTime();
+
+#if SYSVIEW_START_ON_INIT
+  SEGGER_SYSVIEW_Start();                     // Start recording to catch system initialization.
+#endif
+}
+
+/*************************** End of file ****************************/
diff --git a/sched/systemview/SEGGER_SYSVIEW_Int.h b/sched/systemview/SEGGER_SYSVIEW_Int.h
new file mode 100644
index 0000000000..b97bbec211
--- /dev/null
+++ b/sched/systemview/SEGGER_SYSVIEW_Int.h
@@ -0,0 +1,100 @@
+/*********************************************************************
+*                    SEGGER Microcontroller GmbH                     *
+*                        The Embedded Experts                        *
+**********************************************************************
+*                                                                    *
+*            (c) 1995 - 2019 SEGGER Microcontroller GmbH             *
+*                                                                    *
+*       www.segger.com     Support: support@segger.com               *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SEGGER SystemView * Real-time application analysis           *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+* All rights reserved.                                               *
+*                                                                    *
+* SEGGER strongly recommends to not make any changes                 *
+* to or modify the source code of this software in order to stay     *
+* compatible with the SystemView and RTT protocol, and J-Link.       *
+*                                                                    *
+* Redistribution and use in source and binary forms, with or         *
+* without modification, are permitted provided that the following    *
+* condition is met:                                                  *
+*                                                                    *
+* o Redistributions of source code must retain the above copyright   *
+*   notice, this condition and the following disclaimer.             *
+*                                                                    *
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
+* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
+* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
+* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
+* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
+* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
+* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
+* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
+* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
+* DAMAGE.                                                            *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SystemView version: V3.12                                    *
+*                                                                    *
+**********************************************************************
+-------------------------- END-OF-HEADER -----------------------------
+File    : SEGGER_SYSVIEW_Int.h
+Purpose : SEGGER SystemView internal header.
+Revision: $Rev: 9599 $
+*/
+
+#ifndef SEGGER_SYSVIEW_INT_H
+#define SEGGER_SYSVIEW_INT_H
+
+/*********************************************************************
+*
+*       #include Section
+*
+**********************************************************************
+*/
+
+#include "SEGGER_SYSVIEW.h"
+#include "SEGGER_SYSVIEW_Conf.h"
+#include "SEGGER_SYSVIEW_ConfDefaults.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/*********************************************************************
+*
+*       Private data types
+*
+**********************************************************************
+*/
+//
+// Commands that Host can send to target
+//
+typedef enum {
+  SEGGER_SYSVIEW_COMMAND_ID_START = 1,
+  SEGGER_SYSVIEW_COMMAND_ID_STOP,
+  SEGGER_SYSVIEW_COMMAND_ID_GET_SYSTIME,
+  SEGGER_SYSVIEW_COMMAND_ID_GET_TASKLIST,
+  SEGGER_SYSVIEW_COMMAND_ID_GET_SYSDESC,
+  SEGGER_SYSVIEW_COMMAND_ID_GET_NUMMODULES,
+  SEGGER_SYSVIEW_COMMAND_ID_GET_MODULEDESC,
+  // Extended commands: Commands >= 128 have a second parameter
+  SEGGER_SYSVIEW_COMMAND_ID_GET_MODULE = 128
+} SEGGER_SYSVIEW_COMMAND_ID;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+/*************************** End of file ****************************/
diff --git a/sched/systemview/SEGGER_SYSVIEW_NuttX.c b/sched/systemview/SEGGER_SYSVIEW_NuttX.c
new file mode 100644
index 0000000000..586bdaeec5
--- /dev/null
+++ b/sched/systemview/SEGGER_SYSVIEW_NuttX.c
@@ -0,0 +1,269 @@
+/*********************************************************************
+*                    SEGGER Microcontroller GmbH                     *
+*                        The Embedded Experts                        *
+**********************************************************************
+*                                                                    *
+*            (c) 1995 - 2019 SEGGER Microcontroller GmbH             *
+*                                                                    *
+*       www.segger.com     Support: support@segger.com               *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SEGGER SystemView * Real-time application analysis           *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+* All rights reserved.                                               *
+*                                                                    *
+* SEGGER strongly recommends to not make any changes                 *
+* to or modify the source code of this software in order to stay     *
+* compatible with the SystemView and RTT protocol, and J-Link.       *
+*                                                                    *
+* Redistribution and use in source and binary forms, with or         *
+* without modification, are permitted provided that the following    *
+* condition is met:                                                  *
+*                                                                    *
+* o Redistributions of source code must retain the above copyright   *
+*   notice, this condition and the following disclaimer.             *
+*                                                                    *
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
+* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
+* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
+* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
+* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
+* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
+* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
+* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
+* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
+* DAMAGE.                                                            *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SystemView version: V3.12                                    *
+*                                                                    *
+**********************************************************************
+-------------------------- END-OF-HEADER -----------------------------
+
+File    : SEGGER_SYSVIEW_NuttX.c
+Purpose : Interface between NuttX and SystemView.
+Revision: $Rev $
+*/
+#include <nuttx/config.h>
+
+#include "SEGGER_SYSVIEW.h"
+#include "SEGGER_SYSVIEW_NuttX.h"
+#include "string.h" // Required for memset
+
+#include <time.h>
+
+
+#ifdef CONFIG_CLOCK_MONOTONIC
+#  define _TIME_CLOCK CLOCK_MONOTONIC
+#else
+#  define _TIME_CLOCK CLOCK_REALTIME
+#endif
+
+
+typedef struct _SYSVIEW_NUTTX_TASK_STATUS _SYSVIEW_NUTTX_TASK_STATUS;
+
+struct _SYSVIEW_NUTTX_TASK_STATUS {
+  U32         TaskID;
+  const char* sName;
+  unsigned    Priority;
+  U32         StackAddr;
+  unsigned    StackSize;
+};
+
+static _SYSVIEW_NUTTX_TASK_STATUS _aTasks[SYSVIEW_NUTTX_MAX_NOF_TASKS];
+static unsigned _NumTasks;
+
+
+static U64      _Time;
+static U64      _TimeStart;
+
+/*********************************************************************
+*
+*       _cbSendTaskList()
+*
+*  Function description
+*    This function is part of the link between NuttX and SYSVIEW.
+*    Called from SystemView when asked by the host, it uses SYSVIEW
+*    functions to send the entire task list to the host.
+*/
+static void _cbSendTaskList(void) {
+  unsigned n;
+
+  for (n = 0; n < _NumTasks; n++) {
+    SYSVIEW_SendTaskInfo(_aTasks[n].TaskID, _aTasks[n].sName, _aTasks[n].Priority, _aTasks[n].StackAddr, _aTasks[n].StackSize);
+  }
+}
+
+/*********************************************************************
+*
+*       _cbGetTime()
+*
+*  Function description
+*    This function is part of the link between FreeRTOS and SYSVIEW.
+*    Called from SystemView when asked by the host, returns the
+*    current system time in micro seconds.
+*/
+static U64 _cbGetTime(void) {
+  struct timespec TimeSpec;
+  int             r;
+
+  r = clock_gettime(_TIME_CLOCK, &TimeSpec);
+
+  if (r >= 0) {
+    _Time = (U64)TimeSpec.tv_sec;
+    _Time *= 1000000uLL;
+    _Time += TimeSpec.tv_nsec / 1000u;
+  }
+  return _Time - _TimeStart;
+}
+
+/*********************************************************************
+*
+*       Global functions
+*
+**********************************************************************
+*/
+/*********************************************************************
+*
+*       SYSVIEW_InitTime()
+*
+*  Function description
+*    Initialize system time of SystemView, to start at 0 with the initialization.
+*/
+void SYSVIEW_InitTime(void) {
+  _TimeStart = 0;
+  _TimeStart = _cbGetTime();
+}
+
+/*********************************************************************
+*
+*       SYSVIEW_AddTask()
+*
+*  Function description
+*    Add a task to the internal list and record its information.
+*/
+void SYSVIEW_AddTask(U32 TaskID, const char* sName, unsigned Priority, U32 StackAddr, unsigned StackSize) {
+  
+  if (_NumTasks >= SYSVIEW_NUTTX_MAX_NOF_TASKS) {
+    SEGGER_SYSVIEW_Warn("SYSTEMVIEW: Could not record task information. Maximum number of tasks reached.");
+    return;
+  }
+
+  _aTasks[_NumTasks].TaskID = TaskID;
+  _aTasks[_NumTasks].sName = sName;
+  _aTasks[_NumTasks].Priority = Priority;
+  _aTasks[_NumTasks].StackAddr = StackAddr;
+  _aTasks[_NumTasks].StackSize = StackSize;
+
+  _NumTasks++;
+
+  SYSVIEW_SendTaskInfo(TaskID, sName, Priority, StackAddr, StackSize);
+}
+
+/*********************************************************************
+*
+*       SYSVIEW_UpdateTask()
+*
+*  Function description
+*    Update a task in the internal list and record its information.
+*/
+void SYSVIEW_UpdateTask(U32 TaskID, const char* sName, unsigned Priority, U32 StackAddr, unsigned StackSize) {
+  unsigned n;
+
+  for (n = 0; n < _NumTasks; n++) {
+    if (_aTasks[n].TaskID == TaskID) {
+      break;
+    }
+  }
+  if (n < _NumTasks) {
+    _aTasks[n].sName = sName;
+    _aTasks[n].Priority = Priority;
+    _aTasks[n].StackAddr = StackAddr;
+    _aTasks[n].StackSize = StackSize;
+
+    SYSVIEW_SendTaskInfo(TaskID, sName, Priority, StackAddr, StackSize);
+  } else {
+    SYSVIEW_AddTask(TaskID, sName, Priority, StackAddr, StackSize);
+  }
+}
+
+/*********************************************************************
+*
+*       SYSVIEW_DeleteTask()
+*
+*  Function description
+*    Delete a task from the internal list.
+*/
+void SYSVIEW_DeleteTask(U32 TaskID) {
+  unsigned n;
+  
+  if (_NumTasks == 0) {
+    return; // Early out
+  }  
+  for (n = 0; n < _NumTasks; n++) {
+    if (_aTasks[n].TaskID == TaskID) {
+      break;
+    }
+  }
+  if (n == (_NumTasks - 1)) {  
+    //
+    // Task is last item in list.
+    // Simply zero the item and decrement number of tasks.
+    //
+    memset(&_aTasks[n], 0, sizeof(_aTasks[n]));
+    _NumTasks--;
+  } else if (n < _NumTasks) {
+    //
+    // Task is in the middle of the list.
+    // Move last item to current position and decrement number of tasks.
+    // Order of tasks does not really matter, so no need to move all following items.
+    //
+    _aTasks[n].TaskID         = _aTasks[_NumTasks - 1].TaskID;
+    _aTasks[n].sName          = _aTasks[_NumTasks - 1].sName;
+    _aTasks[n].Priority       = _aTasks[_NumTasks - 1].Priority;
+    _aTasks[n].StackAddr      = _aTasks[_NumTasks - 1].StackAddr;
+    _aTasks[n].StackSize      = _aTasks[_NumTasks - 1].StackSize;
+    memset(&_aTasks[_NumTasks - 1], 0, sizeof(_aTasks[_NumTasks - 1]));
+    _NumTasks--;
+  }
+}
+
+/*********************************************************************
+*
+*       SYSVIEW_SendTaskInfo()
+*
+*  Function description
+*    Record task information.
+*/
+void SYSVIEW_SendTaskInfo(U32 TaskID, const char* sName, unsigned Prio, U32 StackAddr, unsigned StackSize) {
+  SEGGER_SYSVIEW_TASKINFO TaskInfo;
+
+  memset(&TaskInfo, 0, sizeof(TaskInfo)); // Fill all elements with 0 to allow extending the structure in future version without breaking the code
+  TaskInfo.TaskID     = TaskID;
+  TaskInfo.sName      = sName;
+  TaskInfo.Prio       = Prio;
+  TaskInfo.StackBase  = StackAddr;
+  TaskInfo.StackSize  = StackSize;
+  SEGGER_SYSVIEW_SendTaskInfo(&TaskInfo);
+}
+
+/*********************************************************************
+*
+*       Public API structures
+*
+**********************************************************************
+*/
+// Callbacks provided to SYSTEMVIEW by FreeRTOS
+const SEGGER_SYSVIEW_OS_API SYSVIEW_X_OS_TraceAPI = {
+  _cbGetTime,
+  _cbSendTaskList,
+};
+
+/*************************** End of file ****************************/
diff --git a/sched/systemview/SEGGER_SYSVIEW_NuttX.h b/sched/systemview/SEGGER_SYSVIEW_NuttX.h
new file mode 100644
index 0000000000..b63abbaff2
--- /dev/null
+++ b/sched/systemview/SEGGER_SYSVIEW_NuttX.h
@@ -0,0 +1,156 @@
+/*********************************************************************
+*                    SEGGER Microcontroller GmbH                     *
+*                        The Embedded Experts                        *
+**********************************************************************
+*                                                                    *
+*            (c) 1995 - 2019 SEGGER Microcontroller GmbH             *
+*                                                                    *
+*       www.segger.com     Support: support@segger.com               *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SEGGER SystemView * Real-time application analysis           *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+* All rights reserved.                                               *
+*                                                                    *
+* SEGGER strongly recommends to not make any changes                 *
+* to or modify the source code of this software in order to stay     *
+* compatible with the SystemView and RTT protocol, and J-Link.       *
+*                                                                    *
+* Redistribution and use in source and binary forms, with or         *
+* without modification, are permitted provided that the following    *
+* condition is met:                                                  *
+*                                                                    *
+* o Redistributions of source code must retain the above copyright   *
+*   notice, this condition and the following disclaimer.             *
+*                                                                    *
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
+* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
+* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
+* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
+* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
+* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
+* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
+* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
+* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
+* DAMAGE.                                                            *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SystemView version: V3.12                                    *
+*                                                                    *
+**********************************************************************
+-------------------------- END-OF-HEADER -----------------------------
+
+File    : SEGGER_SYSVIEW_NuttX.h
+Purpose : Interface between NuttX and SystemView.
+Revision: $Rev: 7745 $
+*/
+
+#ifndef SYSVIEW_NUTTX_H
+#define SYSVIEW_NUTTX_H
+
+#include "SEGGER_SYSVIEW.h"
+
+/*********************************************************************
+*
+*       Defines, configurable
+*
+**********************************************************************
+*/
+#ifdef CONFIG_SYSTEMVIEW_MAX_NOF_TASKS
+  #define SYSVIEW_NUTTX_MAX_NOF_TASKS  CONFIG_SYSTEMVIEW_MAX_NOF_TASKS
+#else
+  #define SYSVIEW_NUTTX_MAX_NOF_TASKS  8
+#endif
+
+/*********************************************************************
+*
+*       Defines, fixed
+*
+**********************************************************************
+*/
+#define _SYSTEMVIEW_ID_OFFSET                              (32u)
+#define _TRACE_API_ID_TASK_CREATE                          (1u + _SYSTEMVIEW_ID_OFFSET)
+#define _TRACE_API_ID_NXTASK_CREATE                        (2u + _SYSTEMVIEW_ID_OFFSET)
+#define _TRACE_API_ID_KTHREAD_CREATE                       (3u + _SYSTEMVIEW_ID_OFFSET)
+#define _TRACE_API_ID_PTHREAD_CREATE                       (4u + _SYSTEMVIEW_ID_OFFSET)
+
+#if !defined(CONFIG_SYSTEMVIEW_ENABLE)
+  #define TRACE_INIT()
+  #define TRACE_START()
+  #define TRACE_TASK_CREATED(PID, Name, Priority, StackAddr, StackSize)
+  #define TRACE_TASK_READY(PID)
+  #define TRACE_TASK_START(pTCB)
+  #define TRACE_TASK_BLOCK(PID, State)
+  #define TRACE_TASK_TERMINATE(PID)
+#else
+  #define TRACE_INIT()                              							SEGGER_SYSVIEW_Conf()
+  #define TRACE_START()                             							SEGGER_SYSVIEW_Start()
+  #define TRACE_TASK_CREATED(PID, Name, Priority, StackAddr, StackSize) 		SEGGER_SYSVIEW_OnTaskCreate(PID); 													\
+                                                                                SYSVIEW_AddTask((U32)PID, (const char*)Name, (unsigned)Priority, (U32)StackAddr, (unsigned)StackSize)
+  #define TRACE_TASK_READY(PID)													SEGGER_SYSVIEW_OnTaskStartReady(PID)
+  #define TRACE_TASK_START(PID)  												{ if (PID == 0) { SEGGER_SYSVIEW_OnIdle(); } else { SEGGER_SYSVIEW_OnTaskStartExec(PID); } }
+  #define TRACE_TASK_BLOCK(PID, State) 											SEGGER_SYSVIEW_OnTaskStopReady(PID, (U32)State)
+  #define TRACE_TASK_TERMINATE(PID)                                             { SEGGER_SYSVIEW_OnTaskTerminate(PID); SYSVIEW_DeleteTask(PID); }
+#endif
+
+#if !defined(CONFIG_SYSTEMVIEW_ENABLE) && !defined(CONFIG_SYSTEMVIEW_RECORD_ISR)
+  #define TRACE_ISR_ENTER()
+  #define TRACE_ISR_EXIT()
+  #define TRACE_ISR_EXIT_TO_SCHEDULER()
+#else
+  #define TRACE_ISR_ENTER()                         							SEGGER_SYSVIEW_RecordEnterISR()
+  #define TRACE_ISR_EXIT()                          							SEGGER_SYSVIEW_RecordExitISR()
+  #define TRACE_ISR_EXIT_TO_SCHEDULER()             							SEGGER_SYSVIEW_RecordExitISRToScheduler()
+#endif
+
+#if !defined(CONFIG_SYSTEMVIEW_ENABLE) && !defined(CONFIG_SYSTEMVIEW_RECORD_API)
+  #define TRACE_API_TASK_CREATE(name, priority, stack_size, entry, argv)
+  #define TRACE_API_TASK_CREATE_RETURN(ret)
+  #define TRACE_API_NXTASK_CREATE(name, priority, stack_size, entry, argv)
+  #define TRACE_API_NXTASK_CREATE_RETURN(ret)
+  #define TRACE_API_KTHREAD_CREATE(name, priority, stack_size, entry, argv)
+  #define TRACE_API_KTHREAD_CREATE_RETURN(ret)
+  #define TRACE_API_PTHREAD_CREATE(thread, attr, start_routine, arg)
+  #define TRACE_API_PTHREAD_CREATE_RETURN(ret)
+#else
+  #define TRACE_API_TASK_CREATE(name, priority, stack_size, entry, argv)        SEGGER_SYSVIEW_RecordU32x5     (_TRACE_API_ID_TASK_CREATE,  (U32)name, (U32)priority, (U32)stack_size, (U32)entry, (U32)argv)
+  #define TRACE_API_TASK_CREATE_RETURN(ret)         														SEGGER_SYSVIEW_RecordEndCallU32(_TRACE_API_ID_TASK_CREATE,  ret)
+  #define TRACE_API_NXTASK_CREATE(name, priority, stack_size, entry, argv)      SEGGER_SYSVIEW_RecordU32x5     (_TRACE_API_ID_NXTASK_CREATE, (U32)name, (U32)priority, (U32)stack_size, (U32)entry, (U32)argv)
+  #define TRACE_API_NXTASK_CREATE_RETURN(ret)                                   SEGGER_SYSVIEW_RecordEndCallU32(_TRACE_API_ID_NXTASK_CREATE, ret)
+  #define TRACE_API_KTHREAD_CREATE(name, priority, stack_size, entry, argv)     SEGGER_SYSVIEW_RecordU32x5     (_TRACE_API_ID_KTHREAD_CREATE,  (U32)name, (U32)priority, (U32)stack_size, (U32)entry, (U32)argv)
+  #define TRACE_API_KTHREAD_CREATE_RETURN(ret)                                  SEGGER_SYSVIEW_RecordEndCallU32(_TRACE_API_ID_KTHREAD_CREATE,  ret)
+  #define TRACE_API_PTHREAD_CREATE(thread, attr, start_routine, arg)            SEGGER_SYSVIEW_RecordU32x4     (_TRACE_API_ID_PTHREAD_CREATE, (U32)thread, (U32)attr, (U32)start_routine, (U32)arg)
+  #define TRACE_API_PTHREAD_CREATE_RETURN(ret)                                  SEGGER_SYSVIEW_RecordEndCallU32(_TRACE_API_ID_PTHREAD_CREATE,  ret)
+#endif
+
+/*********************************************************************
+*
+*       API functions
+*
+**********************************************************************
+*/
+#ifdef __cplusplus
+extern "C" {
+#endif
+void SYSVIEW_InitTime     (void);
+void SYSVIEW_AddTask      (U32 TaskID, const char* sName, unsigned Priority, U32 StackAddr, unsigned StackSize);
+void SYSVIEW_UpdateTask   (U32 TaskID, const char* sName, unsigned Priority, U32 StackAddr, unsigned StackSize);
+void SYSVIEW_DeleteTask   (U32 TaskID);
+void SYSVIEW_SendTaskInfo (U32 TaskID, const char* sName, unsigned Priority, U32 StackAddr, unsigned StackSize);
+
+extern const SEGGER_SYSVIEW_OS_API SYSVIEW_X_OS_TraceAPI;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+/*************************** End of file ****************************/
diff --git a/sched/task/task_create.c b/sched/task/task_create.c
index 9915c5d8b6..f013b1cce9 100644
--- a/sched/task/task_create.c
+++ b/sched/task/task_create.c
@@ -38,6 +38,8 @@
 #include "group/group.h"
 #include "task/task.h"
 
+#include "systemview/SEGGER_SYSVIEW_NuttX.h"
+
 /****************************************************************************
  * Private Functions
  ****************************************************************************/
diff --git a/sched/task/task_start.c b/sched/task/task_start.c
index 1ccace2ce8..d562aa4853 100644
--- a/sched/task/task_start.c
+++ b/sched/task/task_start.c
@@ -52,6 +52,8 @@
 #include "signal/signal.h"
 #include "task/task.h"
 
+#include "systemview/SEGGER_SYSVIEW_NuttX.h"
+
 /****************************************************************************
  * Pre-processor Definitions
  ****************************************************************************/
@@ -134,6 +136,8 @@ void nxtask_start(void)
    * we have to switch to user-mode before calling the task.
    */
 
+  TRACE_TASK_START(tcb->cmn.pid);
+
 #ifndef CONFIG_BUILD_FLAT
   if ((tcb->cmn.flags & TCB_FLAG_TTYPE_MASK) != TCB_FLAG_TTYPE_KERNEL)
     {
@@ -147,6 +151,8 @@ void nxtask_start(void)
   nxtask_startup(tcb->cmn.entry.main, argc, tcb->argv);
 #endif
 
+  TRACE_TASK_TERMINATE(tcb->cmn.pid);
+
   /* Call exit() if/when the task returns */
 
   exit(exitcode);
-- 
2.17.1

