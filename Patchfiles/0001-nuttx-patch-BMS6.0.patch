From 003e0315c16f8e626b6d70f9635c6bc6ac229aff Mon Sep 17 00:00:00 2001
From: nxf63123 <cis.van.mierlo@nxp.com>
Date: Thu, 2 May 2024 16:40:55 +0200
Subject: [PATCH] nuttx patch BMS6.0

---
 arch/arm/src/s32k1xx/Kconfig                  |  118 ++
 .../arm/src/s32k1xx/hardware/s32k14x_dmamux.h |   86 ++
 .../arm/src/s32k1xx/hardware/s32k1xx_dmamux.h |   10 +-
 arch/arm/src/s32k1xx/hardware/s32k1xx_edma.h  |    6 +-
 arch/arm/src/s32k1xx/hardware/s32k1xx_lpi2c.h |   60 +-
 .../src/s32k1xx/hardware/s32k1xx_memorymap.h  |    4 +-
 arch/arm/src/s32k1xx/s32k1xx_clockconfig.c    |   32 +-
 arch/arm/src/s32k1xx/s32k1xx_clockconfig.h    |   21 +-
 arch/arm/src/s32k1xx/s32k1xx_edma.c           |  235 ++--
 arch/arm/src/s32k1xx/s32k1xx_edma.h           |   33 +-
 arch/arm/src/s32k1xx/s32k1xx_flexcan.c        |  105 +-
 arch/arm/src/s32k1xx/s32k1xx_lpi2c.c          |  899 +++++++++---
 arch/arm/src/s32k1xx/s32k1xx_lpspi.c          |  424 +++++-
 arch/arm/src/s32k1xx/s32k1xx_pminitialize.c   |    5 +
 arch/arm/src/s32k1xx/s32k1xx_serial.c         | 1212 ++++++++++++++---
 arch/arm/src/s32k1xx/s32k1xx_serial.h         |  109 ++
 .../rddrone-bms772/configs/bms/defconfig      |  143 ++
 .../rddrone-bms772/configs/bmsdebug/defconfig |  149 ++
 .../rddrone-bms772/configs/bmstrace/defconfig |  158 +++
 .../rddrone-bms772/include/nsh_romfsimg.h     |  226 +--
 .../include/rc.sysinit.template               |    8 +
 .../rddrone-bms772/include/rcS.template       |    5 +-
 .../rddrone-bms772/src/rddrone-bms772.h       |    4 -
 .../rddrone-bms772/src/s32k1xx_clockconfig.c  |    1 -
 .../src/s32k1xx_nrstcheck_procfs.c            |    3 +
 .../rddrone-bms772/src/s32k1xx_periphclocks.c |   12 +
 net/can/can_recvmsg.c                         |    6 +-
 net/utils/net_lock.c                          |    2 +-
 sched/semaphore/sem_trywait.c                 |    7 +-
 29 files changed, 3269 insertions(+), 814 deletions(-)
 create mode 100644 arch/arm/src/s32k1xx/hardware/s32k14x_dmamux.h
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/configs/bms/defconfig
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/configs/bmsdebug/defconfig
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/configs/bmstrace/defconfig
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/include/rc.sysinit.template

diff --git a/arch/arm/src/s32k1xx/Kconfig b/arch/arm/src/s32k1xx/Kconfig
index 57ee616db5..a2c0f578c1 100644
--- a/arch/arm/src/s32k1xx/Kconfig
+++ b/arch/arm/src/s32k1xx/Kconfig
@@ -200,6 +200,7 @@ menu "S32K1XX Peripheral Selection"
 config S32K1XX_EDMA
 	bool "eDMA"
 	default n
+	select ARCH_DMA
 
 config S32K1XX_ENET
 	bool "Ethernet"
@@ -634,12 +635,102 @@ config S32K1XX_LPSPI_DWORD
 	bool "DWORD up to 64 bit transfer support"
 	default n
 
+config S32K1XX_LPSPI_DMA
+	bool "SPI DMA"
+	depends on S32K1XX_EDMA
+	default n
+	---help---
+		Use DMA to improve SPI transfer performance.
+
+config S32K1XX_LPSPI0_DMA
+	bool "LPSPI0 DMA"
+	default n
+	depends on S32K1XX_LPSPI0 && S32K1XX_LPSPI_DMA
+	---help---
+		Use DMA to improve LPSPI0 transfer performance.
+
+config S32K1XX_LPSPI1_DMA
+	bool "LPSPI1 DMA"
+	default n
+	depends on S32K1XX_LPSPI1 && S32K1XX_LPSPI_DMA
+	---help---
+		Use DMA to improve LPSPI1 transfer performance.
+
+config S32K1XX_LPSPI2_DMA
+	bool "LPSPI2 DMA"
+	default n
+	depends on S32K1XX_LPSPI2 && S32K1XX_LPSPI_DMA
+	---help---
+		Use DMA to improve LPSPI2 transfer performance.
+
+config S32K1XX_LPSPI_DMATHRESHOLD
+	int "SPI DMA threshold"
+	default 4
+	depends on S32K1XX_LPSPI_DMA
+	---help---
+		When SPI DMA is enabled, small DMA transfers will still be performed
+		by polling logic.  But we need a threshold value to determine what
+		is small.
+
+
 config S32K1XX_LPSPI_HWPCS
 	bool "Use native hardware peripheral chip selects instead of GPIO pins"
 	default n
 	
 endmenu # LPSPI Configuration
 
+menu "LPI2C Configuration"
+	depends on S32K1XX_LPI2C
+
+config S32K1XX_LPI2C_DMA
+	bool "I2C DMA Support"
+	default n
+	depends on S32K1XX_LPI2C && S32K1XX_EDMA && !I2C_POLLED
+	---help---
+		This option enables the DMA for I2C transfers.
+		Note: The user can define CONFIG_I2C_DMAPRIO: a custom priority value
+		for the I2C dma streams, else the default priority level is set to
+		medium.
+
+config S32K1XX_LPI2C_DMA_MAXMSG
+	int "Maximum number messages that will be DMAed"
+	default 8
+	depends on S32K1XX_LPI2C_DMA
+	---help---
+		This option set the mumber of mesg that can be in a transfer.
+		It is used to allocate space for the 16 bit LPI2C commands
+		that will be DMA-ed to the LPI2C device.
+
+config S32K1XX_LPI2C_DYNTIMEO
+	bool "Use dynamic timeouts"
+	default n
+	depends on S32K1XX_LPI2C
+
+config S32K1XX_LPI2C_DYNTIMEO_USECPERBYTE
+	int "Timeout Microseconds per Byte"
+	default 500
+	depends on S32K1XX_LPI2C_DYNTIMEO
+
+config S32K1XX_LPI2C_DYNTIMEO_STARTSTOP
+	int "Timeout for Start/Stop (Milliseconds)"
+	default 1000
+	depends on S32K1XX_LPI2C_DYNTIMEO
+
+config S32K1XX_LPI2C_TIMEOSEC
+	int "Timeout seconds"
+	default 0
+	depends on S32K1XX_LPI2C
+
+config S32K1XX_LPI2C_TIMEOMS
+	int "Timeout Milliseconds"
+	default 500
+	depends on S32K1XX_LPI2C && !S32K1XX_LPI2C_DYNTIMEO
+
+config S32K1XX_LPI2C_TIMEOTICKS
+	int "Timeout for Done and Stop (ticks)"
+	default 500
+	depends on S32K1XX_LPI2C && !S32K1XX_LPI2C_DYNTIMEO
+
 menu "LPI2C0 Master Configuration"
 	depends on S32K1XX_LPI2C0
 
@@ -647,6 +738,11 @@ config LPI2C0_BUSYIDLE
 	int "Bus idle timeout period in clock cycles"
 	default 0
 
+config LPI2C0_DMA
+	bool "Enable DMA for I2C0"
+	default n
+	depends on S32K1XX_LPI2C_DMA
+
 config LPI2C0_FILTSCL
 	int "I2C master digital glitch filters for SCL input in clock cycles"
 	default 0
@@ -677,6 +773,11 @@ endmenu # LPI2C0 Slave Configuration
 menu "LPI2C1 Master Configuration"
 	depends on S32K1XX_LPI2C1
 
+config LPI2C1_DMA
+	bool "Enable DMA for I2C1"
+	default n
+	depends on S32K1XX_LPI2C_DMA
+
 config LPI2C1_BUSYIDLE
 	int "Bus idle timeout period in clock cycles"
 	default 0
@@ -707,6 +808,23 @@ config LPI2C1_SLAVE_BUS
 		the LPI2C master.  These pins need to be defined in the board.h.
 
 endmenu # LPI2C1 Slave Configuration
+endmenu # LPI2C Configuration
+
+menu "LPUART Configuration"
+comment "LP Uart Driver Configuration"
+
+
+config S32K1XX_LPUART_RXDMA_BUFFER_SIZE
+	int "Rx DMA buffer size"
+	default 64
+	depends on LPUART0_RXDMA || LPUART1_RXDMA || LPUART2_RXDMA
+	---help---
+		The DMA buffer size when using RX DMA to emulate a FIFO.
+
+		When streaming data, the generic serial layer will be called
+		every time the FIFO receives half this number of bytes.
+
+endmenu # LPUART Configuration
 
 menu "Ethernet Configuration"
 	depends on S32K1XX_ENET
diff --git a/arch/arm/src/s32k1xx/hardware/s32k14x_dmamux.h b/arch/arm/src/s32k1xx/hardware/s32k14x_dmamux.h
new file mode 100644
index 0000000000..d4dab6eeba
--- /dev/null
+++ b/arch/arm/src/s32k1xx/hardware/s32k14x_dmamux.h
@@ -0,0 +1,86 @@
+/****************************************************************************
+ * arch/arm/src/s32k1xx/hardware/s32k14x_dmamux.h
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.  The
+ * ASF licenses this file to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ *
+ ****************************************************************************/
+
+#ifndef __ARCH_ARM_SRC_S32K1XX_HARDWARE_S32K14X_DMAMUX_H
+#define __ARCH_ARM_SRC_S32K1XX_HARDWARE_S32K14X_DMAMUX_H
+
+/****************************************************************************
+ * Pre-processor Definitions
+ ****************************************************************************/
+
+/* Peripheral DMA request channels */
+
+#define S32K1XX_DMACHAN_DISABLED                   0  /* Disabled DMA Request */
+#define S32K1XX_DMACHAN_LPUART0_RX                 2  /* lpuart0  Receive DMA Request */
+#define S32K1XX_DMACHAN_LPUART0_TX                 3  /* lpuart0  Transmit DMA Request */
+#define S32K1XX_DMACHAN_LPUART1_RX                 4  /* lpuart1  Receive DMA Request */
+#define S32K1XX_DMACHAN_LPUART1_TX                 5  /* lpuart1  Transmit DMA Request */
+#define S32K1XX_DMACHAN_LPUART2_RX                 6  /* lpuart2  Receive DMA Request */
+#define S32K1XX_DMACHAN_LPUART2_TX                 7  /* lpuart2  Transmit DMA Request */
+#define S32K1XX_DMACHAN_FLEXIO_SHIFTER0            10 /* flexio FlexIO Shifter0 DMA Request */
+#define S32K1XX_DMACHAN_FLEXIO_SHIFTER1            11 /* flexio FlexIO Shifter1 DMA Request */
+#define S32K1XX_DMACHAN_FLEXIO_SHIFTER2            12 /* flexio / SAI1  FlexIO Shifter2 DMA Request / SAI1 DMA RX Request */
+#define S32K1XX_DMACHAN_FLEXIO_SHIFTER3            13 /* flexio / SAI1  FlexIO Shifter3 DMA Request / SAI1 DMA TX Request */
+#define S32K1XX_DMACHAN_LPSPI0_RX                  14 /* lpspi0 DMA RX Request */
+#define S32K1XX_DMACHAN_LPSPI0_TX                  15 /* lpspi0 DMA TX Request */
+#define S32K1XX_DMACHAN_LPSPI1_RX                  16 /* lpspi1 DMA RX Request */
+#define S32K1XX_DMACHAN_LPSPI1_TX                  17 /* lpspi1 DMA TX Request */
+#define S32K1XX_DMACHAN_LPSPI2_RX                  18 /* lpspi2 DMA RX Request */
+#define S32K1XX_DMACHAN_LPSPI2_TX                  19 /* lpspi2 DMA TX Request */
+#define S32K1XX_DMACHAN_FTM1_CHANNEL_0             20 /* ftm1 Channel 0 DMA transfer request */
+#define S32K1XX_DMACHAN_FTM1_CHANNEL_1             21 /* ftm1 Channel 1 DMA transfer request */
+#define S32K1XX_DMACHAN_FTM1_CHANNEL_2             22 /* ftm1 Channel 2 DMA transfer request */
+#define S32K1XX_DMACHAN_FTM1_CHANNEL_3             23 /* ftm1 Channel 3 DMA transfer request */
+#define S32K1XX_DMACHAN_FTM1_CHANNEL_4             24 /* ftm1 Channel 4 DMA transfer request */
+#define S32K1XX_DMACHAN_FTM1_CHANNEL_5             25 /* ftm1 Channel 5 DMA transfer request */
+#define S32K1XX_DMACHAN_FTM1_CHANNEL_6             26 /* ftm1 Channel 6 DMA transfer request */
+#define S32K1XX_DMACHAN_FTM1_CHANNEL_7             27 /* ftm1 Channel 7 DMA transfer request */
+#define S32K1XX_DMACHAN_FTM2_CHANNEL_0             28 /* ftm2 Channel 0 DMA transfer request */
+#define S32K1XX_DMACHAN_FTM2_CHANNEL_1             29 /* ftm2 Channel 1 DMA transfer request */
+#define S32K1XX_DMACHAN_FTM2_CHANNEL_2             30 /* ftm2 Channel 2 DMA transfer request */
+#define S32K1XX_DMACHAN_FTM2_CHANNEL_3             31 /* ftm2 Channel 3 DMA transfer request */
+#define S32K1XX_DMACHAN_FTM2_CHANNEL_4             32 /* ftm2 Channel 4 DMA transfer request */
+#define S32K1XX_DMACHAN_FTM2_CHANNEL_5             33 /* ftm2 Channel 5 DMA transfer request */
+#define S32K1XX_DMACHAN_FTM2_CHANNEL_6             34 /* ftm2 Channel 6 DMA transfer request */
+#define S32K1XX_DMACHAN_FTM2_CHANNEL_7             35 /* ftm2 Channel 7 DMA transfer request */
+#define S32K1XX_DMACHAN_FTM0_OR_CH0_CH7            36 /* ftm0 'OR' of FTM0 channel 0 - 7 */
+#define S32K1XX_DMACHAN_FTM3_OR_CH0_CH7            37 /* ftm3 'OR' of FTM3 channel 0 - 7 */
+#define S32K1XX_DMACHAN_FTM4_OR_CH0_CH7            38 /* ftm4 'OR' of FTM4 channel 0 - 7 */
+#define S32K1XX_DMACHAN_FTM5_OR_CH0_CH7            39 /* ftm5 'OR' of FTM5 channel 0 - 7 */
+#define S32K1XX_DMACHAN_ADC0                       42 /* ftm6 'OR' of FTM6 channel 0 - 7 */
+#define S32K1XX_DMACHAN_ADC1                       43 /* ftm7 'OR' of FTM7 channel 0 - 7 */
+#define S32K1XX_DMACHAN_LPI2C0_RX                  44 /* lpi2c0 DMA RX Request */
+#define S32K1XX_DMACHAN_LPI2C0_TX                  45 /* lpi2c0 DMA TX Request */
+#define S32K1XX_DMACHAN_PDB0                       46 /* pdb0 DMA request */
+#define S32K1XX_DMACHAN_PDB1                       47 /* pdb1 DMA request */
+#define S32K1XX_DMACHAN_CMP0                       48 /* cmp0 DMA request */
+#define S32K1XX_DMACHAN_PORTA                      49 /* PORT PORTA DMA request */
+#define S32K1XX_DMACHAN_PORTB                      50 /* PORT PORTB DMA request */
+#define S32K1XX_DMACHAN_PORTC                      51 /* PORT PORTC DMA request */
+#define S32K1XX_DMACHAN_PORTD                      52 /* PORT PORTD DMA request */
+#define S32K1XX_DMACHAN_PORTE                      53 /* PORT PORTE DMA request */
+#define S32K1XX_DMACHAN_FLEXCAN0                   54 /* flexcan0 DMA request */
+#define S32K1XX_DMACHAN_FLEXCAN1                   55 /* flexcan1 DMA request */
+#define S32K1XX_DMACHAN_FLEXCAN2                   56 /* flexcan2 DMA request */
+#define S32K1XX_DMACHAN_LPTMR0                     59 /* lptmr0 LPTIMER DMA request */
+#define S32K1XX_DMACHAN_DMAMUX_ALWAYS_ENABLED0     62 /* Always On DMA request */
+#define S32K1XX_DMACHAN_DMAMUX_ALWAYS_ENABLED1     63 /* Always On DMA request */
+
+#endif /* __ARCH_ARM_SRC_S32K1XX_HARDWARE_S32K14X_DMAMUX_H */
diff --git a/arch/arm/src/s32k1xx/hardware/s32k1xx_dmamux.h b/arch/arm/src/s32k1xx/hardware/s32k1xx_dmamux.h
index 577bb2d0e8..3e97643b3e 100644
--- a/arch/arm/src/s32k1xx/hardware/s32k1xx_dmamux.h
+++ b/arch/arm/src/s32k1xx/hardware/s32k1xx_dmamux.h
@@ -28,6 +28,12 @@
 #include <nuttx/config.h>
 #include <hardware/s32k1xx_memorymap.h>
 
+#if defined(CONFIG_ARCH_CHIP_S32K11X)
+#  include <hardware/s32k11x_dmamux.h>
+#elif defined(CONFIG_ARCH_CHIP_S32K14X)
+#  include <hardware/s32k14x_dmamux.h>
+#endif
+
 /****************************************************************************
  * Pre-processor Definitions
  ****************************************************************************/
@@ -36,7 +42,7 @@
 
 #if defined(CONFIG_ARCH_CHIP_S32K11X)
 #  define S32K1XX_NDMACH  4
-#elif defined(CONFIG_ARCH_CHIP_S32K14X
+#elif defined(CONFIG_ARCH_CHIP_S32K14X)
 #  define S32K1XX_NDMACH  16
 #endif
 
@@ -46,7 +52,7 @@
 
 /* DMAMUX Register Addresses ************************************************/
 
-#define S32K1XX_DMAMUX_CHCFG(n)         (S32K1XX_DMAMUX_BASE + S32K1XX_DMAMUX_CHCFG_OFFSET(n)) n=1..15 */
+#define S32K1XX_DMAMUX_CHCFG(n)         (S32K1XX_DMAMUX_BASE + S32K1XX_DMAMUX_CHCFG_OFFSET(n)) /* n=1..15 */
 
 /* DMAMUX Register Bitfield Definitions *************************************/
 
diff --git a/arch/arm/src/s32k1xx/hardware/s32k1xx_edma.h b/arch/arm/src/s32k1xx/hardware/s32k1xx_edma.h
index 1d8604584c..ff9bad7d4f 100644
--- a/arch/arm/src/s32k1xx/hardware/s32k1xx_edma.h
+++ b/arch/arm/src/s32k1xx/hardware/s32k1xx_edma.h
@@ -34,7 +34,7 @@
 
 #if defined(CONFIG_ARCH_CHIP_S32K11X)
 #  define S32K1XX_EDMA_NCHANNELS              4
-#elif defined(CONFIG_ARCH_CHIP_S32K14x)
+#elif defined(CONFIG_ARCH_CHIP_S32K14X)
 #  define S32K1XX_EDMA_NCHANNELS              16
 #else
 #  error "Unknown number of DMA channels for this S32K1xx part"
@@ -837,8 +837,8 @@
  * Public Types
  ****************************************************************************/
 
-/* In-memory representation of the 32-byte Transfer Control Descriptor
- * (TCD)
+/* Hardware representation of the 32-byte Transfer
+ * Control Descriptor (TCD)
  */
 
 struct s32k1xx_edmatcd_s
diff --git a/arch/arm/src/s32k1xx/hardware/s32k1xx_lpi2c.h b/arch/arm/src/s32k1xx/hardware/s32k1xx_lpi2c.h
index b9740b7ccc..dbdc70255a 100644
--- a/arch/arm/src/s32k1xx/hardware/s32k1xx_lpi2c.h
+++ b/arch/arm/src/s32k1xx/hardware/s32k1xx_lpi2c.h
@@ -239,7 +239,7 @@
 /* LPI2C Master Config Register 1  */
 
 #define LPI2C_MCFGR1_PRESCALE_MASK          (7 << 0)  /* Clock Prescaler Bit Mask */
-#  define LPI2C_MCFGR1_PRESCALE(n)          (n & LPI2C_MCFGR1_PRESCALE_MASK)
+#  define LPI2C_MCFGR1_PRESCALE(n)          ((n) & LPI2C_MCFGR1_PRESCALE_MASK)
 #  define LPI2C_MCFGR1_PRESCALE_1           (0)
 #  define LPI2C_MCFGR1_PRESCALE_2           (1)
 #  define LPI2C_MCFGR1_PRESCALE_4           (2)
@@ -254,7 +254,7 @@
                                                       /* Bits 15-11 Reserved */
 #define LPI2C_MCFGR1_MATCFG_SHIFT           (16)
 #define LPI2C_MCFGR1_MATCFG_MASK            (7 << LPI2C_MCFGR1_MATCFG_SHIFT)  /* Match Configuration Bit Mask */
-#  define LPI2C_MCFGR1_MATCFG(n)            ((n << LPI2C_MCFGR1_MATCFG_SHIFT) & LPI2C_MCFGR1_MATCFG_MASK)
+#  define LPI2C_MCFGR1_MATCFG(n)            (((n) << LPI2C_MCFGR1_MATCFG_SHIFT) & LPI2C_MCFGR1_MATCFG_MASK)
 #  define LPI2C_MCFGR1_MATCFG_DISABLE       (0 << LPI2C_MCFGR1_MATCFG_SHIFT)
                                                      /* LPI2C_MCFG1_MATCFG = 001b Reserved */
 #  define LPI2C_MCFGR1_MATCFG2              (2 << LPI2C_MCFGR1_MATCFG_SHIFT)
@@ -266,7 +266,7 @@
                                                     /* Bits 23-19 Reserved */
 #define LPI2C_MCFGR1_PINCFG_SHIFT           (24)
 #define LPI2C_MCFGR1_PINCFG_MASK            (7 << LPI2C_MCFGR1_PINCFG_SHIFT)  /* Pin Configuration Bit Mask */
-#  define LPI2C_MCFGR1_PINCFG(n)            ((n << LPI2C_MCFGR1_PINCFG_SHIFT) & LPI2C_MCFGR1_PINCFG_MASK)
+#  define LPI2C_MCFGR1_PINCFG(n)            (((n) << LPI2C_MCFGR1_PINCFG_SHIFT) & LPI2C_MCFGR1_PINCFG_MASK)
 #  define LPI2C_MCFGR1_PINCFG0              (0 << LPI2C_MCFGR1_PINCFG_SHIFT)
 #  define LPI2C_MCFGR1_PINCFG1              (1 << LPI2C_MCFGR1_PINCFG_SHIFT)
 #  define LPI2C_MCFGR1_PINCFG2              (2 << LPI2C_MCFGR1_PINCFG_SHIFT)
@@ -281,17 +281,17 @@
 
 #define LPI2C_MCFG2_BUSIDLE_MASK            (0xfff << 0)  /* Bus Idle Timeout Period in Clock Cycles */
 #define LPI2C_MCFG2_BUSIDLE_DISABLE         (0)
-#  define LPI2C_MCFG2_BUSIDLE(n)            (n & LPI2C_MCFG2_BUSIDLE_MASK)
+#  define LPI2C_MCFG2_BUSIDLE(n)            ((n) & LPI2C_MCFG2_BUSIDLE_MASK)
                                                      /* Bits 15-12 Reserved */
 #define LPI2C_MCFG2_FILTSCL_SHIFT           (16)
 #define LPI2C_MCFG2_FILTSCL_MASK            (15 << LPI2C_MCFG2_FILTSCL_SHIFT)  /* Glitch Filter SCL */
 #define LPI2C_MCFG2_FILTSCL_DISABLE         (0 << LPI2C_MCFG2_FILTSCL_SHIFT)
-#  define LPI2C_MCFG2_FILTSCL_CYCLES(n)     ((n << LPI2C_MCFG2_FILTSCL_SHIFT) & LPI2C_MCFG2_FILTSCL_MASK)
+#  define LPI2C_MCFG2_FILTSCL_CYCLES(n)     (((n) << LPI2C_MCFG2_FILTSCL_SHIFT) & LPI2C_MCFG2_FILTSCL_MASK)
                                                      /* Bits 23-20 Reserved */
 #define LPI2C_MCFG2_FILTSDA_SHIFT           (24)
 #define LPI2C_MCFG2_FILTSDA_MASK            (15 << LPI2C_MCFG2_FILTSDA_SHIFT)  /* Glitch Filter SDA */
 #define LPI2C_MCFG2_FILTSDA_DISABLE         (0 << LPI2C_MCFG2_FILTSDA_SHIFT)
-#  define LPI2C_MCFG2_FILTSDA_CYCLES(n)     ((n << LPI2C_MCFG2_FILTSDA_SHIFT) & LPI2C_MCFG2_FILTSDA_MASK)
+#  define LPI2C_MCFG2_FILTSDA_CYCLES(n)     (((n) << LPI2C_MCFG2_FILTSDA_SHIFT) & LPI2C_MCFG2_FILTSDA_MASK)
                                                      /* Bits 31-28 Reserved */
 
 /* LPI2C Master Config Register 3  */
@@ -299,56 +299,56 @@
                                                      /* Bits 7-0 Reserved */
 #define LPI2C_MCFG3_PINLOW_SHIFT            (8)
 #define LPI2C_MCFG3_PINLOW_MASK             (0xfff << LPI2C_MCFG3_PINLOW_SHIFT)  /* Configure The Pin Low Timeout in Clock Cycles */
-#  define LPI2C_MCFG3_PINLOW_CYCLES(n)      ((n << LPI2C_MCFG3_PINLOW_SHIFT) & LPI2C_MCFG3_PINLOW_MASK)
+#  define LPI2C_MCFG3_PINLOW_CYCLES(n)      (((n) << LPI2C_MCFG3_PINLOW_SHIFT) & LPI2C_MCFG3_PINLOW_MASK)
                                                      /* Bits 31-20 Reserved */
 
 /* LPI2C Master Data Match Register  */
 
 #define LPI2C_MDMR_MATCH0_SHIFT             (0)
 #define LPI2C_MDMR_MATCH0_MASK              (0xff << LPI2C_MDMR_MATCH0_SHIFT)  /* Match 0 Value */
-#  define LPI2C_MDMR_MATCH0(n)              ((n << LPI2C_MDMR_MATCH0_SHIFT) & LPI2C_MDMR_MATCH0_MASK)
+#  define LPI2C_MDMR_MATCH0(n)              (((n) << LPI2C_MDMR_MATCH0_SHIFT) & LPI2C_MDMR_MATCH0_MASK)
                                                      /* Bits 15-8 Reserved */
 #define LPI2C_MDMR_MATCH1_SHIFT             (16)
 #define LPI2C_MDMR_MATCH1_MASK              (0xff << LPI2C_MDMR_MATCH1_SHIFT)  /* Match 1 Value */
-#  define LPI2C_MDMR_MATCH1(n)              ((n << LPI2C_MDMR_MATCH1_SHIFT) & LPI2C_MDMR_MATCH1_MASK)
+#  define LPI2C_MDMR_MATCH1(n)              (((n) << LPI2C_MDMR_MATCH1_SHIFT) & LPI2C_MDMR_MATCH1_MASK)
                                                      /* Bits 31-24 Reserved */
 
 /* LPI2C Master Clock Configuration Register 0 */
 
 #define LPI2C_MCCR0_CLKLO_SHIFT             (0)
 #define LPI2C_MCCR0_CLKLO_MASK              (0x3f << LPI2C_MCCR0_CLKLO_SHIFT)  /* Clock Low Period */
-#  define LPI2C_MCCR0_CLKLO(n)              ((n << LPI2C_MCCR0_CLKLO_SHIFT) & LPI2C_MCCR0_CLKLO_MASK)
+#  define LPI2C_MCCR0_CLKLO(n)              (((n) << LPI2C_MCCR0_CLKLO_SHIFT) & LPI2C_MCCR0_CLKLO_MASK)
                                                      /* Bits 7-6 Reserved */
 #define LPI2C_MCCR0_CLKHI_SHIFT             (8)
 #define LPI2C_MCCR0_CLKHI_MASK              (0x3f << LPI2C_MCCR0_CLKHI_SHIFT)  /* Clock High Period */
-#  define LPI2C_MCCR0_CLKHI(n)              ((n << LPI2C_MCCR0_CLKHI_SHIFT) & LPI2C_MCCR0_CLKHI_MASK)
+#  define LPI2C_MCCR0_CLKHI(n)              (((n) << LPI2C_MCCR0_CLKHI_SHIFT) & LPI2C_MCCR0_CLKHI_MASK)
                                                      /* Bits 15-14 Reserved */
 #define LPI2C_MCCR0_SETHOLD_SHIFT           (16)
 #define LPI2C_MCCR0_SETHOLD_MASK            (0x3f << LPI2C_MCCR0_SETHOLD_SHIFT)  /* Setup Hold Delay */
-#  define LPI2C_MCCR0_SETHOLD(n)            ((n << LPI2C_MCCR0_SETHOLD_SHIFT) & LPI2C_MCCR0_SETHOLD_MASK)
+#  define LPI2C_MCCR0_SETHOLD(n)            (((n) << LPI2C_MCCR0_SETHOLD_SHIFT) & LPI2C_MCCR0_SETHOLD_MASK)
                                                      /* Bits 23-22 Reserved */
 #define LPI2C_MCCR0_DATAVD_SHIFT            (24)
 #define LPI2C_MCCR0_DATAVD_MASK             (0x3f << LPI2C_MCCR0_DATAVD_SHIFT)  /* Setup Hold Delay */
-#  define LPI2C_MCCR0_DATAVD(n)             ((n << LPI2C_MCCR0_DATAVD_SHIFT) & LPI2C_MCCR0_DATAVD_MASK)
+#  define LPI2C_MCCR0_DATAVD(n)             (((n) << LPI2C_MCCR0_DATAVD_SHIFT) & LPI2C_MCCR0_DATAVD_MASK)
                                                      /* Bits 31-30 Reserved */
 
 /* LPI2C Master Clock Configuration Register 1 */
 
 #define LPI2C_MCCR1_CLKLO_SHIFT             (0)
 #define LPI2C_MCCR1_CLKLO_MASK              (0x3f << LPI2C_MCCR1_CLKLO_SHIFT)  /* Clock Low Period */
-#  define LPI2C_MCCR1_CLKLO(n)              ((n << LPI2C_MCCR1_CLKLO_SHIFT) & LPI2C_MCCR1_CLKLO_MASK)
+#  define LPI2C_MCCR1_CLKLO(n)              (((n) << LPI2C_MCCR1_CLKLO_SHIFT) & LPI2C_MCCR1_CLKLO_MASK)
                                                      /* Bits 7-6 Reserved */
 #define LPI2C_MCCR1_CLKHI_SHIFT             (8)
 #define LPI2C_MCCR1_CLKHI_MASK              (0x3f << LPI2C_MCCR1_CLKHI_SHIFT)  /* Clock High Period */
-#  define LPI2C_MCCR1_CLKHI(n)              ((n << LPI2C_MCCR1_CLKHI_SHIFT) & LPI2C_MCCR1_CLKHI_MASK)
+#  define LPI2C_MCCR1_CLKHI(n)              (((n) << LPI2C_MCCR1_CLKHI_SHIFT) & LPI2C_MCCR1_CLKHI_MASK)
                                                      /* Bits 15-14 Reserved */
 #define LPI2C_MCCR1_SETHOLD_SHIFT           (16)
 #define LPI2C_MCCR1_SETHOLD_MASK            (0x3f << LPI2C_MCCR1_SETHOLD_SHIFT)  /* Setup Hold Delay */
-#  define LPI2C_MCCR1_SETHOLD(n)            ((n << LPI2C_MCCR1_SETHOLD_SHIFT) & LPI2C_MCCR1_SETHOLD_MASK)
+#  define LPI2C_MCCR1_SETHOLD(n)            (((n) << LPI2C_MCCR1_SETHOLD_SHIFT) & LPI2C_MCCR1_SETHOLD_MASK)
                                                      /* Bits 23-22 Reserved */
 #define LPI2C_MCCR1_DATAVD_SHIFT            (24)
 #define LPI2C_MCCR1_DATAVD_MASK             (0x3f << LPI2C_MCCR1_DATAVD_SHIFT)  /* Setup Hold Delay */
-#  define LPI2C_MCCR1_DATAVD(n)             ((n << LPI2C_MCCR1_DATAVD_SHIFT) & LPI2C_MCCR1_DATAVD_MASK)
+#  define LPI2C_MCCR1_DATAVD(n)             (((n) << LPI2C_MCCR1_DATAVD_SHIFT) & LPI2C_MCCR1_DATAVD_MASK)
                                                      /* Bits 31-30 Reserved */
 
 /* LPI2C Master FIFO Control Register */
@@ -356,13 +356,13 @@
 #define LPI2C_MFCR_TXWATER_SHIFT            (0)
 #define LPI2C_MFCR_TXWATER_MASK             (3 << LPI2C_MFCR_TXWATER_SHIFT)  /* Transmit FIFO Watermark*/
 
-#  define LPI2C_MFCR_TXWATER(n)             ((n << LPI2C_MFCR_TXWATER_SHIFT) &  LPI2C_MFCR_TXWATER_MASK)  /* Transmit FIFO Watermark*/
+#  define LPI2C_MFCR_TXWATER(n)             (((n) << LPI2C_MFCR_TXWATER_SHIFT) &  LPI2C_MFCR_TXWATER_MASK)  /* Transmit FIFO Watermark*/
 
                                                      /* Bits 15-2 Reserved */
 #define LPI2C_MFCR_RXWATER_SHIFT            (16)
 #define LPI2C_MFCR_RXWATER_MASK             (3 << LPI2C_MFCR_RXWATER_SHIFT)  /* Receive FIFO Watermark */
 
-#  define LPI2C_MFCR_RXWATER(n)             ((n << LPI2C_MFCR_RXWATER_SHIFT) &  LPI2C_MFCR_RXWATER_MASK)  /* Transmit FIFO Watermark*/
+#  define LPI2C_MFCR_RXWATER(n)             (((n) << LPI2C_MFCR_RXWATER_SHIFT) &  LPI2C_MFCR_RXWATER_MASK)  /* Transmit FIFO Watermark*/
 
                                                      /* Bits 31-18 Reserved */
 
@@ -381,10 +381,10 @@
 
 #define LPI2C_MTDR_DATA_SHIFT               (0)
 #define LPI2C_MTDR_DATA_MASK                (0xff << LPI2C_MTDR_DATA_SHIFT)  /* Transmit Data */
-#  define LPI2C_MTDR_DATA(n)                (n & LPI2C_MTDR_DATA_MASK)
+#  define LPI2C_MTDR_DATA(n)                ((n) & LPI2C_MTDR_DATA_MASK)
 #define LPI2C_MTDR_CMD_SHIFT                (8)
 #define LPI2C_MTDR_CMD_MASK                 (7 << LPI2C_MTDR_CMD_SHIFT)  /* Command Data */
-#  define LPI2C_MTDR_CMD(n)                 ((n << LPI2C_MTDR_CMD_SHIFT) & LPI2C_MTDR_CMD_MASK)
+#  define LPI2C_MTDR_CMD(n)                 (((n) << LPI2C_MTDR_CMD_SHIFT) & LPI2C_MTDR_CMD_MASK)
 #  define LPI2C_MTDR_CMD_TXD                (0 << LPI2C_MTDR_CMD_SHIFT)
 #  define LPI2C_MTDR_CMD_RXD                (1 << LPI2C_MTDR_CMD_SHIFT)
 #  define LPI2C_MTDR_CMD_STOP               (2 << LPI2C_MTDR_CMD_SHIFT)
@@ -478,7 +478,7 @@
                                                       /* Bits 15-14 Reserved */
 #define LPI2C_SCFG1_ADDRCFG_SHIFT           (16)
 #define LPI2C_SCFG1_ADDRCFG_MASK            (7 << LPI2C_SCFG1_ADDRCFG_SHIFT)  /* Address Configuration Bit Mask */
-#  define LPI2C_SCFG1_ADDRCFG(n)            ((n << LPI2C_SCFG1_ADDRCFG_SHIFT) & LPI2C_SCFG1_ADDRCFG_MASK)
+#  define LPI2C_SCFG1_ADDRCFG(n)            (((n) << LPI2C_SCFG1_ADDRCFG_SHIFT) & LPI2C_SCFG1_ADDRCFG_MASK)
 #  define LPI2C_SCFG1_ADDRCFG0              (0 << LPI2C_SCFG1_ADDRCFG_SHIFT)
 #  define LPI2C_SCFG1_ADDRCFG1              (2 << LPI2C_SCFG1_ADDRCFG_SHIFT)
 #  define LPI2C_SCFG1_ADDRCFG2              (2 << LPI2C_SCFG1_ADDRCFG_SHIFT)
@@ -492,21 +492,21 @@
 /* LPI2C Slave Configuration Register 2  */
 
 #define LPI2C_SCFG2_CLKHOLD_MASK            (15 << 0) /* Clock Hold Time */
-#  define LPI2C_SCFG2_CLKHOLD(n)            (n & LPI2C_SCFG2_CLKHOLD_MASK)
+#  define LPI2C_SCFG2_CLKHOLD(n)            ((n) & LPI2C_SCFG2_CLKHOLD_MASK)
                                                       /* Bits 7-4 Reserved */
 #define LPI2C_SCFG2_DATAVD_SHIFT            (8)
 #define LPI2C_SCFG2_DATAVD_MASK             (0x3f << LPI2C_SCFG2_DATAVD_SHIFT)  /* Data Valid Delay */
-#  define LPI2C_SCFG2_DATAVD(n)             ((n << LPI2C_SCFG2_DATAVD_SHIFT) & LPI2C_SCFG2_DATAVD_MASK)
+#  define LPI2C_SCFG2_DATAVD(n)             (((n) << LPI2C_SCFG2_DATAVD_SHIFT) & LPI2C_SCFG2_DATAVD_MASK)
                                                       /* Bits 15-14 Reserved */
 #define LPI2C_SCFG2_FILTSCL_SHIFT           (16)
 #define LPI2C_SCFG2_FILTSCL_MASK            (15 << LPI2C_SCFG2_FILTSCL_SHIFT)  /* Glitch Filter SCL */
 #define LPI2C_SCFG2_FILTSCL_DISABLE         (0 << LPI2C_SCFG2_FILTSCL_SHIFT)
-#  define LPI2C_SCFG2_FILTSCL_CYCLES(n)     ((n << LPI2C_SCFG2_FILTSCL_SHIFT) & LPI2C_SCFG2_FILTSCL_MASK)
+#  define LPI2C_SCFG2_FILTSCL_CYCLES(n)     (((n) << LPI2C_SCFG2_FILTSCL_SHIFT) & LPI2C_SCFG2_FILTSCL_MASK)
                                                       /* Bits 23-20 Reserved */
 #define LPI2C_SCFG2_FILTSDA_SHIFT           (24)
 #define LPI2C_SCFG2_FILTSDA_MASK            (15 << LPI2C_SCFG2_FILTSDA_SHIFT)  /* Glitch Filter SDA */
 #define LPI2C_SCFG2_FILTSDA_DISABLE         (0 << LPI2C_SCFG2_FILTSDA_SHIFT)
-#  define LPI2C_SCFG2_FILTSDA_CYCLES(n)     ((n << LPI2C_SCFG2_FILTSDA_SHIFT) & LPI2C_SCFG2_FILTSDA_MASK)
+#  define LPI2C_SCFG2_FILTSDA_CYCLES(n)     (((n) << LPI2C_SCFG2_FILTSDA_SHIFT) & LPI2C_SCFG2_FILTSDA_MASK)
                                                       /* Bits 31-28 Reserved */
 
 /* LPI2C Slave Address Match Register  */
@@ -514,11 +514,11 @@
                                                       /* Bit 0 Reserved */
 #define LPI2C_SAMR_ADDR0_SHIFT              (1)
 #define LPI2C_SAMR_ADDR0_MASK               (0x3ff << LPI2C_SAMR_ADDR0_SHIFT)  /* Address 0 Value */
-#  define LPI2C_SAMR_ADDR0(n)               ((n << LPI2C_SAMR_ADDR0_SHIFT) & LPI2C_SAMR_ADDR0_MASK)
+#  define LPI2C_SAMR_ADDR0(n)               (((n) << LPI2C_SAMR_ADDR0_SHIFT) & LPI2C_SAMR_ADDR0_MASK)
                                                       /* Bits 16-11 Reserved */
 #define LPI2C_SAMR_ADDR1_SHIFT              (17)
 #define LPI2C_SAMR_ADDR1_MASK               (0x3ff << LPI2C_SAMR_ADDR1_SHIFT)  /* Address 1 Value */
-#  define LPI2C_SAMR_ADDR1(n)               ((n << LPI2C_SAMR_ADDR1_SHIFT) & LPI2C_SAMR_ADDR1_MASK)
+#  define LPI2C_SAMR_ADDR1(n)               (((n) << LPI2C_SAMR_ADDR1_SHIFT) & LPI2C_SAMR_ADDR1_MASK)
                                                       /* Bits 31-27 Reserved */
 
 /* LPI2C Slave Address Status Register  */
@@ -538,14 +538,14 @@
 
 #define LPI2C_STDR_DATA_SHIFT               (0)
 #define LPI2C_STDR_DATA_MASK                (0xff << LPI2C_STDR_DATA_SHIFT)  /* Transmit Data */
-#  define LPI2C_STDR_DATA(n)                ((n << LPI2C_STDR_DATA_SHIFT) & LPI2C_STDR_DATA_MASK)
+#  define LPI2C_STDR_DATA(n)                (((n) << LPI2C_STDR_DATA_SHIFT) & LPI2C_STDR_DATA_MASK)
                                                       /* Bits 31-8 Reserved */
 
 /* LPI2C Slave Receive Data Register  */
 
 #define LPI2C_SRDR_DATA_SHIFT               (0)
 #define LPI2C_SRDR_DATA_MASK                (0xff << LPI2C_SRDR_DATA_SHIFT)  /* Receive Data */
-#  define LPI2C_SRDR_DATA(n)                ((n << LPI2C_SRDR_DATA_SHIFT) & LPI2C_SRDR_DATA_MASK)
+#  define LPI2C_SRDR_DATA(n)                (((n) << LPI2C_SRDR_DATA_SHIFT) & LPI2C_SRDR_DATA_MASK)
                                                       /* Bits 8-31 Reserved */
 
 #endif /* __ARCH_ARM_SRC_S32K1XX_HARDWARE_S32K1XX_LPI2C_H */
diff --git a/arch/arm/src/s32k1xx/hardware/s32k1xx_memorymap.h b/arch/arm/src/s32k1xx/hardware/s32k1xx_memorymap.h
index dc7e6f5b62..e12dec7a5a 100644
--- a/arch/arm/src/s32k1xx/hardware/s32k1xx_memorymap.h
+++ b/arch/arm/src/s32k1xx/hardware/s32k1xx_memorymap.h
@@ -34,8 +34,8 @@
 #define S32K1XX_AIPS_LITE_BASE   0x40000000  /* Peripheral bridge (AIPS-Lite) */
 #  define S32K1XX_FLASHCFG_BASE  0x40000400  /* FLASH Configuration bytes */
 #  define S32K1XX_MSCM_BASE      0x40001000  /* MSCM */
-#  define S32K1XX_DMAC_BASE      0x40008000  /* DMA controller */
-#  define S32K1XX_DMADESC_BASE   0x40008000  /* DMA transfer control descriptors */
+#  define S32K1XX_EDMA_BASE      0x40008000  /* EDMA controller */
+#  define S32K1XX_EDMADESC_BASE  0x40008000  /* EDMA transfer control descriptors */
 #  define S32K1XX_MPU_BASE       0x4000d000  /* MPU */
 #  define S32K1XX_GPIOCTL_BASE   0x4000f000  /* GPIO controller */
 #  define S32K1XX_GPIOALIAS_BASE 0x400ff000  /* GPIO controller (alias) */
diff --git a/arch/arm/src/s32k1xx/s32k1xx_clockconfig.c b/arch/arm/src/s32k1xx/s32k1xx_clockconfig.c
index 4b4be95c99..37f99dda0b 100644
--- a/arch/arm/src/s32k1xx/s32k1xx_clockconfig.c
+++ b/arch/arm/src/s32k1xx/s32k1xx_clockconfig.c
@@ -2546,13 +2546,6 @@ int s32k1xx_clockconfig(const struct clock_configuration_s *clkcfg)
 
   DEBUGASSERT(clkcfg != NULL);
 
-#ifdef CONFIG_PM
-  /* Register to receive power management callbacks */
-
-  ret = pm_register(&g_clock_pmcb);
-  DEBUGASSERT(ret == OK);
-#endif
-
   /* Set SCG configuration */
 
   ret = s32k1xx_scg_config(&clkcfg->scg);
@@ -2564,7 +2557,7 @@ int s32k1xx_clockconfig(const struct clock_configuration_s *clkcfg)
 
       /* Set PCC configuration */
 
-      s32k1xx_periphclocks(clkcfg->pcc.count, clkcfg->pcc.pclks);
+      s32k1xx_periphclocks(num_of_peripheral_clocks_0, clkcfg->pcc.pclks);
 
       /* Set SIM configuration */
 
@@ -2578,6 +2571,29 @@ int s32k1xx_clockconfig(const struct clock_configuration_s *clkcfg)
   return ret;
 }
 
+/****************************************************************************
+ * Name: s32k1xx_clock_pm_register
+ *
+ * Description:
+ *   This function is called after OS and PM init in order to register to
+ *   receive power management event callbacks.
+ *
+ * Input Parameters:
+ *   None
+ *
+ * Returned Values:
+ *   None
+ *
+ ****************************************************************************/
+#ifdef CONFIG_PM
+void s32k1xx_clock_pm_register(void)
+{
+  /* Register to receive power management callbacks */
+
+  pm_register(&g_clock_pmcb);
+}
+#endif
+
 /****************************************************************************
  * Name: s32k1xx_get_coreclk
  *
diff --git a/arch/arm/src/s32k1xx/s32k1xx_clockconfig.h b/arch/arm/src/s32k1xx/s32k1xx_clockconfig.h
index 588e79a6d5..01cd3fd470 100644
--- a/arch/arm/src/s32k1xx/s32k1xx_clockconfig.h
+++ b/arch/arm/src/s32k1xx/s32k1xx_clockconfig.h
@@ -86,6 +86,8 @@
  * Public Types
  ****************************************************************************/
 
+extern const unsigned int num_of_peripheral_clocks_0;
+
 /* Clock Configuration ******************************************************/
 
 enum scg_system_clock_type_e
@@ -412,7 +414,6 @@ struct sim_clock_config_s
 struct peripheral_clock_config_s;      /* Forward reference */
 struct pcc_config_s
 {
-  unsigned int count;                            /* Number of peripherals to be configured */
   const struct peripheral_clock_config_s *pclks; /* The peripheral clock configuration array */
 };
 
@@ -525,6 +526,24 @@ enum scg_system_clock_mode_e s32k1xx_set_runmode(enum scg_system_clock_mode_e
 
 int s32k1xx_clockconfig(const struct clock_configuration_s *clkcfg);
 
+/****************************************************************************
+ * Name: s32k1xx_clock_pm_register
+ *
+ * Description:
+ *   This function is called after OS and PM init in order to register to
+ *   receive power management event callbacks.
+ *
+ * Input Parameters:
+ *   None
+ *
+ * Returned Values:
+ *   None
+ *
+ ****************************************************************************/
+#ifdef CONFIG_PM
+void s32k1xx_clock_pm_register(void);
+#endif
+
 /****************************************************************************
  * Name: s32k1xx_get_coreclk
  *
diff --git a/arch/arm/src/s32k1xx/s32k1xx_edma.c b/arch/arm/src/s32k1xx/s32k1xx_edma.c
index 1236b5fd9a..b0fb9c070a 100644
--- a/arch/arm/src/s32k1xx/s32k1xx_edma.c
+++ b/arch/arm/src/s32k1xx/s32k1xx_edma.c
@@ -86,22 +86,16 @@
  */
 
 #ifdef CONFIG_ARMV7M_DCACHE
-/* Align to the cache line size which we assume is >= 8 */
-
-#  define EDMA_ALIGN        ARMV7M_DCACHE_LINESIZE
-#  define EDMA_ALIGN_MASK   (EDMA_ALIGN-1)
-#  define EDMA_ALIGN_UP(n)  (((n) + EDMA_ALIGN_MASK) & ~EDMA_ALIGN_MASK)
-
+#  define EDMA_ALIGN  ARMV7M_DCACHE_LINESIZE
 #else
-/* Special alignment is not required in this case,
- * but we will align to 8-bytes
- */
+/* 32 byte alignment for TCDs is required for scatter gather */
 
-#  define EDMA_ALIGN        8
-#  define EDMA_ALIGN_MASK   7
-#  define EDMA_ALIGN_UP(n)  (((n) + 7) & ~7)
+#define EDMA_ALIGN        32
 #endif
 
+#define EDMA_ALIGN_MASK   (EDMA_ALIGN - 1)
+#define EDMA_ALIGN_UP(n)  (((n) + EDMA_ALIGN_MASK) & ~EDMA_ALIGN_MASK)
+
 /****************************************************************************
  * Private Types
  ****************************************************************************/
@@ -119,10 +113,10 @@ enum s32k1xx_dmastate_e
 
 struct s32k1xx_dmach_s
 {
-  uint8_t chan;                   /* DMA channel number (0-S32K1XX_EDMA_NCHANNELS) */
-  bool inuse;                     /* true: The DMA channel is in use */
-  uint8_t ttype;                  /* Transfer type: M2M, M2P, P2M, or P2P */
-  uint8_t state;                  /* Channel state.  See enum s32k1xx_dmastate_e */
+  uint8_t  chan;                  /* DMA channel number (0-S32K1XX_EDMA_NCHANNELS) */
+  bool     inuse;                 /* true: The DMA channel is in use */
+  uint8_t  state;                 /* Channel state.  See enum s32k1xx_dmastate_e */
+  uint8_t  dmamux;                /* The DMAMUX channel selection */
   uint32_t flags;                 /* DMA channel flags */
   edma_callback_t callback;       /* Callback invoked when the DMA completes */
   void *arg;                      /* Argument passed to callback function */
@@ -338,18 +332,13 @@ static inline void s32k1xx_tcd_chanlink(uint8_t flags,
 
   if (linkch == NULL || flags == EDMA_CONFIG_LINKTYPE_LINKNONE)
     {
-#if 0 /* Already done */
       /* No link or no link channel provided */
 
-      /* Disable minor links */
-
-      tcd->citer &= ~EDMA_TCD_CITER_ELINK;
-      tcd->biter &= ~EDMA_TCD_BITER_ELINK;
+      /* Disable minor links is done in s32k1xx_tcd_configure */
 
       /* Disable major link */
 
       tcd->csr   &= ~EDMA_TCD_CSR_MAJORELINK;
-#endif
     }
   else if (flags == EDMA_CONFIG_LINKTYPE_MINORLINK) /* Minor link config */
     {
@@ -405,13 +394,18 @@ static inline void s32k1xx_tcd_configure(struct s32k1xx_edmatcd_s *tcd,
   tcd->attr     = EDMA_TCD_ATTR_SSIZE(config->ssize) |  /* Transfer Attributes */
                   EDMA_TCD_ATTR_DSIZE(config->dsize);
   tcd->nbytes   = config->nbytes;
-  tcd->slast    = tcd->slast;
+  tcd->slast    = config->flags & EDMA_CONFIG_LOOPSRC ?
+                                  -(config->iter * config->nbytes) : 0;
   tcd->daddr    = config->daddr;
   tcd->doff     = config->doff;
   tcd->citer    = config->iter & EDMA_TCD_CITER_CITER_MASK;
   tcd->biter    = config->iter & EDMA_TCD_BITER_BITER_MASK;
-  tcd->csr      = EDMA_TCD_CSR_DREQ; /* Assume last transfer */
-  tcd->dlastsga = 0;
+  tcd->csr      = config->flags & EDMA_CONFIG_LOOP_MASK ?
+                                  0 : EDMA_TCD_CSR_DREQ;
+  tcd->csr      |= config->flags & EDMA_CONFIG_INTHALF ?
+                                  EDMA_TCD_CSR_INTHALF : 0;
+  tcd->dlastsga = config->flags & EDMA_CONFIG_LOOPDEST ?
+                                  -(config->iter * config->nbytes) : 0;
 
   /* And special case flags */
 
@@ -440,6 +434,10 @@ static void s32k1xx_tcd_instantiate(struct s32k1xx_dmach_s *dmach,
 
   /* Push tcd into hardware TCD register */
 
+  /* Clear DONE bit first, otherwise ESG cannot be set */
+
+  putreg16(0,             base + S32K1XX_EDMA_TCD_CSR_OFFSET);
+
   putreg32(tcd->saddr,    base + S32K1XX_EDMA_TCD_SADDR_OFFSET);
   putreg16(tcd->soff,     base + S32K1XX_EDMA_TCD_SOFF_OFFSET);
   putreg16(tcd->attr,     base + S32K1XX_EDMA_TCD_ATTR_OFFSET);
@@ -450,9 +448,6 @@ static void s32k1xx_tcd_instantiate(struct s32k1xx_dmach_s *dmach,
   putreg16(tcd->citer,    base + S32K1XX_EDMA_TCD_CITER_ELINK_OFFSET);
   putreg32(tcd->dlastsga, base + S32K1XX_EDMA_TCD_DLASTSGA_OFFSET);
 
-  /* Clear DONE bit first, otherwise ESG cannot be set */
-
-  putreg16(0,             base + S32K1XX_EDMA_TCD_CSR_OFFSET);
   putreg16(tcd->csr,      base + S32K1XX_EDMA_TCD_CSR_OFFSET);
 
   putreg16(tcd->biter,    base + S32K1XX_EDMA_TCD_BITER_ELINK_OFFSET);
@@ -488,25 +483,25 @@ static void s32k1xx_dmaterminate(struct s32k1xx_dmach_s *dmach, int result)
   regval8         = EDMA_CERQ(chan);
   putreg8(regval8, S32K1XX_EDMA_CERQ);
 
-  /* Clear CSR to disable channel. Because if the given channel started,
-   * transfer CSR will be not zero. Because if it is the last transfer, DREQ
-   * will be set.  If not, ESG will be set.
-   */
-
   regaddr         = S32K1XX_EDMA_TCD_CSR(chan);
   putreg16(0, regaddr);
 
   /* Cancel next TCD transfer. */
 
   regaddr         = S32K1XX_EDMA_TCD_DLASTSGA(chan);
-  putreg16(0, regaddr);
+  putreg32(0, regaddr);
 
 #if CONFIG_S32K1XX_EDMA_NTCD > 0
   /* Return all allocated TCDs to the free list */
 
   for (tcd = dmach->head; tcd != NULL; tcd = next)
     {
-      next = (struct s32k1xx_edmatcd_s *)tcd->dlastsga;
+      /* If channel looped to itself we are done
+       * if not continue to free tcds in chain
+       */
+
+       next = dmach->flags & EDMA_CONFIG_LOOPDEST ?
+              NULL : (struct s32k1xx_edmatcd_s *)tcd->dlastsga;
       s32k1xx_tcd_free(tcd);
     }
 
@@ -514,15 +509,6 @@ static void s32k1xx_dmaterminate(struct s32k1xx_dmach_s *dmach, int result)
   dmach->tail = NULL;
 #endif
 
-  /* Check for an Rx (memory-to-peripheral/memory-to-memory) DMA transfer */
-
-  if (dmach->ttype == EMDA_MEM2MEM || dmach->ttype == EMDA_PERIPH2MEM)
-    {
-      /* Invalidate the cache to force reloads from memory. */
-
-#warning Missing logic
-    }
-
   /* Perform the DMA complete callback */
 
   if (dmach->callback)
@@ -556,13 +542,13 @@ static int s32k1xx_edma_interrupt(int irq, void *context, void *arg)
 {
   struct s32k1xx_dmach_s *dmach;
   uintptr_t regaddr;
-  uint32_t regval32;
-  uint16_t regval16;
-  uint8_t regval8;
-  uint8_t chan;
-  int result;
+  uint32_t  regval32;
+  uint16_t  regval16;
+  uint8_t   regval8;
+  uint8_t   chan;
+  int       result;
 
-  /* 'arg' should the DMA channel instance. */
+  /* 'arg' should be the DMA channel instance. */
 
   dmach = (struct s32k1xx_dmach_s *)arg;
   DEBUGASSERT(dmach != NULL);
@@ -584,7 +570,7 @@ static int s32k1xx_edma_interrupt(int irq, void *context, void *arg)
       /* Clear the pending eDMA channel interrupt */
 
       regval8 = EDMA_CINT(chan);
-      putreg32(regval8, S32K1XX_EDMA_CINT);
+      putreg8(regval8, S32K1XX_EDMA_CINT);
 
       /* Get the eDMA TCD Control and Status register value. */
 
@@ -604,7 +590,7 @@ static int s32k1xx_edma_interrupt(int irq, void *context, void *arg)
       else
         {
 #if CONFIG_S32K1XX_EDMA_NTCD > 0
-          /* Perform the end-of-major-cycle DMA callback */
+          /* Perform the half or end-of-major-cycle DMA callback */
 
           if (dmach->callback != NULL)
             {
@@ -612,7 +598,7 @@ static int s32k1xx_edma_interrupt(int irq, void *context, void *arg)
                               false, OK);
             }
 
-          return;
+          return OK;
 #else
           /* Otherwise the interrupt was not expected! */
 
@@ -623,8 +609,18 @@ static int s32k1xx_edma_interrupt(int irq, void *context, void *arg)
 
       /* Terminate the transfer when it is done. */
 
-      s32k1xx_dmaterminate(dmach, result);
+      if ((dmach->flags & EDMA_CONFIG_LOOP_MASK) == 0)
+        {
+          s32k1xx_dmaterminate(dmach, result);
+        }
+      else if (dmach->callback != NULL)
+        {
+          dmach->callback((DMACH_HANDLE)dmach, dmach->arg,
+                          true, result);
+        }
     }
+
+  return OK;
 }
 
 /****************************************************************************
@@ -661,7 +657,7 @@ static int s32k1xx_error_interrupt(int irq, void *context, void *arg)
           /* Clear the pending error interrupt status. */
 
           regval8 = EDMA_CERR(chan);
-          putreg32(regval8, S32K1XX_EDMA_CERR);
+          putreg8(regval8, S32K1XX_EDMA_CERR);
 
           /* Remove the bit from the sample ERR register so that perhaps we
            * can exit this loop early.
@@ -755,24 +751,12 @@ void weak_function arm_dma_initialize(void)
 
   /* Attach DMA interrupt vectors. */
 
-  irq_attach(S32K1XX_IRQ_DMACH0,  s32k1xx_edma_interrupt, &g_edma.dmach[0]);
-  irq_attach(S32K1XX_IRQ_DMACH1,  s32k1xx_edma_interrupt, &g_edma.dmach[1]);
-  irq_attach(S32K1XX_IRQ_DMACH2,  s32k1xx_edma_interrupt, &g_edma.dmach[2]);
-  irq_attach(S32K1XX_IRQ_DMACH3,  s32k1xx_edma_interrupt, &g_edma.dmach[3]);
-#if S32K1XX_EDMA_NCHANNELS > 4
-  irq_attach(S32K1XX_IRQ_DMACH4,  s32k1xx_edma_interrupt, &g_edma.dmach[4]);
-  irq_attach(S32K1XX_IRQ_DMACH5,  s32k1xx_edma_interrupt, &g_edma.dmach[5]);
-  irq_attach(S32K1XX_IRQ_DMACH6,  s32k1xx_edma_interrupt, &g_edma.dmach[6]);
-  irq_attach(S32K1XX_IRQ_DMACH7,  s32k1xx_edma_interrupt, &g_edma.dmach[7]);
-  irq_attach(S32K1XX_IRQ_DMACH8,  s32k1xx_edma_interrupt, &g_edma.dmach[8]);
-  irq_attach(S32K1XX_IRQ_DMACH9,  s32k1xx_edma_interrupt, &g_edma.dmach[9]);
-  irq_attach(S32K1XX_IRQ_DMACH10, s32k1xx_edma_interrupt, &g_edma.dmach[10]);
-  irq_attach(S32K1XX_IRQ_DMACH11, s32k1xx_edma_interrupt, &g_edma.dmach[11]);
-  irq_attach(S32K1XX_IRQ_DMACH12, s32k1xx_edma_interrupt, &g_edma.dmach[12]);
-  irq_attach(S32K1XX_IRQ_DMACH13, s32k1xx_edma_interrupt, &g_edma.dmach[13]);
-  irq_attach(S32K1XX_IRQ_DMACH14, s32k1xx_edma_interrupt, &g_edma.dmach[14]);
-  irq_attach(S32K1XX_IRQ_DMACH15, s32k1xx_edma_interrupt, &g_edma.dmach[15]);
-#endif
+  for (i = 0; i < S32K1XX_EDMA_NCHANNELS; i++)
+    {
+      irq_attach(S32K1XX_IRQ_DMACH0 + i,
+                 s32k1xx_edma_interrupt, &g_edma.dmach[i]);
+    }
+
   /* Attach the DMA error interrupt vector */
 
   irq_attach(S32K1XX_IRQ_DMACH_ERR, s32k1xx_error_interrupt, NULL);
@@ -790,6 +774,14 @@ void weak_function arm_dma_initialize(void)
 
       regaddr = S32K1XX_EDMA_TCD_CSR(i);
       putreg16(0, regaddr);
+
+      /* Set all TCD entries to 0 so that biter and citer
+       * will be 0 when DONE is not set so that s32k1xx_dmach_getcount
+       * reports 0.
+       */
+
+      memset((void *)S32K1XX_EDMA_TCD_BASE(i), 0,
+             sizeof(struct s32k1xx_edmatcd_s));
     }
 
   /* Clear all pending DMA channel interrupts */
@@ -800,24 +792,10 @@ void weak_function arm_dma_initialize(void)
    * controller).
    */
 
-  up_enable_irq(S32K1XX_IRQ_DMACH0);
-  up_enable_irq(S32K1XX_IRQ_DMACH1);
-  up_enable_irq(S32K1XX_IRQ_DMACH2);
-  up_enable_irq(S32K1XX_IRQ_DMACH3);
-#if S32K1XX_EDMA_NCHANNELS > 4
-  up_enable_irq(S32K1XX_IRQ_DMACH4);
-  up_enable_irq(S32K1XX_IRQ_DMACH5);
-  up_enable_irq(S32K1XX_IRQ_DMACH6);
-  up_enable_irq(S32K1XX_IRQ_DMACH7);
-  up_enable_irq(S32K1XX_IRQ_DMACH8);
-  up_enable_irq(S32K1XX_IRQ_DMACH9);
-  up_enable_irq(S32K1XX_IRQ_DMACH10);
-  up_enable_irq(S32K1XX_IRQ_DMACH11);
-  up_enable_irq(S32K1XX_IRQ_DMACH12);
-  up_enable_irq(S32K1XX_IRQ_DMACH13);
-  up_enable_irq(S32K1XX_IRQ_DMACH14);
-  up_enable_irq(S32K1XX_IRQ_DMACH15);
-#endif
+  for (i = 0; i < S32K1XX_EDMA_NCHANNELS; i++)
+    {
+      up_enable_irq(S32K1XX_IRQ_DMACH0 + i);
+    }
 
   /* Enable the DMA error interrupt */
 
@@ -837,7 +815,6 @@ void weak_function arm_dma_initialize(void)
  *            Settings include:
  *
  *            DMAMUX_CHCFG_SOURCE     Chip-specific DMA source (required)
- *            DMAMUX_CHCFG_AON        DMA Channel Always Enable (optional)
  *            DMAMUX_CHCFG_TRIG       DMA Channel Trigger Enable (optional)
  *            DMAMUX_CHCFG_ENBL       DMA Mux Channel Enable (required)
  *
@@ -858,7 +835,7 @@ void weak_function arm_dma_initialize(void)
  *
  ****************************************************************************/
 
-DMACH_HANDLE s32k1xx_dmach_alloc(uint32_t dmamux, uint8_t dchpri)
+DMACH_HANDLE s32k1xx_dmach_alloc(uint8_t dmamux, uint8_t dchpri)
 {
   struct s32k1xx_dmach_s *dmach;
   unsigned int chndx;
@@ -884,6 +861,7 @@ DMACH_HANDLE s32k1xx_dmach_alloc(uint32_t dmamux, uint8_t dchpri)
           dmach        = candidate;
           dmach->inuse = true;
           dmach->state = S32K1XX_DMA_IDLE;
+          dmach->dmamux = dmamux;
 
           /* Clear any pending interrupts on the channel */
 
@@ -896,10 +874,9 @@ DMACH_HANDLE s32k1xx_dmach_alloc(uint32_t dmamux, uint8_t dchpri)
           regval8 = EDMA_CERQ(chndx);
           putreg8(regval8, S32K1XX_EDMA_CERQ);
 
-          /* Set the DMAMUX register associated with this channel */
+          /* Disable the associated DMAMUX for now */
 
-          regaddr = S32K1XX_DMAMUX_CHCFG(chndx);
-          putreg32(dmamux, regaddr);
+          putreg8(0, S32K1XX_DMAMUX_CHCFG(chndx));
           break;
         }
     }
@@ -936,7 +913,6 @@ DMACH_HANDLE s32k1xx_dmach_alloc(uint32_t dmamux, uint8_t dchpri)
 void s32k1xx_dmach_free(DMACH_HANDLE handle)
 {
   struct s32k1xx_dmach_s *dmach = (struct s32k1xx_dmach_s *)handle;
-  uintptr_t regaddr;
   uint8_t regval8;
 
   dmainfo("dmach: %p\n", dmach);
@@ -958,8 +934,7 @@ void s32k1xx_dmach_free(DMACH_HANDLE handle)
 
   /* Disable the associated DMAMUX */
 
-  regaddr = S32K1XX_DMAMUX_CHCFG(dmach->chan);
-  putreg32(0, regaddr);
+  putreg8(0, S32K1XX_DMAMUX_CHCFG(dmach->chan));
 }
 
 /****************************************************************************
@@ -995,12 +970,16 @@ int s32k1xx_dmach_xfrsetup(DMACH_HANDLE *handle,
 #if CONFIG_S32K1XX_EDMA_NTCD > 0
   struct s32k1xx_edmatcd_s *tcd;
   struct s32k1xx_edmatcd_s *prev;
+  uint16_t mask = config->flags & EDMA_CONFIG_INTMAJOR ? 0 :
+                                  EDMA_TCD_CSR_INTMAJOR;
 #endif
   uintptr_t regaddr;
   uint16_t regval16;
 
   DEBUGASSERT(dmach != NULL);
-  dmainfo("dmach%u: %p config: %p\n", dmach, config);
+  dmainfo("dmach%u: %p config: %p\n", dmach->chan, dmach, config);
+
+  dmach->flags  = config->flags;
 
 #if CONFIG_S32K1XX_EDMA_NTCD > 0
   /* Scatter/gather DMA is supported */
@@ -1029,7 +1008,6 @@ int s32k1xx_dmach_xfrsetup(DMACH_HANDLE *handle,
 
       dmach->head  = tcd;
       dmach->tail  = tcd;
-      dmach->ttype = config->ttype;
 
       /* And instantiate the first TCD in the DMA channel TCD registers. */
 
@@ -1037,11 +1015,9 @@ int s32k1xx_dmach_xfrsetup(DMACH_HANDLE *handle,
     }
   else
     {
-      /* Cannot mix transfer types (only because of cache-related operations.
-       * this restriction could be removed with some effort).
-       */
+      /* Cannot mix transfer types */
 
-      if (dmach->ttype != config->ttype)
+      if (dmach->flags & EDMA_CONFIG_LOOP_MASK)
         {
           s32k1xx_tcd_free(tcd);
           return -EINVAL;
@@ -1053,8 +1029,9 @@ int s32k1xx_dmach_xfrsetup(DMACH_HANDLE *handle,
 
       prev           = dmach->tail;
       regval16       = prev->csr;
-      regval16      &= ~EDMA_TCD_CSR_DREQ;
+      regval16      &= ~(EDMA_TCD_CSR_DREQ | mask);
       regval16      |= EDMA_TCD_CSR_ESG;
+
       prev->csr      = regval16;
 
       prev->dlastsga = (uint32_t)tcd;
@@ -1076,7 +1053,7 @@ int s32k1xx_dmach_xfrsetup(DMACH_HANDLE *handle,
 
           regaddr   = S32K1XX_EDMA_TCD_CSR(dmach->chan);
           regval16  = getreg16(regaddr);
-          regval16 &= ~EDMA_TCD_CSR_DREQ;
+          regval16 &= ~(EDMA_TCD_CSR_DREQ | mask);
           regval16 |= EDMA_TCD_CSR_ESG;
           putreg16(regval16, regaddr);
 
@@ -1115,34 +1092,9 @@ int s32k1xx_dmach_xfrsetup(DMACH_HANDLE *handle,
   modifyreg16(regaddr, 0, EDMA_TCD_CSR_INTMAJOR);
 #endif
 
-  /* Check for an Rx (memory-to-peripheral/memory-to-memory) DMA transfer */
+  /* Set the DMAMUX source and enable and optional trigger */
 
-  if (dmach->ttype == EMDA_MEM2MEM || dmach->ttype == EMDA_PERIPH2MEM)
-    {
-      /* Invalidate caches associated with the destination DMA memory.
-       * REVISIT:  nbytes is the number of bytes transferred on each
-       * minor loop.  The following is only valid when the major loop
-       * is one.
-       */
-
-      up_invalidate_dcache((uintptr_t)config->daddr,
-                           (uintptr_t)config->daddr + config->nbytes);
-    }
-
-  /* Check for an Tx (peripheral-to-memory/memory-to-memory) DMA transfer */
-
-  if (dmach->ttype == EMDA_MEM2MEM || dmach->ttype == EMDA_MEM2PERIPH)
-    {
-      /* Clean caches associated with the source DMA memory.
-       * REVISIT:  nbytes is the number of bytes transferred on each
-       * minor loop.  The following is only valid when the major loop
-       * is one.
-       */
-#warning Missing logic
-
-      up_clean_dcache((uintptr_t)config->saddr,
-                      (uintptr_t)config->saddr + config->nbytes);
-    }
+  putreg8(dmach->dmamux, S32K1XX_DMAMUX_CHCFG(dmach->chan));
 
   dmach->state = S32K1XX_DMA_CONFIGURED;
   return OK;
@@ -1155,10 +1107,10 @@ int s32k1xx_dmach_xfrsetup(DMACH_HANDLE *handle,
  *   Start the DMA transfer.  This function should be called after the final
  *   call to s32k1xx_dmach_xfrsetup() in order to avoid race conditions.
  *
- *   At the conclusion of each major DMA loop, a callback to the user
- *   provided function is made:  |For "normal" DMAs, this will correspond to
- *   the DMA DONE interrupt; for scatter gather DMAs, multiple interrupts
- *   will be generated with the final being the DONE interrupt.
+ *   At the conclusion of each major DMA loop, a callback to
+ *   the user-provided function is made: For "normal" DMAs, this will
+ *   correspond to the DMA DONE interrupt; for scatter gather DMAs,
+ *   this will be generated with the final TCD.
  *
  *   At the conclusion of the DMA, the DMA channel is reset, all TCDs are
  *   freed, and the callback function is called with the the success/fail
@@ -1191,14 +1143,13 @@ int s32k1xx_dmach_start(DMACH_HANDLE handle, edma_callback_t callback,
 
   DEBUGASSERT(dmach != NULL && dmach->state == S32K1XX_DMA_CONFIGURED);
   chan            = dmach->chan;
-  dmainfo("dmach%u: %p callback: %p arg: %p\n", dmach, chan, callback, arg);
+  dmainfo("dmach%u: %p callback: %p arg: %p\n", chan, dmach, callback, arg);
 
   /* Save the callback info.  This will be invoked when the DMA completes */
 
   flags           = spin_lock_irqsave(NULL);
   dmach->callback = callback;
   dmach->arg      = arg;
-  dmach->state    = S32K1XX_DMA_ACTIVE;
 
 #if CONFIG_S32K1XX_EDMA_NTCD > 0
   /* Although it is not recommended, it might be possible to call this
@@ -1208,6 +1159,8 @@ int s32k1xx_dmach_start(DMACH_HANDLE handle, edma_callback_t callback,
   if (dmach->state != S32K1XX_DMA_ACTIVE)
 #endif
     {
+      dmach->state    = S32K1XX_DMA_ACTIVE;
+
       /* Enable channel ERROR interrupts */
 
       regval8         = EDMA_SEEI(chan);
@@ -1216,7 +1169,7 @@ int s32k1xx_dmach_start(DMACH_HANDLE handle, edma_callback_t callback,
       /* Enable the DMA request for this channel */
 
       regval8         = EDMA_SERQ(chan);
-      putreg8(regval8, S32K1XX_EDMA_SERQ_OFFSET);
+      putreg8(regval8, S32K1XX_EDMA_SERQ);
     }
 
   spin_unlock_irqrestore(NULL, flags);
diff --git a/arch/arm/src/s32k1xx/s32k1xx_edma.h b/arch/arm/src/s32k1xx/s32k1xx_edma.h
index cd29a6d4e2..ac85a0a03f 100644
--- a/arch/arm/src/s32k1xx/s32k1xx_edma.h
+++ b/arch/arm/src/s32k1xx/s32k1xx_edma.h
@@ -122,6 +122,18 @@
 #  define EDMA_CONFIG_LINKTYPE_MINORLINK (1 << EDMA_CONFIG_LINKTYPE_SHIFT) /* Channel link after each minor loop */
 #  define EDMA_CONFIG_LINKTYPE_MAJORLINK (2 << EDMA_CONFIG_LINKTYPE_SHIFT) /* Channel link when major loop count exhausted */
 
+#define EDMA_CONFIG_LOOP_SHIFT           (2) /* Bits 2-3: Loop type */
+#define EDMA_CONFIG_LOOP_MASK            (3 << EDMA_CONFIG_LOOP_SHIFT)
+#  define EDMA_CONFIG_LOOPNONE           (0 << EDMA_CONFIG_LOOP_SHIFT) /* No looping */
+#  define EDMA_CONFIG_LOOPSRC            (1 << EDMA_CONFIG_LOOP_SHIFT) /* Source looping */
+#  define EDMA_CONFIG_LOOPDEST           (2 << EDMA_CONFIG_LOOP_SHIFT) /* Dest looping */
+
+#define EDMA_CONFIG_INTHALF              (1 << 4) /* Bits 4: Int on HALF */
+#define EDMA_CONFIG_INTMAJOR             (1 << 5) /* Bits 5: Int on all Major completion
+                                                   * Default is only on last completion
+                                                   * if using scatter gather
+                                                   */
+
 /****************************************************************************
  * Public Types
  ****************************************************************************/
@@ -130,19 +142,19 @@ typedef void *DMACH_HANDLE;
 typedef void (*edma_callback_t)(DMACH_HANDLE handle,
                                 void *arg, bool done, int result);
 
-/* eDMA transfer type */
-
-enum s32k1xx_edma_xfrtype_e
-{
-  EDMA_MEM2MEM = 0,      /* Transfer from memory to memory */
-  EDMA_PERIPH2MEM,       /* Transfer from peripheral to memory */
-  EDMA_MEM2PERIPH,       /* Transfer from memory to peripheral */
-};
-
 /* This structure holds the source/destination transfer attribute
  * configuration.
  */
 
+/* eDMA transfer sizes */
+
+enum s32k1xx_edma_sizes_e
+{
+  EDMA_8BIT    = 0,      /* Transfer data size 8 */
+  EDMA_16BIT   = 1,      /* Transfer data size 16 */
+  EDMA_32BIT   = 2,      /* Transfer data size 32 */
+};
+
 struct s32k1xx_edma_xfrconfig_s
 {
     uint32_t saddr;      /* Source data address. */
@@ -153,7 +165,6 @@ struct s32k1xx_edma_xfrconfig_s
     uint8_t  flags;      /* See EDMA_CONFIG_* definitions */
     uint8_t  ssize;      /* Source data transfer size (see TCD_ATTR_SIZE_* definitions in rdware/. */
     uint8_t  dsize;      /* Destination data transfer size. */
-    uint8_t  ttype;      /* Transfer type (see enum s32k1xx_edma_xfrtype_e). */
 #ifdef CONFIG_S32K1XX_EDMA_EMLIM
     uint16_t nbytes;     /* Bytes to transfer in a minor loop */
 #else
@@ -264,7 +275,7 @@ extern "C"
  *
  ****************************************************************************/
 
-DMACH_HANDLE s32k1xx_dmach_alloc(uint32_t dmamux, uint8_t dchpri);
+DMACH_HANDLE s32k1xx_dmach_alloc(uint8_t dmamux, uint8_t dchpri);
 
 /****************************************************************************
  * Name: s32k1xx_dmach_free
diff --git a/arch/arm/src/s32k1xx/s32k1xx_flexcan.c b/arch/arm/src/s32k1xx/s32k1xx_flexcan.c
index 5b6d2f9b5e..c92dc5b897 100644
--- a/arch/arm/src/s32k1xx/s32k1xx_flexcan.c
+++ b/arch/arm/src/s32k1xx/s32k1xx_flexcan.c
@@ -41,6 +41,7 @@
 #include <nuttx/signal.h>
 #include <nuttx/net/netdev.h>
 #include <nuttx/net/can.h>
+#include <netpacket/can.h>
 
 #include "arm_internal.h"
 #include "chip.h"
@@ -502,9 +503,6 @@ static void s32k1xx_setfreeze(uint32_t base, uint32_t freeze);
 static uint32_t s32k1xx_waitmcr_change(uint32_t base,
                                        uint32_t mask,
                                        uint32_t target_state);
-static uint32_t s32k1xx_waitesr2_change(uint32_t base,
-                                       uint32_t mask,
-                                       uint32_t target_state);
 
 /* Interrupt handling */
 
@@ -1219,26 +1217,6 @@ static void s32k1xx_setenable(uint32_t base, uint32_t enable)
   s32k1xx_waitmcr_change(base, CAN_MCR_LPMACK, 1);
 }
 
-static uint32_t s32k1xx_waitesr2_change(uint32_t base, uint32_t mask,
-                                       uint32_t target_state)
-{
-  const uint32_t timeout = 1000;
-  uint32_t wait_ack;
-
-  for (wait_ack = 0; wait_ack < timeout; wait_ack++)
-    {
-      uint32_t state = (getreg32(base + S32K1XX_CAN_ESR2_OFFSET) & mask);
-      if (state == target_state)
-        {
-          return true;
-        }
-
-      up_udelay(10);
-    }
-
-  return false;
-}
-
 static void s32k1xx_setfreeze(uint32_t base, uint32_t freeze)
 {
   uint32_t regval;
@@ -1398,9 +1376,7 @@ static void s32k1xx_txavail_work(void *arg)
        * packet.
        */
 
-      if (s32k1xx_waitesr2_change(priv->base,
-                             (CAN_ESR2_IMB | CAN_ESR2_VPS),
-                             (CAN_ESR2_IMB | CAN_ESR2_VPS)))
+      if (!s32k1xx_txringfull(priv))
         {
           /* No, there is space for another transfer.  Poll the network for
            * new XMIT data.
@@ -1452,6 +1428,65 @@ static int s32k1xx_txavail(struct net_driver_s *dev)
   return OK;
 }
 
+#ifdef CONFIG_NETDEV_CAN_FILTER_IOCTL
+static int s32k1xx_extfilter(struct s32k1xx_driver_s *priv, bool add, struct can_ioctl_filter_s *arg)
+{
+  int i;
+
+  if(arg->ftype != CAN_FILTER_MASK)
+    {
+      return -ENOTSUP;
+    }
+
+  /* Enter freeze mode */
+
+  s32k1xx_setfreeze(priv->base, 1);
+  if (!s32k1xx_waitfreezeack_change(priv->base, 1))
+    {
+      ninfo("FLEXCAN: freeze fail\n");
+      return -1;
+    }
+
+  /* Single filter support for now */
+
+  if (add)
+    {
+      for (i = 0; i < RXMBCOUNT; i++)
+        {
+          /* Setup mask */
+
+          putreg32(arg->fid2 | (1 << 30), priv->base + S32K1XX_CAN_RXIMR_OFFSET(i));
+
+          /* Setup filter */
+          priv->rx[i].id.ext = arg->fid1;
+        }
+    }
+  else
+    {
+      for (i = 0; i < RXMBCOUNT; i++)
+        {
+          /* Reset mask */
+
+          putreg32(0x0, priv->base + S32K1XX_CAN_RXIMR_OFFSET(i));
+
+          /* Reset filter */
+          priv->rx[i].id.ext = 0x0;
+        }
+    }
+
+  /* Exit freeze mode */
+  
+  s32k1xx_setfreeze(priv->base, 0);
+  if (!s32k1xx_waitfreezeack_change(priv->base, 0))
+    {
+      ninfo("FLEXCAN: unfreeze fail\n");
+      return -1;
+    }
+
+  return OK;
+}
+#endif
+
 /****************************************************************************
  * Function: s32k1xx_ioctl
  *
@@ -1470,7 +1505,7 @@ static int s32k1xx_txavail(struct net_driver_s *dev)
  *
  ****************************************************************************/
 
-#ifdef CONFIG_NETDEV_CAN_BITRATE_IOCTL
+#ifdef CONFIG_NETDEV_IOCTL
 static int s32k1xx_ioctl(struct net_driver_s *dev, int cmd,
                          unsigned long arg)
 {
@@ -1481,6 +1516,7 @@ static int s32k1xx_ioctl(struct net_driver_s *dev, int cmd,
 
   switch (cmd)
     {
+#ifdef CONFIG_NETDEV_CAN_BITRATE_IOCTL
       case SIOCGCANBITRATE: /* Get bitrate from a CAN controller */
         {
           struct can_ioctl_data_s *req =
@@ -1543,6 +1579,21 @@ static int s32k1xx_ioctl(struct net_driver_s *dev, int cmd,
             }
         }
         break;
+#endif
+
+#ifdef CONFIG_NETDEV_CAN_FILTER_IOCTL
+      case SIOCACANEXTFILTER: /* Add hardware-level extended ID filter */
+        {
+          ret = s32k1xx_extfilter(priv, true, (struct can_ioctl_filter_s *)arg);
+        }
+        break;
+
+      case SIOCDCANEXTFILTER: /* Delete hardware-level extended ID filter */
+        {
+          ret = s32k1xx_extfilter(priv, false, (struct can_ioctl_filter_s *)arg);
+        }
+        break;
+#endif
 
       default:
         ret = -ENOTTY;
diff --git a/arch/arm/src/s32k1xx/s32k1xx_lpi2c.c b/arch/arm/src/s32k1xx/s32k1xx_lpi2c.c
index 1a900fc724..aa581b70cb 100644
--- a/arch/arm/src/s32k1xx/s32k1xx_lpi2c.c
+++ b/arch/arm/src/s32k1xx/s32k1xx_lpi2c.c
@@ -43,7 +43,9 @@
 #include <arch/irq.h>
 
 #include "arm_internal.h"
+#include "s32k1xx_edma.h"
 #include "s32k1xx_pin.h"
+#include "hardware/s32k1xx_dmamux.h"
 #include "hardware/s32k1xx_pinmux.h"
 #include "s32k1xx_lpi2c.h"
 #include "s32k1xx_periphclocks.h"
@@ -67,24 +69,24 @@
 
 /* Interrupt wait timeout in seconds and milliseconds */
 
-#if !defined(CONFIG_S32K1XX_I2CTIMEOSEC) && !defined(CONFIG_S32K1XX_I2CTIMEOMS)
-#  define CONFIG_S32K1XX_I2CTIMEOSEC 0
-#  define CONFIG_S32K1XX_I2CTIMEOMS  500   /* Default is 500 milliseconds */
-#elif !defined(CONFIG_S32K1XX_I2CTIMEOSEC)
-#  define CONFIG_S32K1XX_I2CTIMEOSEC 0     /* User provided milliseconds */
-#elif !defined(CONFIG_S32K1XX_I2CTIMEOMS)
-#  define CONFIG_S32K1XX_I2CTIMEOMS  0     /* User provided seconds */
+#if !defined(CONFIG_S32K1XX_LPI2CTIMEOSEC) && !defined(CONFIG_S32K1XX_LPI2CTIMEOMS)
+#  define CONFIG_S32K1XX_LPI2CTIMEOSEC 0
+#  define CONFIG_S32K1XX_LPI2CTIMEOMS  500   /* Default is 500 milliseconds */
+#elif !defined(CONFIG_S32K1XX_LPI2CTIMEOSEC)
+#  define CONFIG_S32K1XX_LPI2CTIMEOSEC 0     /* User provided milliseconds */
+#elif !defined(CONFIG_S32K1XX_LPI2CTIMEOMS)
+#  define CONFIG_S32K1XX_LPI2CTIMEOMS  0     /* User provided seconds */
 #endif
 
 /* Interrupt wait time timeout in system timer ticks */
 
-#ifndef CONFIG_S32K1XX_I2CTIMEOTICKS
-#  define CONFIG_S32K1XX_I2CTIMEOTICKS \
-    (SEC2TICK(CONFIG_S32K1XX_I2CTIMEOSEC) + MSEC2TICK(CONFIG_S32K1XX_I2CTIMEOMS))
+#ifndef CONFIG_S32K1XX_LPI2CTIMEOTICKS
+#  define CONFIG_S32K1XX_LPI2CTIMEOTICKS \
+    (SEC2TICK(CONFIG_S32K1XX_LPI2CTIMEOSEC) + MSEC2TICK(CONFIG_S32K1XX_LPI2CTIMEOMS))
 #endif
 
-#ifndef CONFIG_S32K1XX_I2C_DYNTIMEO_STARTSTOP
-#  define CONFIG_S32K1XX_I2C_DYNTIMEO_STARTSTOP TICK2USEC(CONFIG_S32K1XX_I2CTIMEOTICKS)
+#ifndef CONFIG_S32K1XX_LPI2C_DYNTIMEO_STARTSTOP
+#  define CONFIG_S32K1XX_LPI2C_DYNTIMEO_STARTSTOP TICK2USEC(CONFIG_S32K1XX_LPI2CTIMEOTICKS)
 #endif
 
 /* Debug ********************************************************************/
@@ -111,6 +113,8 @@
 #define MKI2C_OUTPUT(p) (((p) & (~_PIN_MODE_MASK)) | GPIO_OUTPUT | GPIO_OUTPUT_ONE)
 #define MKI2C_INPUT(p)  (((p) & (~_PIN_MODE_MASK)) | GPIO_INPUT)
 
+#define LPI2C_MSR_LIMITED_ERROR_MASK (LPI2C_MSR_ERROR_MASK & ~(LPI2C_MSR_FEF))
+
 /****************************************************************************
  * Private Types
  ****************************************************************************/
@@ -163,6 +167,10 @@ struct s32k1xx_lpi2c_config_s
 #ifndef CONFIG_I2C_POLLED
   uint32_t irq;               /* Event IRQ */
 #endif
+#ifdef CONFIG_S32K1XX_LPI2C_DMA
+  uint32_t        dma_rxreqsrc;  /* DMA mux rx source */
+  uint32_t        dma_txreqsrc;  /* DMA mux tx source */
+#endif
 };
 
 /* I2C Device Private Data */
@@ -202,6 +210,11 @@ struct s32k1xx_lpi2c_priv_s
   struct s32k1xx_trace_s trace[CONFIG_I2C_NTRACE];
 #endif
 
+#ifdef CONFIG_S32K1XX_LPI2C_DMA
+  DMACH_HANDLE rxdma;                                  /* rx DMA handle */
+  DMACH_HANDLE txdma;                                  /* tx DMA handle */
+  uint16_t     cmnds[CONFIG_S32K1XX_LPI2C_DMA_MAXMSG]; /* Commands */
+#endif
   uint32_t status;             /* End of transfer SR2|SR1 status */
 };
 
@@ -222,10 +235,10 @@ s32k1xx_lpi2c_modifyreg(struct s32k1xx_lpi2c_priv_s *priv,
 static inline int
 s32k1xx_lpi2c_sem_wait(struct s32k1xx_lpi2c_priv_s *priv);
 
-#ifdef CONFIG_S32K1XX_I2C_DYNTIMEO
+#ifdef CONFIG_S32K1XX_LPI2C_DYNTIMEO
 static uint32_t
 s32k1xx_lpi2c_toticks(int msgc, struct i2c_msg_s *msgs);
-#endif /* CONFIG_S32K1XX_I2C_DYNTIMEO */
+#endif /* CONFIG_S32K1XX_LPI2C_DYNTIMEO */
 
 static inline int
 s32k1xx_lpi2c_sem_waitdone(struct s32k1xx_lpi2c_priv_s *priv);
@@ -273,6 +286,13 @@ static int s32k1xx_lpi2c_transfer(struct i2c_master_s *dev,
 static int s32k1xx_lpi2c_reset(struct i2c_master_s *dev);
 #endif
 
+#ifdef CONFIG_S32K1XX_LPI2C_DMA
+static void s32k1xx_rxdma_callback(DMACH_HANDLE handle, void *arg, bool done,
+                                  int result);
+static void s32k1xx_txdma_callback(DMACH_HANDLE handle, void *arg, bool done,
+                                  int result);
+#endif
+
 /****************************************************************************
  * Private Data
  ****************************************************************************/
@@ -318,6 +338,10 @@ static const struct s32k1xx_lpi2c_config_s s32k1xx_lpi2c0_config =
 #ifndef CONFIG_I2C_POLLED
   .irq        = S32K1XX_IRQ_LPI2C0M,
 #endif
+#ifdef CONFIG_LPI2C0_DMA
+  .dma_rxreqsrc    = S32K1XX_DMACHAN_LPI2C0_RX,
+  .dma_txreqsrc    = S32K1XX_DMACHAN_LPI2C0_TX,
+#endif
 };
 
 static struct s32k1xx_lpi2c_priv_s s32k1xx_lpi2c0_priv =
@@ -348,6 +372,10 @@ static const struct s32k1xx_lpi2c_config_s s32k1xx_lpi2c1_config =
 #ifndef CONFIG_I2C_POLLED
   .irq        = S32K1XX_IRQ_LPI2C1M,
 #endif
+#ifdef CONFIG_LPI2C1_DMA
+  .dma_rxreqsrc    = S32K1XX_DMACHAN_LPI2C1_RX,
+  .dma_txreqsrc    = S32K1XX_DMACHAN_LPI2C1_TX,
+#endif
 };
 
 static struct s32k1xx_lpi2c_priv_s s32k1xx_lpi2c1_priv =
@@ -439,7 +467,7 @@ s32k1xx_lpi2c_sem_wait(struct s32k1xx_lpi2c_priv_s *priv)
  *
  ****************************************************************************/
 
-#ifdef CONFIG_S32K1XX_I2C_DYNTIMEO
+#ifdef CONFIG_S32K1XX_LPI2C_DYNTIMEO
 static uint32_t s32k1xx_lpi2c_toticks(int msgc, struct i2c_msg_s *msgs)
 {
   size_t bytecount = 0;
@@ -456,7 +484,7 @@ static uint32_t s32k1xx_lpi2c_toticks(int msgc, struct i2c_msg_s *msgs)
    * factor.
    */
 
-  return USEC2TICK(CONFIG_S32K1XX_I2C_DYNTIMEO_USECPERBYTE * bytecount);
+  return USEC2TICK(CONFIG_S32K1XX_LPI2C_DYNTIMEO_USECPERBYTE * bytecount);
 }
 #endif
 
@@ -478,47 +506,53 @@ s32k1xx_lpi2c_sem_waitdone(struct s32k1xx_lpi2c_priv_s *priv)
 
   flags = enter_critical_section();
 
+#ifdef CONFIG_S32K1XX_LPI2C_DMA
+  if (priv->rxdma == NULL && priv->txdma == NULL)
+    {
+#endif
+      /* Clear the TX and RX FIFOs */
+
+      s32k1xx_lpi2c_modifyreg(priv, S32K1XX_LPI2C_MCR_OFFSET, 0,
+                              LPI2C_MCR_RTF | LPI2C_MCR_RRF);
+
   /* Enable Interrupts when master mode */
 
-  if (priv->config->mode == LPI2C_MASTER)
-    {
-      if ((priv->flags & I2C_M_READ) != 0)
-        {
-          regval = LPI2C_MIER_TDIE | LPI2C_MIER_RDIE | LPI2C_MIER_NDIE | \
-                   LPI2C_MIER_ALIE | LPI2C_MIER_SDIE;
-          s32k1xx_lpi2c_putreg(priv, S32K1XX_LPI2C_MIER_OFFSET, regval);
-        }
-      else
+      if (priv->config->mode == LPI2C_MASTER)
         {
-          regval = LPI2C_MIER_TDIE | LPI2C_MIER_NDIE | \
-                   LPI2C_MIER_ALIE | LPI2C_MIER_SDIE;
-          s32k1xx_lpi2c_putreg(priv, S32K1XX_LPI2C_MIER_OFFSET, regval);
+          if ((priv->flags & I2C_M_READ) != 0)
+            {
+              regval = LPI2C_MIER_TDIE | LPI2C_MIER_RDIE | LPI2C_MIER_NDIE |
+                       LPI2C_MIER_ALIE | LPI2C_MIER_SDIE;
+              s32k1xx_lpi2c_putreg(priv, S32K1XX_LPI2C_MIER_OFFSET, regval);
+            }
+          else
+            {
+              regval = LPI2C_MIER_TDIE | LPI2C_MIER_NDIE | \
+                       LPI2C_MIER_ALIE | LPI2C_MIER_SDIE;
+              s32k1xx_lpi2c_putreg(priv, S32K1XX_LPI2C_MIER_OFFSET, regval);
+            }
         }
-    }
 
-  /* Enable Interrupts when slave mode */
+      /* Enable Interrupts when slave mode */
 
-  else
-    {
+      else
+        {
 #warning Missing logic for I2C Slave mode
+        }
+#ifdef CONFIG_S32K1XX_LPI2C_DMA
     }
+#endif
 
-  /* Signal the interrupt handler that we are waiting.  NOTE:  Interrupts
-   * are currently disabled but will be temporarily re-enabled below when
-   * nxsem_tickwait_uninterruptible() sleeps.
-   */
-
-  priv->intstate = INTSTATE_WAITING;
   do
     {
       /* Wait until either the transfer is complete or the timeout expires */
 
-#ifdef CONFIG_S32K1XX_I2C_DYNTIMEO
+#ifdef CONFIG_S32K1XX_LPI2C_DYNTIMEO
       ret = nxsem_tickwait_uninterruptible(&priv->sem_isr,
                      s32k1xx_lpi2c_toticks(priv->msgc, priv->msgv));
 #else
       ret = nxsem_tickwait_uninterruptible(&priv->sem_isr,
-                                           CONFIG_S32K1XX_I2CTIMEOTICKS);
+                                           CONFIG_S32K1XX_LPI2CTIMEOTICKS);
 #endif
       if (ret < 0)
         {
@@ -541,16 +575,12 @@ s32k1xx_lpi2c_sem_waitdone(struct s32k1xx_lpi2c_priv_s *priv)
 
   /* Disable I2C interrupts */
 
-  /* Enable Interrupts when master mode */
-
   if (priv->config->mode == LPI2C_MASTER)
     {
       s32k1xx_lpi2c_putreg(priv, S32K1XX_LPI2C_MIER_OFFSET, 0);
     }
 
 #if 0
-  /* Enable Interrupts when slave mode */
-
   else
     {
       s32k1xx_lpi2c_putreg(priv, S32K1XX_LPI2C_SIER_OFFSET, 0);
@@ -571,18 +601,11 @@ s32k1xx_lpi2c_sem_waitdone(struct s32k1xx_lpi2c_priv_s *priv)
 
   /* Get the timeout value */
 
-#ifdef CONFIG_S32K1XX_I2C_DYNTIMEO
+#ifdef CONFIG_S32K1XX_LPI2C_DYNTIMEO
   timeout = s32k1xx_lpi2c_toticks(priv->msgc, priv->msgv);
 #else
-  timeout = CONFIG_S32K1XX_I2CTIMEOTICKS;
+  timeout = CONFIG_S32K1XX_LPI2CTIMEOTICKS;
 #endif
-
-  /* Signal the interrupt handler that we are waiting.  NOTE:  Interrupts
-   * are currently disabled but will be temporarily re-enabled below when
-   * nxsem_tickwait_uninterruptible() sleeps.
-   */
-
-  priv->intstate = INTSTATE_WAITING;
   start = clock_systime_ticks();
 
   do
@@ -631,10 +654,10 @@ s32k1xx_lpi2c_sem_waitstop(struct s32k1xx_lpi2c_priv_s *priv)
 
   /* Select a timeout */
 
-#ifdef CONFIG_S32K1XX_I2C_DYNTIMEO
-  timeout = USEC2TICK(CONFIG_S32K1XX_I2C_DYNTIMEO_STARTSTOP);
+#ifdef CONFIG_S32K1XX_LPI2C_DYNTIMEO
+  timeout = USEC2TICK(CONFIG_S32K1XX_LPI2C_DYNTIMEO_STARTSTOP);
 #else
-  timeout = CONFIG_S32K1XX_I2CTIMEOTICKS;
+  timeout = CONFIG_S32K1XX_LPI2CTIMEOTICKS;
 #endif
 
   /* Wait as stop might still be in progress; but stop might also
@@ -755,6 +778,81 @@ s32k1xx_lpi2c_sem_destroy(struct s32k1xx_lpi2c_priv_s *priv)
 #endif
 }
 
+/****************************************************************************
+ * Name: s32k1xx_rxdma_callback
+ *
+ * Description:
+ *   This function performs the next I2C operation
+ *
+ ****************************************************************************/
+#ifdef CONFIG_S32K1XX_LPI2C_DMA
+static void s32k1xx_rxdma_callback(DMACH_HANDLE handle, void *arg, bool done,
+                              int result)
+{
+  struct s32k1xx_lpi2c_priv_s *priv = (struct s32k1xx_lpi2c_priv_s *)arg;
+
+  s32k1xx_lpi2c_modifyreg(priv, S32K1XX_LPI2C_MIER_OFFSET, 0,
+                              LPI2C_MIER_SDIE);
+
+  if (result == OK)
+    {
+      if ((priv->flags & I2C_M_NOSTOP) == 0)
+        {
+          s32k1xx_lpi2c_traceevent(priv, I2CEVENT_STOP, 0);
+          s32k1xx_lpi2c_sendstop(priv);
+        }
+    }
+  else
+    {
+      uint32_t status = s32k1xx_lpi2c_getstatus(priv);
+
+      if ((status & LPI2C_MSR_ERROR_MASK) != 0)
+        {
+          i2cerr("ERROR: MSR: status: 0x0%" PRIx32 "\n", status);
+
+          s32k1xx_lpi2c_traceevent(priv, I2CEVENT_ERROR, 0);
+        }
+    }
+}
+#endif
+
+/****************************************************************************
+ * Name: s32k1xx_txdma_callback
+ *
+ * Description:
+ *   This function performs the next I2C operation
+ *
+ ****************************************************************************/
+#ifdef CONFIG_S32K1XX_LPI2C_DMA
+static void s32k1xx_txdma_callback(DMACH_HANDLE handle, void *arg, bool done,
+                              int result)
+{
+  struct s32k1xx_lpi2c_priv_s *priv = (struct s32k1xx_lpi2c_priv_s *)arg;
+
+  s32k1xx_lpi2c_modifyreg(priv, S32K1XX_LPI2C_MIER_OFFSET, 0,
+                              LPI2C_MIER_SDIE);
+
+  if (result == OK)
+    {
+      if ((priv->flags & I2C_M_NOSTOP) == 0)
+        {
+          s32k1xx_lpi2c_sendstop(priv);
+        }
+    }
+  else
+    {
+      uint32_t status = s32k1xx_lpi2c_getstatus(priv);
+
+      if ((status & LPI2C_MSR_ERROR_MASK) != 0)
+        {
+          i2cerr("ERROR: MSR: status: 0x0%" PRIx32 "\n", status);
+
+          s32k1xx_lpi2c_traceevent(priv, I2CEVENT_ERROR, 0);
+        }
+    }
+}
+#endif
+
 /****************************************************************************
  * Name: s32k1xx_lpi2c_trace*
  *
@@ -1080,10 +1178,10 @@ s32k1xx_lpi2c_sendstart(struct s32k1xx_lpi2c_priv_s *priv,
 
   /* Generate START condition and send the address */
 
-  /* Turn off auto_stop option */
+  /* Disable AUTOSTOP and NAK Ignore */
 
   s32k1xx_lpi2c_modifyreg(priv, S32K1XX_LPI2C_MCFGR1_OFFSET,
-                          LPI2C_MCFGR1_IGNACK, 0);
+                          LPI2C_MCFGR1_IGNACK | LPI2C_MCFGR1_AUTOSTOP, 0);
 
   do
     {
@@ -1142,6 +1240,20 @@ s32k1xx_lpi2c_getstatus(struct s32k1xx_lpi2c_priv_s *priv)
   return s32k1xx_lpi2c_getreg(priv, S32K1XX_LPI2C_MSR_OFFSET);
 }
 
+/****************************************************************************
+ * Name: imxrt_lpi2c_getenabledints
+ *
+ * Description:
+ *   Get 32-bit status
+ *
+ ****************************************************************************/
+
+static inline uint32_t
+s32k1xx_lpi2c_getenabledints(struct s32k1xx_lpi2c_priv_s *priv)
+{
+  return s32k1xx_lpi2c_getreg(priv, S32K1XX_LPI2C_MIER_OFFSET);
+}
+
 /****************************************************************************
  * Name: s32k1xx_lpi2c_isr_process
  *
@@ -1154,208 +1266,278 @@ static int s32k1xx_lpi2c_isr_process(struct s32k1xx_lpi2c_priv_s *priv)
 {
   uint32_t status = s32k1xx_lpi2c_getstatus(priv);
 
-  /* Check for new trace setup */
+#ifdef CONFIG_S32K1XX_LPI2C_DMA
+  uint32_t current_status = status;
 
-  s32k1xx_lpi2c_tracenew(priv, status);
+  /* Condition the status with only the enabled interrupts */
 
-  /* After an error we can get a STOP Detect Flag  */
+  status &= s32k1xx_lpi2c_getenabledints(priv);
 
-  if (priv->intstate == INTSTATE_DONE && (status & LPI2C_MSR_SDF) != 0)
+  if (priv->rxdma != NULL || priv->txdma != NULL)
     {
-      s32k1xx_lpi2c_traceevent(priv, I2CEVENT_STOP, 0);
-      s32k1xx_lpi2c_putreg(priv, S32K1XX_LPI2C_MSR_OFFSET, LPI2C_MSR_SDF);
-    }
-
-  /* Check if there is more bytes to send */
+      /* Is there an Error condition */
 
-  else if (((priv->flags & I2C_M_READ) == 0) &&
-           (status & LPI2C_MSR_TDF) != 0)
-    {
-      if (priv->dcnt > 0)
+      if (current_status & LPI2C_MSR_LIMITED_ERROR_MASK)
         {
-          s32k1xx_lpi2c_traceevent(priv, I2CEVENT_SENDBYTE, priv->dcnt);
-          s32k1xx_lpi2c_putreg(priv, S32K1XX_LPI2C_MTDR_OFFSET,
-                             LPI2C_MTDR_CMD_TXD |
-                             LPI2C_MTDR_DATA(*priv->ptr++));
-          priv->dcnt--;
+          s32k1xx_lpi2c_traceevent(priv, I2CEVENT_ERROR, 0);
 
-          if ((priv->msgc <= 0) && (priv->dcnt == 0))
-            {
-              s32k1xx_lpi2c_sendstop(priv);
-            }
-        }
-    }
+          /* Return the full error status */
 
-  /* Check if there is more bytes to read */
+          priv->status = current_status;
+        }
 
-  else if (((priv->flags & I2C_M_READ) != 0) &&
-           (status & LPI2C_MSR_RDF) != 0)
-    {
-      /* Read a byte, if dcnt goes < 0, then read dummy bytes to ack ISRs */
+      /* End of packet or Stop */
 
-      if (priv->dcnt > 0)
+      if ((status & (LPI2C_MSR_SDF | LPI2C_MSR_EPF)) != 0)
         {
-          s32k1xx_lpi2c_traceevent(priv, I2CEVENT_RCVBYTE, priv->dcnt);
-
-          /* No interrupts or contex switches should occur in the following
-           * sequence. Otherwise, additional bytes may be sent by the device.
-           */
+          s32k1xx_lpi2c_traceevent(priv, I2CEVENT_STOP, 0);
 
-#ifdef CONFIG_I2C_POLLED
-          irqstate_t flags = enter_critical_section();
-#endif
+          /* Acknowledge End of packet or Stop */
 
-          /* Receive a byte */
+          s32k1xx_lpi2c_putreg(priv, S32K1XX_LPI2C_MSR_OFFSET, status &
+                                                           (LPI2C_MSR_SDF |
+                                                           LPI2C_MSR_EPF));
 
-          *priv->ptr++ =
-            s32k1xx_lpi2c_getreg(priv, S32K1XX_LPI2C_MRDR_OFFSET) &
-            LPI2C_MRDR_DATA_MASK;
+          /* Mark that this transaction stopped */
 
-          priv->dcnt--;
+          priv->msgv = NULL;
+          priv->msgc = 0;
+          priv->dcnt = -1;
 
-#ifdef CONFIG_I2C_POLLED
-          leave_critical_section(flags);
-#endif
-          if ((priv->msgc <= 0) && (priv->dcnt == 0))
+          if (priv->intstate == INTSTATE_WAITING)
             {
-              s32k1xx_lpi2c_sendstop(priv);
-            }
-        }
-      else
-        {
-          s32k1xx_lpi2c_getreg(priv, S32K1XX_LPI2C_MRDR_OFFSET);
-        }
-    }
+              /* inform the thread that transfer is complete
+               * and wake it up
+               */
 
-  if (priv->dcnt <= 0)
-    {
-      if (priv->msgc > 0 && priv->msgv != NULL)
-        {
-          priv->ptr   = priv->msgv->buffer;
-          priv->dcnt  = priv->msgv->length;
-          priv->flags = priv->msgv->flags;
+              s32k1xx_dmach_stop(priv->txdma);
+              s32k1xx_dmach_stop(priv->rxdma);
 
-          if ((priv->msgv->flags & I2C_M_NOSTART) == 0)
-            {
-              s32k1xx_lpi2c_traceevent(priv, I2CEVENT_STARTRESTART,
-                                     priv->msgc);
-              s32k1xx_lpi2c_sendstart(priv, priv->msgv->addr);
-            }
-          else
-            {
-              s32k1xx_lpi2c_traceevent(priv, I2CEVENT_NOSTART, priv->msgc);
+              priv->intstate = INTSTATE_DONE;
+              nxsem_post(&priv->sem_isr);
             }
+        }
 
-          priv->msgv++;
-          priv->msgc--;
+          /* Clear the error */
 
-          if ((priv->flags & I2C_M_READ) != 0)
-            {
-#ifndef CONFIG_I2C_POLLED
-              /* Stop TX interrupt */
+          s32k1xx_lpi2c_putreg(priv, S32K1XX_LPI2C_MSR_OFFSET,
+                            (current_status & (LPI2C_MSR_NDF |
+                                               LPI2C_MSR_ALF |
+                                               LPI2C_MSR_FEF)));
 
-              s32k1xx_lpi2c_modifyreg(priv, S32K1XX_LPI2C_MIER_OFFSET,
-                                    LPI2C_MIER_TDIE, LPI2C_MIER_RDIE);
+      return OK;
+    }
 #endif
-              /* Set LPI2C in read mode */
 
-              s32k1xx_lpi2c_putreg(priv, S32K1XX_LPI2C_MTDR_OFFSET,
-                                 LPI2C_MTDR_CMD_RXD |
-                                 LPI2C_MTDR_DATA((priv->dcnt - 1)));
-            }
-          else
-            {
-              /* Send the first byte from tx buffer */
+  /* Check for new trace setup */
+
+  s32k1xx_lpi2c_tracenew(priv, status);
 
+  if ((status & LPI2C_MSR_LIMITED_ERROR_MASK) == 0)
+    {
+      /* Check if there is more bytes to send */
+
+      if (((priv->flags & I2C_M_READ) == 0) &&
+               (status & LPI2C_MSR_TDF) != 0)
+        {
+          if (priv->dcnt > 0)
+            {
               s32k1xx_lpi2c_traceevent(priv, I2CEVENT_SENDBYTE, priv->dcnt);
               s32k1xx_lpi2c_putreg(priv, S32K1XX_LPI2C_MTDR_OFFSET,
                                  LPI2C_MTDR_CMD_TXD |
                                  LPI2C_MTDR_DATA(*priv->ptr++));
               priv->dcnt--;
+
+              /* Last byte of last message? */
+
               if ((priv->msgc <= 0) && (priv->dcnt == 0))
                 {
-                  s32k1xx_lpi2c_sendstop(priv);
+                  if ((priv->flags & I2C_M_NOSTOP) == 0)
+                    {
+                      s32k1xx_lpi2c_traceevent(priv, I2CEVENT_STOP, 0);
+
+                      /* Do this once */
+
+                      priv->flags |= I2C_M_NOSTOP;
+                      s32k1xx_lpi2c_sendstop(priv);
+                    }
                 }
             }
         }
-      else if (priv->msgv && ((status & LPI2C_MSR_SDF) != 0))
-        {
-          s32k1xx_lpi2c_traceevent(priv, I2CEVENT_STOP, 0);
-          s32k1xx_lpi2c_putreg(priv, S32K1XX_LPI2C_MSR_OFFSET,
-                             LPI2C_MSR_SDF);
 
-          /* Check is there thread waiting for this event (there should be) */
+      /* Check if there is more bytes to read */
 
-#ifndef CONFIG_I2C_POLLED
-          if (priv->intstate == INTSTATE_WAITING)
-            {
-              /* Update Status once at the end */
+      else if (((priv->flags & I2C_M_READ) != 0) &&
+               (status & LPI2C_MSR_RDF) != 0)
+        {
+          /* Read a byte, if dcnt goes < 0, read dummy bytes to ack ISRs */
 
-              priv->status = status;
+          if (priv->dcnt > 0)
+            {
+              s32k1xx_lpi2c_traceevent(priv, I2CEVENT_RCVBYTE, priv->dcnt);
 
-              /* inform the thread that transfer is complete
-               * and wake it up
+              /* No interrupts or context switches should occur in the
+               * following sequence. Otherwise, additional bytes may be
+               * sent by the device.
                */
 
-              nxsem_post(&priv->sem_isr);
-              priv->intstate = INTSTATE_DONE;
+    #ifdef CONFIG_I2C_POLLED
+              irqstate_t flags = enter_critical_section();
+    #endif
+
+              /* Receive a byte */
+
+              *priv->ptr++ = s32k1xx_lpi2c_getreg(priv,
+                                                S32K1XX_LPI2C_MRDR_OFFSET) &
+                                                LPI2C_MRDR_DATA_MASK;
+              priv->dcnt--;
+
+    #ifdef CONFIG_I2C_POLLED
+              leave_critical_section(flags);
+    #endif
+              /* Last byte of last message? */
+
+              if ((priv->msgc <= 0) && (priv->dcnt == 0))
+                {
+                  if ((priv->flags & I2C_M_NOSTOP) == 0)
+                    {
+                      s32k1xx_lpi2c_traceevent(priv, I2CEVENT_STOP, 0);
+
+                      /* Do this once */
+
+                      priv->flags |= I2C_M_NOSTOP;
+                      s32k1xx_lpi2c_sendstop(priv);
+                    }
+                }
             }
-#else
-          priv->status = status;
-          priv->intstate = INTSTATE_DONE;
-#endif
-          /* Mark that this transaction stopped */
+          else
+            {
+              /* Read and discard data */
 
-          priv->msgv = NULL;
+              s32k1xx_lpi2c_getreg(priv, S32K1XX_LPI2C_MRDR_OFFSET);
+            }
         }
-#ifndef CONFIG_I2C_POLLED
-      else
+
+      /* Start the first or next message */
+
+      if (priv->dcnt <= 0 && (status & (LPI2C_MSR_EPF | LPI2C_MSR_SDF)) == 0)
         {
-          s32k1xx_lpi2c_modifyreg(priv, S32K1XX_LPI2C_MIER_OFFSET,
-                                LPI2C_MIER_TDIE | LPI2C_MIER_RDIE, 0);
-        }
+          if (priv->msgc > 0 && priv->msgv != NULL)
+            {
+              priv->ptr   = priv->msgv->buffer;
+              priv->dcnt  = priv->msgv->length;
+              priv->flags = priv->msgv->flags;
+
+              if ((priv->flags & I2C_M_NOSTART) == 0)
+                {
+                  s32k1xx_lpi2c_traceevent(priv, I2CEVENT_STARTRESTART,
+                                         priv->msgc);
+
+                  /* Do this once */
+
+                  priv->flags |= I2C_M_NOSTART;
+
+                  s32k1xx_lpi2c_sendstart(priv, priv->msgv->addr);
+                }
+              else
+                {
+                  s32k1xx_lpi2c_traceevent(priv, I2CEVENT_NOSTART,
+                                           priv->msgc);
+                }
+
+              priv->msgv++;
+              priv->msgc--;
+
+              if ((priv->flags & I2C_M_READ) != 0)
+                {
+#ifndef CONFIG_I2C_POLLED
+                  /* Stop TX interrupt */
+
+                  s32k1xx_lpi2c_modifyreg(priv, S32K1XX_LPI2C_MIER_OFFSET,
+                                        LPI2C_MIER_TDIE, LPI2C_MIER_RDIE);
 #endif
-    }
+                  /* Set LPI2C in read mode */
 
-  /* Check for errors */
+                  s32k1xx_lpi2c_putreg(priv, S32K1XX_LPI2C_MTDR_OFFSET,
+                                     LPI2C_MTDR_CMD_RXD |
+                                     LPI2C_MTDR_DATA((priv->dcnt - 1)));
+                }
+              else
+                {
+                  /* Send the first byte from tx buffer */
 
-  if ((status & LPI2C_MSR_EPF) != 0)
-    {
-      s32k1xx_lpi2c_putreg(priv, S32K1XX_LPI2C_MSR_OFFSET, LPI2C_MSR_EPF);
-    }
+                  s32k1xx_lpi2c_traceevent(priv, I2CEVENT_SENDBYTE,
+                                         priv->dcnt);
+                  s32k1xx_lpi2c_putreg(priv, S32K1XX_LPI2C_MTDR_OFFSET,
+                                     LPI2C_MTDR_CMD_TXD |
+                                     LPI2C_MTDR_DATA(*priv->ptr++));
+                  priv->dcnt--;
 
-  if ((status & LPI2C_MSR_ERROR_MASK) != 0)
+                  /* Last byte of last message? */
+
+                  if ((priv->msgc <= 0) && (priv->dcnt == 0))
+                    {
+                      if ((priv->flags & I2C_M_NOSTOP) == 0)
+                        {
+                          s32k1xx_lpi2c_traceevent(priv, I2CEVENT_STOP, 0);
+
+                          /* Do this once */
+
+                          priv->flags |= I2C_M_NOSTOP;
+                          s32k1xx_lpi2c_sendstop(priv);
+                        }
+                    }
+                }
+            }
+        }
+    }
+  else
     {
       s32k1xx_lpi2c_traceevent(priv, I2CEVENT_ERROR, 0);
 
-      /* Clear the TX and RX FIFOs */
+      priv->status = status;
 
-      s32k1xx_lpi2c_modifyreg(priv, S32K1XX_LPI2C_MCR_OFFSET, 0,
-                            LPI2C_MCR_RTF | LPI2C_MCR_RRF);
+      if ((priv->flags & I2C_M_NOSTOP) == 0)
+        {
+          s32k1xx_lpi2c_traceevent(priv, I2CEVENT_STOP, 0);
+
+          /* Do this once */
+
+          priv->flags |= I2C_M_NOSTOP;
+          s32k1xx_lpi2c_sendstop(priv);
+        }
 
       /* Clear the error */
 
       s32k1xx_lpi2c_putreg(priv, S32K1XX_LPI2C_MSR_OFFSET,
-                         (status & (LPI2C_MSR_NDF | LPI2C_MSR_ALF |
-                                    LPI2C_MSR_FEF)));
+                           (status & (LPI2C_MSR_NDF | LPI2C_MSR_ALF |
+                                      LPI2C_MSR_FEF | LPI2C_MSR_EPF)));
+    }
 
-#ifndef CONFIG_I2C_POLLED
-          if (priv->intstate == INTSTATE_WAITING)
-            {
-              /* Update Status once at the end */
+  /* Check for endof packet */
 
-              priv->status = status;
+  if ((status & (LPI2C_MSR_EPF | LPI2C_MSR_SDF)) != 0)
+    {
+      s32k1xx_lpi2c_putreg(priv, S32K1XX_LPI2C_MSR_OFFSET, status &
+                           (LPI2C_MSR_EPF | LPI2C_MSR_SDF));
 
-              /* inform the thread that transfer is complete
-               * and wake it up
-               */
+#ifndef CONFIG_I2C_POLLED
+      if (priv->intstate == INTSTATE_WAITING)
+        {
+          /* inform the thread that transfer is complete
+           * and wake it up
+           */
 
-              nxsem_post(&priv->sem_isr);
-              priv->intstate = INTSTATE_DONE;
-            }
-#else
-          priv->status = status;
           priv->intstate = INTSTATE_DONE;
+
+          s32k1xx_lpi2c_modifyreg(priv, S32K1XX_LPI2C_MIER_OFFSET,
+                               LPI2C_MIER_TDIE | LPI2C_MIER_RDIE |
+                               LPI2C_MIER_NDIE | LPI2C_MIER_ALIE |
+                               LPI2C_MIER_SDIE | LPI2C_MIER_EPIE, 0);
+          nxsem_post(&priv->sem_isr);
+        }
+#else
+      priv->intstate = INTSTATE_DONE;
 #endif
     }
 
@@ -1491,6 +1673,239 @@ static int s32k1xx_lpi2c_deinit(struct s32k1xx_lpi2c_priv_s *priv)
  * Device Driver Operations
  ****************************************************************************/
 
+/****************************************************************************
+ * Name: s32k1xx_lpi2c_dma_command_configure
+ *
+ * Description:
+ *   Create a command TCD
+ *
+ ****************************************************************************/
+
+#ifdef CONFIG_S32K1XX_LPI2C_DMA
+static int
+s32k1xx_lpi2c_dma_command_configure(struct s32k1xx_lpi2c_priv_s
+                                    *priv, uint16_t *ccmd,
+                                     uint32_t ncmd)
+{
+  struct s32k1xx_edma_xfrconfig_s config;
+  memset(&config, 0, sizeof(config));
+
+  config.saddr  = (uint32_t) ccmd;
+  config.daddr  = priv->config->base + S32K1XX_LPI2C_MTDR_OFFSET;
+  config.soff   = sizeof(uint16_t);
+  config.doff   = 0;
+  config.iter   = 1;
+  config.flags  = EDMA_CONFIG_LINKTYPE_LINKNONE;
+  config.ssize  = EDMA_16BIT;
+  config.dsize  = EDMA_16BIT;
+  config.nbytes = sizeof(uint16_t) * ncmd;
+
+  up_clean_dcache((uintptr_t)config.saddr,
+                  (uintptr_t)config.saddr + config.nbytes);
+
+  return s32k1xx_dmach_xfrsetup(priv->txdma, &config);
+}
+#endif
+
+/****************************************************************************
+ * Name: s32k1xx_lpi2c_dma_data_configure
+ *
+ * Description:
+ *   Create a data TCD
+ *
+ ****************************************************************************/
+
+#ifdef CONFIG_S32K1XX_LPI2C_DMA
+static int s32k1xx_lpi2c_dma_data_configure(struct s32k1xx_lpi2c_priv_s
+                                              *priv,
+                                              struct i2c_msg_s *msg)
+{
+  DMACH_HANDLE dma;
+  struct s32k1xx_edma_xfrconfig_s config;
+  memset(&config, 0, sizeof(config));
+
+  config.iter   = msg->length;
+  config.flags  = EDMA_CONFIG_LINKTYPE_LINKNONE;
+  config.ssize  = EDMA_8BIT;
+  config.dsize  = EDMA_8BIT;
+  config.nbytes = sizeof(msg->buffer[0]);
+
+  if (msg->flags & I2C_M_READ)
+    {
+      dma           = priv->rxdma;
+      config.saddr  = priv->config->base + S32K1XX_LPI2C_MRDR_OFFSET;
+      config.daddr  = (uint32_t) msg->buffer;
+      config.soff   = 0;
+      config.doff   = sizeof(msg->buffer[0]);
+      up_invalidate_dcache((uintptr_t)msg->buffer,
+                           (uintptr_t)msg->buffer + msg->length);
+    }
+  else
+    {
+      dma           = priv->txdma;
+      config.saddr  = (uint32_t) msg->buffer;
+      config.daddr  = priv->config->base + S32K1XX_LPI2C_MTDR_OFFSET;
+      config.soff   = sizeof(msg->buffer[0]);
+      config.doff   = 0;
+      up_clean_dcache((uintptr_t)msg->buffer,
+                      (uintptr_t)msg->buffer + msg->length);
+    }
+
+  return s32k1xx_dmach_xfrsetup(dma, &config) ? 0 : msg->length;
+}
+#endif
+
+/****************************************************************************
+ * Name: s32k1xx_lpi2c_lpi2c_form_command_list
+ *
+ * Description:
+ *   Form the DMA command list
+ *
+ ****************************************************************************/
+
+#ifdef CONFIG_S32K1XX_LPI2C_DMA
+static int s32k1xx_lpi2c_form_command_list(struct s32k1xx_lpi2c_priv_s
+                                              *priv, struct i2c_msg_s *msg,
+                                              int ncmds)
+{
+  ssize_t length = 0;
+
+  if (priv->flags & I2C_M_NOSTART)
+    {
+      if (priv->flags & I2C_M_READ)
+        {
+          /* No start read operation */
+
+          priv->cmnds[ncmds++] = LPI2C_MTDR_CMD_RXD |
+                                 LPI2C_MTDR_DATA(msg->length - 1);
+        }
+    }
+  else
+    {
+      /* A start based read or write operation */
+
+      /* Create bus address with R/W */
+
+      uint16_t badd = (priv->flags & I2C_M_READ) ? I2C_READADDR8(msg->addr) :
+                                                   I2C_WRITEADDR8(msg->addr);
+
+      priv->cmnds[ncmds++] = LPI2C_MTDR_CMD_START | LPI2C_MTDR_DATA(badd);
+
+      if (badd & I2C_READBIT)
+        {
+          length =  msg->length;
+          while (length)
+            {
+              if (length > 256u)
+                {
+                  priv->cmnds[ncmds++] = LPI2C_MTDR_CMD_RXD |
+                                         LPI2C_MTDR_DATA(256u - 1);
+                  length -= 256u;
+                }
+              else
+                {
+                  priv->cmnds[ncmds++] = LPI2C_MTDR_CMD_RXD |
+                                         LPI2C_MTDR_DATA(length - 1);
+                  length = 0;
+                }
+            }
+        }
+    }
+
+  return ncmds;
+}
+#endif
+
+/****************************************************************************
+ * Name: s32k1xx_lpi2c_dma_transfer
+ *
+ * Description:
+ *   DMA based I2C transfer function
+ *
+ ****************************************************************************/
+
+#ifdef CONFIG_S32K1XX_LPI2C_DMA
+static int s32k1xx_lpi2c_dma_transfer(struct s32k1xx_lpi2c_priv_s *priv)
+{
+  int m;
+  int ntotcmds = 0;
+  int ncmds = 0;
+  uint16_t *ccmnd = NULL;
+
+  /* Disable Interrupts */
+
+  s32k1xx_lpi2c_putreg(priv, S32K1XX_LPI2C_MIER_OFFSET, 0);
+
+  /* Disable DMA */
+
+  s32k1xx_lpi2c_modifyreg(priv, S32K1XX_LPI2C_MDER_OFFSET, LPI2C_MDER_TDDE |
+                                                       LPI2C_MDER_RDDE, 0);
+
+  /* Enable AUTOSTOP and NAK Ignore */
+
+  s32k1xx_lpi2c_modifyreg(priv, S32K1XX_LPI2C_MCFGR1_OFFSET, 0,
+                          LPI2C_MCFGR1_IGNACK | LPI2C_MCFGR1_AUTOSTOP);
+
+  /* Form chains of tcd to process the messages */
+
+  for (m = 0; m < priv->msgc; m++)
+    {
+      ncmds = 0;
+      priv->flags = priv->msgv[m].flags;
+
+      /* Form a command list */
+
+      ccmnd = &priv->cmnds[ntotcmds];
+
+      ncmds = s32k1xx_lpi2c_form_command_list(priv, &priv->msgv[m],
+                                              ntotcmds);
+
+      /* Have commands for this message ? */
+
+      if (ncmds != 0)
+        {
+          /* Build up a TCD with the command from this message */
+
+          s32k1xx_lpi2c_dma_command_configure(priv, ccmnd, ncmds - ntotcmds);
+
+          ntotcmds += ncmds;
+
+          DEBUGASSERT(ntotcmds < CONFIG_S32K1XX_LPI2C_DMA_MAXMSG);
+
+          s32k1xx_lpi2c_dma_data_configure(priv, &priv->msgv[m]);
+        }
+    }
+
+  /* Clear the TX and RX FIFOs */
+
+  s32k1xx_lpi2c_modifyreg(priv, S32K1XX_LPI2C_MCR_OFFSET, 0,
+                          LPI2C_MCR_RTF | LPI2C_MCR_RRF);
+
+  /* Reset the Error bits */
+
+  s32k1xx_lpi2c_putreg(priv, S32K1XX_LPI2C_MSR_OFFSET, LPI2C_MSR_NDF |
+                                                       LPI2C_MSR_ALF |
+                                                       LPI2C_MSR_FEF);
+
+  /* Enable the Iterrupts */
+
+  s32k1xx_lpi2c_putreg(priv, S32K1XX_LPI2C_MIER_OFFSET,
+                     LPI2C_MIER_NDIE | LPI2C_MIER_ALIE |
+                     LPI2C_MIER_PLTIE);
+
+  /* Start The DMA */
+
+  s32k1xx_dmach_start(priv->rxdma, s32k1xx_rxdma_callback, (void *)priv);
+  s32k1xx_dmach_start(priv->txdma, s32k1xx_txdma_callback, (void *)priv);
+
+  /* Enable the DMA Request */
+
+  s32k1xx_lpi2c_modifyreg(priv, S32K1XX_LPI2C_MDER_OFFSET, 0,
+                          LPI2C_MDER_TDDE | LPI2C_MDER_RDDE);
+  return OK;
+}
+#endif
+
 /****************************************************************************
  * Name: s32k1xx_lpi2c_transfer
  *
@@ -1504,6 +1919,9 @@ static int s32k1xx_lpi2c_transfer(struct i2c_master_s *dev,
 {
   struct s32k1xx_lpi2c_priv_s *priv = (struct s32k1xx_lpi2c_priv_s *)dev;
   int ret;
+#ifdef CONFIG_S32K1XX_LPI2C_DMA
+  int m;
+#endif
 
   DEBUGASSERT(count > 0);
 
@@ -1544,14 +1962,39 @@ static int s32k1xx_lpi2c_transfer(struct i2c_master_s *dev,
 
   priv->status = 0;
 
-  /* Wait for ISR. If there was a timeout, fetch latest status to get
+  /* Signal the interrupt handler that we are waiting.  NOTE:  Interrupts
+   * are currently disabled but will be temporarily re-enabled below when
+   * nxsem_tickwait_uninterruptible() sleeps.
+   */
+
+  priv->intstate = INTSTATE_WAITING;
+
+  /* Wait for an ISR, if there was a timeout, fetch latest status to get
    * the BUSY flag.
    */
 
+#ifdef CONFIG_S32K1XX_LPI2C_DMA
+  if (priv->rxdma || priv->txdma)
+    {
+      s32k1xx_lpi2c_dma_transfer(priv);
+    }
+#endif
+
   if (s32k1xx_lpi2c_sem_waitdone(priv) < 0)
     {
-      ret = -ETIMEDOUT;
+#ifdef CONFIG_S32K1XX_LPI2C_DMA
+    if (priv->rxdma != NULL)
+      {
+        s32k1xx_dmach_stop(priv->rxdma);
+      }
 
+    if (priv->txdma != NULL)
+      {
+        s32k1xx_dmach_stop(priv->txdma);
+      }
+
+#endif
+      ret = -ETIMEDOUT;
       i2cerr("ERROR: Timed out: MCR: status: 0x%" PRIx32 "\n", priv->status);
     }
 
@@ -1582,6 +2025,18 @@ static int s32k1xx_lpi2c_transfer(struct i2c_master_s *dev,
           i2cerr("Transfer without start condition\n");
           ret = -EINVAL;
         }
+
+        /* TODO fix in a better way if stuck and I2C won't work anymore */
+
+        /* In case the I2C peripheral is stuck, reset it */
+
+        /* De-init the port */
+
+        s32k1xx_lpi2c_deinit(priv);
+
+        /* Re-init the port */
+
+        s32k1xx_lpi2c_init(priv);
     }
 
   /* Dump the trace result */
@@ -1595,6 +2050,20 @@ static int s32k1xx_lpi2c_transfer(struct i2c_master_s *dev,
   priv->dcnt = 0;
   priv->ptr = NULL;
 
+#ifdef CONFIG_S32K1XX_LPI2C_DMA
+  if (priv->rxdma)
+    {
+      for (m = 0; m < count; m++)
+        {
+          if (msgs[m].flags & I2C_M_READ)
+            {
+            up_invalidate_dcache((uintptr_t)msgs[m].buffer,
+                                (uintptr_t)msgs[m].buffer + msgs[m].length);
+            }
+        }
+    }
+#endif
+
   s32k1xx_lpi2c_sem_post(priv);
   return ret;
 }
@@ -1787,6 +2256,22 @@ struct i2c_master_s *s32k1xx_i2cbus_initialize(int port)
     {
       s32k1xx_lpi2c_sem_init(priv);
       s32k1xx_lpi2c_init(priv);
+
+#ifdef CONFIG_S32K1XX_LPI2C_DMA
+      if (priv->config->dma_txreqsrc != 0)
+        {
+          priv->txdma = s32k1xx_dmach_alloc(priv->config->dma_txreqsrc |
+                                        DMAMUX_CHCFG_ENBL, 0);
+          DEBUGASSERT(priv->txdma != NULL);
+        }
+
+      if (priv->config->dma_rxreqsrc != 0)
+        {
+          priv->rxdma = s32k1xx_dmach_alloc(priv->config->dma_rxreqsrc |
+                                        DMAMUX_CHCFG_ENBL, 0);
+          DEBUGASSERT(priv->rxdma != NULL);
+        }
+#endif
     }
 
   leave_critical_section(flags);
@@ -1828,6 +2313,22 @@ int s32k1xx_i2cbus_uninitialize(struct i2c_master_s *dev)
 
   /* Disable power and other HW resource (GPIO's) */
 
+#ifdef CONFIG_S32K1XX_LPI2C_DMA
+  if (priv->rxdma != NULL)
+    {
+      s32k1xx_dmach_stop(priv->rxdma);
+      s32k1xx_dmach_free(priv->rxdma);
+      priv->rxdma = NULL;
+    }
+
+  if (priv->txdma != NULL)
+    {
+      s32k1xx_dmach_stop(priv->txdma);
+      s32k1xx_dmach_free(priv->txdma);
+      priv->txdma = NULL;
+    }
+#endif
+
   s32k1xx_lpi2c_deinit(priv);
 
   /* Release unused resources */
diff --git a/arch/arm/src/s32k1xx/s32k1xx_lpspi.c b/arch/arm/src/s32k1xx/s32k1xx_lpspi.c
index 1fc9e2b412..ff6b12a7dd 100644
--- a/arch/arm/src/s32k1xx/s32k1xx_lpspi.c
+++ b/arch/arm/src/s32k1xx/s32k1xx_lpspi.c
@@ -77,6 +77,11 @@
 #include "s32k1xx_periphclocks.h"
 #include "s32k1xx_lpspi.h"
 
+#ifdef CONFIG_S32K1XX_LPSPI_DMA
+#  include "hardware/s32k1xx_dmamux.h"
+#  include "s32k1xx_edma.h"
+#endif
+
 #include <arch/board/board.h>
 
 #if defined(CONFIG_S32K1XX_LPSPI0) || defined(CONFIG_S32K1XX_LPSPI1) || \
@@ -94,16 +99,15 @@
 #  error "Interrupt driven SPI not yet supported"
 #endif
 
-#if defined(CONFIG_S32K1XX_LPSPI_DMA)
-#  error "DMA mode is not yet supported"
-#endif
-
 /* Can't have both interrupt driven SPI and SPI DMA */
 
 #if defined(CONFIG_S32K1XX_LPSPI_INTERRUPTS) && defined(CONFIG_S32K1XX_LPSPI_DMA)
 #  error "Cannot enable both interrupt mode and DMA mode for SPI"
 #endif
 
+#define  SPI_SR_CLEAR   (LPSPI_SR_WCF | LPSPI_SR_FCF | LPSPI_SR_TCF  | \
+                         LPSPI_SR_TEF | LPSPI_SR_REF | LPSPI_SR_DMF)
+
 /* Power management definitions */
 
 #if defined(CONFIG_PM) && !defined(CONFIG_S32K1XX_PM_SPI_ACTIVITY)
@@ -136,6 +140,16 @@ struct s32k1xx_lpspidev_s
 #ifdef CONFIG_S32K1XX_LPSPI_HWPCS
   uint32_t pcs;               /* Peripheral Chip Select currently used */
 #endif
+#ifdef CONFIG_S32K1XX_LPSPI_DMA
+  volatile uint32_t rxresult;   /* Result of the RX DMA */
+  volatile uint32_t txresult;   /* Result of the TX DMA */
+  const uint16_t    rxch;       /* The RX DMA channel number */
+  const uint16_t    txch;       /* The TX DMA channel number */
+  DMACH_HANDLE      rxdma;      /* DMA channel handle for RX transfers */
+  DMACH_HANDLE      txdma;      /* DMA channel handle for TX transfers */
+  sem_t             rxsem;      /* Wait for RX DMA to complete */
+  sem_t             txsem;      /* Wait for TX DMA to complete */
+#endif
 };
 
 enum s32k1xx_delay_e
@@ -174,6 +188,21 @@ void s32k1xx_lpspi_set_delay_scaler(struct s32k1xx_lpspidev_s *priv,
                                     uint32_t scaler,
                                     enum s32k1xx_delay_e type);
 
+/* DMA support */
+
+#ifdef CONFIG_S32K1XX_LPSPI_DMA
+static int         spi_dmarxwait(struct s32k1xx_lpspidev_s *priv);
+static int         spi_dmatxwait(struct s32k1xx_lpspidev_s *priv);
+static inline void spi_dmarxwakeup(struct s32k1xx_lpspidev_s *priv);
+static inline void spi_dmatxwakeup(struct s32k1xx_lpspidev_s *priv);
+static void        spi_dmarxcallback(DMACH_HANDLE handle, void *arg,
+                                     bool done, int result);
+static void        spi_dmatxcallback(DMACH_HANDLE handle, void *arg,
+                                     bool done, int result);
+static inline void spi_dmarxstart(struct s32k1xx_lpspidev_s *priv);
+static inline void spi_dmatxstart(struct s32k1xx_lpspidev_s *priv);
+#endif
+
 /* SPI methods */
 
 static int s32k1xx_lpspi_lock(struct spi_dev_s *dev, bool lock);
@@ -260,9 +289,9 @@ static struct s32k1xx_lpspidev_s g_lpspi0dev =
 #ifdef CONFIG_S32K1XX_LPSPI_INTERRUPTS
   .spiirq       = S32K1XX_IRQ_LPSPI0,
 #endif
-#ifdef CONFIG_S32K1XX_LPSPI_DMA
-  .rxch         = DMAMAP_LPSPI0_RX,
-  .txch         = DMAMAP_LPSPI0_TX,
+#ifdef CONFIG_S32K1XX_LPSPI0_DMA
+  .rxch         = S32K1XX_DMACHAN_LPSPI0_RX,
+  .txch         = S32K1XX_DMACHAN_LPSPI0_TX,
 #endif
 };
 #endif
@@ -310,9 +339,9 @@ static struct s32k1xx_lpspidev_s g_lpspi1dev =
 #ifdef CONFIG_S32K1XX_LPSPI_INTERRUPTS
   .spiirq       = S32K1XX_IRQ_LPSPI1,
 #endif
-#ifdef CONFIG_S32K1XX_LPSPI_DMA
-  .rxch         = DMAMAP_LPSPI1_RX,
-  .txch         = DMAMAP_LPSPI1_TX,
+#ifdef CONFIG_S32K1XX_LPSPI1_DMA
+  .rxch         = S32K1XX_DMACHAN_LPSPI1_RX,
+  .txch         = S32K1XX_DMACHAN_LPSPI1_TX,
 #endif
 };
 #endif
@@ -360,9 +389,9 @@ static struct s32k1xx_lpspidev_s g_lpspi2dev =
 #ifdef CONFIG_S32K1XX_LPSPI_INTERRUPTS
   .spiirq       = S32K1XX_IRQ_LPSPI2,
 #endif
-#ifdef CONFIG_S32K1XX_LPSPI_DMA
-  .rxch         = DMAMAP_LPSPI2_RX,
-  .txch         = DMAMAP_LPSPI2_TX,
+#ifdef CONFIG_S32K1XX_LPSPI2_DMA
+  .rxch         = S32K1XX_DMACHAN_LPSPI2_RX,
+  .txch         = S32K1XX_DMACHAN_LPSPI3_TX,
 #endif
 };
 #endif
@@ -637,8 +666,8 @@ void s32k1xx_lpspi_writebyte(struct s32k1xx_lpspidev_s *priv,
  *
  ****************************************************************************/
 
-static inline uint16_t s32k1xx_lpspi_9to16bitmode(
-    struct s32k1xx_lpspidev_s *priv)
+static inline uint16_t
+  s32k1xx_lpspi_9to16bitmode(struct s32k1xx_lpspidev_s *priv)
 {
   uint16_t ret;
 
@@ -1024,7 +1053,6 @@ static uint32_t s32k1xx_lpspi_setfrequency(struct spi_dev_s *dev,
   struct s32k1xx_lpspidev_s *priv = (struct s32k1xx_lpspidev_s *)dev;
 
   uint32_t men;
-  uint32_t regval;
   uint32_t inclock;
   uint32_t prescaler;
   uint32_t best_prescaler;
@@ -1088,14 +1116,9 @@ static uint32_t s32k1xx_lpspi_setfrequency(struct spi_dev_s *dev,
 
       /* Write the best values in the CCR register */
 
-      regval = s32k1xx_lpspi_getreg32(priv, S32K1XX_LPSPI_CCR_OFFSET);
-      regval &= ~LPSPI_CCR_SCKDIV_MASK;
-      regval |= LPSPI_CCR_SCKDIV(best_scaler);
-      s32k1xx_lpspi_putreg32(priv, S32K1XX_LPSPI_CCR_OFFSET, regval);
-
       s32k1xx_lpspi_modifyreg32(priv, S32K1XX_LPSPI_TCR_OFFSET,
-                              LPSPI_TCR_PRESCALE_MASK,
-                              LPSPI_TCR_PRESCALE(best_prescaler));
+                                LPSPI_TCR_PRESCALE_MASK,
+                                LPSPI_TCR_PRESCALE(best_prescaler));
 
       priv->frequency = frequency;
       priv->actual = best_frequency;
@@ -1105,7 +1128,11 @@ static uint32_t s32k1xx_lpspi_setfrequency(struct spi_dev_s *dev,
       s32k1xx_lpspi_set_delays(priv, 1000000000 / best_frequency,
                                     LPSPI_LAST_SCK_TO_PCS);
       s32k1xx_lpspi_set_delays(priv, 1000000000 / best_frequency,
-                                    LPSPI_BETWEEN_TRANSFER);
+                               LPSPI_BETWEEN_TRANSFER);
+
+      s32k1xx_lpspi_modifyreg32(priv, S32K1XX_LPSPI_CCR_OFFSET,
+                                LPSPI_CCR_SCKDIV_MASK,
+                                LPSPI_CCR_SCKDIV(best_scaler));
 
       /* Re-enable LPSPI if it was enabled previously */
 
@@ -1453,7 +1480,6 @@ static uint32_t s32k1xx_lpspi_send_dword(struct spi_dev_s *dev,
  *
  ****************************************************************************/
 
-#if !defined(CONFIG_S32K1XX_LPSPI_DMA) || defined(CONFIG_S32K1XX_DMACAPABLE)
 #if !defined(CONFIG_S32K1XX_LPSPI_DMA)
 static void s32k1xx_lpspi_exchange(struct spi_dev_s *dev,
                                    const void *txbuffer,
@@ -1710,7 +1736,151 @@ static void s32k1xx_lpspi_exchange_nodma(struct spi_dev_s *dev,
         }
     }
 }
-#endif /* !CONFIG_S32K1XX_LPSPI_DMA || CONFIG_S32K1XX_DMACAPABLE */
+
+/****************************************************************************
+ * Name: spi_exchange (with DMA capability)
+ *
+ * Description:
+ *   Exchange a block of data on SPI using DMA
+ *
+ * Input Parameters:
+ *   dev      - Device-specific state data
+ *   txbuffer - A pointer to the buffer of data to be sent
+ *   rxbuffer - A pointer to a buffer in which to receive data
+ *   nwords   - the length of data to be exchanged in units of words.
+ *              The wordsize is determined by the number of bits-per-word
+ *              selected for the SPI interface.  If nbits <= 8, the data is
+ *              packed into uint8_t's; if nbits > 8, the data is packed into
+ *              uint16_t's
+ *
+ * Returned Value:
+ *   None
+ *
+ ****************************************************************************/
+
+#ifdef CONFIG_S32K1XX_LPSPI_DMA
+static void s32k1xx_lpspi_exchange(struct spi_dev_s *dev,
+                                   const void *txbuffer, void *rxbuffer,
+                                   size_t nwords)
+{
+  int                       ret;
+  size_t                    adjust;
+  ssize_t                   nbytes;
+  static uint8_t            rxdummy[4] aligned_data(4);
+  static const uint16_t     txdummy = 0xffff;
+  uint32_t                  regval;
+  struct s32k1xx_lpspidev_s *priv = (struct s32k1xx_lpspidev_s *)dev;
+
+  DEBUGASSERT(priv != NULL);
+  DEBUGASSERT(priv && priv->spibase);
+  spiinfo("txbuffer=%p rxbuffer=%p nwords=%d\n", txbuffer, rxbuffer, nwords);
+
+  /* Convert the number of word to a number of bytes */
+
+  nbytes = (priv->nbits > 8) ? nwords << 2 : nwords;
+
+  /* Invalid DMA channels fall back to non-DMA method. */
+
+  if (priv->rxdma == NULL || priv->txdma == NULL
+#ifdef CONFIG_S32K1XX_LPSPI_DMATHRESHOLD
+      /* If this is a small SPI transfer, then let
+       * s32k1xx_lpspi_exchange_nodma() do the work.
+       */
+
+      || nbytes <= CONFIG_S32K1XX_LPSPI_DMATHRESHOLD
+#endif
+      )
+    {
+      s32k1xx_lpspi_exchange_nodma(dev, txbuffer, rxbuffer, nwords);
+      return;
+    }
+
+  /* ERR050456 workaround: Reset FIFOs using CR[RST] bit */
+
+  regval = s32k1xx_lpspi_getreg32(priv, S32K1XX_LPSPI_CFGR1_OFFSET);
+
+  s32k1xx_lpspi_modifyreg32(priv, S32K1XX_LPSPI_CR_OFFSET,
+                            LPSPI_CR_RTF | LPSPI_CR_RRF,
+                            LPSPI_CR_RTF | LPSPI_CR_RRF);
+
+  s32k1xx_lpspi_putreg32(priv, S32K1XX_LPSPI_CFGR1_OFFSET, regval);
+
+  /* Clear all status bits */
+
+  s32k1xx_lpspi_putreg32(priv, S32K1XX_LPSPI_SR_OFFSET, SPI_SR_CLEAR);
+
+  /* disable DMA */
+
+  s32k1xx_lpspi_putreg32(priv, S32K1XX_LPSPI_DER_OFFSET, 0);
+
+  /* Set up the DMA */
+
+  adjust = (priv->nbits > 8) ? 2 : 1;
+
+  struct s32k1xx_edma_xfrconfig_s config;
+
+  config.saddr  = priv->spibase + S32K1XX_LPSPI_RDR_OFFSET;
+  config.daddr  = (uint32_t)(rxbuffer ? rxbuffer : rxdummy);
+  config.soff   = 0;
+  config.doff   = rxbuffer ? adjust : 0;
+  config.iter   = nbytes;
+  config.flags  = EDMA_CONFIG_LINKTYPE_LINKNONE;
+  config.ssize  = adjust == 1 ? EDMA_8BIT : EDMA_16BIT;
+  config.dsize  = adjust == 1 ? EDMA_8BIT : EDMA_16BIT;
+  config.nbytes = adjust;
+#ifdef CONFIG_KINETIS_EDMA_ELINK
+  config.linkch = NULL;
+#endif
+  s32k1xx_dmach_xfrsetup(priv->rxdma, &config);
+
+  config.saddr  = (uint32_t) (txbuffer ? txbuffer : &txdummy);
+  config.daddr  = priv->spibase + S32K1XX_LPSPI_TDR_OFFSET;
+  config.soff   = txbuffer ? adjust : 0;
+  config.doff   = 0;
+  config.iter   = nbytes;
+  config.flags  = EDMA_CONFIG_LINKTYPE_LINKNONE;
+  config.ssize  = adjust == 1 ? EDMA_8BIT : EDMA_16BIT;
+  config.dsize  = adjust == 1 ? EDMA_8BIT : EDMA_16BIT;
+  config.nbytes = adjust;
+#ifdef CONFIG_KINETIS_EDMA_ELINK
+  config.linkch = NULL;
+#endif
+  s32k1xx_dmach_xfrsetup(priv->txdma, &config);
+
+  /* Start the DMAs */
+
+  spi_dmarxstart(priv);
+  spi_dmatxstart(priv);
+
+  /* Invoke SPI DMA */
+
+  s32k1xx_lpspi_modifyreg32(priv, S32K1XX_LPSPI_DER_OFFSET,
+                            0, LPSPI_DER_TDDE | LPSPI_DER_RDDE);
+
+  /* Then wait for each to complete */
+
+  ret = spi_dmatxwait(priv);
+
+  if (ret < 0)
+    {
+      ret = spi_dmarxwait(priv);
+    }
+
+  /* Reset any status */
+
+  s32k1xx_lpspi_putreg32(priv, S32K1XX_LPSPI_SR_OFFSET,
+                         s32k1xx_lpspi_getreg32(priv,
+                                                S32K1XX_LPSPI_SR_OFFSET));
+
+  /* Disable DMA */
+
+  s32k1xx_lpspi_putreg32(priv, S32K1XX_LPSPI_DER_OFFSET, 0);
+
+  up_invalidate_dcache((uintptr_t)rxbuffer,
+                       (uintptr_t)rxbuffer + nbytes);
+}
+
+#endif  /* CONFIG_S32K1XX_SPI_DMA */
 
 /****************************************************************************
  * Name: s32k1xx_lpspi_sndblock
@@ -2017,6 +2187,174 @@ static void up_pm_notify(struct pm_callback_s *cb, int domain,
 }
 #endif
 
+/****************************************************************************
+ * Name: spi_dmarxwait
+ *
+ * Description:
+ *   Wait for DMA to complete.
+ *
+ ****************************************************************************/
+
+#ifdef CONFIG_S32K1XX_LPSPI_DMA
+static int spi_dmarxwait(struct s32k1xx_lpspidev_s *priv)
+{
+  int ret;
+
+  /* Take the semaphore (perhaps waiting).  If the result is zero, then the
+   *  DMA must not really have completed.
+   */
+
+  do
+    {
+      ret = nxsem_wait_uninterruptible(&priv->rxsem);
+
+      /* The only expected error is ECANCELED which would occur if the
+       * calling thread were canceled.
+       */
+
+      DEBUGASSERT(ret == OK || ret == -ECANCELED);
+    }
+  while (priv->rxresult == 0 && ret == OK);
+
+  return ret;
+}
+#endif
+
+/****************************************************************************
+ * Name: spi_dmatxwait
+ *
+ * Description:
+ *   Wait for DMA to complete.
+ *
+ ****************************************************************************/
+
+#ifdef CONFIG_S32K1XX_LPSPI_DMA
+static int spi_dmatxwait(struct s32k1xx_lpspidev_s *priv)
+{
+  int ret;
+
+  /* Take the semaphore (perhaps waiting).  If the result is zero, then the
+   * DMA must not really have completed.
+   */
+
+  do
+    {
+      ret = nxsem_wait_uninterruptible(&priv->txsem);
+
+      /* The only expected error is ECANCELED which would occur if the
+       * calling thread were canceled.
+       */
+
+      DEBUGASSERT(ret == OK || ret == -ECANCELED);
+    }
+  while (priv->txresult == 0 && ret == OK);
+
+  return ret;
+}
+#endif
+
+/****************************************************************************
+ * Name: spi_dmarxwakeup
+ *
+ * Description:
+ *   Signal that DMA is complete
+ *
+ ****************************************************************************/
+
+#ifdef CONFIG_S32K1XX_LPSPI_DMA
+static inline void spi_dmarxwakeup(struct s32k1xx_lpspidev_s *priv)
+{
+  nxsem_post(&priv->rxsem);
+}
+#endif
+
+/****************************************************************************
+ * Name: spi_dmatxwakeup
+ *
+ * Description:
+ *   Signal that DMA is complete
+ *
+ ****************************************************************************/
+
+#ifdef CONFIG_S32K1XX_LPSPI_DMA
+static inline void spi_dmatxwakeup(struct s32k1xx_lpspidev_s *priv)
+{
+  nxsem_post(&priv->txsem);
+}
+#endif
+
+/****************************************************************************
+ * Name: spi_dmarxcallback
+ *
+ * Description:
+ *   Called when the RX DMA completes
+ *
+ ****************************************************************************/
+
+#ifdef CONFIG_S32K1XX_LPSPI_DMA
+static void spi_dmarxcallback(DMACH_HANDLE handle, void *arg, bool done,
+                              int result)
+{
+  struct s32k1xx_lpspidev_s *priv = (struct s32k1xx_lpspidev_s *)arg;
+
+  priv->rxresult = result | 0x80000000;  /* assure non-zero */
+  spi_dmarxwakeup(priv);
+}
+#endif
+
+/****************************************************************************
+ * Name: spi_dmatxcallback
+ *
+ * Description:
+ *   Called when the RX DMA completes
+ *
+ ****************************************************************************/
+
+#ifdef CONFIG_S32K1XX_LPSPI_DMA
+static void spi_dmatxcallback(DMACH_HANDLE handle, void *arg, bool done,
+                              int result)
+{
+  struct s32k1xx_lpspidev_s *priv = (struct s32k1xx_lpspidev_s *)arg;
+
+  /* Wake-up the SPI driver */
+
+  priv->txresult = result | 0x80000000;  /* assure non-zero */
+  spi_dmatxwakeup(priv);
+}
+#endif
+
+/****************************************************************************
+ * Name: spi_dmarxstart
+ *
+ * Description:
+ *   Start RX DMA
+ *
+ ****************************************************************************/
+
+#ifdef CONFIG_S32K1XX_LPSPI_DMA
+static inline void spi_dmarxstart(struct s32k1xx_lpspidev_s *priv)
+{
+  priv->rxresult = 0;
+  s32k1xx_dmach_start(priv->rxdma, spi_dmarxcallback, priv);
+}
+#endif
+
+/****************************************************************************
+ * Name: spi_dmatxstart
+ *
+ * Description:
+ *   Start TX DMA
+ *
+ ****************************************************************************/
+
+#ifdef CONFIG_S32K1XX_LPSPI_DMA
+static inline void spi_dmatxstart(struct s32k1xx_lpspidev_s *priv)
+{
+  priv->txresult = 0;
+  s32k1xx_dmach_start(priv->txdma, spi_dmatxcallback, priv);
+}
+#endif
+
 /****************************************************************************
  * Name: up_pm_prepare
  *
@@ -2139,7 +2477,7 @@ static int up_pm_prepare(struct pm_callback_s *cb, int domain,
 
       count++;
 
-# endif     
+# endif
     }
     break;
 
@@ -2278,7 +2616,7 @@ struct spi_dev_s *s32k1xx_lpspibus_initialize(int bus)
   if (bus == 1)
     {
       #ifdef CONFIG_PM
-        #if defined(CONFIG_PM_SPI_STANDBY) || defined(CONFIG_PM_SPI_SLEEP) 
+        #if defined(CONFIG_PM_SPI_STANDBY) || defined(CONFIG_PM_SPI_SLEEP)
           int ret;
 
           /* Register to receive power management callbacks */
@@ -2339,6 +2677,36 @@ struct spi_dev_s *s32k1xx_lpspibus_initialize(int bus)
       spierr("ERROR: Unsupported SPI bus: %d\n", bus);
     }
 
+#ifdef CONFIG_S32K1XX_LPSPI_DMA
+  /* Initialize the SPI semaphores that is used to wait for DMA completion.
+   * This semaphore is used for signaling and, hence, should not have
+   * priority inheritance enabled.
+   */
+
+  if (priv->rxch && priv->txch)
+    {
+      if (priv->txdma == NULL && priv->rxdma == NULL)
+        {
+          nxsem_init(&priv->rxsem, 0, 0);
+          nxsem_init(&priv->txsem, 0, 0);
+
+          nxsem_set_protocol(&priv->rxsem, SEM_PRIO_NONE);
+          nxsem_set_protocol(&priv->txsem, SEM_PRIO_NONE);
+
+          priv->txdma = s32k1xx_dmach_alloc(priv->txch | DMAMUX_CHCFG_ENBL,
+                                            0);
+          priv->rxdma = s32k1xx_dmach_alloc(priv->rxch | DMAMUX_CHCFG_ENBL,
+                                            0);
+          DEBUGASSERT(priv->rxdma && priv->txdma);
+        }
+    }
+  else
+    {
+      priv->rxdma = NULL;
+      priv->txdma = NULL;
+    }
+#endif
+
   leave_critical_section(flags);
 
   return (struct spi_dev_s *)priv;
diff --git a/arch/arm/src/s32k1xx/s32k1xx_pminitialize.c b/arch/arm/src/s32k1xx/s32k1xx_pminitialize.c
index 99278d24e5..4aa4ef9d0d 100644
--- a/arch/arm/src/s32k1xx/s32k1xx_pminitialize.c
+++ b/arch/arm/src/s32k1xx/s32k1xx_pminitialize.c
@@ -25,6 +25,7 @@
 #include <nuttx/config.h>
 #include <nuttx/power/pm.h>
 
+#include "s32k1xx_clockconfig.h"
 #include "arm_internal.h"
 
 #ifdef CONFIG_PM
@@ -56,6 +57,10 @@ void arm_pminitialize(void)
   /* Initialize the NuttX power management subsystem proper */
 
   pm_initialize();
+
+  /* Register clockconfig first to receive power management callbacks */
+
+  s32k1xx_clock_pm_register();
 }
 
 #endif /* CONFIG_PM */
diff --git a/arch/arm/src/s32k1xx/s32k1xx_serial.c b/arch/arm/src/s32k1xx/s32k1xx_serial.c
index e113182b28..513a6431cf 100644
--- a/arch/arm/src/s32k1xx/s32k1xx_serial.c
+++ b/arch/arm/src/s32k1xx/s32k1xx_serial.c
@@ -50,10 +50,13 @@
 #include "chip.h"
 #include "arm_internal.h"
 #include "hardware/s32k1xx_lpuart.h"
+#include "s32k1xx_edma.h"
+#include "hardware/s32k1xx_dmamux.h"
 #include "hardware/s32k1xx_pinmux.h"
 #include "s32k1xx_config.h"
 #include "s32k1xx_pin.h"
 #include "s32k1xx_lowputc.h"
+#include "s32k1xx_serial.h"
 
 #include "s32k1xx_periphclocks.h"
 
@@ -71,27 +74,45 @@
 /* First pick the console and ttys0.  This could be any of LPUART0-2 */
 
 #if defined(CONFIG_LPUART0_SERIAL_CONSOLE)
-#  define CONSOLE_DEV         g_uart0port /* LPUART0 is console */
-#  define TTYS0_DEV           g_uart0port /* LPUART0 is ttyS0 */
+#  define CONSOLE_DEV         g_lpuart0priv /* LPUART0 is console */
+#  define TTYS0_DEV           g_lpuart0priv /* LPUART0 is ttyS0 */
 #  define UART1_ASSIGNED      1
+#  if defined(CONFIG_LPUART0_RXDMA)
+#    define SERIAL_HAVE_CONSOLE_RXDMA 1
+#  endif
+#  if defined(CONFIG_LPUART0_TXDMA)
+#    define SERIAL_HAVE_CONSOLE_TXDMA 1
+#  endif
 #elif defined(CONFIG_LPUART1_SERIAL_CONSOLE)
-#  define CONSOLE_DEV         g_uart1port /* LPUART1 is console */
-#  define TTYS0_DEV           g_uart1port /* LPUART1 is ttyS0 */
+#  define CONSOLE_DEV         g_lpuart1priv /* LPUART1 is console */
+#  define TTYS0_DEV           g_lpuart1priv /* LPUART1 is ttyS0 */
 #  define UART2_ASSIGNED      1
+#  if defined(CONFIG_LPUART1_RXDMA)
+#    define SERIAL_HAVE_CONSOLE_RXDMA 1
+#  endif
+#  if defined(CONFIG_LPUART1_TXDMA)
+#    define SERIAL_HAVE_CONSOLE_TXDMA 1
+#  endif
 #elif defined(CONFIG_LPUART2_SERIAL_CONSOLE)
-#  define CONSOLE_DEV         g_uart2port /* LPUART2 is console */
-#  define TTYS0_DEV           g_uart2port /* LPUART2 is ttyS0 */
-#  define UART3_ASSIGNED      1
+#  define CONSOLE_DEV         g_lpuart2priv /* LPUART2 is console */
+#  define TTYS0_DEV           g_lpuart2priv /* LPUART2 is ttyS0 */
+#  define UART2_ASSIGNED      1
+#  if defined(CONFIG_LPUART2_RXDMA)
+#    define SERIAL_HAVE_CONSOLE_RXDMA 1
+#  endif
+#  if defined(CONFIG_LPUART2_TXDMA)
+#    define SERIAL_HAVE_CONSOLE_TXDMA 1
+#  endif
 #else
 #  undef CONSOLE_DEV                      /* No console */
 #  if defined(CONFIG_S32K1XX_LPUART0)
-#    define TTYS0_DEV         g_uart0port /* LPUART0 is ttyS0 */
+#    define TTYS0_DEV         g_lpuart0priv /* LPUART0 is ttyS0 */
 #    define UART1_ASSIGNED    1
 #  elif defined(CONFIG_S32K1XX_LPUART1)
-#    define TTYS0_DEV         g_uart1port /* LPUART1 is ttyS0 */
+#    define TTYS0_DEV         g_lpuart1priv /* LPUART1 is ttyS0 */
 #    define UART2_ASSIGNED    1
 #  elif defined(CONFIG_S32K1XX_LPUART2)
-#    define TTYS0_DEV         g_uart2port /* LPUART2 is ttyS0 */
+#    define TTYS0_DEV         g_lpuart2priv /* LPUART2 is ttyS0 */
 #    define UART3_ASSIGNED    1
 #  endif
 #endif
@@ -102,26 +123,30 @@
  */
 
 #if defined(CONFIG_S32K1XX_LPUART0) && !defined(UART1_ASSIGNED)
-#  define TTYS1_DEV           g_uart0port /* LPUART0 is ttyS1 */
+#  define TTYS1_DEV           g_lpuart0priv /* LPUART0 is ttyS1 */
 #  define UART1_ASSIGNED      1
 #elif defined(CONFIG_S32K1XX_LPUART1) && !defined(UART2_ASSIGNED)
-#  define TTYS1_DEV           g_uart1port /* LPUART1 is ttyS1 */
+#  define TTYS1_DEV           g_lpuart1priv /* LPUART1 is ttyS1 */
 #  define UART2_ASSIGNED      1
 #elif defined(CONFIG_S32K1XX_LPUART2) && !defined(UART3_ASSIGNED)
-#  define TTYS1_DEV           g_uart2port /* LPUART2 is ttyS1 */
+#  define TTYS1_DEV           g_lpuart2priv /* LPUART2 is ttyS1 */
 #  define UART3_ASSIGNED      1
 #endif
 
+#if defined(SERIAL_HAVE_CONSOLE_RXDMA) || defined(SERIAL_HAVE_CONSOLE_TXDMA)
+#  define SERIAL_HAVE_CONSOLE_DMA
+#endif
+
 /* Pick ttys2.  This could be one of LPUART0-2. It can't be LPUART0 because
  * that was either assigned as ttyS0 or ttys1.  One of LPUART0-2 could be the
  * console.  One of UART1-2 has already been assigned to ttys0 or ttyS1.
  */
 
 #if defined(CONFIG_S32K1XX_LPUART1) && !defined(UART2_ASSIGNED)
-#  define TTYS2_DEV           g_uart1port /* LPUART1 is ttyS2 */
+#  define TTYS2_DEV           g_lpuart1priv /* LPUART1 is ttyS2 */
 #  define UART2_ASSIGNED      1
 #elif defined(CONFIG_S32K1XX_LPUART2) && !defined(UART3_ASSIGNED)
-#  define TTYS2_DEV           g_uart2port /* LPUART2 is ttyS2 */
+#  define TTYS2_DEV           g_lpuart2priv /* LPUART2 is ttyS2 */
 #  define UART3_ASSIGNED      1
 #endif
 
@@ -140,12 +165,20 @@
 #if defined(CONFIG_PM_SERIAL2_STANDBY) || defined(CONFIG_PM_SERIAL2_SLEEP)
 #   define CONFIG_PM_SERIAL2
 #endif
+
+#if !defined(CONFIG_S32K1XX_SERIAL_RXDMA_BUFFER_SIZE)
+#  define CONFIG_S32K1XX_SERIAL_RXDMA_BUFFER_SIZE 32
+#endif
+
+#define RXDMA_BUFFER_SIZE   CONFIG_S32K1XX_SERIAL_RXDMA_BUFFER_SIZE
+
 /****************************************************************************
  * Private Types
  ****************************************************************************/
 
 struct s32k1xx_uart_s
 {
+  struct uart_dev_s dev;    /* Generic UART device */
   uint32_t uartbase;        /* Base address of UART registers */
   uint32_t baud;            /* Configured baud */
   uint32_t ie;              /* Saved enabled interrupts */
@@ -169,6 +202,23 @@ struct s32k1xx_uart_s
 #endif
 #ifdef CONFIG_SERIAL_RS485CONTROL
   uint8_t rs485mode:1;      /* We are in RS485 (RTS on TX) mode */
+#endif
+  /* TX DMA state */
+
+#ifdef SERIAL_HAVE_TXDMA
+  const unsigned int dma_txreqsrc;  /* DMAMUX source of TX DMA request */
+  DMACH_HANDLE       txdma;         /* currently-open trasnmit DMA stream */
+  sem_t              txdmasem;      /* Indicate TX DMA completion */
+#endif
+
+  /* RX DMA state */
+
+#ifdef SERIAL_HAVE_RXDMA
+  const unsigned int dma_rxreqsrc;  /* DMAMUX source of RX DMA request */
+  DMACH_HANDLE       rxdma;         /* currently-open receive DMA stream */
+  bool               rxenable;      /* DMA-based reception en/disable */
+  uint32_t           rxdmanext;     /* Next byte in the DMA buffer to be read */
+  char *const        rxfifo;        /* Receive DMA buffer */
 #endif
 };
 
@@ -191,12 +241,46 @@ static int  s32k1xx_attach(struct uart_dev_s *dev);
 static void s32k1xx_detach(struct uart_dev_s *dev);
 static int  s32k1xx_interrupt(int irq, void *context, void *arg);
 static int  s32k1xx_ioctl(struct file *filep, int cmd, unsigned long arg);
+#if !defined(SERIAL_HAVE_ONLY_RXDMA)
 static int  s32k1xx_receive(struct uart_dev_s *dev, unsigned int *status);
 static void s32k1xx_rxint(struct uart_dev_s *dev, bool enable);
 static bool s32k1xx_rxavailable(struct uart_dev_s *dev);
-static void s32k1xx_send(struct uart_dev_s *dev, int ch);
+#endif
+#if !defined(SERIAL_HAVE_ONLY_TXDMA)
 static void s32k1xx_txint(struct uart_dev_s *dev, bool enable);
+#endif
+#ifdef CONFIG_SERIAL_IFLOWCONTROL
+static bool s32k1xx_rxflowcontrol(struct uart_dev_s *dev,
+                                  unsigned int nbuffered, bool upper);
+#endif
+static void s32k1xx_send(struct uart_dev_s *dev, int ch);
 static bool s32k1xx_txready(struct uart_dev_s *dev);
+#ifdef SERIAL_HAVE_TXDMA
+static void s32k1xx_dma_send(struct uart_dev_s *dev);
+static void s32k1xx_dma_txint(struct uart_dev_s *dev, bool enable);
+static void s32k1xx_dma_txavailable(struct uart_dev_s *dev);
+static void s32k1xx_dma_txcallback(DMACH_HANDLE handle, void *arg, bool done,
+                                   int result);
+#endif
+
+#if defined(SERIAL_HAVE_RXDMA) || defined(SERIAL_HAVE_TXDMA)
+static int  s32k1xx_dma_setup(struct uart_dev_s *dev);
+static void s32k1xx_dma_shutdown(struct uart_dev_s *dev);
+#endif
+
+#ifdef SERIAL_HAVE_RXDMA
+static int  s32k1xx_dma_receive(struct uart_dev_s *dev,
+                                unsigned int *status);
+#ifdef CONFIG_PM
+static void s32k1xx_dma_reenable(struct s32k1xx_uart_s *priv);
+#endif
+static void s32k1xx_dma_rxint(struct uart_dev_s *dev, bool enable);
+static bool s32k1xx_dma_rxavailable(struct uart_dev_s *dev);
+
+static void s32k1xx_dma_rxcallback(DMACH_HANDLE handle, void *arg, bool done,
+                                   int result);
+#endif
+
 static bool s32k1xx_txempty(struct uart_dev_s *dev);
 
 #ifdef CONFIG_PM
@@ -212,7 +296,8 @@ static int  up_pm_prepare(struct pm_callback_s *cb, int domain,
 
 /* Serial driver UART operations */
 
-static const struct uart_ops_s g_uart_ops =
+#if !defined(SERIAL_HAVE_ONLY_TXDMA) && !defined(SERIAL_HAVE_ONLY_RXDMA)
+static const struct uart_ops_s g_lpuart_ops =
 {
   .setup          = s32k1xx_setup,
   .shutdown       = s32k1xx_shutdown,
@@ -223,174 +308,307 @@ static const struct uart_ops_s g_uart_ops =
   .rxint          = s32k1xx_rxint,
   .rxavailable    = s32k1xx_rxavailable,
 #ifdef CONFIG_SERIAL_IFLOWCONTROL
-  .rxflowcontrol  = NULL,
+  .rxflowcontrol  = s32k1xx_rxflowcontrol,
 #endif
   .send           = s32k1xx_send,
   .txint          = s32k1xx_txint,
   .txready        = s32k1xx_txready,
   .txempty        = s32k1xx_txempty,
 };
+#endif
+
+#if defined(SERIAL_HAVE_RXDMA) && defined(SERIAL_HAVE_TXDMA)
+static const struct uart_ops_s g_lpuart_rxtxdma_ops =
+{
+  .setup          = s32k1xx_dma_setup,
+  .shutdown       = s32k1xx_dma_shutdown,
+  .attach         = s32k1xx_attach,
+  .detach         = s32k1xx_detach,
+  .ioctl          = s32k1xx_ioctl,
+  .receive        = s32k1xx_dma_receive,
+  .rxint          = s32k1xx_dma_rxint,
+  .rxavailable    = s32k1xx_dma_rxavailable,
+#ifdef CONFIG_SERIAL_IFLOWCONTROL
+  .rxflowcontrol  = s32k1xx_rxflowcontrol,
+#endif
+  .send           = s32k1xx_send,
+  .txint          = s32k1xx_dma_txint,
+  .txready        = s32k1xx_txready,
+  .txempty        = s32k1xx_txempty,
+  .dmatxavail     = s32k1xx_dma_txavailable,
+  .dmasend        = s32k1xx_dma_send,
+};
+#endif
+#if !defined(SERIAL_HAVE_ONLY_DMA) && defined(SERIAL_HAVE_RXDMA)
+static const struct uart_ops_s g_lpuart_rxdma_ops =
+{
+  .setup          = s32k1xx_dma_setup,
+  .shutdown       = s32k1xx_dma_shutdown,
+  .attach         = s32k1xx_attach,
+  .detach         = s32k1xx_detach,
+  .ioctl          = s32k1xx_ioctl,
+  .receive        = s32k1xx_dma_receive,
+  .rxint          = s32k1xx_dma_rxint,
+  .rxavailable    = s32k1xx_dma_rxavailable,
+#ifdef CONFIG_SERIAL_IFLOWCONTROL
+  .rxflowcontrol  = s32k1xx_rxflowcontrol,
+#endif
+  .send           = s32k1xx_send,
+  .txint          = s32k1xx_txint,
+  .txready        = s32k1xx_txready,
+  .txempty        = s32k1xx_txempty,
+};
+#endif
+
+#if !defined(SERIAL_HAVE_ONLY_DMA) && defined(SERIAL_HAVE_TXDMA)
+static const struct uart_ops_s g_lpuart_txdma_ops =
+{
+    .setup          = s32k1xx_dma_setup,
+    .shutdown       = s32k1xx_dma_shutdown,
+    .attach         = s32k1xx_attach,
+    .detach         = s32k1xx_detach,
+    .ioctl          = s32k1xx_ioctl,
+    .receive        = s32k1xx_receive,
+    .rxint          = s32k1xx_rxint,
+    .rxavailable    = s32k1xx_rxavailable,
+#ifdef CONFIG_SERIAL_IFLOWCONTROL
+  .rxflowcontrol  = s32k1xx_rxflowcontrol,
+#endif
+    .send           = s32k1xx_send,
+    .txint          = s32k1xx_dma_txint,
+    .txready        = s32k1xx_txready,
+    .txempty        = s32k1xx_txempty,
+    .dmatxavail     = s32k1xx_dma_txavailable,
+    .dmasend        = s32k1xx_dma_send,
+};
+#endif
+
+/* Avoid unused warning */
+#if !defined(SERIAL_HAVE_ONLY_DMA) && defined(SERIAL_HAVE_RXDMA)
+const struct uart_ops_s *g_o0 = &g_lpuart_rxdma_ops;
+#endif
+#if !defined(SERIAL_HAVE_ONLY_DMA) && defined(SERIAL_HAVE_TXDMA)
+const struct uart_ops_s *g_o1 = &g_lpuart_txdma_ops;
+#endif
+
+/* I/O buffers */
+
+#ifdef CONFIG_LPUART0_RXDMA
+static char g_lpuart0rxfifo[RXDMA_BUFFER_SIZE];
+#endif
+
+# ifdef CONFIG_LPUART1_RXDMA
+static char g_lpuart1rxfifo[RXDMA_BUFFER_SIZE];
+#endif
+
+#ifdef CONFIG_LPUART2_RXDMA
+static char g_lpuart2rxfifo[RXDMA_BUFFER_SIZE];
+#endif
 
 /* I/O buffers */
 
 #ifdef CONFIG_S32K1XX_LPUART0
-static char g_uart0rxbuffer[CONFIG_LPUART0_RXBUFSIZE];
-static char g_uart0txbuffer[CONFIG_LPUART0_TXBUFSIZE];
+static char g_lpuart0rxbuffer[CONFIG_LPUART0_RXBUFSIZE];
+static char g_lpuart0txbuffer[CONFIG_LPUART0_TXBUFSIZE];
 #endif
 
 #ifdef CONFIG_S32K1XX_LPUART1
-static char g_uart1rxbuffer[CONFIG_LPUART1_RXBUFSIZE];
-static char g_uart1txbuffer[CONFIG_LPUART1_TXBUFSIZE];
+static char g_lpuart1rxbuffer[CONFIG_LPUART1_RXBUFSIZE];
+static char g_lpuart1txbuffer[CONFIG_LPUART1_TXBUFSIZE];
 #endif
 
 #ifdef CONFIG_S32K1XX_LPUART2
-static char g_uart2rxbuffer[CONFIG_LPUART2_RXBUFSIZE];
-static char g_uart2txbuffer[CONFIG_LPUART2_TXBUFSIZE];
+static char g_lpuart2rxbuffer[CONFIG_LPUART2_RXBUFSIZE];
+static char g_lpuart2txbuffer[CONFIG_LPUART2_TXBUFSIZE];
 #endif
 
 /* This describes the state of the S32K1XX lpuart0 port. */
 
 #ifdef CONFIG_S32K1XX_LPUART0
-static struct s32k1xx_uart_s g_uart0priv =
+static struct s32k1xx_uart_s g_lpuart0priv =
 {
+  .dev =
+    {
+      .recv         =
+      {
+        .size       = CONFIG_LPUART0_RXBUFSIZE,
+        .buffer     = g_lpuart0rxbuffer,
+      },
+      .xmit         =
+      {
+        .size       = CONFIG_LPUART0_TXBUFSIZE,
+        .buffer     = g_lpuart0txbuffer,
+      },
+#  if defined(CONFIG_LPUART1_RXDMA) && defined(CONFIG_LPUART1_TXDMA)
+        .ops       = &g_lpuart_rxtxdma_ops,
+#  elif defined(CONFIG_LPUART1_RXDMA) && !defined(CONFIG_LPUART1_TXDMA)
+        .ops       = &g_lpuart_rxdma_ops,
+#  elif !defined(CONFIG_LPUART1_RXDMA) && defined(CONFIG_LPUART1_TXDMA)
+        .ops       = &g_lpuart_txdma_ops,
+#  else
+        .ops       = &g_lpuart_ops,
+#  endif
+        .priv         = &g_lpuart0priv,
+      },
   .uartbase     = S32K1XX_LPUART0_BASE,
   .baud         = CONFIG_LPUART0_BAUD,
   .irq          = S32K1XX_IRQ_LPUART0,
   .parity       = CONFIG_LPUART0_PARITY,
   .bits         = CONFIG_LPUART0_BITS,
   .stopbits2    = CONFIG_LPUART0_2STOP,
-#if defined(CONFIG_SERIAL_OFLOWCONTROL) && defined(CONFIG_LPUART0_OFLOWCONTROL)
+#  if defined(CONFIG_SERIAL_OFLOWCONTROL) && defined(CONFIG_LPUART0_OFLOWCONTROL)
   .oflow        = 1,
-  .cts_gpio     = GPIO_LPUART0_CTS,
-#endif
-#if defined(CONFIG_SERIAL_IFLOWCONTROL) && defined(CONFIG_LPUART0_IFLOWCONTROL)
+  .cts_gpio     = PIN_LPUART0_CTS,
+#  endif
+#  if defined(CONFIG_SERIAL_IFLOWCONTROL) && defined(CONFIG_LPUART0_IFLOWCONTROL)
   .iflow        = 1,
-#endif
-# if ((defined(CONFIG_SERIAL_RS485CONTROL) && defined(CONFIG_LPUART0_RS485RTSCONTROL)) \
+#  endif
+#  if ((defined(CONFIG_SERIAL_RS485CONTROL) && defined(CONFIG_LPUART0_RS485RTSCONTROL)) \
    || (defined(CONFIG_SERIAL_IFLOWCONTROL) && defined(CONFIG_LPUART0_IFLOWCONTROL)))
-  .rts_gpio     = GPIO_LPUART0_RTS,
-#endif
+  .rts_gpio     = PIN_LPUART0_RTS,
+#  endif
 
-#if (((defined(CONFIG_SERIAL_RS485CONTROL) || defined(CONFIG_SERIAL_IFLOWCONTROL))) \
+#  if (((defined(CONFIG_SERIAL_RS485CONTROL) || defined(CONFIG_SERIAL_IFLOWCONTROL))) \
     && defined(CONFIG_LPUART0_INVERTIFLOWCONTROL))
   .inviflow     = 1,
-#endif
+#  endif
 
-#if defined(CONFIG_SERIAL_RS485CONTROL) && defined(CONFIG_LPUART0_RS485RTSCONTROL)
+#  if defined(CONFIG_SERIAL_RS485CONTROL) && defined(CONFIG_LPUART0_RS485RTSCONTROL)
   .rs485mode    = 1,
-#endif
-};
-
-static struct uart_dev_s g_uart0port =
-{
-  .recv         =
-  {
-    .size       = CONFIG_LPUART0_RXBUFSIZE,
-    .buffer     = g_uart0rxbuffer,
-  },
-  .xmit         =
-  {
-    .size       = CONFIG_LPUART0_TXBUFSIZE,
-    .buffer     = g_uart0txbuffer,
-  },
-  .ops          = &g_uart_ops,
-  .priv         = &g_uart0priv,
+#  endif
+#  ifdef CONFIG_LPUART0_TXDMA
+  .dma_txreqsrc = S32K1XX_DMACHAN_LPUART0_TX,
+#  endif
+#  ifdef CONFIG_LPUART0_RXDMA
+  .dma_rxreqsrc = S32K1XX_DMACHAN_LPUART0_RX,
+  .rxfifo        = g_lpuart0rxfifo,
+#  endif
 };
 #endif
 
 /* This describes the state of the S32K1XX lpuart1 port. */
 
 #ifdef CONFIG_S32K1XX_LPUART1
-static struct s32k1xx_uart_s g_uart1priv =
+static struct s32k1xx_uart_s g_lpuart1priv =
 {
+  .dev =
+    {
+      .recv         =
+      {
+        .size       = CONFIG_LPUART1_RXBUFSIZE,
+        .buffer     = g_lpuart1rxbuffer,
+      },
+      .xmit         =
+      {
+        .size       = CONFIG_LPUART1_TXBUFSIZE,
+        .buffer     = g_lpuart1txbuffer,
+      },
+#    if defined(CONFIG_LPUART1_RXDMA) && defined(CONFIG_LPUART1_TXDMA)
+          .ops       = &g_lpuart_rxtxdma_ops,
+#    elif defined(CONFIG_LPUART1_RXDMA) && !defined(CONFIG_LPUART1_TXDMA)
+          .ops       = &g_lpuart_rxdma_ops,
+#    elif !defined(CONFIG_LPUART1_RXDMA) && defined(CONFIG_LPUART1_TXDMA)
+          .ops       = &g_lpuart_txdma_ops,
+#    else
+          .ops       = &g_lpuart_ops,
+#    endif
+          .priv           = &g_lpuart1priv,
+  },
+
   .uartbase     = S32K1XX_LPUART1_BASE,
   .baud         = CONFIG_LPUART1_BAUD,
   .irq          = S32K1XX_IRQ_LPUART1,
   .parity       = CONFIG_LPUART1_PARITY,
   .bits         = CONFIG_LPUART1_BITS,
   .stopbits2    = CONFIG_LPUART1_2STOP,
-#if defined(CONFIG_SERIAL_OFLOWCONTROL) && defined(CONFIG_LPUART1_OFLOWCONTROL)
+#  if defined(CONFIG_SERIAL_OFLOWCONTROL) && defined(CONFIG_LPUART1_OFLOWCONTROL)
   .oflow        = 1,
-  .cts_gpio     = GPIO_LPUART1_CTS,
-#endif
-#if defined(CONFIG_SERIAL_IFLOWCONTROL) && defined(CONFIG_LPUART1_IFLOWCONTROL)
+  .cts_gpio     = PIN_LPUART1_CTS,
+#  endif
+#  if defined(CONFIG_SERIAL_IFLOWCONTROL) && defined(CONFIG_LPUART1_IFLOWCONTROL)
   .iflow        = 1,
-#endif
-# if ((defined(CONFIG_SERIAL_RS485CONTROL) && defined(CONFIG_LPUART1_RS485RTSCONTROL)) \
+#  endif
+#  if ((defined(CONFIG_SERIAL_RS485CONTROL) && defined(CONFIG_LPUART1_RS485RTSCONTROL)) \
    || (defined(CONFIG_SERIAL_IFLOWCONTROL) && defined(CONFIG_LPUART1_IFLOWCONTROL)))
-  .rts_gpio     = GPIO_LPUART1_RTS,
-#endif
-#if (((defined(CONFIG_SERIAL_RS485CONTROL) || defined(CONFIG_SERIAL_IFLOWCONTROL))) \
+  .rts_gpio     = PIN_LPUART1_RTS,
+#  endif
+#  if (((defined(CONFIG_SERIAL_RS485CONTROL) || defined(CONFIG_SERIAL_IFLOWCONTROL))) \
     && defined(CONFIG_LPUART1_INVERTIFLOWCONTROL))
   .inviflow     = 1,
-#endif
+#  endif
 
-#if defined(CONFIG_SERIAL_RS485CONTROL) && defined(CONFIG_LPUART1_RS485RTSCONTROL)
+#  if defined(CONFIG_SERIAL_RS485CONTROL) && defined(CONFIG_LPUART1_RS485RTSCONTROL)
   .rs485mode    = 1,
-#endif
-};
-
-static struct uart_dev_s g_uart1port =
-{
-  .recv           =
-    {
-      .size       = CONFIG_LPUART1_RXBUFSIZE,
-      .buffer     = g_uart1rxbuffer,
-    },
-  .xmit           =
-    {
-      .size       = CONFIG_LPUART1_TXBUFSIZE,
-      .buffer     = g_uart1txbuffer,
-    },
-  .ops            = &g_uart_ops,
-  .priv           = &g_uart1priv,
+#  endif
+#  ifdef CONFIG_LPUART1_TXDMA
+  .dma_txreqsrc = S32K1XX_DMACHAN_LPUART1_TX,
+#  endif
+#  ifdef CONFIG_LPUART1_RXDMA
+  .dma_rxreqsrc = S32K1XX_DMACHAN_LPUART1_RX,
+  .rxfifo        = g_lpuart1rxfifo,
+#  endif
 };
 #endif
 
 #ifdef CONFIG_S32K1XX_LPUART2
-static struct s32k1xx_uart_s g_uart2priv =
+static struct s32k1xx_uart_s g_lpuart2priv =
 {
+  .dev =
+    {
+      .recv         =
+      {
+        .size       = CONFIG_LPUART2_RXBUFSIZE,
+        .buffer     = g_lpuart2rxbuffer,
+      },
+      .xmit         =
+      {
+        .size       = CONFIG_LPUART2_TXBUFSIZE,
+        .buffer     = g_lpuart2txbuffer,
+      },
+#  if defined(CONFIG_LPUART1_RXDMA) && defined(CONFIG_LPUART1_TXDMA)
+        .ops       = &g_lpuart_rxtxdma_ops,
+#  elif defined(CONFIG_LPUART1_RXDMA) && !defined(CONFIG_LPUART1_TXDMA)
+        .ops       = &g_lpuart_rxdma_ops,
+#  elif !defined(CONFIG_LPUART1_RXDMA) && defined(CONFIG_LPUART1_TXDMA)
+        .ops       = &g_lpuart_txdma_ops,
+#  else
+        .ops       = &g_lpuart_ops,
+#  endif
+        .priv           = &g_lpuart2priv,
+  },
+
   .uartbase     = S32K1XX_LPUART2_BASE,
   .baud         = CONFIG_LPUART2_BAUD,
   .irq          = S32K1XX_IRQ_LPUART2,
   .parity       = CONFIG_LPUART2_PARITY,
   .bits         = CONFIG_LPUART2_BITS,
   .stopbits2    = CONFIG_LPUART2_2STOP,
-#if defined(CONFIG_SERIAL_OFLOWCONTROL) && defined(CONFIG_LPUART2_OFLOWCONTROL)
+#  if defined(CONFIG_SERIAL_OFLOWCONTROL) && defined(CONFIG_LPUART2_OFLOWCONTROL)
   .oflow        = 1,
-  .cts_gpio     = GPIO_LPUART2_CTS,
-#endif
-#if defined(CONFIG_SERIAL_IFLOWCONTROL) && defined(CONFIG_LPUART2_IFLOWCONTROL)
+  .cts_gpio     = PIN_LPUART2_CTS,
+#  endif
+#  if defined(CONFIG_SERIAL_IFLOWCONTROL) && defined(CONFIG_LPUART2_IFLOWCONTROL)
   .iflow        = 1,
-#endif
-# if ((defined(CONFIG_SERIAL_RS485CONTROL) && defined(CONFIG_LPUART2_RS485RTSCONTROL)) \
+#  endif
+#  if ((defined(CONFIG_SERIAL_RS485CONTROL) && defined(CONFIG_LPUART2_RS485RTSCONTROL)) \
    || (defined(CONFIG_SERIAL_IFLOWCONTROL) && defined(CONFIG_LPUART2_IFLOWCONTROL)))
-  .rts_gpio     = GPIO_LPUART2_RTS,
-#endif
-#if (((defined(CONFIG_SERIAL_RS485CONTROL) || defined(CONFIG_SERIAL_IFLOWCONTROL))) \
+  .rts_gpio     = PIN_LPUART2_RTS,
+#  endif
+#  if (((defined(CONFIG_SERIAL_RS485CONTROL) || defined(CONFIG_SERIAL_IFLOWCONTROL))) \
     && defined(CONFIG_LPUART2_INVERTIFLOWCONTROL))
   .inviflow     = 1,
-#endif
+#  endif
 
-#if defined(CONFIG_SERIAL_RS485CONTROL) && defined(CONFIG_LPUART2_RS485RTSCONTROL)
+#  if defined(CONFIG_SERIAL_RS485CONTROL) && defined(CONFIG_LPUART2_RS485RTSCONTROL)
   .rs485mode    = 1,
-#endif
-};
-
-static struct uart_dev_s g_uart2port =
-{
-  .recv           =
-    {
-      .size       = CONFIG_LPUART2_RXBUFSIZE,
-      .buffer     = g_uart2rxbuffer,
-    },
-  .xmit           =
-    {
-      .size       = CONFIG_LPUART2_TXBUFSIZE,
-      .buffer     = g_uart2txbuffer,
-    },
-  .ops            = &g_uart_ops,
-  .priv           = &g_uart2priv,
+#  endif
+#  ifdef CONFIG_LPUART2_TXDMA
+  .dma_txreqsrc = S32K1XX_DMACHAN_LPUART2_TX,
+#  endif
+#  ifdef CONFIG_LPUART2_RXDMA
+  .dma_rxreqsrc = S32K1XX_DMACHAN_LPUART2_RX,
+  .rxfifo        = g_lpuart2rxfifo,
+# endif
 };
 #endif
 
@@ -426,6 +644,24 @@ static inline void s32k1xx_serialout(struct s32k1xx_uart_s *priv,
   putreg32(value, priv->uartbase + offset);
 }
 
+/****************************************************************************
+ * Name: s32k1xx_dma_nextrx
+ *
+ * Description:
+ *   Returns the index into the RX FIFO where the DMA will place the next
+ *   byte that it receives.
+ *
+ ****************************************************************************/
+
+#ifdef SERIAL_HAVE_RXDMA
+static int s32k1xx_dma_nextrx(struct s32k1xx_uart_s *priv)
+{
+  int dmaresidual = s32k1xx_dmach_getcount(priv->rxdma);
+
+  return RXDMA_BUFFER_SIZE - dmaresidual;
+}
+#endif
+
 /****************************************************************************
  * Name: s32k1xx_disableuartint
  ****************************************************************************/
@@ -473,6 +709,132 @@ static inline void s32k1xx_restoreuartint(struct s32k1xx_uart_s *priv,
   spin_unlock_irqrestore(NULL, flags);
 }
 
+/****************************************************************************
+ * Name: s32k1xx_dma_setup
+ *
+ * Description:
+ *   Configure the LPUART baud, bits, parity, etc. This method is called the
+ *   first time that the serial port is opened.
+ *
+ ****************************************************************************/
+
+#if defined(SERIAL_HAVE_RXDMA) || defined(SERIAL_HAVE_TXDMA)
+static int s32k1xx_dma_setup(struct uart_dev_s *dev)
+{
+  struct s32k1xx_uart_s *priv = (struct s32k1xx_uart_s *)dev;
+#if defined(SERIAL_HAVE_RXDMA)
+  struct s32k1xx_edma_xfrconfig_s config;
+#endif
+  int result;
+
+  /* Do the basic UART setup first, unless we are the console */
+
+  if (!dev->isconsole)
+    {
+      result = s32k1xx_setup(dev);
+      if (result != OK)
+        {
+          return result;
+        }
+    }
+
+#if defined(SERIAL_HAVE_TXDMA)
+  /* Acquire the Tx DMA channel.  This should always succeed. */
+
+  if (priv->dma_txreqsrc != 0)
+    {
+      if (priv->txdma == NULL)
+        {
+          priv->txdma = s32k1xx_dmach_alloc(priv->dma_txreqsrc |
+                                            DMAMUX_CHCFG_ENBL, 0);
+          if (priv->txdma == NULL)
+            {
+              return -EBUSY;
+            }
+
+          nxsem_init(&priv->txdmasem, 0, 1);
+          nxsem_set_protocol(&priv->txdmasem, SEM_PRIO_NONE);
+        }
+
+      /* Enable Tx DMA for the UART */
+
+      modifyreg32(priv->uartbase + S32K1XX_LPUART_BAUD_OFFSET,
+                  0, LPUART_BAUD_TDMAE);
+    }
+#endif
+
+#if defined(SERIAL_HAVE_RXDMA)
+  /* Acquire the Rx DMA channel.  This should always succeed. */
+
+  if (priv->dma_rxreqsrc != 0)
+    {
+      if (priv->rxdma == NULL)
+        {
+          priv->rxdma = s32k1xx_dmach_alloc(priv->dma_rxreqsrc |
+                                            DMAMUX_CHCFG_ENBL, 0);
+
+          if (priv->rxdma == NULL)
+            {
+              return -EBUSY;
+            }
+        }
+      else
+        {
+          s32k1xx_dmach_stop(priv->rxdma);
+        }
+
+      /* Configure for circular DMA reception into the RX FIFO */
+
+      config.saddr  = priv->uartbase + S32K1XX_LPUART_DATA_OFFSET;
+      config.daddr  = (uint32_t)priv->rxfifo;
+      config.soff   = 0;
+      config.doff   = 1;
+      config.iter   = RXDMA_BUFFER_SIZE;
+      config.flags  = EDMA_CONFIG_LINKTYPE_LINKNONE |
+                      EDMA_CONFIG_LOOPDEST |
+                      EDMA_CONFIG_INTHALF  |
+                      EDMA_CONFIG_INTMAJOR;
+      config.ssize  = EDMA_8BIT;
+      config.dsize  = EDMA_8BIT;
+      config.nbytes = 1;
+    #ifdef CONFIG_KINETIS_EDMA_ELINK
+      config.linkch = 0;
+    #endif
+
+      s32k1xx_dmach_xfrsetup(priv->rxdma , &config);
+
+      /* Reset our DMA shadow pointer and Rx data availability count to
+       * match the address just programmed above.
+       */
+
+      priv->rxdmanext = 0;
+
+      /* Enable receive Rx DMA for the UART */
+
+      modifyreg32(priv->uartbase + S32K1XX_LPUART_BAUD_OFFSET,
+                  0, LPUART_BAUD_RDMAE);
+
+      /* Enable itnerrupt on Idel and erros */
+
+      modifyreg32(priv->uartbase + S32K1XX_LPUART_CTRL_OFFSET, 0,
+                  LPUART_CTRL_PEIE |
+                  LPUART_CTRL_FEIE |
+                  LPUART_CTRL_NEIE |
+                  LPUART_CTRL_ILIE);
+
+      /* Start the DMA channel, and arrange for callbacks at the half and
+       * full points in the FIFO.  This ensures that we have half a FIFO
+       * worth of time to claim bytes before they are overwritten.
+       */
+
+      s32k1xx_dmach_start(priv->rxdma, s32k1xx_dma_rxcallback, (void *)priv);
+    }
+#endif
+
+  return OK;
+}
+#endif
+
 /****************************************************************************
  * Name: s32k1xx_setup
  *
@@ -504,7 +866,13 @@ static int s32k1xx_setup(struct uart_dev_s *dev)
   config.usects     = priv->iflow;      /* Flow control on inbound side */
 #endif
 #ifdef CONFIG_SERIAL_OFLOWCONTROL
-  config.userts     = priv->oflow;      /* Flow control on outbound side */
+  /* Flow control on outbound side if not GPIO based */
+
+  if ((priv->rts_gpio & _PIN_MODE_MASK) != _PIN_MODE_GPIO)
+    {
+      config.userts = priv->oflow;
+    }
+
 #endif
 #ifdef CONFIG_SERIAL_RS485CONTROL
   config.users485   = priv->rs485mode;  /* Switch into RS485 mode */
@@ -556,6 +924,55 @@ static void s32k1xx_shutdown(struct uart_dev_s *dev)
   s32k1xx_serialout(priv, S32K1XX_LPUART_GLOBAL_OFFSET, 0);
 }
 
+/****************************************************************************
+ * Name: s32k1xx_dma_shutdown
+ *
+ * Description:
+ *   Disable the LPUART.  This method is called when the serial
+ *   port is closed
+ *
+ ****************************************************************************/
+
+#if defined(SERIAL_HAVE_RXDMA) || defined(SERIAL_HAVE_TXDMA)
+static void s32k1xx_dma_shutdown(struct uart_dev_s *dev)
+{
+  struct s32k1xx_uart_s *priv = (struct s32k1xx_uart_s *)dev;
+
+  /* Perform the normal UART shutdown */
+
+  s32k1xx_shutdown(dev);
+
+#if defined(SERIAL_HAVE_RXDMA)
+  /* Stop the RX DMA channel */
+
+  if (priv->dma_rxreqsrc != 0)
+    {
+      s32k1xx_dmach_stop(priv->rxdma);
+
+      /* Release the RX DMA channel */
+
+      s32k1xx_dmach_free(priv->rxdma);
+      priv->rxdma = NULL;
+    }
+#endif
+
+#if defined(SERIAL_HAVE_TXDMA)
+  /* Stop the TX DMA channel */
+
+  if (priv->dma_txreqsrc != 0)
+    {
+      s32k1xx_dmach_stop(priv->txdma);
+
+      /* Release the TX DMA channel */
+
+      s32k1xx_dmach_free(priv->txdma);
+      priv->txdma = NULL;
+      nxsem_destroy(&priv->txdmasem);
+    }
+#endif
+}
+#endif
+
 /****************************************************************************
  * Name: s32k1xx_attach
  *
@@ -651,10 +1068,11 @@ static int s32k1xx_interrupt(int irq, void *context, void *arg)
        */
 
       usr  = s32k1xx_serialin(priv, S32K1XX_LPUART_STAT_OFFSET);
-      usr &= (LPUART_STAT_RDRF | LPUART_STAT_TC | LPUART_STAT_OR |
-              LPUART_STAT_FE);
+      usr &= (LPUART_STAT_RDRF | LPUART_STAT_TDRE | LPUART_STAT_OR |
+              LPUART_STAT_FE | LPUART_STAT_NF | LPUART_STAT_PF |
+              LPUART_STAT_IDLE);
 
-      /* Clear serial overrun and framing errors */
+      /* Clear serial overrun, parity and framing errors */
 
       if ((usr & LPUART_STAT_OR) != 0)
         {
@@ -662,12 +1080,42 @@ static int s32k1xx_interrupt(int irq, void *context, void *arg)
                             LPUART_STAT_OR);
         }
 
+      if ((usr & LPUART_STAT_NF) != 0)
+        {
+          s32k1xx_serialout(priv, S32K1XX_LPUART_STAT_OFFSET,
+                            LPUART_STAT_NF);
+        }
+
+      if ((usr & LPUART_STAT_PF) != 0)
+        {
+          s32k1xx_serialout(priv, S32K1XX_LPUART_STAT_OFFSET,
+                            LPUART_STAT_PF);
+        }
+
       if ((usr & LPUART_STAT_FE) != 0)
         {
           s32k1xx_serialout(priv, S32K1XX_LPUART_STAT_OFFSET,
                             LPUART_STAT_FE);
         }
 
+      if ((usr & (LPUART_STAT_FE | LPUART_STAT_PF | LPUART_STAT_NF)) != 0)
+        {
+          /* Discard data */
+
+          s32k1xx_serialin(priv, S32K1XX_LPUART_DATA_OFFSET);
+        }
+
+#ifdef SERIAL_HAVE_RXDMA
+      /* The line going to idle, deliver any fractions of RX data */
+
+      if ((usr & LPUART_STAT_IDLE) != 0)
+        {
+          s32k1xx_serialout(priv, S32K1XX_LPUART_STAT_OFFSET,
+                            LPUART_STAT_IDLE);
+          s32k1xx_dma_rxcallback(priv->rxdma, priv, false, LPUART_STAT_IDLE);
+        }
+#endif
+
       /* Handle incoming, receive bytes */
 
       if ((usr & LPUART_STAT_RDRF) != 0 &&
@@ -679,8 +1127,8 @@ static int s32k1xx_interrupt(int irq, void *context, void *arg)
 
       /* Handle outgoing, transmit bytes */
 
-      if ((usr & LPUART_STAT_TC) != 0 &&
-          (priv->ie & LPUART_CTRL_TCIE) != 0)
+      if ((usr & LPUART_STAT_TDRE) != 0 &&
+          (priv->ie & LPUART_CTRL_TIE) != 0)
         {
           uart_xmitchars(dev);
           handled = true;
@@ -702,7 +1150,8 @@ static int s32k1xx_ioctl(struct file *filep, int cmd, unsigned long arg)
 {
 #if defined(CONFIG_SERIAL_TIOCSERGSTRUCT) || defined(CONFIG_SERIAL_TERMIOS)
   struct inode *inode = filep->f_inode;
-  struct uart_dev_s *dev   = inode->i_private;
+  struct uart_dev_s *dev = inode->i_private;
+  irqstate_t flags;
 #endif
   int ret   = OK;
 
@@ -877,13 +1326,15 @@ static int s32k1xx_ioctl(struct file *filep, int cmd, unsigned long arg)
              * implement TCSADRAIN / TCSAFLUSH
              */
 
+            flags = spin_lock_irqsave(NULL);
             s32k1xx_disableuartint(priv, &ie);
-            ret = s32k1xx_setup(dev);
+            ret = dev->ops->setup(dev);
 
             /* Restore the interrupt state */
 
             s32k1xx_restoreuartint(priv, ie);
             priv->ie = ie;
+            spin_unlock_irqrestore(NULL, flags);
           }
       }
       break;
@@ -959,6 +1410,7 @@ static int s32k1xx_ioctl(struct file *filep, int cmd, unsigned long arg)
  *
  ****************************************************************************/
 
+#ifndef SERIAL_HAVE_ONLY_RXDMA
 static int s32k1xx_receive(struct uart_dev_s *dev, unsigned int *status)
 {
   struct s32k1xx_uart_s *priv = (struct s32k1xx_uart_s *)dev->priv;
@@ -968,6 +1420,7 @@ static int s32k1xx_receive(struct uart_dev_s *dev, unsigned int *status)
   *status = rxd >> LPUART_DATA_STATUS_SHIFT;
   return (rxd & LPUART_DATA_MASK) >> LPUART_DATA_SHIFT;
 }
+#endif
 
 /****************************************************************************
  * Name: s32k1xx_rxint
@@ -977,6 +1430,7 @@ static int s32k1xx_receive(struct uart_dev_s *dev, unsigned int *status)
  *
  ****************************************************************************/
 
+#ifndef SERIAL_HAVE_ONLY_RXDMA
 static void s32k1xx_rxint(struct uart_dev_s *dev, bool enable)
 {
   struct s32k1xx_uart_s *priv = (struct s32k1xx_uart_s *)dev->priv;
@@ -1003,6 +1457,7 @@ static void s32k1xx_rxint(struct uart_dev_s *dev, bool enable)
   s32k1xx_serialout(priv, S32K1XX_LPUART_CTRL_OFFSET, regval);
   spin_unlock_irqrestore(NULL, flags);
 }
+#endif
 
 /****************************************************************************
  * Name: s32k1xx_rxavailable
@@ -1012,6 +1467,7 @@ static void s32k1xx_rxint(struct uart_dev_s *dev, bool enable)
  *
  ****************************************************************************/
 
+#ifndef SERIAL_HAVE_ONLY_RXDMA
 static bool s32k1xx_rxavailable(struct uart_dev_s *dev)
 {
   struct s32k1xx_uart_s *priv = (struct s32k1xx_uart_s *)dev->priv;
@@ -1022,6 +1478,359 @@ static bool s32k1xx_rxavailable(struct uart_dev_s *dev)
   regval = s32k1xx_serialin(priv, S32K1XX_LPUART_STAT_OFFSET);
   return ((regval & LPUART_STAT_RDRF) != 0);
 }
+#endif
+
+/****************************************************************************
+ * Name: s32k1xx_rxflowcontrol
+ *
+ * Description:
+ *   Called when Rx buffer is full (or exceeds configured watermark levels
+ *   if CONFIG_SERIAL_IFLOWCONTROL_WATERMARKS is defined).
+ *   Return true if UART activated RX flow control to block more incoming
+ *   data
+ *
+ * Input Parameters:
+ *   dev       - UART device instance
+ *   nbuffered - the number of characters currently buffered
+ *               (if CONFIG_SERIAL_IFLOWCONTROL_WATERMARKS is
+ *               not defined the value will be 0 for an empty buffer or the
+ *               defined buffer size for a full buffer)
+ *   upper     - true indicates the upper watermark was crossed where
+ *               false indicates the lower watermark has been crossed
+ *
+ * Returned Value:
+ *   true if RX flow control activated.
+ *
+ ****************************************************************************/
+
+#ifdef CONFIG_SERIAL_IFLOWCONTROL
+static bool s32k1xx_rxflowcontrol(struct uart_dev_s *dev,
+                                  unsigned int nbuffered, bool upper)
+{
+  struct s32k1xx_uart_s *priv = (struct s32k1xx_uart_s *)dev;
+  bool use_swhs = false;
+
+#if defined(CONFIG_SERIAL_IFLOWCONTROL_WATERMARKS)
+  use_swhs = (priv->rts_gpio & _PIN_MODE_MASK) == _PIN_MODE_GPIO;
+#endif
+
+  if (use_swhs && priv->iflow && (priv->rts_gpio != 0))
+    {
+      /* Assert/de-assert nRTS set it high resume/stop sending */
+
+      s32k1xx_gpiowrite(priv->rts_gpio, upper);
+
+      if (upper)
+        {
+          /* With heavy Rx traffic, RXNE might be set and data pending.
+           * Returning 'true' in such case would cause RXNE left unhandled
+           * and causing interrupt storm. Sending end might be also be slow
+           * to react on nRTS, and returning 'true' here would prevent
+           * processing that data.
+           *
+           * Therefore, return 'false' so input data is still being processed
+           * until sending end reacts on nRTS signal and stops sending more.
+           */
+
+          return false;
+        }
+
+      return upper;
+    }
+  else
+    {
+      /* Is the RX buffer full? */
+
+      if (upper)
+        {
+          /* Disable Rx interrupt to prevent more data being from
+           * peripheral.  When hardware RTS is enabled, this will
+           * prevent more data from coming in.
+           *
+           * This function is only called when UART recv buffer is full,
+           * that is: "dev->recv.head + 1 == dev->recv.tail".
+           *
+           * Logic in "uart_read" will automatically toggle Rx interrupts
+           * when buffer is read empty and thus we do not have to re-
+           * enable Rx interrupts.
+           */
+
+          uart_disablerxint(dev);
+          return true;
+        }
+
+      /* No.. The RX buffer is empty */
+
+      else
+        {
+          /* We might leave Rx interrupt disabled if full recv buffer was
+           * read empty.  Enable Rx interrupt to make sure that more input is
+           * received.
+           */
+
+          uart_enablerxint(dev);
+        }
+    }
+
+  return false;
+}
+#endif
+
+/****************************************************************************
+ * Name: s32k1xx_dma_receive
+ *
+ * Description:
+ *   Called (usually) from the interrupt level to receive one
+ *   character from the LPUART.  Error bits associated with the
+ *   receipt are provided in the return 'status'.
+ *
+ ****************************************************************************/
+
+#ifdef SERIAL_HAVE_RXDMA
+static int s32k1xx_dma_receive(struct uart_dev_s *dev, unsigned int *status)
+{
+  struct s32k1xx_uart_s *priv = (struct s32k1xx_uart_s *)dev;
+  uint32_t nextrx = s32k1xx_dma_nextrx(priv);
+  int c = 0;
+
+  /* Check if more data is available */
+
+  if (nextrx != priv->rxdmanext)
+    {
+      /* Now read from the DMA buffer */
+
+      c = priv->rxfifo[priv->rxdmanext];
+
+      priv->rxdmanext++;
+
+      if (priv->rxdmanext == RXDMA_BUFFER_SIZE)
+        {
+          priv->rxdmanext = 0;
+        }
+    }
+
+  /* NOTE:  If no data is available, then we would return NULL which is,
+   * of course, valid binary data.  The protocol is that the upper half
+   * driver must call s32k1xx_dma_rxavailable prior to calling this
+   * function to assure that this never happens.
+   */
+
+  return c;
+}
+#endif
+
+/****************************************************************************
+ * Name: s32k1xx_dma_reenable
+ *
+ * Description:
+ *   Call to re-enable RX DMA.
+ *
+ ****************************************************************************/
+
+#if defined(SERIAL_HAVE_RXDMA) && defined(CONFIG_PM)
+static void s32k1xx_dma_reenable(struct s32k1xx_uart_s *priv)
+{
+  struct s32k1xx_edma_xfrconfig_s config;
+
+  /* Stop an reset the RX DMA */
+
+  s32k1xx_dmach_stop(priv->rxdma);
+
+  /* Configure for circular DMA reception into the RX FIFO */
+
+  config.saddr  = priv->uartbase + S32K1XX_LPUART_DATA_OFFSET;
+  config.daddr  = (uint32_t) priv->rxfifo;
+  config.soff   = 0;
+  config.doff   = 1;
+  config.iter   = RXDMA_BUFFER_SIZE;
+  config.flags  = EDMA_CONFIG_LINKTYPE_LINKNONE |
+                  EDMA_CONFIG_LOOPDEST |
+                  EDMA_CONFIG_INTHALF |
+                  EDMA_CONFIG_INTMAJOR;
+  config.ssize  = EDMA_8BIT;
+  config.dsize  = EDMA_8BIT;
+  config.nbytes = 1;
+#ifdef CONFIG_KINETIS_EDMA_ELINK
+  config.linkch = 0;
+#endif
+
+  s32k1xx_dmach_xfrsetup(priv->rxdma, &config);
+
+  /* Reset our DMA shadow pointer and Rx data availability count to match
+   * the address just programmed above.
+   */
+
+  priv->rxdmanext = 0;
+
+  /* Start the DMA channel, and arrange for callbacks at the half and
+   * full points in the FIFO.  This ensures that we have half a FIFO
+   * worth of time to claim bytes before they are overwritten.
+   */
+
+  s32k1xx_dmach_start(priv->rxdma, s32k1xx_dma_rxcallback, (void *)priv);
+
+  /* Clear DMA suspended flag. */
+
+  priv->rxdmasusp  = false;
+}
+#endif
+
+/****************************************************************************
+ * Name: s32k1xx_dma_rxint
+ *
+ * Description:
+ *   Call to enable or disable RX interrupts
+ *
+ ****************************************************************************/
+
+#ifdef SERIAL_HAVE_RXDMA
+static void s32k1xx_dma_rxint(struct uart_dev_s *dev, bool enable)
+{
+  struct s32k1xx_uart_s *priv = (struct s32k1xx_uart_s *)dev;
+
+  /* Enable/disable DMA reception.
+   *
+   * Note that it is not safe to check for available bytes and immediately
+   * pass them to uart_recvchars as that could potentially recurse back
+   * to us again.  Instead, bytes must wait until the next up_dma_poll or
+   * DMA event.
+   */
+
+  priv->rxenable = enable;
+}
+#endif
+
+/****************************************************************************
+ * Name: s32k1xx_dma_rxavailable
+ *
+ * Description:
+ *   Return true if the receive register is not empty
+ *
+ ****************************************************************************/
+
+#ifdef SERIAL_HAVE_RXDMA
+static bool s32k1xx_dma_rxavailable(struct uart_dev_s *dev)
+{
+  struct s32k1xx_uart_s *priv = (struct s32k1xx_uart_s *)dev;
+
+  /* Compare our receive pointer to the current DMA pointer, if they
+   * do not match, then there are bytes to be received.
+   */
+
+  return (s32k1xx_dma_nextrx(priv) != priv->rxdmanext);
+}
+#endif
+
+/****************************************************************************
+ * Name: s32k1xx_dma_txcallback
+ *
+ * Description:
+ *   This function clears dma buffer at complete of DMA transfer and wakes up
+ *   threads waiting for space in buffer.
+ *
+ ****************************************************************************/
+
+#ifdef SERIAL_HAVE_TXDMA
+static void s32k1xx_dma_txcallback(DMACH_HANDLE handle, void *arg, bool done,
+                                   int result)
+{
+  struct s32k1xx_uart_s *priv = (struct s32k1xx_uart_s *)arg;
+  /* Update 'nbytes' indicating number of bytes actually transferred by DMA.
+   * This is important to free TX buffer space by 'uart_xmitchars_done'.
+   */
+
+  priv->dev.dmatx.nbytes = priv->dev.dmatx.length + priv->dev.dmatx.nlength;
+
+  /* Adjust the pointers */
+
+  uart_xmitchars_done(&priv->dev);
+
+  /* Release waiter */
+
+  nxsem_post(&priv->txdmasem);
+}
+#endif
+
+/****************************************************************************
+ * Name: s32k1xx_dma_txavailable
+ *
+ * Description:
+ *        Informs DMA that Tx data is available and is ready for transfer.
+ *
+ ****************************************************************************/
+
+#ifdef SERIAL_HAVE_TXDMA
+static void s32k1xx_dma_txavailable(struct uart_dev_s *dev)
+{
+  struct s32k1xx_uart_s *priv = (struct s32k1xx_uart_s *)dev;
+
+  /* Only send when the DMA is idle */
+
+  nxsem_wait(&priv->txdmasem);
+
+  uart_xmitchars_dma(dev);
+}
+#endif
+
+/****************************************************************************
+ * Name: s32k1xx_dma_send
+ *
+ * Description:
+ *   Called (usually) from the interrupt level to start DMA transfer.
+ *   (Re-)Configures DMA Stream updating buffer and buffer length.
+ *
+ ****************************************************************************/
+
+#ifdef SERIAL_HAVE_TXDMA
+static void s32k1xx_dma_send(struct uart_dev_s *dev)
+{
+  struct s32k1xx_uart_s *priv = (struct s32k1xx_uart_s *)dev;
+  struct s32k1xx_edma_xfrconfig_s config;
+
+  /* We need to stop DMA before reconfiguration */
+
+  s32k1xx_dmach_stop(priv->txdma);
+
+  /* Reset the number sent */
+
+  dev->dmatx.nbytes = 0;
+
+  /* Make use of setup function to update buffer and its length for next
+   * transfer
+   */
+
+  config.iter   = dev->dmatx.length;
+  config.flags  = EDMA_CONFIG_LINKTYPE_LINKNONE;
+  config.ssize  = EDMA_8BIT;
+  config.dsize  = EDMA_8BIT;
+  config.nbytes = sizeof(dev->dmatx.buffer[0]);
+  config.saddr  = (uint32_t)dev->dmatx.buffer;
+  config.daddr  = priv->uartbase + S32K1XX_LPUART_DATA_OFFSET;
+  config.soff   = sizeof(dev->dmatx.buffer[0]);
+  config.doff   = 0;
+#ifdef CONFIG_S32K1XX_EDMA_ELINK
+  config.linkch  = 0;
+#endif
+
+  /* Setup first half */
+
+  s32k1xx_dmach_xfrsetup(priv->txdma, &config);
+
+  /* Is this a split transfer? */
+
+  if (dev->dmatx.nbuffer)
+    {
+      config.iter   = priv->dev.dmatx.nlength;
+      config.saddr  = (uint32_t)priv->dev.dmatx.nbuffer;
+
+      s32k1xx_dmach_xfrsetup(priv->txdma, &config);
+    }
+
+  /* Start transmission with the callback on DMA completion */
+
+  s32k1xx_dmach_start(priv->txdma, s32k1xx_dma_txcallback, (void *)priv);
+}
+#endif
 
 /****************************************************************************
  * Name: s32k1xx_send
@@ -1037,6 +1846,28 @@ static void s32k1xx_send(struct uart_dev_s *dev, int ch)
   s32k1xx_serialout(priv, S32K1XX_LPUART_DATA_OFFSET, (uint32_t)ch);
 }
 
+/****************************************************************************
+ * Name: s32k1xx_dma_txint
+ *
+ * Description:
+ *   Call to enable or disable TX interrupts from the UART.
+ *
+ ****************************************************************************/
+
+#ifdef SERIAL_HAVE_TXDMA
+static void s32k1xx_dma_txint(struct uart_dev_s *dev, bool enable)
+{
+  /* Nothing to do. */
+
+  /* In case of DMA transfer we do not want to make use of UART interrupts.
+   * Instead, we use DMA interrupts that are activated once during boot
+   * sequence. Furthermore we can use s32k1xx_dma_txcallback() to handle
+   * stuff at half DMA transfer or after transfer completion (depending on
+   * the configuration).
+   */
+}
+#endif
+
 /****************************************************************************
  * Name: s32k1xx_txint
  *
@@ -1045,6 +1876,7 @@ static void s32k1xx_send(struct uart_dev_s *dev, int ch)
  *
  ****************************************************************************/
 
+#if !defined(SERIAL_HAVE_ONLY_TXDMA)
 static void s32k1xx_txint(struct uart_dev_s *dev, bool enable)
 {
   struct s32k1xx_uart_s *priv = (struct s32k1xx_uart_s *)dev->priv;
@@ -1057,12 +1889,12 @@ static void s32k1xx_txint(struct uart_dev_s *dev, bool enable)
   if (enable)
     {
 #ifndef CONFIG_SUPPRESS_SERIAL_INTS
-      priv->ie |= LPUART_CTRL_TCIE;
+      priv->ie |= LPUART_CTRL_TIE;
 #endif
     }
   else
     {
-      priv->ie &= ~LPUART_CTRL_TCIE;
+      priv->ie &= ~LPUART_CTRL_TIE;
     }
 
   regval  = s32k1xx_serialin(priv, S32K1XX_LPUART_CTRL_OFFSET);
@@ -1071,6 +1903,7 @@ static void s32k1xx_txint(struct uart_dev_s *dev, bool enable)
   s32k1xx_serialout(priv, S32K1XX_LPUART_CTRL_OFFSET, regval);
   spin_unlock_irqrestore(NULL, flags);
 }
+#endif
 
 /****************************************************************************
  * Name: s32k1xx_txready
@@ -1106,6 +1939,48 @@ static bool s32k1xx_txempty(struct uart_dev_s *dev)
   return ((regval & LPUART_STAT_TDRE) != 0);
 }
 
+/****************************************************************************
+ * Name: s32k1xx_dma_rxcallback
+ *
+ * Description:
+ *   This function checks the current DMA state and calls the generic
+ *   serial stack when bytes appear to be available.
+ *
+ ****************************************************************************/
+
+#ifdef SERIAL_HAVE_RXDMA
+static void s32k1xx_dma_rxcallback(DMACH_HANDLE handle, void *arg, bool done,
+                                   int result)
+{
+  struct s32k1xx_uart_s *priv = (struct s32k1xx_uart_s *)arg;
+  uint32_t sr;
+
+  if (priv->rxenable && s32k1xx_dma_rxavailable(&priv->dev))
+    {
+      uart_recvchars(&priv->dev);
+    }
+
+  /* Get the masked LPUART status word to check and clear error flags.
+   *
+   * When wake-up from low power mode was not fast enough, UART is resumed
+   * too late and sometimes exactly when character was coming over UART,
+   * resulting to frame error.
+   * If error flag is not cleared, Rx DMA will be stuck. Clearing errors
+   * will release Rx DMA.
+   */
+
+  sr = s32k1xx_serialin(priv, S32K1XX_LPUART_STAT_OFFSET);
+
+  if ((sr & (LPUART_STAT_OR | LPUART_STAT_NF | LPUART_STAT_FE)) != 0)
+    {
+      s32k1xx_serialout(priv, S32K1XX_LPUART_STAT_OFFSET,
+                        sr & (LPUART_STAT_OR |
+                              LPUART_STAT_NF |
+                              LPUART_STAT_FE));
+    }
+}
+#endif
+
 /****************************************************************************
  * Name: up_pm_notify
  *
@@ -1136,13 +2011,13 @@ static void up_pm_notify(struct pm_callback_s *cb, int domain,
   peripheral_clock_source_t clock_source;
 
   #ifdef CONFIG_PM_SERIAL0
-    struct s32k1xx_uart_s *priv0 = g_uart0port.priv;
+    struct s32k1xx_uart_s *priv0 = g_lpuart0priv.dev.priv;
   #endif
   #ifdef CONFIG_PM_SERIAL1
-    struct s32k1xx_uart_s *priv1 = g_uart1port.priv;
+    struct s32k1xx_uart_s *priv1 = g_lpuart1priv.dev.priv;
   #endif
   #ifdef CONFIG_PM_SERIAL2
-    struct s32k1xx_uart_s *priv2 = g_uart2port.priv;
+    struct s32k1xx_uart_s *priv2 = g_lpuart2priv.dev.priv;
   #endif
 
   uint32_t ret_reg = 0;
@@ -1215,7 +2090,7 @@ static void up_pm_notify(struct pm_callback_s *cb, int domain,
 
       /* shutdown the LPUART1 (soft reset) */
 
-      s32k1xx_shutdown(&g_uart0port);
+      s32k1xx_shutdown(&g_lpuart0priv);
 
       /* change the clock config for the new mode */
 
@@ -1223,16 +2098,16 @@ static void up_pm_notify(struct pm_callback_s *cb, int domain,
 
       /* shutdown the LPUART1 (soft reset) */
 
-      s32k1xx_shutdown(&g_uart0port);
+      s32k1xx_shutdown(&g_lpuart0priv);
 
       /* set up the LPUART1 again for the new mode */
 
-      s32k1xx_setup(&g_uart0port);
+      s32k1xx_setup(&g_lpuart0priv);
 
       /* enable the interrupts */
 
-      s32k1xx_rxint(&g_uart0port, true);
-      s32k1xx_txint(&g_uart0port, true);
+      s32k1xx_rxint(&g_lpuart0priv, true);
+      s32k1xx_txint(&g_lpuart0priv, true);
 
     #endif
     #ifdef CONFIG_PM_SERIAL1
@@ -1262,7 +2137,7 @@ static void up_pm_notify(struct pm_callback_s *cb, int domain,
 
       /* shutdown the LPUART1 (soft reset) */
 
-      s32k1xx_shutdown(&g_uart1port);
+      s32k1xx_shutdown(&g_lpuart1priv);
 
       /* change the clock config for the new mode */
 
@@ -1270,16 +2145,16 @@ static void up_pm_notify(struct pm_callback_s *cb, int domain,
 
       /* shutdown the LPUART1 (soft reset) */
 
-      s32k1xx_shutdown(&g_uart1port);
+      s32k1xx_shutdown(&g_lpuart1priv);
 
       /* set up the LPUART1 again for the new mode */
 
-      s32k1xx_setup(&g_uart1port);
+      s32k1xx_setup(&g_lpuart1priv);
 
       /* enable the interrupts */
 
-      s32k1xx_rxint(&g_uart1port, true);
-      s32k1xx_txint(&g_uart1port, true);
+      s32k1xx_rxint(&g_lpuart1priv, true);
+      s32k1xx_txint(&g_lpuart1priv, true);
 
     #endif
     #ifdef CONFIG_PM_SERIAL2
@@ -1309,7 +2184,7 @@ static void up_pm_notify(struct pm_callback_s *cb, int domain,
 
       /* shutdown the LPUART1 (soft reset) */
 
-      s32k1xx_shutdown(&g_uart2port);
+      s32k1xx_shutdown(&g_lpuart2priv);
 
       /* change the clock config for the new mode */
 
@@ -1317,16 +2192,16 @@ static void up_pm_notify(struct pm_callback_s *cb, int domain,
 
       /* shutdown the LPUART1 (soft reset) */
 
-      s32k1xx_shutdown(&g_uart2port);
+      s32k1xx_shutdown(&g_lpuart2priv);
 
       /* set up the LPUART1 again for the new mode */
 
-      s32k1xx_setup(&g_uart2port);
+      s32k1xx_setup(&g_lpuart2priv);
 
       /* enable the interrupts */
 
-      s32k1xx_rxint(&g_uart2port, true);
-      s32k1xx_txint(&g_uart2port, true);
+      s32k1xx_rxint(&g_lpuart2priv, true);
+      s32k1xx_txint(&g_lpuart2priv, true);
 
     #endif
   }
@@ -1378,13 +2253,16 @@ static int up_pm_prepare(struct pm_callback_s *cb, int domain,
   peripheral_clock_source_t clock_source;
 
   #ifdef CONFIG_PM_SERIAL0
-    struct s32k1xx_uart_s *priv0 = (struct s32k1xx_uart_s *)g_uart0port.priv;
+    struct s32k1xx_uart_s *priv0 =
+        (struct s32k1xx_uart_s *)g_lpuart0priv.dev.priv;
   #endif
   #ifdef CONFIG_PM_SERIAL1
-    struct s32k1xx_uart_s *priv1 = (struct s32k1xx_uart_s *)g_uart1port.priv;
+    struct s32k1xx_uart_s *priv1 =
+        (struct s32k1xx_uart_s *)g_lpuart1priv.dev.priv;
   #endif
   #ifdef CONFIG_PM_SERIAL2
-    struct s32k1xx_uart_s *priv2 = (struct s32k1xx_uart_s *)g_uart2port.priv;
+    struct s32k1xx_uart_s *priv2 =
+        (struct s32k1xx_uart_s *)g_lpuart2priv.dev.priv;
   #endif
 
   uint32_t ret_reg = 0;
@@ -1461,7 +2339,7 @@ static int up_pm_prepare(struct pm_callback_s *cb, int domain,
 
     /* shutdown the LPUART1 (soft reset) */
 
-    s32k1xx_shutdown(&g_uart0port);
+    s32k1xx_shutdown(&g_lpuart0priv);
 
     /* change the clock config for the new mode */
 
@@ -1469,16 +2347,16 @@ static int up_pm_prepare(struct pm_callback_s *cb, int domain,
 
     /* shutdown the LPUART1 (soft reset) */
 
-    s32k1xx_shutdown(&g_uart0port);
+    s32k1xx_shutdown(&g_lpuart0priv);
 
     /* set up the LPUART1 again for the new mode */
 
-    s32k1xx_setup(&g_uart0port);
+    s32k1xx_setup(&g_lpuart0priv);
 
     /* enable the interrupts */
 
-    s32k1xx_rxint(&g_uart0port, true);
-    s32k1xx_txint(&g_uart0port, true);
+    s32k1xx_rxint(&g_lpuart0priv, true);
+    s32k1xx_txint(&g_lpuart0priv, true);
 
   #endif
   #ifdef CONFIG_PM_SERIAL1
@@ -1508,7 +2386,7 @@ static int up_pm_prepare(struct pm_callback_s *cb, int domain,
 
     /* shutdown the LPUART1 (soft reset) */
 
-    s32k1xx_shutdown(&g_uart1port);
+    s32k1xx_shutdown(&g_lpuart1priv);
 
     /* change the clock config for the new mode */
 
@@ -1516,16 +2394,16 @@ static int up_pm_prepare(struct pm_callback_s *cb, int domain,
 
     /* shutdown the LPUART1 (soft reset) */
 
-    s32k1xx_shutdown(&g_uart1port);
+    s32k1xx_shutdown(&g_lpuart1priv);
 
     /* set up the LPUART1 again for the new mode */
 
-    s32k1xx_setup(&g_uart1port);
+    s32k1xx_setup(&g_lpuart1priv);
 
     /* enable the interrupts */
 
-    s32k1xx_rxint(&g_uart1port, true);
-    s32k1xx_txint(&g_uart1port, true);
+    s32k1xx_rxint(&g_lpuart1priv, true);
+    s32k1xx_txint(&g_lpuart1priv, true);
 
   #endif
   #ifdef CONFIG_PM_SERIAL2
@@ -1555,7 +2433,7 @@ static int up_pm_prepare(struct pm_callback_s *cb, int domain,
 
     /* shutdown the LPUART1 (soft reset) */
 
-    s32k1xx_shutdown(&g_uart2port);
+    s32k1xx_shutdown(&g_lpuart2priv);
 
     /* change the clock config for the new mode */
 
@@ -1563,16 +2441,16 @@ static int up_pm_prepare(struct pm_callback_s *cb, int domain,
 
     /* shutdown the LPUART1 (soft reset) */
 
-    s32k1xx_shutdown(&g_uart2port);
+    s32k1xx_shutdown(&g_lpuart2priv);
 
     /* set up the LPUART1 again for the new mode */
 
-    s32k1xx_setup(&g_uart2port);
+    s32k1xx_setup(&g_lpuart2priv);
 
     /* enable the interrupts */
 
-    s32k1xx_rxint(&g_uart2port, true);
-    s32k1xx_txint(&g_uart2port, true);
+    s32k1xx_rxint(&g_lpuart2priv, true);
+    s32k1xx_txint(&g_lpuart2priv, true);
 
   #endif
 
@@ -1606,8 +2484,8 @@ void s32k1xx_earlyserialinit(void)
    */
 
 #ifdef CONSOLE_DEV
-  CONSOLE_DEV.isconsole = true;
-  s32k1xx_setup(&CONSOLE_DEV);
+  CONSOLE_DEV.dev.isconsole = true;
+  s32k1xx_setup(&CONSOLE_DEV.dev);
 #endif
 }
 
@@ -1623,7 +2501,7 @@ void s32k1xx_earlyserialinit(void)
 void arm_serialinit(void)
 {
 #ifdef CONFIG_PM
-  #if defined(CONFIG_PM_SERIAL_STANDBY) || defined(CONFIG_PM_SERIAL_SLEEP) 
+  #if defined(CONFIG_PM_SERIAL_STANDBY) || defined(CONFIG_PM_SERIAL_SLEEP)
 
   int ret;
 
@@ -1636,17 +2514,20 @@ void arm_serialinit(void)
 #endif
 
 #ifdef CONSOLE_DEV
-  uart_register("/dev/console", &CONSOLE_DEV);
+  uart_register("/dev/console", &CONSOLE_DEV.dev);
+#  if defined(SERIAL_HAVE_CONSOLE_DMA)
+  s32k1xx_dma_setup(&CONSOLE_DEV.dev);
+#  endif
 #endif
 
   /* Register all UARTs */
 
-  uart_register("/dev/ttyS0", &TTYS0_DEV);
+  uart_register("/dev/ttyS0", &TTYS0_DEV.dev);
 #ifdef TTYS1_DEV
-  uart_register("/dev/ttyS1", &TTYS1_DEV);
+  uart_register("/dev/ttyS1", &TTYS1_DEV.dev);
 #endif
 #ifdef TTYS2_DEV
-  uart_register("/dev/ttyS2", &TTYS2_DEV);
+  uart_register("/dev/ttyS2", &TTYS2_DEV.dev);
 #endif
 }
 
@@ -1661,7 +2542,8 @@ void arm_serialinit(void)
 int up_putc(int ch)
 {
 #ifdef CONSOLE_DEV
-  struct s32k1xx_uart_s *priv = (struct s32k1xx_uart_s *)CONSOLE_DEV.priv;
+  struct s32k1xx_uart_s *priv =
+      (struct s32k1xx_uart_s *)CONSOLE_DEV.dev.priv;
   uint32_t ie;
 
   s32k1xx_disableuartint(priv, &ie);
diff --git a/arch/arm/src/s32k1xx/s32k1xx_serial.h b/arch/arm/src/s32k1xx/s32k1xx_serial.h
index e0c26f2a83..4b05fff5a8 100644
--- a/arch/arm/src/s32k1xx/s32k1xx_serial.h
+++ b/arch/arm/src/s32k1xx/s32k1xx_serial.h
@@ -34,6 +34,115 @@
  * Pre-processor Definitions
  ****************************************************************************/
 
+#if defined(CONFIG_S32K1XX_LPUART0) || defined(CONFIG_S32K1XX_LPUART1) || \
+    defined(CONFIG_S32K1XX_LPUART2)
+#  define HAVE_UART 1
+#endif
+
+/* Assume DMA is not used on the console UART */
+
+#undef SERIAL_HAVE_CONSOLE_RXDMA
+#undef SERIAL_HAVE_CONSOLE_TXDMA
+
+#if !defined(HAVE_UART) || !defined(CONFIG_ARCH_DMA)
+#  undef CONFIG_LPUART0_RXDMA
+#  undef CONFIG_LPUART0_TXDMA
+#  undef CONFIG_LPUART1_RXDMA
+#  undef CONFIG_LPUART1_TXDMA
+#  undef CONFIG_LPUART2_RXDMA
+#  undef CONFIG_LPUART2_TXDMA
+#endif
+
+/* Disable the DMA configuration on all unused LPUARTs */
+
+#ifndef CONFIG_S32K1XX_LPUART0
+#  undef CONFIG_LPUART0_RXDMA
+#  undef CONFIG_LPUART0_TXDMA
+#endif
+
+#ifndef CONFIG_S32K1XX_LPUART1
+#  undef CONFIG_LPUART1_RXDMA
+#  undef CONFIG_LPUART1_TXDMA
+#endif
+
+#ifndef CONFIG_S32K1XX_LPUART2
+#  undef CONFIG_LPUART2_RXDMA
+#  undef CONFIG_LPUART2_TXDMA
+#endif
+
+/* Is RX DMA available on any (enabled) LPUART? */
+
+#undef SERIAL_HAVE_RXDMA
+#if defined(CONFIG_LPUART0_RXDMA) || defined(CONFIG_LPUART1_RXDMA) || \
+    defined(CONFIG_LPUART2_RXDMA)
+#  define SERIAL_HAVE_RXDMA 1
+#endif
+
+/* Is TX DMA available on any (enabled) LPUART? */
+#undef SERIAL_HAVE_TXDMA
+#if defined(CONFIG_LPUART0_TXDMA) || defined(CONFIG_LPUART1_TXDMA) || \
+    defined(CONFIG_LPUART2_TXDMA)
+#    define SERIAL_HAVE_TXDMA 1
+#endif
+
+/* Is RX DMA used on all (enabled) LPUARTs */
+
+#define SERIAL_HAVE_ONLY_RXDMA 1
+#if defined(CONFIG_S32K1XX_LPUART0) && !defined(CONFIG_LPUART0_RXDMA)
+#  undef SERIAL_HAVE_ONLY_RXDMA
+#elif defined(CONFIG_S32K1XX_LPUART1) && !defined(CONFIG_LPUART1_RXDMA)
+#  undef SERIAL_HAVE_ONLY_RXDMA
+#elif defined(CONFIG_S32K1XX_LPUART2) && !defined(CONFIG_LPUART2_RXDMA)
+#  undef SERIAL_HAVE_ONLY_RXDMA
+#endif
+
+/* Is TX DMA used on all (enabled) LPUARTs */
+
+#define SERIAL_HAVE_ONLY_TXDMA 1
+#if defined(CONFIG_S32K1XX_LPUART0) && !defined(CONFIG_LPUART0_TXDMA)
+#  undef SERIAL_HAVE_ONLY_TXDMA
+#elif defined(CONFIG_S32K1XX_LPUART1) && !defined(CONFIG_LPUART1_TXDMA)
+#  undef SERIAL_HAVE_ONLY_TXDMA
+#elif defined(CONFIG_S32K1XX_LPUART2) && !defined(CONFIG_LPUART2_TXDMA)
+#  undef SERIAL_HAVE_ONLY_TXDMA
+#endif
+
+#undef SERIAL_HAVE_ONLY_DMA
+#if defined(SERIAL_HAVE_ONLY_RXDMA) && defined(SERIAL_HAVE_ONLY_TXDMA)
+#define SERIAL_HAVE_ONLY_DMA
+#endif
+
+/* Verify that DMA has been enabled and the DMA channel has been defined.
+ */
+
+#if defined(SERIAL_HAVE_TXDMA) || defined(SERIAL_HAVE_RXDMA)
+#  ifndef CONFIG_S32K1XX_EDMA
+#    error S32K1XX LPUART receive or transmit DMA requires CONFIG_S32K1XX_EDMA
+#  endif
+#endif
+
+#if defined(SERIAL_HAVE_RXDMA)
+/* Currently RS-485 support cannot be enabled when RXDMA is in use due to
+ * lack of testing.
+ */
+
+#  if (defined(CONFIG_LPUART0_RXDMA) && defined(CONFIG_LPUART0_RS485)) || \
+      (defined(CONFIG_LPUART1_RXDMA) && defined(CONFIG_LPUART1_RS485)) || \
+      (defined(CONFIG_LPUART2_RXDMA) && defined(CONFIG_LPUART2_RS485))
+#    error "RXDMA and RS-485 cannot be enabled at the same time for the same LPUART"
+#  endif
+#endif /* SERIAL_HAVE_RXDMA */
+
+/* Currently RS-485 support cannot be enabled when TXDMA is in use due to
+ * lack of testing.
+ */
+
+#if (defined(CONFIG_LPUART0_TXDMA) && defined(CONFIG_LPUART0_RS485)) || \
+    (defined(CONFIG_LPUART1_TXDMA) && defined(CONFIG_LPUART1_RS485)) || \
+    (defined(CONFIG_LPUART2_TXDMA) && defined(CONFIG_LPUART2_RS485))
+#  error "TXDMA and RS-485 cannot be enabled at the same time for the same LPUART"
+#endif
+
 /****************************************************************************
  * Public Types
  ****************************************************************************/
diff --git a/boards/arm/s32k1xx/rddrone-bms772/configs/bms/defconfig b/boards/arm/s32k1xx/rddrone-bms772/configs/bms/defconfig
new file mode 100644
index 0000000000..17a3ceb609
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/configs/bms/defconfig
@@ -0,0 +1,143 @@
+#
+# This file is autogenerated: PLEASE DO NOT EDIT IT.
+#
+# You can use "make menuconfig" to make any modifications to the installed .config file.
+# You can then do "make savedefconfig" to generate a new defconfig file that includes your
+# modifications.
+#
+# CONFIG_ARCH_LEDS is not set
+# CONFIG_NDEBUG is not set
+# CONFIG_NET_ETHERNET is not set
+# CONFIG_NET_IPv4 is not set
+# CONFIG_NSH_ARGCAT is not set
+# CONFIG_NSH_CMDOPT_HEXDUMP is not set
+# CONFIG_NSH_CMDPARMS is not set
+CONFIG_ALLOW_MIT_COMPONENTS=y
+CONFIG_ARCH="arm"
+CONFIG_ARCH_BOARD="rddrone-bms772"
+CONFIG_ARCH_BOARD_RDDRONE_BMS772=y
+CONFIG_ARCH_CHIP="s32k1xx"
+CONFIG_ARCH_CHIP_S32K144=y
+CONFIG_ARCH_CHIP_S32K14X=y
+CONFIG_ARCH_CHIP_S32K1XX=y
+CONFIG_ARCH_INTERRUPTSTACK=1024
+CONFIG_ARCH_STACKDUMP=y
+CONFIG_ARMV7M_LIBM=y
+CONFIG_ARMV7M_MEMCPY=y
+CONFIG_BCH=y
+CONFIG_BINFMT_DISABLE=y
+CONFIG_BOARDCTL_RESET=y
+CONFIG_BOARDCTL_UNIQUEID=y
+CONFIG_BOARD_LOOPSPERMSEC=6667
+CONFIG_BUILTIN=y
+CONFIG_CANUTILS_LIBCANARDV1=y
+CONFIG_CANUTILS_LIBDRONECAN=y
+CONFIG_CAN_CONNS=1
+CONFIG_DEBUG_SYMBOLS=y
+CONFIG_DEV_GPIO=y
+CONFIG_DRIVERS_VIDEO=y
+CONFIG_EVENT_FD=y
+CONFIG_FS_PROCFS=y
+CONFIG_FS_ROMFS=y
+CONFIG_I2C_DRIVER=y
+CONFIG_I2C_RESET=y
+CONFIG_I2C_SLAVE=y
+CONFIG_INIT_ENTRYPOINT="nsh_main"
+CONFIG_INIT_STACKSIZE=2304
+CONFIG_IOB_BUFSIZE=96
+CONFIG_LCD=y
+CONFIG_LCD_FRAMEBUFFER=y
+CONFIG_LCD_MAXCONTRAST=255
+CONFIG_LCD_RLANDSCAPE=y
+CONFIG_LCD_SSD1306_CUSTOM=y
+CONFIG_LCD_SSD1306_I2C=y
+CONFIG_LIBDRONECAN_VERSION="21f2a73df86886101e254d02cfc2277cd2a15717"
+CONFIG_LIBM=y
+CONFIG_LPI2C0_SLAVE_BUS=y
+CONFIG_LPUART0_RXBUFSIZE=64
+CONFIG_LPUART0_TXBUFSIZE=64
+CONFIG_LPUART1_RXBUFSIZE=64
+CONFIG_LPUART1_SERIAL_CONSOLE=y
+CONFIG_LPUART1_TXBUFSIZE=64
+CONFIG_NET=y
+CONFIG_NETDEV_CAN_BITRATE_IOCTL=y
+CONFIG_NETDEV_CAN_FILTER_IOCTL=y
+CONFIG_NETDEV_IFINDEX=y
+CONFIG_NET_CAN=y
+CONFIG_NET_CAN_EXTID=y
+CONFIG_NET_CAN_NOTIFIER=y
+CONFIG_NET_CAN_RAW_FILTER_MAX=0
+CONFIG_NET_CAN_RAW_TX_DEADLINE=y
+CONFIG_NET_CAN_SOCK_OPTS=y
+CONFIG_NET_TIMESTAMP=y
+CONFIG_NSH_ARCHINIT=y
+CONFIG_NSH_ARCHROMFS=y
+CONFIG_NSH_BUILTIN_APPS=y
+CONFIG_NSH_FILEIOSIZE=512
+CONFIG_NSH_READLINE=y
+CONFIG_NSH_ROMFSETC=y
+CONFIG_NXFONTS=y
+CONFIG_NXFONTS_CHARBITS=8
+CONFIG_NXFONTS_DISABLE_16BPP=y
+CONFIG_NXFONTS_DISABLE_1BPP=y
+CONFIG_NXFONTS_DISABLE_24BPP=y
+CONFIG_NXFONTS_DISABLE_2BPP=y
+CONFIG_NXFONTS_DISABLE_32BPP=y
+CONFIG_NXFONTS_DISABLE_4BPP=y
+CONFIG_NXFONTS_DISABLE_8BPP=y
+CONFIG_NXFONT_X11_MISC_FIXED_5X8=y
+CONFIG_NXP_BMS=y
+CONFIG_PATH_MAX=128
+CONFIG_PM=y
+CONFIG_PM_CONSOLE_SLEEP=y
+CONFIG_PM_CONSOLE_STANDBY=y
+CONFIG_PM_SERIAL_SLEEP=y
+CONFIG_PM_SERIAL_STANDBY=y
+CONFIG_PM_SPI0_SLEEP=y
+CONFIG_PM_SPI0_STANDBY=y
+CONFIG_PM_SPI1_STANDBY=y
+CONFIG_PM_SPI_SLEEP=y
+CONFIG_PM_SPI_STANDBY=y
+CONFIG_PREALLOC_TIMERS=4
+CONFIG_RAM_SIZE=61440
+CONFIG_RAM_START=0x1fff8000
+CONFIG_RAW_BINARY=y
+CONFIG_RR_INTERVAL=200
+CONFIG_S32K1XX_EEEPROM=y
+CONFIG_S32K1XX_FLEXCAN0=y
+CONFIG_S32K1XX_GPIOIRQ=y
+CONFIG_S32K1XX_LPI2C0=y
+CONFIG_S32K1XX_LPSPI0=y
+CONFIG_S32K1XX_LPSPI1=y
+CONFIG_S32K1XX_LPSPI_DWORD=y
+CONFIG_S32K1XX_LPSPI_HWPCS=y
+CONFIG_S32K1XX_LPUART0=y
+CONFIG_S32K1XX_LPUART1=y
+CONFIG_S32K1XX_NRSTCHECK_PROCFS=y
+CONFIG_S32K1XX_PORTAINTS=y
+CONFIG_S32K1XX_PORTBINTS=y
+CONFIG_S32K1XX_PORTCINTS=y
+CONFIG_S32K1XX_PORTDINTS=y
+CONFIG_S32K1XX_PORTEINTS=y
+CONFIG_S32K1XX_RESETCAUSE_PROCFS=y
+CONFIG_S32K1XX_RTC=y
+CONFIG_SCHED_CPULOAD=y
+CONFIG_SCHED_LPWORK=y
+CONFIG_SCHED_LPWORKSTACKSIZE=1536
+CONFIG_SCHED_WAITPID=y
+CONFIG_SIG_DEFAULT=y
+CONFIG_SMBUS_SBD=y
+CONFIG_SPI_DRIVER=y
+CONFIG_SSD1306_POWEROFF_RECONFIGURE=y
+CONFIG_STACK_COLORATION=y
+CONFIG_START_DAY=25
+CONFIG_START_MONTH=5
+CONFIG_START_YEAR=2022
+CONFIG_STDIO_DISABLE_BUFFERING=y
+CONFIG_SYMTAB_ORDEREDBYNAME=y
+CONFIG_SYSLOG_DEVPATH="/dev/ttyS0"
+CONFIG_SYSTEM_NSH=y
+CONFIG_USERLED=y
+CONFIG_USERLED_LOWER=y
+CONFIG_USERLED_LOWER_READSTATE=y
+CONFIG_VIDEO_FB=y
diff --git a/boards/arm/s32k1xx/rddrone-bms772/configs/bmsdebug/defconfig b/boards/arm/s32k1xx/rddrone-bms772/configs/bmsdebug/defconfig
new file mode 100644
index 0000000000..a6007e8249
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/configs/bmsdebug/defconfig
@@ -0,0 +1,149 @@
+#
+# This file is autogenerated: PLEASE DO NOT EDIT IT.
+#
+# You can use "make menuconfig" to make any modifications to the installed .config file.
+# You can then do "make savedefconfig" to generate a new defconfig file that includes your
+# modifications.
+#
+# CONFIG_ARCH_LEDS is not set
+# CONFIG_NDEBUG is not set
+# CONFIG_NET_ETHERNET is not set
+# CONFIG_NET_IPv4 is not set
+# CONFIG_NSH_ARGCAT is not set
+# CONFIG_NSH_CMDOPT_HEXDUMP is not set
+# CONFIG_NSH_CMDPARMS is not set
+CONFIG_ALLOW_MIT_COMPONENTS=y
+CONFIG_ARCH="arm"
+CONFIG_ARCH_BOARD="rddrone-bms772"
+CONFIG_ARCH_BOARD_RDDRONE_BMS772=y
+CONFIG_ARCH_CHIP="s32k1xx"
+CONFIG_ARCH_CHIP_S32K144=y
+CONFIG_ARCH_CHIP_S32K14X=y
+CONFIG_ARCH_CHIP_S32K1XX=y
+CONFIG_ARCH_INTERRUPTSTACK=1024
+CONFIG_ARCH_STACKDUMP=y
+CONFIG_ARMV7M_LIBM=y
+CONFIG_ARMV7M_MEMCPY=y
+CONFIG_BCH=y
+CONFIG_BINFMT_DISABLE=y
+CONFIG_BOARDCTL_RESET=y
+CONFIG_BOARDCTL_UNIQUEID=y
+CONFIG_BOARD_LOOPSPERMSEC=6667
+CONFIG_BUILTIN=y
+CONFIG_CANUTILS_LIBCANARDV1=y
+CONFIG_CANUTILS_LIBDRONECAN=y
+CONFIG_CAN_CONNS=1
+CONFIG_DEBUG_ASSERTIONS=y
+CONFIG_DEBUG_ERROR=y
+CONFIG_DEBUG_FEATURES=y
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_SYMBOLS=y
+CONFIG_DEBUG_TCBINFO=y
+CONFIG_DEBUG_WARN=y
+CONFIG_DEV_GPIO=y
+CONFIG_DRIVERS_VIDEO=y
+CONFIG_EVENT_FD=y
+CONFIG_FS_PROCFS=y
+CONFIG_FS_ROMFS=y
+CONFIG_I2C_DRIVER=y
+CONFIG_I2C_RESET=y
+CONFIG_I2C_SLAVE=y
+CONFIG_INIT_ENTRYPOINT="nsh_main"
+CONFIG_INIT_STACKSIZE=2304
+CONFIG_IOB_BUFSIZE=96
+CONFIG_LCD=y
+CONFIG_LCD_FRAMEBUFFER=y
+CONFIG_LCD_MAXCONTRAST=255
+CONFIG_LCD_RLANDSCAPE=y
+CONFIG_LCD_SSD1306_CUSTOM=y
+CONFIG_LCD_SSD1306_I2C=y
+CONFIG_LIBDRONECAN_VERSION="21f2a73df86886101e254d02cfc2277cd2a15717"
+CONFIG_LIBM=y
+CONFIG_LPI2C0_SLAVE_BUS=y
+CONFIG_LPUART0_RXBUFSIZE=64
+CONFIG_LPUART0_TXBUFSIZE=64
+CONFIG_LPUART1_RXBUFSIZE=64
+CONFIG_LPUART1_SERIAL_CONSOLE=y
+CONFIG_LPUART1_TXBUFSIZE=64
+CONFIG_NET=y
+CONFIG_NETDEV_CAN_BITRATE_IOCTL=y
+CONFIG_NETDEV_CAN_FILTER_IOCTL=y
+CONFIG_NETDEV_IFINDEX=y
+CONFIG_NET_CAN=y
+CONFIG_NET_CAN_EXTID=y
+CONFIG_NET_CAN_NOTIFIER=y
+CONFIG_NET_CAN_RAW_FILTER_MAX=0
+CONFIG_NET_CAN_RAW_TX_DEADLINE=y
+CONFIG_NET_CAN_SOCK_OPTS=y
+CONFIG_NET_TIMESTAMP=y
+CONFIG_NSH_ARCHINIT=y
+CONFIG_NSH_ARCHROMFS=y
+CONFIG_NSH_BUILTIN_APPS=y
+CONFIG_NSH_FILEIOSIZE=512
+CONFIG_NSH_READLINE=y
+CONFIG_NSH_ROMFSETC=y
+CONFIG_NXFONTS=y
+CONFIG_NXFONTS_CHARBITS=8
+CONFIG_NXFONTS_DISABLE_16BPP=y
+CONFIG_NXFONTS_DISABLE_1BPP=y
+CONFIG_NXFONTS_DISABLE_24BPP=y
+CONFIG_NXFONTS_DISABLE_2BPP=y
+CONFIG_NXFONTS_DISABLE_32BPP=y
+CONFIG_NXFONTS_DISABLE_4BPP=y
+CONFIG_NXFONTS_DISABLE_8BPP=y
+CONFIG_NXFONT_X11_MISC_FIXED_5X8=y
+CONFIG_NXP_BMS=y
+CONFIG_PATH_MAX=128
+CONFIG_PM=y
+CONFIG_PM_CONSOLE_SLEEP=y
+CONFIG_PM_CONSOLE_STANDBY=y
+CONFIG_PM_SERIAL_SLEEP=y
+CONFIG_PM_SERIAL_STANDBY=y
+CONFIG_PM_SPI0_SLEEP=y
+CONFIG_PM_SPI0_STANDBY=y
+CONFIG_PM_SPI1_STANDBY=y
+CONFIG_PM_SPI_SLEEP=y
+CONFIG_PM_SPI_STANDBY=y
+CONFIG_PREALLOC_TIMERS=4
+CONFIG_RAM_SIZE=61440
+CONFIG_RAM_START=0x1fff8000
+CONFIG_RAW_BINARY=y
+CONFIG_RR_INTERVAL=200
+CONFIG_S32K1XX_EEEPROM=y
+CONFIG_S32K1XX_FLEXCAN0=y
+CONFIG_S32K1XX_GPIOIRQ=y
+CONFIG_S32K1XX_LPI2C0=y
+CONFIG_S32K1XX_LPSPI0=y
+CONFIG_S32K1XX_LPSPI1=y
+CONFIG_S32K1XX_LPSPI_DWORD=y
+CONFIG_S32K1XX_LPSPI_HWPCS=y
+CONFIG_S32K1XX_LPUART0=y
+CONFIG_S32K1XX_LPUART1=y
+CONFIG_S32K1XX_NRSTCHECK_PROCFS=y
+CONFIG_S32K1XX_PORTAINTS=y
+CONFIG_S32K1XX_PORTBINTS=y
+CONFIG_S32K1XX_PORTCINTS=y
+CONFIG_S32K1XX_PORTDINTS=y
+CONFIG_S32K1XX_PORTEINTS=y
+CONFIG_S32K1XX_RESETCAUSE_PROCFS=y
+CONFIG_S32K1XX_RTC=y
+CONFIG_SCHED_CPULOAD=y
+CONFIG_SCHED_LPWORK=y
+CONFIG_SCHED_LPWORKSTACKSIZE=1536
+CONFIG_SCHED_WAITPID=y
+CONFIG_SIG_DEFAULT=y
+CONFIG_SMBUS_SBD=y
+CONFIG_SPI_DRIVER=y
+CONFIG_SSD1306_POWEROFF_RECONFIGURE=y
+CONFIG_STACK_COLORATION=y
+CONFIG_START_DAY=25
+CONFIG_START_MONTH=5
+CONFIG_START_YEAR=2022
+CONFIG_STDIO_DISABLE_BUFFERING=y
+CONFIG_SYMTAB_ORDEREDBYNAME=y
+CONFIG_SYSLOG_DEVPATH="/dev/ttyS0"
+CONFIG_SYSTEM_NSH=y
+CONFIG_USERLED=y
+CONFIG_USERLED_LOWER=y
+CONFIG_USERLED_LOWER_READSTATE=y
+CONFIG_VIDEO_FB=y
diff --git a/boards/arm/s32k1xx/rddrone-bms772/configs/bmstrace/defconfig b/boards/arm/s32k1xx/rddrone-bms772/configs/bmstrace/defconfig
new file mode 100644
index 0000000000..c3d0ab4a4e
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/configs/bmstrace/defconfig
@@ -0,0 +1,158 @@
+#
+# This file is autogenerated: PLEASE DO NOT EDIT IT.
+#
+# You can use "make menuconfig" to make any modifications to the installed .config file.
+# You can then do "make savedefconfig" to generate a new defconfig file that includes your
+# modifications.
+#
+# CONFIG_ARCH_LEDS is not set
+# CONFIG_NDEBUG is not set
+# CONFIG_NET_ETHERNET is not set
+# CONFIG_NET_IPv4 is not set
+# CONFIG_NSH_ARGCAT is not set
+# CONFIG_NSH_CMDOPT_HEXDUMP is not set
+# CONFIG_NSH_CMDPARMS is not set
+CONFIG_ALLOW_MIT_COMPONENTS=y
+CONFIG_ARCH="arm"
+CONFIG_ARCH_BOARD="rddrone-bms772"
+CONFIG_ARCH_BOARD_RDDRONE_BMS772=y
+CONFIG_ARCH_CHIP="s32k1xx"
+CONFIG_ARCH_CHIP_S32K144=y
+CONFIG_ARCH_CHIP_S32K14X=y
+CONFIG_ARCH_CHIP_S32K1XX=y
+CONFIG_ARCH_INTERRUPTSTACK=1024
+CONFIG_ARCH_STACKDUMP=y
+CONFIG_ARMV7M_LIBM=y
+CONFIG_ARMV7M_MEMCPY=y
+CONFIG_BCH=y
+CONFIG_BINFMT_DISABLE=y
+CONFIG_BOARDCTL_RESET=y
+CONFIG_BOARDCTL_UNIQUEID=y
+CONFIG_BOARD_LOOPSPERMSEC=6667
+CONFIG_BUILTIN=y
+CONFIG_CANUTILS_LIBCANARDV1=y
+CONFIG_CANUTILS_LIBDRONECAN=y
+CONFIG_CAN_CONNS=1
+CONFIG_DEBUG_ERROR=y
+CONFIG_DEBUG_FEATURES=y
+CONFIG_DEBUG_SYMBOLS=y
+CONFIG_DEBUG_TCBINFO=y
+CONFIG_DEV_GPIO=y
+CONFIG_DRIVERS_VIDEO=y
+CONFIG_DRIVER_NOTE=y
+CONFIG_EVENT_FD=y
+CONFIG_FS_PROCFS=y
+CONFIG_FS_ROMFS=y
+CONFIG_I2C_DRIVER=y
+CONFIG_I2C_RESET=y
+CONFIG_I2C_SLAVE=y
+CONFIG_INIT_ENTRYPOINT="nsh_main"
+CONFIG_INIT_STACKSIZE=2304
+CONFIG_IOB_BUFSIZE=96
+CONFIG_LCD=y
+CONFIG_LCD_FRAMEBUFFER=y
+CONFIG_LCD_MAXCONTRAST=255
+CONFIG_LCD_RLANDSCAPE=y
+CONFIG_LCD_SSD1306_CUSTOM=y
+CONFIG_LCD_SSD1306_I2C=y
+CONFIG_LIBDRONECAN_VERSION="21f2a73df86886101e254d02cfc2277cd2a15717"
+CONFIG_LIBM=y
+CONFIG_LPI2C0_SLAVE_BUS=y
+CONFIG_LPUART0_RXBUFSIZE=64
+CONFIG_LPUART0_TXBUFSIZE=64
+CONFIG_LPUART1_RXBUFSIZE=64
+CONFIG_LPUART1_SERIAL_CONSOLE=y
+CONFIG_LPUART1_TXBUFSIZE=64
+CONFIG_NET=y
+CONFIG_NETDEV_CAN_BITRATE_IOCTL=y
+CONFIG_NETDEV_CAN_FILTER_IOCTL=y
+CONFIG_NETDEV_IFINDEX=y
+CONFIG_NET_CAN=y
+CONFIG_NET_CAN_EXTID=y
+CONFIG_NET_CAN_NOTIFIER=y
+CONFIG_NET_CAN_RAW_FILTER_MAX=0
+CONFIG_NET_CAN_RAW_TX_DEADLINE=y
+CONFIG_NET_CAN_SOCK_OPTS=y
+CONFIG_NET_TIMESTAMP=y
+CONFIG_NSH_ARCHINIT=y
+CONFIG_NSH_ARCHROMFS=y
+CONFIG_NSH_BUILTIN_APPS=y
+CONFIG_NSH_FILEIOSIZE=512
+CONFIG_NSH_READLINE=y
+CONFIG_NSH_ROMFSETC=y
+CONFIG_NXFONTS=y
+CONFIG_NXFONTS_CHARBITS=8
+CONFIG_NXFONTS_DISABLE_16BPP=y
+CONFIG_NXFONTS_DISABLE_1BPP=y
+CONFIG_NXFONTS_DISABLE_24BPP=y
+CONFIG_NXFONTS_DISABLE_2BPP=y
+CONFIG_NXFONTS_DISABLE_32BPP=y
+CONFIG_NXFONTS_DISABLE_4BPP=y
+CONFIG_NXFONTS_DISABLE_8BPP=y
+CONFIG_NXFONT_X11_MISC_FIXED_5X8=y
+CONFIG_NXP_BMS=y
+CONFIG_PATH_MAX=128
+CONFIG_PM=y
+CONFIG_PM_CONSOLE_SLEEP=y
+CONFIG_PM_CONSOLE_STANDBY=y
+CONFIG_PM_SERIAL_SLEEP=y
+CONFIG_PM_SERIAL_STANDBY=y
+CONFIG_PM_SPI0_SLEEP=y
+CONFIG_PM_SPI0_STANDBY=y
+CONFIG_PM_SPI1_STANDBY=y
+CONFIG_PM_SPI_SLEEP=y
+CONFIG_PM_SPI_STANDBY=y
+CONFIG_PREALLOC_TIMERS=4
+CONFIG_RAM_SIZE=61440
+CONFIG_RAM_START=0x1fff8000
+CONFIG_RAW_BINARY=y
+CONFIG_RR_INTERVAL=200
+CONFIG_S32K1XX_EEEPROM=y
+CONFIG_S32K1XX_FLEXCAN0=y
+CONFIG_S32K1XX_GPIOIRQ=y
+CONFIG_S32K1XX_LPI2C0=y
+CONFIG_S32K1XX_LPSPI0=y
+CONFIG_S32K1XX_LPSPI1=y
+CONFIG_S32K1XX_LPSPI_DWORD=y
+CONFIG_S32K1XX_LPSPI_HWPCS=y
+CONFIG_S32K1XX_LPUART0=y
+CONFIG_S32K1XX_LPUART1=y
+CONFIG_S32K1XX_NRSTCHECK_PROCFS=y
+CONFIG_S32K1XX_PORTAINTS=y
+CONFIG_S32K1XX_PORTBINTS=y
+CONFIG_S32K1XX_PORTCINTS=y
+CONFIG_S32K1XX_PORTDINTS=y
+CONFIG_S32K1XX_PORTEINTS=y
+CONFIG_S32K1XX_RESETCAUSE_PROCFS=y
+CONFIG_S32K1XX_RTC=y
+CONFIG_SCHED_CPULOAD=y
+CONFIG_SCHED_INSTRUMENTATION=y
+CONFIG_SCHED_INSTRUMENTATION_FILTER=y
+CONFIG_SCHED_INSTRUMENTATION_FILTER_DEFAULT_MODE=0x0B
+CONFIG_SCHED_INSTRUMENTATION_IRQHANDLER=y
+CONFIG_SCHED_INSTRUMENTATION_SWITCH=y
+CONFIG_SCHED_LPWORK=y
+CONFIG_SCHED_LPWORKSTACKSIZE=1536
+CONFIG_SCHED_WAITPID=y
+CONFIG_SEGGER_RTT_BUFFER_SIZE_DOWN=2048
+CONFIG_SEGGER_RTT_BUFFER_SIZE_UP=2048
+CONFIG_SEGGER_RTT_MAX_NUM_DOWN_BUFFERS=6
+CONFIG_SEGGER_RTT_MAX_NUM_UP_BUFFERS=6
+CONFIG_SEGGER_SYSVIEW=y
+CONFIG_SEGGER_SYSVIEW_RTT_BUFFER_SIZE=6144
+CONFIG_SIG_DEFAULT=y
+CONFIG_SMBUS_SBD=y
+CONFIG_SPI_DRIVER=y
+CONFIG_SSD1306_POWEROFF_RECONFIGURE=y
+CONFIG_STACK_COLORATION=y
+CONFIG_START_DAY=25
+CONFIG_START_MONTH=5
+CONFIG_START_YEAR=2022
+CONFIG_STDIO_DISABLE_BUFFERING=y
+CONFIG_SYMTAB_ORDEREDBYNAME=y
+CONFIG_SYSLOG_DEVPATH="/dev/ttyS0"
+CONFIG_SYSTEM_NSH=y
+CONFIG_USERLED=y
+CONFIG_USERLED_LOWER=y
+CONFIG_USERLED_LOWER_READSTATE=y
+CONFIG_VIDEO_FB=y
diff --git a/boards/arm/s32k1xx/rddrone-bms772/include/nsh_romfsimg.h b/boards/arm/s32k1xx/rddrone-bms772/include/nsh_romfsimg.h
index 1517f0b65c..cdca12da98 100644
--- a/boards/arm/s32k1xx/rddrone-bms772/include/nsh_romfsimg.h
+++ b/boards/arm/s32k1xx/rddrone-bms772/include/nsh_romfsimg.h
@@ -1,49 +1,7 @@
-/****************************************************************************
- * boards/arm/s32k1xx/rddrone-bms772/include/nsh_romfsimg.h
- *
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.  The
- * ASF licenses this file to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- *
- ****************************************************************************/
-
-/* Copyright 2022 NXP */
-
-#ifndef __BOARDS_ARM_S32K1XX_RDDRONE_BMS772_INCLUDE_NSH_ROMFSIMG_H
-#define __BOARDS_ARM_S32K1XX_RDDRONE_BMS772_INCLUDE_NSH_ROMFSIMG_H
-
-/****************************************************************************
- * Included Files
- ****************************************************************************/
-
-#include <nuttx/config.h>
 #include <nuttx/compiler.h>
-
-/****************************************************************************
- * Public Data
- ****************************************************************************/
-
-#ifdef CONFIG_DEBUG_FEATURES
-
-/* Full init script is used, including a call to the free command to show the
- * memory usage after board initialization has finished.
- */
-
-const unsigned char aligned_data(4) romfs_img[] =
-{
-  0x2d, 0x72, 0x6f, 0x6d, 0x31, 0x66, 0x73, 0x2d, 0x00, 0x00, 0x01, 0xb0,
-  0x98, 0xcd, 0xf3, 0x32, 0x4e, 0x53, 0x48, 0x49, 0x6e, 0x69, 0x74, 0x56,
+const unsigned char aligned_data(4) romfs_img[] = {
+  0x2d, 0x72, 0x6f, 0x6d, 0x31, 0x66, 0x73, 0x2d, 0x00, 0x00, 0x03, 0x00,
+  0x7d, 0xfd, 0xe7, 0x59, 0x4e, 0x53, 0x48, 0x49, 0x6e, 0x69, 0x74, 0x56,
   0x6f, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x49,
   0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0xd1, 0xff, 0xff, 0x97,
   0x2e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
@@ -52,8 +10,8 @@ const unsigned char aligned_data(4) romfs_img[] =
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00,
   0x68, 0x2d, 0x96, 0x03, 0x69, 0x6e, 0x69, 0x74, 0x2e, 0x64, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7a,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xce, 0x8d, 0x9c, 0xaa, 0xb8,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xaa,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfa, 0x8d, 0x9c, 0xaa, 0x5c,
   0x72, 0x63, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x23, 0x20, 0x49, 0x6e, 0x69, 0x74, 0x69, 0x61,
   0x6c, 0x69, 0x7a, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x52, 0x44, 0x44,
@@ -64,142 +22,47 @@ const unsigned char aligned_data(4) romfs_img[] =
   0x72, 0x79, 0x20, 0x61, 0x66, 0x74, 0x65, 0x72, 0x20, 0x62, 0x6f, 0x61,
   0x72, 0x64, 0x20, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x61, 0x6c, 0x69, 0x7a,
   0x61, 0x74, 0x69, 0x6f, 0x6e, 0x3a, 0x22, 0x0a, 0x22, 0x66, 0x72, 0x65,
-  0x65, 0x22, 0x0a, 0x65, 0x63, 0x68, 0x6f, 0x20, 0x22, 0x42, 0x72, 0x69,
-  0x6e, 0x67, 0x20, 0x75, 0x70, 0x20, 0x63, 0x61, 0x6e, 0x30, 0x20, 0x69,
-  0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x3a, 0x22, 0x0a, 0x22,
-  0x69, 0x66, 0x75, 0x70, 0x22, 0x20, 0x22, 0x63, 0x61, 0x6e, 0x30, 0x22,
-  0x0a, 0x65, 0x63, 0x68, 0x6f, 0x20, 0x22, 0x52, 0x44, 0x44, 0x52, 0x4f,
-  0x4e, 0x45, 0x2d, 0x42, 0x4d, 0x53, 0x37, 0x37, 0x32, 0x3a, 0x20, 0x53,
-  0x74, 0x61, 0x72, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x42, 0x4d, 0x53, 0x20,
-  0x61, 0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x22,
-  0x0a, 0x22, 0x62, 0x6d, 0x73, 0x22, 0x00, 0x00, 0x00, 0x00, 0x01, 0x90,
-  0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0xd1, 0xff, 0xfe, 0x10,
-  0x2e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,
-  0x00, 0x00, 0x00, 0x00, 0xd1, 0xd1, 0xff, 0xe0, 0x2e, 0x2e, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00
-};
-const unsigned int romfs_img_len = 1024;
-
-#else /* !CONFIG_DEBUG_FEATURES */
-
-/* Init script does not call the free command to show available memory */
-
-const unsigned char aligned_data(4) romfs_img[] =
-{
-  0x2d, 0x72, 0x6f, 0x6d, 0x31, 0x66, 0x73, 0x2d, 0x00, 0x00, 0x01, 0xb0,
-  0x4e, 0x7a, 0x78, 0x04, 0x4e, 0x53, 0x48, 0x49, 0x6e, 0x69, 0x74, 0x56,
-  0x6f, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x49,
-  0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0xd1, 0xff, 0xff, 0x97,
-  0x2e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x20,
-  0x00, 0x00, 0x00, 0x00, 0xd1, 0xd1, 0xff, 0x80, 0x2e, 0x2e, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00,
-  0x68, 0x2d, 0x96, 0x03, 0x69, 0x6e, 0x69, 0x74, 0x2e, 0x64, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7a,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd0, 0x8d, 0x9c, 0xaa, 0xb6,
-  0x72, 0x63, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x65, 0x22, 0x0a, 0x23, 0x20, 0x65, 0x63, 0x68, 0x6f, 0x20, 0x22, 0x4e,
+  0x4f, 0x54, 0x20, 0x62, 0x72, 0x69, 0x6e, 0x67, 0x69, 0x6e, 0x67, 0x20,
+  0x75, 0x70, 0x20, 0x63, 0x61, 0x6e, 0x30, 0x20, 0x69, 0x6e, 0x74, 0x65,
+  0x72, 0x66, 0x61, 0x63, 0x65, 0x22, 0x0a, 0x23, 0x20, 0x65, 0x63, 0x68,
+  0x6f, 0x20, 0x22, 0x42, 0x72, 0x69, 0x6e, 0x67, 0x20, 0x75, 0x70, 0x20,
+  0x63, 0x61, 0x6e, 0x30, 0x20, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61,
+  0x63, 0x65, 0x3a, 0x22, 0x0a, 0x23, 0x20, 0x22, 0x69, 0x66, 0x75, 0x70,
+  0x22, 0x20, 0x22, 0x63, 0x61, 0x6e, 0x30, 0x22, 0x0a, 0x65, 0x63, 0x68,
+  0x6f, 0x20, 0x22, 0x52, 0x44, 0x44, 0x52, 0x4f, 0x4e, 0x45, 0x2d, 0x42,
+  0x4d, 0x53, 0x37, 0x37, 0x32, 0x3a, 0x20, 0x53, 0x74, 0x61, 0x72, 0x74,
+  0x69, 0x6e, 0x67, 0x20, 0x42, 0x4d, 0x53, 0x20, 0x61, 0x70, 0x70, 0x6c,
+  0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x0a, 0x22, 0x62, 0x6d,
+  0x73, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xca,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfa, 0xaa, 0xb5, 0x64, 0x5b,
+  0x72, 0x63, 0x2e, 0x73, 0x79, 0x73, 0x69, 0x6e, 0x69, 0x74, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x23, 0x20, 0x49, 0x6e, 0x69, 0x74, 0x69, 0x61,
   0x6c, 0x69, 0x7a, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x52, 0x44, 0x44,
   0x52, 0x4f, 0x4e, 0x45, 0x2d, 0x42, 0x4d, 0x53, 0x37, 0x37, 0x32, 0x20,
   0x42, 0x4d, 0x53, 0x20, 0x61, 0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74,
-  0x69, 0x6f, 0x6e, 0x0a, 0x23, 0x65, 0x63, 0x68, 0x6f, 0x20, 0x22, 0x41,
-  0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x6d, 0x65, 0x6d,
-  0x6f, 0x72, 0x79, 0x20, 0x61, 0x66, 0x74, 0x65, 0x72, 0x20, 0x62, 0x6f,
-  0x61, 0x72, 0x64, 0x20, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x61, 0x6c, 0x69,
-  0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x3a, 0x22, 0x0a, 0x23, 0x22, 0x66,
-  0x72, 0x65, 0x65, 0x22, 0x0a, 0x65, 0x63, 0x68, 0x6f, 0x20, 0x22, 0x42,
-  0x72, 0x69, 0x6e, 0x67, 0x20, 0x75, 0x70, 0x20, 0x63, 0x61, 0x6e, 0x30,
-  0x20, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x3a, 0x22,
-  0x0a, 0x22, 0x69, 0x66, 0x75, 0x70, 0x22, 0x20, 0x22, 0x63, 0x61, 0x6e,
-  0x30, 0x22, 0x0a, 0x65, 0x63, 0x68, 0x6f, 0x20, 0x22, 0x52, 0x44, 0x44,
-  0x52, 0x4f, 0x4e, 0x45, 0x2d, 0x42, 0x4d, 0x53, 0x37, 0x37, 0x32, 0x3a,
-  0x20, 0x53, 0x74, 0x61, 0x72, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x42, 0x4d,
-  0x53, 0x20, 0x61, 0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f,
-  0x6e, 0x22, 0x0a, 0x22, 0x62, 0x6d, 0x73, 0x22, 0x00, 0x00, 0x01, 0x90,
-  0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0xd1, 0xff, 0xfe, 0x10,
-  0x2e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,
-  0x00, 0x00, 0x00, 0x00, 0xd1, 0xd1, 0xff, 0xe0, 0x2e, 0x2e, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x69, 0x6f, 0x6e, 0x0a, 0x65, 0x63, 0x68, 0x6f, 0x20, 0x22, 0x41, 0x76,
+  0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x6d, 0x65, 0x6d, 0x6f,
+  0x72, 0x79, 0x20, 0x61, 0x66, 0x74, 0x65, 0x72, 0x20, 0x62, 0x6f, 0x61,
+  0x72, 0x64, 0x20, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x61, 0x6c, 0x69, 0x7a,
+  0x61, 0x74, 0x69, 0x6f, 0x6e, 0x3a, 0x22, 0x0a, 0x22, 0x66, 0x72, 0x65,
+  0x65, 0x22, 0x0a, 0x23, 0x20, 0x65, 0x63, 0x68, 0x6f, 0x20, 0x22, 0x4e,
+  0x4f, 0x54, 0x20, 0x62, 0x72, 0x69, 0x6e, 0x67, 0x69, 0x6e, 0x67, 0x20,
+  0x75, 0x70, 0x20, 0x63, 0x61, 0x6e, 0x30, 0x20, 0x69, 0x6e, 0x74, 0x65,
+  0x72, 0x66, 0x61, 0x63, 0x65, 0x22, 0x0a, 0x23, 0x20, 0x65, 0x63, 0x68,
+  0x6f, 0x20, 0x22, 0x42, 0x72, 0x69, 0x6e, 0x67, 0x20, 0x75, 0x70, 0x20,
+  0x63, 0x61, 0x6e, 0x30, 0x20, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61,
+  0x63, 0x65, 0x3a, 0x22, 0x0a, 0x23, 0x20, 0x22, 0x69, 0x66, 0x75, 0x70,
+  0x22, 0x20, 0x22, 0x63, 0x61, 0x6e, 0x30, 0x22, 0x0a, 0x65, 0x63, 0x68,
+  0x6f, 0x20, 0x22, 0x52, 0x44, 0x44, 0x52, 0x4f, 0x4e, 0x45, 0x2d, 0x42,
+  0x4d, 0x53, 0x37, 0x37, 0x32, 0x3a, 0x20, 0x53, 0x74, 0x61, 0x72, 0x74,
+  0x69, 0x6e, 0x67, 0x20, 0x42, 0x4d, 0x53, 0x20, 0x61, 0x70, 0x70, 0x6c,
+  0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x0a, 0x22, 0x62, 0x6d,
+  0x73, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xe0,
+  0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0xd1, 0xd1, 0xfd, 0x00,
+  0x2e, 0x2e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60,
+  0x00, 0x00, 0x00, 0x00, 0xd1, 0xff, 0xff, 0xa0, 0x2e, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
@@ -224,7 +87,4 @@ const unsigned char aligned_data(4) romfs_img[] =
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00
 };
-const unsigned int romfs_img_len = 1024;
-
-#endif /* CONFIG_DEBUG_FEATURES */
-#endif /* __BOARDS_ARM_S32K1XX_RDDRONE_BMS772_INCLUDE_NSH_ROMFSIMG_H */
+unsigned int romfs_img_len = 1024;
diff --git a/boards/arm/s32k1xx/rddrone-bms772/include/rc.sysinit.template b/boards/arm/s32k1xx/rddrone-bms772/include/rc.sysinit.template
new file mode 100644
index 0000000000..9a3c4a894f
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/include/rc.sysinit.template
@@ -0,0 +1,8 @@
+# Initialize the RDDRONE-BMS772 BMS application
+echo "Available memory after board initialization:"
+"free"
+# echo "NOT bringing up can0 interface"
+# echo "Bring up can0 interface:"
+# "ifup" "can0"
+echo "RDDRONE-BMS772: Starting BMS application"
+"bms"
\ No newline at end of file
diff --git a/boards/arm/s32k1xx/rddrone-bms772/include/rcS.template b/boards/arm/s32k1xx/rddrone-bms772/include/rcS.template
index f9c98396c2..9a3c4a894f 100644
--- a/boards/arm/s32k1xx/rddrone-bms772/include/rcS.template
+++ b/boards/arm/s32k1xx/rddrone-bms772/include/rcS.template
@@ -1,7 +1,8 @@
 # Initialize the RDDRONE-BMS772 BMS application
 echo "Available memory after board initialization:"
 "free"
-echo "Bring up can0 interface:"
-"ifup" "can0"
+# echo "NOT bringing up can0 interface"
+# echo "Bring up can0 interface:"
+# "ifup" "can0"
 echo "RDDRONE-BMS772: Starting BMS application"
 "bms"
\ No newline at end of file
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/rddrone-bms772.h b/boards/arm/s32k1xx/rddrone-bms772/src/rddrone-bms772.h
index f9865c7f9d..61114c4c00 100644
--- a/boards/arm/s32k1xx/rddrone-bms772/src/rddrone-bms772.h
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/rddrone-bms772.h
@@ -77,10 +77,6 @@
 
 #define NUM_OF_GPIO 12
 
-/* Count of peripheral clock user configurations */
-
-#define NUM_OF_PERIPHERAL_CLOCKS_0 12
-
 /****************************************************************************
  * Public Data
  ****************************************************************************/
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_clockconfig.c b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_clockconfig.c
index f628d415e5..a6cf7ce645 100644
--- a/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_clockconfig.c
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_clockconfig.c
@@ -163,7 +163,6 @@ const struct clock_configuration_s g_initial_clkconfig =
   },
   .pcc             =
   {
-    .count         = NUM_OF_PERIPHERAL_CLOCKS_0,       /* Number peripheral clock configurations */
     .pclks         = g_peripheral_clockconfig0,        /* Peripheral clock configurations */
   },
   .pmc             =
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_nrstcheck_procfs.c b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_nrstcheck_procfs.c
index 81f3b4783d..dfc45df09a 100644
--- a/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_nrstcheck_procfs.c
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_nrstcheck_procfs.c
@@ -289,6 +289,9 @@ int s32k1xx_nrstcheck_procfs_register(void)
       return ret;
     }
 
+  /* Sleep for a small amount of time for the NRST pin to become low */
+  usleep(10);
+
   /* Read the input level of the pin, which should be pulled high externally
    * by a resistor or another IC
    */
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_periphclocks.c b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_periphclocks.c
index 969eb59402..f07236dbca 100644
--- a/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_periphclocks.c
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_periphclocks.c
@@ -40,6 +40,14 @@
 
 const struct peripheral_clock_config_s g_peripheral_clockconfig0[] =
 {
+  {
+    .clkname = DMAMUX0_CLK,
+#ifdef CONFIG_S32K1XX_EDMA
+    .clkgate = true,
+#else
+    .clkgate = false,
+#endif
+  },
   {
     .clkname = FLEXCAN0_CLK,
 #ifdef CONFIG_S32K1XX_FLEXCAN0
@@ -123,6 +131,10 @@ const struct peripheral_clock_config_s g_peripheral_clockconfig0[] =
   },
 };
 
+unsigned int const num_of_peripheral_clocks_0 =
+    sizeof(g_peripheral_clockconfig0) /
+    sizeof(g_peripheral_clockconfig0[0]);
+
 /****************************************************************************
  * Public Functions
  ****************************************************************************/
diff --git a/net/can/can_recvmsg.c b/net/can/can_recvmsg.c
index 536e72a1ed..8b18529049 100644
--- a/net/can/can_recvmsg.c
+++ b/net/can/can_recvmsg.c
@@ -290,7 +290,7 @@ static inline int can_readahead(struct can_recvfrom_s *pstate)
       if (!conn->fd_frames)
 #endif
         {
-          if (recvlen > sizeof(struct can_frame))
+          if (iob->io_pktlen > sizeof(struct can_frame))
             {
               return 0;
             }
@@ -625,12 +625,12 @@ ssize_t can_recvmsg(FAR struct socket *psock, FAR struct msghdr *msg,
    */
 
   ret = can_readahead(&state);
-  if (ret > 0)
+  if (1)
     {
 #ifdef CONFIG_NET_TIMESTAMP
       if (conn->sconn.s_timestamp)
         {
-          if (state.pr_msglen == sizeof(struct timeval))
+          if (state.pr_msglen == sizeof(struct timeval) && ret > 0)
             {
               can_readahead_timestamp(conn, state.pr_msgbuf);
             }
diff --git a/net/utils/net_lock.c b/net/utils/net_lock.c
index 5dc6967c4c..be8f8d7915 100644
--- a/net/utils/net_lock.c
+++ b/net/utils/net_lock.c
@@ -244,7 +244,7 @@ int net_trylock(void)
 
 void net_unlock(void)
 {
-  DEBUGASSERT(g_holder == getpid() && g_count > 0);
+  DEBUGASSERT(g_count > 0);
 
   /* If the count would go to zero, then release the semaphore */
 
diff --git a/sched/semaphore/sem_trywait.c b/sched/semaphore/sem_trywait.c
index 4e9cc0ea01..dc1dbe83ae 100644
--- a/sched/semaphore/sem_trywait.c
+++ b/sched/semaphore/sem_trywait.c
@@ -70,10 +70,11 @@ int nxsem_trywait(FAR sem_t *sem)
   irqstate_t flags;
   int ret;
 
-  /* This API should not be called from interrupt handlers & idleloop */
+  /* This API should not be called from the idleloop */
 
-  DEBUGASSERT(sem != NULL && up_interrupt_context() == false);
-  DEBUGASSERT(!OSINIT_IDLELOOP() || !sched_idletask());
+  DEBUGASSERT(sem != NULL);
+  DEBUGASSERT(!OSINIT_IDLELOOP() || !sched_idletask() ||
+              up_interrupt_context());
 
   if (sem != NULL)
     {
-- 
2.25.1

