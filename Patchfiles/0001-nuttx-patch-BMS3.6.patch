From b878fcf9e2c5d53cbcc0ccd4b1b8e113df3d519b Mon Sep 17 00:00:00 2001
From: Cis van Mierlo <cis.van.mierlo@nxp.com>
Date: Fri, 29 Jan 2021 09:16:47 +0100
Subject: [PATCH] nuttx patch BMS3.6

---
 Kconfig                                       |    1 +
 arch/arm/src/s32k1xx/s32k1xx_lpspi.c          |  224 +-
 arch/arm/src/s32k1xx/s32k1xx_pingpio.c        |   10 +-
 boards/Kconfig                                |   12 +
 boards/arm/s32k1xx/rddrone-bms772/Kconfig     |    8 +
 boards/arm/s32k1xx/rddrone-bms772/README.txt  |   15 +
 .../rddrone-bms772/configs/bms/.gitignore     |    2 +
 .../rddrone-bms772/configs/bms/defconfig      |  106 +
 .../configs/bmsdebug/.gitignore               |    2 +
 .../rddrone-bms772/configs/bmsdebug/defconfig |  110 +
 .../s32k1xx/rddrone-bms772/include/board.h    |  162 +
 .../rddrone-bms772/include/nsh_romfsimg.h     |   89 +
 .../rddrone-bms772/include/rcS.template       |   20 +
 .../s32k1xx/rddrone-bms772/scripts/Make.defs  |  108 +
 .../s32k1xx/rddrone-bms772/scripts/flash.ld   |  152 +
 .../rddrone-bms772/scripts/s32k144.cfg        |   58 +
 .../s32k1xx/rddrone-bms772/scripts/sram.ld    |  129 +
 .../arm/s32k1xx/rddrone-bms772/src/.gitignore |    2 +
 .../arm/s32k1xx/rddrone-bms772/src/Makefile   |   71 +
 .../rddrone-bms772/src/rddrone-bms772.h       |  215 ++
 .../rddrone-bms772/src/s32k1xx_appinit.c      |   94 +
 .../rddrone-bms772/src/s32k1xx_autoleds.c     |  165 +
 .../s32k1xx/rddrone-bms772/src/s32k1xx_boot.c |   93 +
 .../rddrone-bms772/src/s32k1xx_bringup.c      |  181 +
 .../rddrone-bms772/src/s32k1xx_buttons.c      |  164 +
 .../rddrone-bms772/src/s32k1xx_clockconfig.c  |  217 ++
 .../s32k1xx/rddrone-bms772/src/s32k1xx_gpio.c |  399 +++
 .../rddrone-bms772/src/s32k1xx_periphclocks.c |  159 +
 .../rddrone-bms772/src/s32k1xx_reset.c        |   77 +
 .../s32k1xx/rddrone-bms772/src/s32k1xx_spi.c  |  168 +
 .../rddrone-bms772/src/s32k1xx_userleds.c     |  138 +
 net/can/can_callback.c                        |    6 +-
 net/can/can_setsockopt.c                      |    2 +-
 net/devif/devif_poll.c                        |    9 +-
 net/utils/net_lock.c                          |   22 +-
 sched/Makefile                                |    1 +
 sched/init/nx_start.c                         |    4 +
 sched/irq/irq_dispatch.c                      |   13 +
 sched/pthread/pthread_create.c                |   11 +
 sched/pthread/pthread_exit.c                  |    4 +
 sched/sched/sched_addblocked.c                |   16 +
 sched/sched/sched_addreadytorun.c             |    4 +
 sched/sched/sched_resumescheduler.c           |    2 +
 sched/semaphore/sem_trywait.c                 |    6 +-
 sched/systemview/Global.h                     |  113 +
 sched/systemview/Kconfig                      |   66 +
 sched/systemview/Make.defs                    |   47 +
 sched/systemview/Makefile                     |   76 +
 sched/systemview/SEGGER.h                     |  248 ++
 sched/systemview/SEGGER_RTT.c                 | 2009 +++++++++++
 sched/systemview/SEGGER_RTT.h                 |  325 ++
 sched/systemview/SEGGER_RTT_ASM_ARMv7M.S      |  235 ++
 sched/systemview/SEGGER_RTT_Conf.h            |  388 +++
 sched/systemview/SEGGER_RTT_printf.c          |  504 +++
 sched/systemview/SEGGER_SYSVIEW.c             | 2945 +++++++++++++++++
 sched/systemview/SEGGER_SYSVIEW.h             |  346 ++
 sched/systemview/SEGGER_SYSVIEW_Conf.h        |  203 ++
 .../systemview/SEGGER_SYSVIEW_ConfDefaults.h  |  172 +
 .../systemview/SEGGER_SYSVIEW_Config_NuttX.c  |  194 ++
 sched/systemview/SEGGER_SYSVIEW_Int.h         |  100 +
 sched/systemview/SEGGER_SYSVIEW_NuttX.c       |  269 ++
 sched/systemview/SEGGER_SYSVIEW_NuttX.h       |  156 +
 sched/task/task_create.c                      |    2 +
 sched/task/task_start.c                       |    6 +
 tools/version.sh                              |   10 +-
 65 files changed, 11795 insertions(+), 70 deletions(-)
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/Kconfig
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/README.txt
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/configs/bms/.gitignore
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/configs/bms/defconfig
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/configs/bmsdebug/.gitignore
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/configs/bmsdebug/defconfig
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/include/board.h
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/include/nsh_romfsimg.h
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/include/rcS.template
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/scripts/Make.defs
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/scripts/flash.ld
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/scripts/s32k144.cfg
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/scripts/sram.ld
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/src/.gitignore
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/src/Makefile
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/src/rddrone-bms772.h
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_appinit.c
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_autoleds.c
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_boot.c
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_bringup.c
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_buttons.c
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_clockconfig.c
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_gpio.c
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_periphclocks.c
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_reset.c
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_spi.c
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_userleds.c
 create mode 100644 sched/systemview/Global.h
 create mode 100644 sched/systemview/Kconfig
 create mode 100644 sched/systemview/Make.defs
 create mode 100644 sched/systemview/Makefile
 create mode 100644 sched/systemview/SEGGER.h
 create mode 100644 sched/systemview/SEGGER_RTT.c
 create mode 100644 sched/systemview/SEGGER_RTT.h
 create mode 100644 sched/systemview/SEGGER_RTT_ASM_ARMv7M.S
 create mode 100644 sched/systemview/SEGGER_RTT_Conf.h
 create mode 100644 sched/systemview/SEGGER_RTT_printf.c
 create mode 100644 sched/systemview/SEGGER_SYSVIEW.c
 create mode 100644 sched/systemview/SEGGER_SYSVIEW.h
 create mode 100644 sched/systemview/SEGGER_SYSVIEW_Conf.h
 create mode 100644 sched/systemview/SEGGER_SYSVIEW_ConfDefaults.h
 create mode 100644 sched/systemview/SEGGER_SYSVIEW_Config_NuttX.c
 create mode 100644 sched/systemview/SEGGER_SYSVIEW_Int.h
 create mode 100644 sched/systemview/SEGGER_SYSVIEW_NuttX.c
 create mode 100644 sched/systemview/SEGGER_SYSVIEW_NuttX.h

diff --git a/Kconfig b/Kconfig
index c69636205e..c23d98de40 100644
--- a/Kconfig
+++ b/Kconfig
@@ -1764,6 +1764,7 @@ endmenu
 menu "RTOS Features"
 source sched/Kconfig
 source syscall/Kconfig
+source sched/systemview/Kconfig
 endmenu
 
 menu "Device Drivers"
diff --git a/arch/arm/src/s32k1xx/s32k1xx_lpspi.c b/arch/arm/src/s32k1xx/s32k1xx_lpspi.c
index b0cb406a93..ead9320222 100644
--- a/arch/arm/src/s32k1xx/s32k1xx_lpspi.c
+++ b/arch/arm/src/s32k1xx/s32k1xx_lpspi.c
@@ -151,12 +151,12 @@ static inline void s32k1xx_lpspi_putreg32(FAR struct s32k1xx_lpspidev_s *priv,
               uint8_t offset, uint32_t value);
 static inline uint32_t s32k1xx_lpspi_readword(FAR struct s32k1xx_lpspidev_s *priv);
 static inline void s32k1xx_lpspi_writeword(FAR struct s32k1xx_lpspidev_s *priv,
-              uint16_t byte);
-static inline bool s32k1xx_lpspi_9to16bitmode(FAR struct s32k1xx_lpspidev_s *priv);
+              uint32_t byte);
+static inline uint16_t s32k1xx_lpspi_9to16bitmode(FAR struct s32k1xx_lpspidev_s *priv);
 static uint32_t s32k1xx_lpspi_pckfreq(uintptr_t base);
-static inline void s32k1xx_lpspi_set_delays(FAR struct s32k1xx_lpspidev_s
+static inline void s32k1xx_lpspi_master_set_delays(FAR struct s32k1xx_lpspidev_s
               *priv, uint32_t delay_ns, enum s32k1xx_delay_e type);
-static inline void s32k1xx_lpspi_set_delay_scaler(FAR struct
+static inline void s32k1xx_lpspi_master_set_delay_scaler(FAR struct
               s32k1xx_lpspidev_s *priv, uint32_t scaler, enum s32k1xx_delay_e type);
 
 /* SPI methods */
@@ -457,7 +457,7 @@ static inline uint32_t s32k1xx_lpspi_readword(FAR struct s32k1xx_lpspidev_s *pri
  ************************************************************************************/
 
 static inline void s32k1xx_lpspi_writeword(FAR struct s32k1xx_lpspidev_s *priv,
-                                           uint16_t word)
+                                           uint32_t word)
 {
   /* Wait until the transmit buffer is empty */
 
@@ -470,6 +470,36 @@ static inline void s32k1xx_lpspi_writeword(FAR struct s32k1xx_lpspidev_s *priv,
   s32k1xx_lpspi_putreg32(priv, S32K1XX_LPSPI_TDR_OFFSET, word);
 }
 
+/************************************************************************************
+ * Name: s32k1xx_lpspi_writeDword
+ *
+ * Description:
+ *   Write two words to SPI
+ *
+ * Input Parameters:
+ *   priv - Device-specific state data
+ *   word0, word1 - words to send
+ *
+ * Returned Value:
+ *   None
+ *
+ ************************************************************************************/
+
+static inline void s32k1xx_lpspi_writeDword(FAR struct s32k1xx_lpspidev_s *priv,
+                                           uint32_t word0, uint32_t word1)
+{
+  /* Wait until the transmit buffer is empty */
+
+  while ((s32k1xx_lpspi_getreg32(priv, S32K1XX_LPSPI_SR_OFFSET) & LPSPI_SR_TDF) == 0)
+    {
+    }
+
+  /* Then send the words, use the FIFO */
+
+  s32k1xx_lpspi_putreg32(priv, S32K1XX_LPSPI_TDR_OFFSET, word0);
+  s32k1xx_lpspi_putreg32(priv, S32K1XX_LPSPI_TDR_OFFSET, word1);
+}
+
 /************************************************************************************
  * Name: s32k1xx_lpspi_readbyte
  *
@@ -531,29 +561,22 @@ static inline void s32k1xx_lpspi_writebyte(FAR struct s32k1xx_lpspidev_s *priv,
  *
  * Description:
  *   Check if the SPI is operating in more then 8 bit mode
+ *   On the S32K the frame size can grow to 4096 bit/frame
  *
  * Input Parameters:
  *   priv     - Device-specific state data
  *
  * Returned Value:
- *   true: >8 bit mode-bit mode, false: <= 8-bit mode
+ *   value: frame size
  *
  ************************************************************************************/
 
-static inline bool s32k1xx_lpspi_9to16bitmode(FAR struct s32k1xx_lpspidev_s *priv)
+static inline uint16_t s32k1xx_lpspi_9to16bitmode(FAR struct s32k1xx_lpspidev_s *priv)
 {
-  bool ret;
-
-  if (((s32k1xx_lpspi_getreg32(priv, S32K1XX_LPSPI_TCR_OFFSET) &
-        LPSPI_TCR_FRAMESZ_MASK) + 1) < 9)
-    {
-      ret = false;
-    }
-  else
-    {
-      ret = true;
-    }
+  uint16_t ret;
 
+  ret = ((s32k1xx_lpspi_getreg32(priv, S32K1XX_LPSPI_TCR_OFFSET) &
+        LPSPI_TCR_FRAMESZ_MASK) + 1);
   return ret;
 }
 
@@ -640,7 +663,7 @@ static uint32_t s32k1xx_lpspi_pckfreq(uintptr_t base)
 }
 
 /************************************************************************************
- * Name: s32k1xx_lpspi_set_delays
+ * Name: s32k1xx_lpspi_master_set_delays
  *
  * Description:
  *   SET LPSPI Delay times
@@ -655,10 +678,9 @@ static uint32_t s32k1xx_lpspi_pckfreq(uintptr_t base)
  *
  ************************************************************************************/
 
-static inline void s32k1xx_lpspi_set_delay_scaler(FAR struct
-                                                  s32k1xx_lpspidev_s *priv,
-                                                  uint32_t scaler,
-                                                  enum s32k1xx_delay_e type)
+static inline void s32k1xx_lpspi_master_set_delay_scaler(FAR struct s32k1xx_lpspidev_s *priv,
+                                                         uint32_t scaler,
+                                                         enum s32k1xx_delay_e type)
 {
   switch (type)
     {
@@ -686,7 +708,7 @@ static inline void s32k1xx_lpspi_set_delay_scaler(FAR struct
 }
 
 /************************************************************************************
- * Name: s32k1xx_lpspi_set_delays
+ * Name: s32k1xx_lpspi_master_set_delays
  *
  * Description:
  *   SET LPSPI Delay times
@@ -701,7 +723,7 @@ static inline void s32k1xx_lpspi_set_delay_scaler(FAR struct
  *
  ************************************************************************************/
 
-static inline void s32k1xx_lpspi_set_delays(FAR struct s32k1xx_lpspidev_s *priv,
+static inline void s32k1xx_lpspi_master_set_delays(FAR struct s32k1xx_lpspidev_s *priv,
                                                    uint32_t delay_ns,
                                                    enum s32k1xx_delay_e type)
 {
@@ -786,7 +808,7 @@ static inline void s32k1xx_lpspi_set_delays(FAR struct s32k1xx_lpspidev_s *priv,
 
   if (initial_delay_ns >= delay_ns)
     {
-      s32k1xx_lpspi_set_delay_scaler(priv, 0, type);
+      s32k1xx_lpspi_master_set_delay_scaler(priv, 0, type);
     }
   else
     {
@@ -823,7 +845,7 @@ static inline void s32k1xx_lpspi_set_delays(FAR struct s32k1xx_lpspidev_s *priv,
             }
         }
 
-      s32k1xx_lpspi_set_delay_scaler(priv, best_scaler, type);
+      s32k1xx_lpspi_master_set_delay_scaler(priv, best_scaler, type);
     }
 }
 
@@ -852,7 +874,8 @@ static int s32k1xx_lpspi_lock(FAR struct spi_dev_s *dev, bool lock)
 {
   FAR struct s32k1xx_lpspidev_s *priv = (FAR struct s32k1xx_lpspidev_s *)dev;
   int ret;
-
+// TODO; Needs to be switched of for debugging
+#if 0
   if (lock)
     {
       ret = nxsem_wait_uninterruptible(&priv->exclsem);
@@ -863,6 +886,9 @@ static int s32k1xx_lpspi_lock(FAR struct spi_dev_s *dev, bool lock)
     }
 
   return ret;
+#else
+  return 1;
+#endif
 }
 
 /************************************************************************************
@@ -960,11 +986,11 @@ static uint32_t s32k1xx_lpspi_setfrequency(FAR struct spi_dev_s *dev,
       priv->frequency = frequency;
       priv->actual = best_frequency;
 
-      s32k1xx_lpspi_set_delays(priv, 1000000000 / best_frequency,
+      s32k1xx_lpspi_master_set_delays(priv, 1000000000 / best_frequency,
                                     LPSPI_PCS_TO_SCK);
-      s32k1xx_lpspi_set_delays(priv, 1000000000 / best_frequency,
+      s32k1xx_lpspi_master_set_delays(priv, 1000000000 / best_frequency,
                                     LPSPI_LAST_SCK_TO_PCS);
-      s32k1xx_lpspi_set_delays(priv, 1000000000 / best_frequency,
+      s32k1xx_lpspi_master_set_delays(priv, 1000000000 / best_frequency,
                                     LPSPI_BETWEEN_TRANSFER);
 
       /* Re-enable LPSPI if it was enabled previously */
@@ -1220,6 +1246,57 @@ static uint32_t s32k1xx_lpspi_send(FAR struct spi_dev_s *dev, uint32_t wd)
   return ret;
 }
 
+/************************************************************************************
+ * Name: s32k1xx_lpspi_send2
+ *
+ * Description:
+ *   Exchange two words on SPI
+ *
+ * Input Parameters:
+ *   dev - Device-specific state data
+ *   wd0, wd1  - The word to send.  the size of the data is determined by the
+ *         number of bits selected for the SPI interface.
+ *
+ * Returned Value:
+ *   response
+ *
+ ************************************************************************************/
+
+static uint32_t s32k1xx_lpspi_send2(FAR struct spi_dev_s *dev, uint32_t wd0, uint32_t wd1, uint32_t *rw1)
+{
+  FAR struct s32k1xx_lpspidev_s *priv = (FAR struct s32k1xx_lpspidev_s *)dev;
+  uint32_t regval;
+  uint32_t ret;
+
+  DEBUGASSERT(priv && priv->spibase);
+
+#if 1
+  /* check if the receive buffer is empty, if not clear it */
+  while ((s32k1xx_lpspi_getreg32(priv, S32K1XX_LPSPI_SR_OFFSET) & LPSPI_SR_RDF)) {
+    s32k1xx_lpspi_getreg32(priv, S32K1XX_LPSPI_RDR_OFFSET);
+  }
+#endif
+
+  s32k1xx_lpspi_writeDword(priv, wd0, wd1);
+
+  while ((s32k1xx_lpspi_getreg32(priv, S32K1XX_LPSPI_SR_OFFSET) & LPSPI_SR_RDF) !=
+         LPSPI_SR_RDF);
+
+  ret  = s32k1xx_lpspi_readword(priv);
+  *rw1 = s32k1xx_lpspi_readword(priv);
+
+  /* Check and clear any error flags (Reading from the SR clears the error
+   * flags).
+   */
+
+  regval = s32k1xx_lpspi_getreg32(priv, S32K1XX_LPSPI_SR_OFFSET);
+
+  spiinfo("Sent: %02x %08x  Return: %04x Status: %02x\n", wd1, wd0, ret, regval);
+
+  UNUSED(regval);
+  return ret;
+}
+
 /************************************************************************************
  * Name: s32k1xx_lpspi_exchange (no DMA).  aka s32k1xx_lpspi_exchange_nodma
  *
@@ -1254,42 +1331,85 @@ static void s32k1xx_lpspi_exchange_nodma(FAR struct spi_dev_s *dev,
 {
   FAR struct s32k1xx_lpspidev_s *priv = (FAR struct s32k1xx_lpspidev_s *)dev;
   DEBUGASSERT(priv && priv->spibase);
+  uint16_t frameSize;
 
   spiinfo("txbuffer=%p rxbuffer=%p nwords=%d\n", txbuffer, rxbuffer, nwords);
 
   /* 8- or 16-bit mode? */
-
-  if (s32k1xx_lpspi_9to16bitmode(priv))
+  frameSize = s32k1xx_lpspi_9to16bitmode(priv);
+  if (frameSize > 8)
     {
-      /* 16-bit mode */
+      /* 16-bit, 32-bit or 40-bit mode */
+      /* take care of big endian mode of hardware !! */
 
-      const uint16_t *src = (const uint16_t *)txbuffer;
-      uint16_t *dest = (uint16_t *) rxbuffer;
-      uint16_t word;
+      const uint8_t *src = (const uint8_t *)txbuffer;
+      uint8_t *dest = (uint8_t *) rxbuffer;
+      uint32_t word, word1, rword1;
+      bool     dwords = false;
 
-      while (nwords-- > 0)
-        {
+      while (nwords-- > 0) {
           /* Get the next word to write.  Is there a source buffer? */
 
-          if (src)
-            {
-              word = *src++;
-            }
-          else
-            {
-              word = 0xffff;
-            }
+          if (src) {
+			// read the required number of bytes
+			switch (frameSize) {
+			  case 16:
+				   word = (src[0] << 8) + src[1];
+				   src += 2;
+				   break;
+			  case 32:
+				   word = (src[0] << 24) + (src[1] << 16) + (src[2] << 8) + src[3];
+				   src += 4;
+				   break;
+			  case 40:
+				   word = (src[0] << 24) + (src[1] << 16) + (src[2] << 8) + src[3];
+				   word1 = src[4];
+				   src += 5;
+				   dwords = true;
+			  default: // expect 40 bit TODO
+					  break;
+			}
+          } else {
+              word = 0xffffffff;
+          }
 
           /* Exchange one word */
-
-          word = (uint16_t) s32k1xx_lpspi_send(dev, (uint32_t) word);
+          if (dwords) {
+              word = s32k1xx_lpspi_send2(dev, word, word1, &rword1);
+          } else {
+            word = s32k1xx_lpspi_send(dev, word);
+          }
 
           /* Is there a buffer to receive the return value? */
 
-          if (dest)
-            {
-              *dest++ = word;
+          if (dest) {
+			switch (frameSize) {
+			  case 16:
+				   dest[0] = (word >> 8) & 0xff;
+				   dest[1] =  word       & 0xff;
+				   dest += 2;
+				   break;
+			  case 32:
+				   dest[0] = (word >> 24) & 0xff;
+				   dest[1] = (word >> 16) & 0xff;
+				   dest[2] = (word >>  8) & 0xff;
+				   dest[3] =  word        & 0xff;
+				   dest += 4;
+				   break;
+			  case 40:
+				   dest[0] = (word >> 24) & 0xff;
+				   dest[1] = (word >> 16) & 0xff;
+				   dest[2] = (word >>  8) & 0xff;
+				   dest[3] =  word        & 0xff;
+				   dest[4] =  rword1      & 0xff;
+				   dest += 5;
+				   break;
+
+			  default: // expect 40 bit TODO
+
+					  break;
             }
+	      }
         }
     }
   else
diff --git a/arch/arm/src/s32k1xx/s32k1xx_pingpio.c b/arch/arm/src/s32k1xx/s32k1xx_pingpio.c
index 5661da57b6..b8dfedbfb2 100644
--- a/arch/arm/src/s32k1xx/s32k1xx_pingpio.c
+++ b/arch/arm/src/s32k1xx/s32k1xx_pingpio.c
@@ -111,7 +111,6 @@ bool s32k1xx_gpioread(uint32_t pinset)
   bool         ret = false;
 
   DEBUGASSERT((pinset & _PIN_MODE_MASK) == _PIN_MODE_GPIO);
-  DEBUGASSERT((pinset & _PIN_IO_MASK) == _PIN_INPUT);
 
   /* Get the port number and pin number */
 
@@ -127,8 +126,17 @@ bool s32k1xx_gpioread(uint32_t pinset)
 
       /* return the state of the pin */
 
+      //if ((pinset & _PIN_IO_MASK) == _PIN_INPUT)
+      //  {
       regval = getreg32(base + S32K1XX_GPIO_PDIR_OFFSET);
+      //  }
+      // else if ((pinset & _PIN_IO_MASK) == _PIN_OUTPUT)
+      //   {
+      //     regval = getreg32(base + S32K1XX_GPIO_PDOR_OFFSET);
+      //   }
+
       ret    = ((regval & (1 << pin)) != 0);
     }
+
   return ret;
 }
diff --git a/boards/Kconfig b/boards/Kconfig
index ef0913fc4b..e92b23f776 100644
--- a/boards/Kconfig
+++ b/boards/Kconfig
@@ -1313,6 +1313,14 @@ config ARCH_BOARD_S32K144EVB
 		This options selects support for NuttX on the NXP S32K144EVB board
 		featuring the S32K144 Cortex-M4F.
 
+config ARCH_BOARD_RDDRONE_BMS772
+	bool "NXP RDDRONE-BMS772"
+	depends on ARCH_CHIP_S32K144
+	select ARCH_HAVE_LEDS
+	---help---
+		This options selects support for NuttX on the NXP RDDRONE-BMS772 board
+		featuring the S32K144 Cortex-M4F.
+
 config ARCH_BOARD_RDDRONE_UAVCAN144
 	bool "NXP RDDRONE-UAVCAN144"
 	depends on ARCH_CHIP_S32K144
@@ -2276,6 +2284,7 @@ config ARCH_BOARD
 	default "rddrone-uavcan146"        if ARCH_BOARD_RDDRONE_UAVCAN146
 	default "s32k146evb"               if ARCH_BOARD_S32K146EVB
 	default "s32k148evb"               if ARCH_BOARD_S32K148EVB
+	default "rddrone-bms772"           if ARCH_BOARD_RDDRONE_BMS772
 	default "sabre-6quad"              if ARCH_BOARD_SABRE_6QUAD
 	default "sama5d2-xult"             if ARCH_BOARD_SAMA5D2_XULT
 	default "giant-board"              if ARCH_BOARD_GIANT_BOARD
@@ -2416,6 +2425,9 @@ endif
 if ARCH_BOARD_S32K144EVB
 source "boards/arm/s32k1xx/s32k144evb/Kconfig"
 endif
+if ARCH_BOARD_RDDRONE_BMS772
+source "boards/arm/s32k1xx/rddrone-bms772/Kconfig"
+endif
 if ARCH_BOARD_RDDRONE_UAVCAN144
 source "boards/arm/s32k1xx/rddrone-uavcan144/Kconfig"
 endif
diff --git a/boards/arm/s32k1xx/rddrone-bms772/Kconfig b/boards/arm/s32k1xx/rddrone-bms772/Kconfig
new file mode 100644
index 0000000000..4eef827d41
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/Kconfig
@@ -0,0 +1,8 @@
+#
+# For a description of the syntax of this configuration file,
+# see the file kconfig-language.txt in the NuttX tools repository.
+#
+
+if ARCH_BOARD_RDDRONE_BMS772
+
+endif # ARCH_BOARD_RDDRONE_BMS772
diff --git a/boards/arm/s32k1xx/rddrone-bms772/README.txt b/boards/arm/s32k1xx/rddrone-bms772/README.txt
new file mode 100644
index 0000000000..8e0a75f186
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/README.txt
@@ -0,0 +1,15 @@
+README
+======
+
+This directory holds the port to the NXP RDDRONE-BMS772 board with S32K144 MCU.
+
+Contents
+========
+
+  o Status
+
+Status
+======
+
+  2020-02-11:  Configuration created (copy-paste from S32K146EVB).
+    Tested: -
\ No newline at end of file
diff --git a/boards/arm/s32k1xx/rddrone-bms772/configs/bms/.gitignore b/boards/arm/s32k1xx/rddrone-bms772/configs/bms/.gitignore
new file mode 100644
index 0000000000..aff67cd1fb
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/configs/bms/.gitignore
@@ -0,0 +1,2 @@
+old/
+/old
\ No newline at end of file
diff --git a/boards/arm/s32k1xx/rddrone-bms772/configs/bms/defconfig b/boards/arm/s32k1xx/rddrone-bms772/configs/bms/defconfig
new file mode 100644
index 0000000000..584b47c797
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/configs/bms/defconfig
@@ -0,0 +1,106 @@
+#
+# This file is autogenerated: PLEASE DO NOT EDIT IT.
+#
+# You can use "make menuconfig" to make any modifications to the installed .config file.
+# You can then do "make savedefconfig" to generate a new defconfig file that includes your
+# modifications.
+#
+# CONFIG_ARCH_LEDS is not set
+# CONFIG_NET_ETHERNET is not set
+# CONFIG_NET_IPv4 is not set
+# CONFIG_NSH_ARGCAT is not set
+# CONFIG_NSH_CMDOPT_HEXDUMP is not set
+# CONFIG_NSH_CMDPARMS is not set
+CONFIG_ARCH="arm"
+CONFIG_ARCH_BOARD="rddrone-bms772"
+CONFIG_ARCH_BOARD_RDDRONE_BMS772=y
+CONFIG_ARCH_CHIP="s32k1xx"
+CONFIG_ARCH_CHIP_S32K144=y
+CONFIG_ARCH_CHIP_S32K14X=y
+CONFIG_ARCH_CHIP_S32K1XX=y
+CONFIG_ARCH_STACKDUMP=y
+CONFIG_ARMV7M_LIBM=y
+CONFIG_ARMV7M_MEMCPY=y
+CONFIG_BINFMT_DISABLE=y
+CONFIG_BOARDCTL_RESET=y
+CONFIG_BOARD_LOOPSPERMSEC=3997
+CONFIG_BUILTIN=y
+CONFIG_CANUTILS_LIBCANARDV1=y
+CONFIG_CLOCK_MONOTONIC=y
+CONFIG_DEBUG_ERROR=y
+CONFIG_DEBUG_FEATURES=y
+CONFIG_DEBUG_SYMBOLS=y
+CONFIG_DEV_GPIO=y
+CONFIG_DEV_GPIO_NSIGNALS=5
+CONFIG_EXAMPLES_HELLO=y
+CONFIG_FS_PROCFS=y
+CONFIG_FS_ROMFS=y
+CONFIG_I2C=y
+CONFIG_I2C_DRIVER=y
+CONFIG_IOB_BUFSIZE=96
+CONFIG_LIBC_FLOATINGPOINT=y
+CONFIG_LIBM=y
+CONFIG_LPUART0_RXBUFSIZE=64
+CONFIG_LPUART0_TXBUFSIZE=64
+CONFIG_LPUART1_RXBUFSIZE=64
+CONFIG_LPUART1_SERIAL_CONSOLE=y
+CONFIG_LPUART1_TXBUFSIZE=64
+CONFIG_MAX_TASKS=16
+CONFIG_NET=y
+CONFIG_NETDEV_CAN_BITRATE_IOCTL=y
+CONFIG_NETDEV_IFINDEX=y
+CONFIG_NET_CAN=y
+CONFIG_NET_CAN_NOTIFIER=y
+CONFIG_NET_CAN_RAW_TX_DEADLINE=y
+CONFIG_NET_CAN_SOCK_OPTS=y
+CONFIG_NET_TIMESTAMP=y
+CONFIG_NFILE_DESCRIPTORS=20
+CONFIG_NSH_ARCHINIT=y
+CONFIG_NSH_ARCHROMFS=y
+CONFIG_NSH_BUILTIN_APPS=y
+CONFIG_NSH_DISABLE_DATE=y
+CONFIG_NSH_FILEIOSIZE=512
+CONFIG_NSH_READLINE=y
+CONFIG_NSH_ROMFSETC=y
+CONFIG_NXP_BMS=y
+CONFIG_PATH_MAX=128
+CONFIG_PREALLOC_TIMERS=4
+CONFIG_RAM_SIZE=61440
+CONFIG_RAM_START=0x1fff8000
+CONFIG_RAW_BINARY=y
+CONFIG_RR_INTERVAL=200
+CONFIG_RTC=y
+CONFIG_RTC_FREQUENCY=32768
+CONFIG_RTC_HIRES=y
+CONFIG_S32K1XX_EEEPROM=y
+CONFIG_S32K1XX_FLEXCAN0=y
+CONFIG_S32K1XX_GPIOIRQ=y
+CONFIG_S32K1XX_LPI2C0=y
+CONFIG_S32K1XX_LPSPI0=y
+CONFIG_S32K1XX_LPSPI1=y
+CONFIG_S32K1XX_LPUART0=y
+CONFIG_S32K1XX_LPUART1=y
+CONFIG_S32K1XX_PORTAINTS=y
+CONFIG_S32K1XX_PORTBINTS=y
+CONFIG_S32K1XX_PORTCINTS=y
+CONFIG_S32K1XX_PORTDINTS=y
+CONFIG_S32K1XX_PORTEINTS=y
+CONFIG_S32K1XX_RTC=y
+CONFIG_SCHED_CPULOAD=y
+CONFIG_SCHED_LPWORK=y
+CONFIG_SCHED_LPWORKSTACKSIZE=1536
+CONFIG_SCHED_WAITPID=y
+CONFIG_SDCLONE_DISABLE=y
+CONFIG_SIG_DEFAULT=y
+CONFIG_SPI_DRIVER=y
+CONFIG_STACK_COLORATION=y
+CONFIG_START_DAY=18
+CONFIG_START_MONTH=8
+CONFIG_START_YEAR=2019
+CONFIG_STDIO_DISABLE_BUFFERING=y
+CONFIG_SYMTAB_ORDEREDBYNAME=y
+CONFIG_SYSLOG_CONSOLE=y
+CONFIG_SYSTEM_NSH=y
+CONFIG_USERLED=y
+CONFIG_USERLED_LOWER=y
+CONFIG_USER_ENTRYPOINT="nsh_main"
diff --git a/boards/arm/s32k1xx/rddrone-bms772/configs/bmsdebug/.gitignore b/boards/arm/s32k1xx/rddrone-bms772/configs/bmsdebug/.gitignore
new file mode 100644
index 0000000000..aff67cd1fb
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/configs/bmsdebug/.gitignore
@@ -0,0 +1,2 @@
+old/
+/old
\ No newline at end of file
diff --git a/boards/arm/s32k1xx/rddrone-bms772/configs/bmsdebug/defconfig b/boards/arm/s32k1xx/rddrone-bms772/configs/bmsdebug/defconfig
new file mode 100644
index 0000000000..267a5497eb
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/configs/bmsdebug/defconfig
@@ -0,0 +1,110 @@
+#
+# This file is autogenerated: PLEASE DO NOT EDIT IT.
+#
+# You can use "make menuconfig" to make any modifications to the installed .config file.
+# You can then do "make savedefconfig" to generate a new defconfig file that includes your
+# modifications.
+#
+# CONFIG_ARCH_LEDS is not set
+# CONFIG_NET_ETHERNET is not set
+# CONFIG_NET_IPv4 is not set
+# CONFIG_NSH_ARGCAT is not set
+# CONFIG_NSH_CMDOPT_HEXDUMP is not set
+# CONFIG_NSH_CMDPARMS is not set
+CONFIG_ARCH="arm"
+CONFIG_ARCH_BOARD="rddrone-bms772"
+CONFIG_ARCH_BOARD_RDDRONE_BMS772=y
+CONFIG_ARCH_CHIP="s32k1xx"
+CONFIG_ARCH_CHIP_S32K144=y
+CONFIG_ARCH_CHIP_S32K14X=y
+CONFIG_ARCH_CHIP_S32K1XX=y
+CONFIG_ARCH_STACKDUMP=y
+CONFIG_ARMV7M_LIBM=y
+CONFIG_ARMV7M_MEMCPY=y
+CONFIG_BINFMT_DISABLE=y
+CONFIG_BOARDCTL_RESET=y
+CONFIG_BOARD_LOOPSPERMSEC=3997
+CONFIG_BUILTIN=y
+CONFIG_CANUTILS_LIBCANARDV1=y
+CONFIG_CLOCK_MONOTONIC=y
+CONFIG_DEBUG_ASSERTIONS=y
+CONFIG_DEBUG_ERROR=y
+CONFIG_DEBUG_FEATURES=y
+CONFIG_DEBUG_SYMBOLS=y
+CONFIG_DEV_GPIO=y
+CONFIG_DEV_GPIO_NSIGNALS=5
+CONFIG_EXAMPLES_HELLO=y
+CONFIG_FS_PROCFS=y
+CONFIG_FS_ROMFS=y
+CONFIG_I2C=y
+CONFIG_I2C_DRIVER=y
+CONFIG_IOB_BUFSIZE=96
+CONFIG_LIBC_FLOATINGPOINT=y
+CONFIG_LIBM=y
+CONFIG_LPUART0_RXBUFSIZE=64
+CONFIG_LPUART0_TXBUFSIZE=64
+CONFIG_LPUART1_RXBUFSIZE=64
+CONFIG_LPUART1_SERIAL_CONSOLE=y
+CONFIG_LPUART1_TXBUFSIZE=64
+CONFIG_MAX_TASKS=16
+CONFIG_MAX_WDOGPARMS=2
+CONFIG_NET=y
+CONFIG_NETDEV_CAN_BITRATE_IOCTL=y
+CONFIG_NETDEV_IFINDEX=y
+CONFIG_NET_CAN=y
+CONFIG_NET_CAN_NOTIFIER=y
+CONFIG_NET_CAN_RAW_TX_DEADLINE=y
+CONFIG_NET_CAN_SOCK_OPTS=y
+CONFIG_NET_TIMESTAMP=y
+CONFIG_NFILE_DESCRIPTORS=20
+CONFIG_NSH_ARCHINIT=y
+CONFIG_NSH_ARCHROMFS=y
+CONFIG_NSH_BUILTIN_APPS=y
+CONFIG_NSH_DISABLE_DATE=y
+CONFIG_NSH_FILEIOSIZE=512
+CONFIG_NSH_READLINE=y
+CONFIG_NSH_ROMFSETC=y
+CONFIG_NXP_BMS=y
+CONFIG_PATH_MAX=128
+CONFIG_PREALLOC_MQ_MSGS=4
+CONFIG_PREALLOC_TIMERS=4
+CONFIG_PREALLOC_WDOGS=16
+CONFIG_RAM_SIZE=61440
+CONFIG_RAM_START=0x1fff8000
+CONFIG_RAW_BINARY=y
+CONFIG_RR_INTERVAL=200
+CONFIG_RTC=y
+CONFIG_RTC_FREQUENCY=32768
+CONFIG_RTC_HIRES=y
+CONFIG_S32K1XX_EEEPROM=y
+CONFIG_S32K1XX_FLEXCAN0=y
+CONFIG_S32K1XX_GPIOIRQ=y
+CONFIG_S32K1XX_LPI2C0=y
+CONFIG_S32K1XX_LPSPI0=y
+CONFIG_S32K1XX_LPSPI1=y
+CONFIG_S32K1XX_LPUART0=y
+CONFIG_S32K1XX_LPUART1=y
+CONFIG_S32K1XX_PORTAINTS=y
+CONFIG_S32K1XX_PORTBINTS=y
+CONFIG_S32K1XX_PORTCINTS=y
+CONFIG_S32K1XX_PORTDINTS=y
+CONFIG_S32K1XX_PORTEINTS=y
+CONFIG_S32K1XX_RTC=y
+CONFIG_SCHED_CPULOAD=y
+CONFIG_SCHED_LPWORK=y
+CONFIG_SCHED_LPWORKSTACKSIZE=1536
+CONFIG_SCHED_WAITPID=y
+CONFIG_SDCLONE_DISABLE=y
+CONFIG_SIG_DEFAULT=y
+CONFIG_SPI_DRIVER=y
+CONFIG_STACK_COLORATION=y
+CONFIG_START_DAY=18
+CONFIG_START_MONTH=8
+CONFIG_START_YEAR=2019
+CONFIG_STDIO_DISABLE_BUFFERING=y
+CONFIG_SYMTAB_ORDEREDBYNAME=y
+CONFIG_SYSLOG_CONSOLE=y
+CONFIG_SYSTEM_NSH=y
+CONFIG_USERLED=y
+CONFIG_USERLED_LOWER=y
+CONFIG_USER_ENTRYPOINT="nsh_main"
diff --git a/boards/arm/s32k1xx/rddrone-bms772/include/board.h b/boards/arm/s32k1xx/rddrone-bms772/include/board.h
new file mode 100644
index 0000000000..d05f77f772
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/include/board.h
@@ -0,0 +1,162 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/rddrone-bms772/include/board.h
+ *
+ *   Copyright (C) 2019 Gregory Nutt. All rights reserved.
+ *   Author: Gregory Nutt <gnutt@nuttx.org>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+#ifndef __BOARDS_ARM_RDDRONE_BMS772_INCLUDE_BOARD_H
+#define __BOARDS_ARM_RDDRONE_BMS772_INCLUDE_BOARD_H
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#ifndef __ASSEMBLY__
+#  include <stdint.h>
+#  include <stdbool.h>
+#endif
+
+/****************************************************************************
+ * Pre-processor Definitions
+ ****************************************************************************/
+
+/* Clocking *****************************************************************/
+
+/* The RDDRONE-BMS772 is fitted with a 32 MHz Crystal */
+
+#define BOARD_XTAL_FREQUENCY 32000000
+
+/* The S32K144 will run at 80 MHz */
+
+/* LED definitions **********************************************************/
+
+/* The RDDRONE-BMS772 has one RGB LED:
+ *
+ *   RedLED   PTD16 (FTM0 CH1)
+ *   GreenLED PTB13 (FTM0 CH1)
+ *   BlueLED  PTD15 (FTM0 CH0)
+ *
+ * If CONFIG_ARCH_LEDS is not defined, then the user can control the LEDs in
+ * any way.  The following definitions are used to access individual RGB
+ * components.
+ *
+ * The RGB components could, alternatively be controlled through PWM using
+ * the common RGB LED driver.
+ */
+
+/* LED index values for use with board_userled() */
+
+#define BOARD_LED_R       0
+#define BOARD_LED_G       1
+#define BOARD_LED_B       2
+#define BOARD_NLEDS       3
+
+/* LED bits for use with board_userled_all() */
+
+#define BOARD_LED_R_BIT   (1 << BOARD_LED_R)
+#define BOARD_LED_G_BIT   (1 << BOARD_LED_G)
+#define BOARD_LED_B_BIT   (1 << BOARD_LED_B)
+
+/* If CONFIG_ARCH_LEDs is defined, then NuttX will control the LEDs on board
+ * the RDDRONE-BMS772.  The following definitions describe how NuttX
+ * controls the LEDs:
+ *
+ *   SYMBOL                Meaning                      LED state
+ *                                                      RED   GREEN  BLUE
+ *   -------------------  ----------------------------  -----------------
+ */
+
+#define LED_STARTED       1 /* NuttX has been started    OFF   OFF    OFF */
+#define LED_HEAPALLOCATE  2 /* Heap has been allocated   OFF   OFF    ON  */
+#define LED_IRQSENABLED   0 /* Interrupts enabled        OFF   OFF    ON  */
+#define LED_STACKCREATED  3 /* Idle stack created        OFF   ON     OFF */
+#define LED_INIRQ         0 /* In an interrupt          (no change)       */
+#define LED_SIGNAL        0 /* In a signal handler      (no change)       */
+#define LED_ASSERTION     0 /* An assertion failed      (no change)       */
+#define LED_PANIC         4 /* The system has crashed    FLASH OFF    OFF */
+#undef  LED_IDLE            /* RDDRONE-BMS772 in sleep mode (Not used)    */
+
+/* Button definitions *******************************************************/
+
+/* The rddrone-bms772 supports one button:
+ *
+ *   SW1  PTC14
+ */
+
+#define BUTTON_SW1         0
+
+#define NUM_BUTTONS        1
+
+#define BUTTON_SW1_BIT    (1 << BUTTON_SW1)
+
+/* Alternate function pin selections ****************************************/
+
+/* By default, the serial console will be provided on the OpenSDA VCOM port:
+ *
+ *   OpenSDA UART TX  PTC7 (LPUART1_TX)
+ *   OpenSDA UART RX  PTC6 (LPUART1_RX)
+ */
+
+/* optional UART on connector J21                   */
+#define PIN_LPUART0_RX    PIN_LPUART0_RX_1  /* PTB0 */
+#define PIN_LPUART0_TX    PIN_LPUART0_TX_1  /* PTB1 */
+
+/* NuttX console                                    */
+#define PIN_LPUART1_RX    PIN_LPUART1_RX_1  /* PTC6 */
+#define PIN_LPUART1_TX    PIN_LPUART1_TX_1  /* PTC7 */
+
+/* SPI selections ***********************************************************/
+
+/* SBC connection through SPI 0                     */
+#define PIN_LPSPI0_SCK   PIN_LPSPI0_SCK_2   /* PTB2 */
+#define PIN_LPSPI0_MISO  PIN_LPSPI0_SIN_2   /* PTB3 */
+#define PIN_LPSPI0_MOSI  PIN_LPSPI0_SOUT_3  /* PTB4 */
+#define PIN_LPSPI0_PCS   PIN_LPSPI0_PCS0_2 // don't make it a GPIO 
+
+/* BCC connection through SPI 1                     */
+#define PIN_LPSPI1_SCK   PIN_LPSPI1_SCK_2   /* PTD0 */
+#define PIN_LPSPI1_MISO  PIN_LPSPI1_SIN_2   /* PTD1 */
+#define PIN_LPSPI1_MOSI  PIN_LPSPI1_SOUT_2  /* PTD2 */
+#define PIN_LPSPI1_PCS   PIN_LPSPI1_PCS0_1 // don't make it a GPIO 
+
+/* I2C selections ***********************************************************/
+
+#define PIN_LPI2C0_SCL   PIN_LPI2C0_SCL_2   /* PTA3 */
+#define PIN_LPI2C0_SDA	 PIN_LPI2C0_SDA_2   /* PTA2 */
+
+/* CAN selections ***********************************************************/
+#define PIN_CAN0_TX      PIN_CAN0_TX_3      /* PTE5 */
+#define PIN_CAN0_RX      PIN_CAN0_RX_3      /* PTE4 */
+
+#endif  /* __BOARDS_ARM_RDDRONE_BMS772_INCLUDE_BOARD_H */
diff --git a/boards/arm/s32k1xx/rddrone-bms772/include/nsh_romfsimg.h b/boards/arm/s32k1xx/rddrone-bms772/include/nsh_romfsimg.h
new file mode 100644
index 0000000000..5e3d107769
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/include/nsh_romfsimg.h
@@ -0,0 +1,89 @@
+const unsigned char romfs_img[] = {
+  0x2d, 0x72, 0x6f, 0x6d, 0x31, 0x66, 0x73, 0x2d, 0x00, 0x00, 0x02, 0x70,
+  0xe9, 0x59, 0x88, 0x5d, 0x4e, 0x53, 0x48, 0x49, 0x6e, 0x69, 0x74, 0x56,
+  0x6f, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x49,
+  0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0xd1, 0xff, 0xff, 0x97,
+  0x2e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x20,
+  0x00, 0x00, 0x00, 0x00, 0xd1, 0xd1, 0xff, 0x80, 0x2e, 0x2e, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00,
+  0x68, 0x2d, 0x96, 0x03, 0x69, 0x6e, 0x69, 0x74, 0x2e, 0x64, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3a,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x8b, 0x8d, 0x9c, 0xa9, 0x3b,
+  0x72, 0x63, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x23, 0x20, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65,
+  0x20, 0x72, 0x63, 0x53, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x3b, 0x20, 0x79,
+  0x6f, 0x75, 0x20, 0x6d, 0x75, 0x73, 0x74, 0x20, 0x72, 0x75, 0x6e, 0x20,
+  0x74, 0x6f, 0x6f, 0x6c, 0x73, 0x2f, 0x67, 0x65, 0x6e, 0x72, 0x6f, 0x6d,
+  0x66, 0x73, 0x20, 0x3c, 0x6e, 0x75, 0x74, 0x74, 0x78, 0x20, 0x64, 0x69,
+  0x72, 0x3e, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x77, 0x69, 0x74, 0x68,
+  0x69, 0x6e, 0x20, 0x74, 0x68, 0x69, 0x73, 0x0a, 0x23, 0x20, 0x6c, 0x6f,
+  0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x74, 0x6f, 0x20, 0x63, 0x6f,
+  0x6e, 0x76, 0x65, 0x72, 0x74, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x66,
+  0x69, 0x6c, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x6e, 0x73, 0x68, 0x5f, 0x72,
+  0x6f, 0x6d, 0x66, 0x73, 0x69, 0x6d, 0x67, 0x2e, 0x68, 0x20, 0x66, 0x6f,
+  0x72, 0x20, 0x69, 0x6e, 0x63, 0x6c, 0x75, 0x73, 0x69, 0x6f, 0x6e, 0x20,
+  0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x75, 0x69, 0x6c, 0x64,
+  0x0a, 0x23, 0x20, 0x65, 0x63, 0x68, 0x6f, 0x20, 0x22, 0x54, 0x68, 0x69,
+  0x73, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x74, 0x61,
+  0x72, 0x74, 0x75, 0x70, 0x20, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x22,
+  0x0a, 0x23, 0x20, 0x65, 0x63, 0x68, 0x6f, 0x20, 0x22, 0x43, 0x6f, 0x75,
+  0x6e, 0x74, 0x64, 0x6f, 0x77, 0x6e, 0x22, 0x0a, 0x23, 0x20, 0x73, 0x6c,
+  0x65, 0x65, 0x70, 0x20, 0x31, 0x0a, 0x23, 0x20, 0x65, 0x63, 0x68, 0x6f,
+  0x20, 0x22, 0x33, 0x22, 0x0a, 0x23, 0x20, 0x73, 0x6c, 0x65, 0x65, 0x70,
+  0x20, 0x31, 0x0a, 0x23, 0x20, 0x65, 0x63, 0x68, 0x6f, 0x20, 0x22, 0x32,
+  0x22, 0x0a, 0x23, 0x20, 0x73, 0x6c, 0x65, 0x65, 0x70, 0x20, 0x31, 0x0a,
+  0x23, 0x20, 0x65, 0x63, 0x68, 0x6f, 0x20, 0x22, 0x31, 0x22, 0x0a, 0x23,
+  0x20, 0x73, 0x6c, 0x65, 0x65, 0x70, 0x20, 0x31, 0x0a, 0x20, 0x65, 0x63,
+  0x68, 0x6f, 0x20, 0x22, 0x53, 0x74, 0x61, 0x72, 0x74, 0x69, 0x6e, 0x67,
+  0x20, 0x42, 0x4d, 0x53, 0x22, 0x0a, 0x20, 0x73, 0x6c, 0x65, 0x65, 0x70,
+  0x20, 0x31, 0x0a, 0x22, 0x66, 0x72, 0x65, 0x65, 0x22, 0x0a, 0x65, 0x63,
+  0x68, 0x6f, 0x20, 0x22, 0x53, 0x74, 0x61, 0x72, 0x74, 0x69, 0x6e, 0x67,
+  0x20, 0x63, 0x61, 0x6e, 0x30, 0x22, 0x0a, 0x22, 0x69, 0x66, 0x75, 0x70,
+  0x22, 0x20, 0x22, 0x63, 0x61, 0x6e, 0x30, 0x22, 0x0a, 0x22, 0x62, 0x6d,
+  0x73, 0x22, 0x0a, 0x20, 0x73, 0x6c, 0x65, 0x65, 0x70, 0x20, 0x31, 0x0a,
+  0x20, 0x65, 0x63, 0x68, 0x6f, 0x20, 0x22, 0x53, 0x74, 0x61, 0x72, 0x74,
+  0x65, 0x64, 0x22, 0x0a, 0x20, 0x23, 0x20, 0x73, 0x6c, 0x65, 0x65, 0x70,
+  0x20, 0x31, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x50,
+  0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0xd1, 0xd1, 0xfd, 0x90,
+  0x2e, 0x2e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60,
+  0x00, 0x00, 0x00, 0x00, 0xd1, 0xff, 0xff, 0xa0, 0x2e, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00
+};
+const unsigned int romfs_img_len = 1024;
diff --git a/boards/arm/s32k1xx/rddrone-bms772/include/rcS.template b/boards/arm/s32k1xx/rddrone-bms772/include/rcS.template
new file mode 100644
index 0000000000..749d48a926
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/include/rcS.template
@@ -0,0 +1,20 @@
+# sample rcS file; you must run tools/genromfs <nuttx dir> from within this
+# location to convert this file to nsh_romfsimg.h for inclusion in the build
+# echo "This is the startup script"
+# echo "Countdown"
+# sleep 1
+# echo "3"
+# sleep 1
+# echo "2"
+# sleep 1
+# echo "1"
+# sleep 1
+ echo "Starting BMS"
+ sleep 1
+"free"
+echo "Starting can0"
+"ifup" "can0"
+"bms"
+ sleep 1
+ echo "Started"
+ # sleep 1
diff --git a/boards/arm/s32k1xx/rddrone-bms772/scripts/Make.defs b/boards/arm/s32k1xx/rddrone-bms772/scripts/Make.defs
new file mode 100644
index 0000000000..ef6d67909e
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/scripts/Make.defs
@@ -0,0 +1,108 @@
+############################################################################
+# boards/arm/s32k1xx/rddrone-bms772/scripts/Make.defs
+#
+#   Copyright (C) 2018 Gregory Nutt. All rights reserved.
+#   Author: Gregory Nutt <gnutt@nuttx.org>
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in
+#    the documentation and/or other materials provided with the
+#    distribution.
+# 3. Neither the name NuttX nor the names of its contributors may be
+#    used to endorse or promote products derived from this software
+#    without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+# OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+# AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+############################################################################
+
+include $(TOPDIR)/.config
+include $(TOPDIR)/tools/Config.mk
+include $(TOPDIR)/arch/arm/src/armv7-m/Toolchain.defs
+
+ifeq ($(CONFIG_BOOT_RUNFROMFLASH),y)
+ LDSCRIPT = flash.ld
+else ifeq ($(CONFIG_BOOT_RUNFROMISRAM),y)
+ LDSCRIPT = sram.ld
+endif
+
+$(warning, LDSCRIPT is $(LDSCRIPT))
+CINCPATH := ${shell $(INCDIR) -s "$(CC)" $(TOPDIR)$(DELIM)include}
+CXXINCPATH := ${shell $(INCDIR) -s "$(CC)" $(TOPDIR)$(DELIM)include$(DELIM)cxx}
+
+ARCHINCLUDES += $(CINCPATH)
+ARCHXXINCLUDES += $(CINCPATH) $(CXXINCPATH)
+
+ifeq ($(CONFIG_CYGWIN_WINTOOL),y)
+  ARCHSCRIPT = -T "${shell cygpath -w $(BOARD_DIR)$(DELIM)scripts$(DELIM)$(LDSCRIPT)}"
+else
+  ARCHSCRIPT = -T$(BOARD_DIR)$(DELIM)scripts$(DELIM)$(LDSCRIPT)
+endif
+$(warning, LDSCRIPT is $(LDSCRIPT))
+$(warning, ARCHSCRIPT is $(ARCHSCRIPT))
+
+CC = $(CROSSDEV)gcc
+CXX = $(CROSSDEV)g++
+CPP = $(CROSSDEV)gcc -E
+LD = $(CROSSDEV)ld
+STRIP = $(CROSSDEV)strip --strip-unneeded
+AR = $(ARCROSSDEV)ar rcs
+NM = $(ARCROSSDEV)nm
+OBJCOPY = $(CROSSDEV)objcopy
+OBJDUMP = $(CROSSDEV)objdump
+
+ARCHCCVERSION = ${shell $(CC) -v 2>&1 | sed -n '/^gcc version/p' | sed -e 's/^gcc version \([0-9\.]\)/\1/g' -e 's/[-\ ].*//g' -e '1q'}
+ARCHCCMAJOR = ${shell echo $(ARCHCCVERSION) | cut -d'.' -f1}
+
+ifeq ($(CONFIG_DEBUG_SYMBOLS),y)
+  ARCHOPTIMIZATION = -g
+endif
+
+ifneq ($(CONFIG_DEBUG_NOOPT),y)
+  ARCHOPTIMIZATION += $(MAXOPTIMIZATION) -fno-strict-aliasing -fno-strength-reduce -fomit-frame-pointer
+endif
+
+ARCHCFLAGS = -fno-builtin
+ARCHCXXFLAGS = -fno-builtin -fno-exceptions -fcheck-new -fno-rtti
+ARCHWARNINGS = -Wall -Wstrict-prototypes -Wshadow -Wundef
+ARCHWARNINGSXX = -Wall -Wshadow -Wundef
+ARCHPICFLAGS = -fpic -msingle-pic-base -mpic-register=r10
+
+CFLAGS = $(ARCHCFLAGS) $(ARCHWARNINGS) $(ARCHOPTIMIZATION) $(ARCHCPUFLAGS) $(ARCHINCLUDES) $(ARCHDEFINES) $(EXTRAFLAGS) -pipe
+CPICFLAGS = $(ARCHPICFLAGS) $(CFLAGS)
+CXXFLAGS = $(ARCHCXXFLAGS) $(ARCHWARNINGSXX) $(ARCHOPTIMIZATION) $(ARCHCPUFLAGS) $(ARCHXXINCLUDES) $(ARCHDEFINES) $(EXTRAFLAGS) -pipe
+CXXPICFLAGS = $(ARCHPICFLAGS) $(CXXFLAGS)
+CPPFLAGS = $(ARCHINCLUDES) $(ARCHDEFINES) $(EXTRAFLAGS)
+AFLAGS = $(CFLAGS) -D__ASSEMBLY__
+
+NXFLATLDFLAGS1 = -r -d -warn-common
+NXFLATLDFLAGS2 = $(NXFLATLDFLAGS1) -T$(TOPDIR)/binfmt/libnxflat/gnu-nxflat-pcrel.ld -no-check-sections
+LDNXFLATFLAGS = -e main -s 2048
+
+ifneq ($(CROSSDEV),arm-nuttx-elf-)
+  LDFLAGS += -nostartfiles -nodefaultlibs
+endif
+ifeq ($(CONFIG_DEBUG_SYMBOLS),y)
+  LDFLAGS += -g
+endif
+
+
+HOSTCC = gcc
+HOSTCFLAGS = -Wall -Wstrict-prototypes -Wshadow -Wundef -g -pipe
diff --git a/boards/arm/s32k1xx/rddrone-bms772/scripts/flash.ld b/boards/arm/s32k1xx/rddrone-bms772/scripts/flash.ld
new file mode 100644
index 0000000000..83b003c887
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/scripts/flash.ld
@@ -0,0 +1,152 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/rddrone-bms772/scripts/flash.ld
+ *
+ *   Copyright (C) 2019 Gregory Nutt. All rights reserved.
+ *   Author: Gregory Nutt <gnutt@nuttx.org>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/* The S32K144 has 512Kb of FLASH beginning at address 0x0000:0000 and
+ * 60Kb of SRAM beginning at address 0x1fff:8000 (plus 4Kb of FlexRAM)
+ *
+ * The on-chip RAM is split in two regions: SRAM_L and SRAM_U. The RAM is
+ * implemented such that the SRAM_L and SRAM_U ranges form a contiguous
+ * block in the memory map
+ *
+ *   SRAM_L 1fff8000 - 1fffffff 32Kb
+ *   SRAM_U 20000000 - 20006fff 28Kb
+ */
+
+MEMORY
+{
+  vflash (rx) : ORIGIN = 0x00000000, LENGTH = 1K
+  pflash (rx) : ORIGIN = 0x00000400, LENGTH = 16
+  dflash (rx) : ORIGIN = 0x00000410, LENGTH = 511K-16
+  sram  (rwx) : ORIGIN = 0x1fff8000, LENGTH = 60K
+}
+
+OUTPUT_ARCH(arm)
+EXTERN(_vectors)
+EXTERN(g_flashcfg)
+ENTRY(_stext)
+
+SECTIONS
+{
+  .vectors :
+  {
+    _stext = ABSOLUTE(.);
+    *(.vectors)
+  } > vflash
+
+  .flashcfg :
+  {
+    *(.flashcfg)
+  } > pflash
+
+  .text :
+  {
+    *(.text .text.*)
+    *(.fixup)
+    *(.gnu.warning)
+    *(.rodata .rodata.*)
+    *(.gnu.linkonce.t.*)
+    *(.glue_7)
+    *(.glue_7t)
+    *(.got)
+    *(.gcc_except_table)
+    *(.gnu.linkonce.r.*)
+    _etext = ABSOLUTE(.);
+  } > dflash
+
+  .init_section :
+  {
+    _sinit = ABSOLUTE(.);
+    *(.init_array .init_array.*)
+    _einit = ABSOLUTE(.);
+  } > dflash
+
+  .ARM.extab :
+  {
+    *(.ARM.extab*)
+  } >dflash
+
+  .ARM.exidx :
+  {
+    __exidx_start = ABSOLUTE(.);
+    *(.ARM.exidx*)
+    __exidx_end = ABSOLUTE(.);
+  } >dflash
+
+  .data :
+  {
+    _sdata = ABSOLUTE(.);
+    *(.data .data.*)
+    *(.gnu.linkonce.d.*)
+    CONSTRUCTORS
+    . = ALIGN(4);
+    _edata = ABSOLUTE(.);
+  } > sram AT > dflash
+
+  _eronly = LOADADDR(.data);
+
+  .ramfunc ALIGN(4):
+  {
+    _sramfuncs = ABSOLUTE(.);
+    *(.ramfunc  .ramfunc.*)
+    _eramfuncs = ABSOLUTE(.);
+  } > sram AT > dflash
+
+  _framfuncs = LOADADDR(.ramfunc);
+
+  .bss :
+  {
+    _sbss = ABSOLUTE(.);
+    *(.bss .bss.*)
+    *(.gnu.linkonce.b.*)
+    *(COMMON)
+    . = ALIGN(4);
+    _ebss = ABSOLUTE(.);
+  } > sram
+
+  /* Stabs debugging sections. */
+
+  .stab 0 : { *(.stab) }
+  .stabstr 0 : { *(.stabstr) }
+  .stab.excl 0 : { *(.stab.excl) }
+  .stab.exclstr 0 : { *(.stab.exclstr) }
+  .stab.index 0 : { *(.stab.index) }
+  .stab.indexstr 0 : { *(.stab.indexstr) }
+  .comment 0 : { *(.comment) }
+  .debug_abbrev 0 : { *(.debug_abbrev) }
+  .debug_info 0 : { *(.debug_info) }
+  .debug_line 0 : { *(.debug_line) }
+  .debug_pubnames 0 : { *(.debug_pubnames) }
+  .debug_aranges 0 : { *(.debug_aranges) }
+}
diff --git a/boards/arm/s32k1xx/rddrone-bms772/scripts/s32k144.cfg b/boards/arm/s32k1xx/rddrone-bms772/scripts/s32k144.cfg
new file mode 100644
index 0000000000..7d30a9f05f
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/scripts/s32k144.cfg
@@ -0,0 +1,58 @@
+#
+# NXP S32K144 - 1x ARM Cortex-M4 @ up to 112 MHz
+#
+
+adapter_khz 4000
+transport select swd
+
+if { [info exists CHIPNAME] } {
+	set _CHIPNAME $CHIPNAME
+} else {
+	set _CHIPNAME s32k144
+}
+
+#
+# M4 JTAG mode TAP
+#
+if { [info exists M4_JTAG_TAPID] } {
+	set _M4_JTAG_TAPID $M4_JTAG_TAPID
+} else {
+	set _M4_JTAG_TAPID 0x4ba00477
+}
+
+#
+# M4 SWD mode TAP
+#
+if { [info exists M4_SWD_TAPID] } {
+	set _M4_SWD_TAPID $M4_SWD_TAPID
+} else {
+	set _M4_SWD_TAPID 0x2ba01477
+}
+
+source [find target/swj-dp.tcl]
+
+if { [using_jtag] } {
+	set _M4_TAPID $_M4_JTAG_TAPID
+} else {
+	set _M4_TAPID $_M4_SWD_TAPID
+}
+
+swj_newdap $_CHIPNAME m4 -irlen 4 -ircapture 0x1 -irmask 0xf \
+				-expected-id $_M4_TAPID
+
+target create $_CHIPNAME.m4 cortex_m -chain-position $_CHIPNAME.m4
+
+# S32K144 has 32+28 KB contiguous SRAM
+if { [info exists WORKAREASIZE] } {
+	set _WORKAREASIZE $WORKAREASIZE
+} else {
+	set _WORKAREASIZE 0xF000
+}
+$_CHIPNAME.m4 configure -work-area-phys 0x1FFF8000 \
+                        -work-area-size $_WORKAREASIZE -work-area-backup 0
+
+$_CHIPNAME.m4 configure -rtos nuttx
+
+if { ![using_hla] } {
+	cortex_m reset_config vectreset
+}
diff --git a/boards/arm/s32k1xx/rddrone-bms772/scripts/sram.ld b/boards/arm/s32k1xx/rddrone-bms772/scripts/sram.ld
new file mode 100644
index 0000000000..0c6b5867e0
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/scripts/sram.ld
@@ -0,0 +1,129 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/rddrone-bms772/scripts/sram.ld
+ *
+ *   Copyright (C) 2019 Gregory Nutt. All rights reserved.
+ *   Author: Gregory Nutt <gnutt@nuttx.org>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/* The S32K144 has 512Kb of FLASH beginning at address 0x0000:0000 and
+ * 60Kb of SRAM beginning at address 0x1fff:8000 (plus 4Kb of FlexRAM)
+ *
+ * The on-chip RAM is split in two regions: SRAM_L and SRAM_U. The RAM is
+ * implemented such that the SRAM_L and SRAM_U ranges form a contiguous
+ * block in the memory map
+ *
+ *   SRAM_L 1fff8000 - 1fffffff 32Kb
+ *   SRAM_U 20000000 - 20006fff 28Kb
+ */
+
+MEMORY
+{
+  flash (rx)  : ORIGIN = 0x00000000, LENGTH = 512K
+  sram  (rwx) : ORIGIN = 0x1fff8000, LENGTH = 60K
+}
+
+OUTPUT_ARCH(arm)
+EXTERN(_vectors)
+ENTRY(_stext)
+
+SECTIONS
+{
+  .text :
+  {
+    _stext = ABSOLUTE(.);
+    *(.vectors)
+    *(.text .text.*)
+    *(.fixup)
+    *(.gnu.warning)
+    *(.rodata .rodata.*)
+    *(.gnu.linkonce.t.*)
+    *(.glue_7)
+    *(.glue_7t)
+    *(.got)
+    *(.gcc_except_table)
+    *(.gnu.linkonce.r.*)
+    _etext = ABSOLUTE(.);
+  } > sram
+
+  .init_section :
+  {
+    _sinit = ABSOLUTE(.);
+    *(.init_array .init_array.*)
+    _einit = ABSOLUTE(.);
+  } > sram
+
+  .ARM.extab :
+  {
+    *(.ARM.extab*)
+  } >sram
+
+  .ARM.exidx :
+  {
+    __exidx_start = ABSOLUTE(.);
+    *(.ARM.exidx*)
+    __exidx_end = ABSOLUTE(.);
+  } >sram
+
+  .data :
+  {
+    _sdata = ABSOLUTE(.);
+    *(.data .data.*)
+    *(.gnu.linkonce.d.*)
+    CONSTRUCTORS
+    . = ALIGN(4);
+    _edata = ABSOLUTE(.);
+  } > sram
+
+  .bss :
+  {
+    _sbss = ABSOLUTE(.);
+    *(.bss .bss.*)
+    *(.gnu.linkonce.b.*)
+    *(COMMON)
+    . = ALIGN(4);
+    _ebss = ABSOLUTE(.);
+  } > sram
+
+  /* Stabs debugging sections. */
+
+  .stab 0 : { *(.stab) }
+  .stabstr 0 : { *(.stabstr) }
+  .stab.excl 0 : { *(.stab.excl) }
+  .stab.exclstr 0 : { *(.stab.exclstr) }
+  .stab.index 0 : { *(.stab.index) }
+  .stab.indexstr 0 : { *(.stab.indexstr) }
+  .comment 0 : { *(.comment) }
+  .debug_abbrev 0 : { *(.debug_abbrev) }
+  .debug_info 0 : { *(.debug_info) }
+  .debug_line 0 : { *(.debug_line) }
+  .debug_pubnames 0 : { *(.debug_pubnames) }
+  .debug_aranges 0 : { *(.debug_aranges) }
+}
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/.gitignore b/boards/arm/s32k1xx/rddrone-bms772/src/.gitignore
new file mode 100644
index 0000000000..726d936e1e
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/.gitignore
@@ -0,0 +1,2 @@
+/.depend
+/Make.dep
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/Makefile b/boards/arm/s32k1xx/rddrone-bms772/src/Makefile
new file mode 100644
index 0000000000..596d1b7611
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/Makefile
@@ -0,0 +1,71 @@
+############################################################################
+# boards/arm/s32k1xx/rddrone-bms772/src/Makefile
+#
+#   Copyright (C) 2019 Gregory Nutt. All rights reserved.
+#   Author: Gregory Nutt <gnutt@nuttx.org>
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in
+#    the documentation and/or other materials provided with the
+#    distribution.
+# 3. Neither the name NuttX nor the names of its contributors may be
+#    used to endorse or promote products derived from this software
+#    without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+# OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+# AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+############################################################################
+
+include $(TOPDIR)/Make.defs
+
+CSRCS  = s32k1xx_boot.c s32k1xx_bringup.c s32k1xx_clockconfig.c
+CSRCS += s32k1xx_periphclocks.c
+
+ifeq ($(CONFIG_ARCH_LEDS),y)
+CSRCS += s32k1xx_autoleds.c
+else
+CSRCS += s32k1xx_userleds.c
+endif
+
+ifeq ($(CONFIG_ARCH_BUTTONS),y)
+CSRCS += s32k1xx_buttons.c
+endif
+
+ifeq ($(CONFIG_DEV_GPIO),y)
+CSRCS += s32k1xx_gpio.c
+endif
+
+ifeq ($(CONFIG_LIB_BOARDCTL),y)
+CSRCS += s32k1xx_appinit.c
+endif
+
+ifeq ($(CONFIG_PWM),y)
+CSRCS += s32k1xx_pwm.c
+endif
+
+ifeq ($(CONFIG_S32K1XX_LPSPI),y)
+CSRCS += s32k1xx_spi.c
+endif
+
+ifeq ($(CONFIG_BOARDCTL_RESET),y)
+CSRCS += s32k1xx_reset.c
+endif
+
+include $(TOPDIR)/boards/Board.mk
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/rddrone-bms772.h b/boards/arm/s32k1xx/rddrone-bms772/src/rddrone-bms772.h
new file mode 100644
index 0000000000..e68df0300c
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/rddrone-bms772.h
@@ -0,0 +1,215 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/rddrone-bms772/src/rddrone-bms772.h
+ *
+ *   Copyright (C) 2019 Gregory Nutt. All rights reserved.
+ *   Author: Gregory Nutt <gnutt@nuttx.org>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+#ifndef __BOARDS_ARM_S32K1XX_RDDRONE_BMS772_SRC_RDDRONE_BMS772_H
+#define __BOARDS_ARM_S32K1XX_RDDRONE_BMS772_SRC_RDDRONE_BMS772_H
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+#include <nuttx/compiler.h>
+
+#include <stdint.h>
+
+#include "hardware/s32k1xx_pinmux.h"
+#include "s32k1xx_periphclocks.h"
+#include "s32k1xx_pin.h"
+
+/****************************************************************************
+ * Pre-processor Definitions
+ ****************************************************************************/
+
+/* Configuration ************************************************************/
+
+/* RDDRONE-BMS772 GPIOs *****************************************************/
+
+/* LEDs.  The RDDRONE-BMS772 has one RGB LED:
+ *
+ *   RedLED   PTD16 (FTM0 CH1)
+ *   GreenLED PTB13 (FTM0 CH1)
+ *   BlueLED  PTD15 (FTM0 CH0)
+ *
+ * An output of '1' illuminates the LED.
+ */
+
+#define GPIO_LED_R     (PIN_PTD16 | GPIO_LOWDRIVE | GPIO_OUTPUT_ZERO)
+#define GPIO_LED_G     (PIN_PTB13 | GPIO_LOWDRIVE | GPIO_OUTPUT_ZERO)
+#define GPIO_LED_B     (PIN_PTD15 | GPIO_LOWDRIVE | GPIO_OUTPUT_ZERO)
+
+/* Buttons.  The rddrone-bms772 supports one button:
+ *
+ *   SW1  PTC14
+ */
+
+//#define GPIO_SW1       (PIN_PTC14 | PIN_INT_BOTH)    
+//#define GPIO_SW3       (PIN_PTC13 | PIN_INT_BOTH)
+
+/* GPIO pins to be registered to the GPIO driver: */
+
+/*WARNING IF THIS CHANGES CHANGE gpio.h 
+			and the define of GPIO_x
+			and the array in s32k1xx_gpio.c */
+#define NUM_OF_GPIO_IN  0//5 /* Amount of GPIO input pins */
+#define NUM_OF_GPIO_OUT 6//5//5 /* Amount of GPIO output pins */
+#ifdef CONFIG_S32K1XX_GPIOIRQ
+#define NUM_OF_GPIO_INT 7//4 /* Amount of GPIO interrupt pins */
+#else
+#define NUM_OF_GPIO_INT 0 /* Amount of GPIO interrupt pins */
+#endif
+
+/*WARNING IF THIS CHANGES CHANGE gpio.h 
+			and the NUM_OF_GPIO_x
+			and the array in s32k1xx_gpio.c */
+//#define GPIO_IN0 	(PIN_PTA13 | GPIO_INPUT) // NFC_ED
+// #define GPIO_IN1 	(PIN_PTC14 | GPIO_INPUT) // SBC Wake
+// #define GPIO_IN2 	(PIN_PTC8  | GPIO_INPUT) // GATE_RS
+// #define GPIO_IN3 	(PIN_PTA11 | GPIO_INPUT) // SBC_LIMP
+//#define GPIO_IN0 	(PIN_PTC9  | GPIO_INPUT) // BCC_FAULT
+
+// #define GPIO_OUT1 	(PIN_PTC1  | GPIO_OUTPUT) // GATE_CTRL_CP
+// #define GPIO_OUT2 	(PIN_PTC2  | GPIO_OUTPUT) // GATE_CTRL_D
+// #define GPIO_OUT3 	(PIN_PTD5  | GPIO_OUTPUT) // BCC_RESET
+// #define GPIO_OUT4 	(PIN_PTA12 | GPIO_OUTPUT) // NFC_HPD
+// #define GPIO_OUT5 	(PIN_PTC15 | GPIO_OUTPUT) // AUTH_WAKE
+#define GPIO_OUT0 	(PIN_PTC1  | GPIO_OUTPUT) // GATE_CTRL_CP
+#define GPIO_OUT1 	(PIN_PTC2  | GPIO_OUTPUT) // GATE_CTRL_D
+#define GPIO_OUT2 	(PIN_PTD5  | GPIO_OUTPUT) // BCC_RESET
+#define GPIO_OUT3 	(PIN_PTA12 | GPIO_OUTPUT) // NFC_HPD
+#define GPIO_OUT4 	(PIN_PTC15 | GPIO_OUTPUT) // AUTH_WAKE
+#define GPIO_OUT5 	(PIN_PTE8  | GPIO_OUTPUT) // EXT_OUT1 To ext header
+//#define GPIO_OUT6 	(PIN_PTE9  | GPIO_OUTPUT) // EXT_OUT2 To ext header
+//#define GPIO_OUT6 	(PIN_PTD3  | GPIO_OUTPUT) // BCC_CS
+
+#define GPIO_INT6 	(PIN_PTC3  | GPIO_INPUT | PIN_INT_BOTH) // OVERCURRENT
+#define GPIO_INT7 	(PIN_PTC14 | GPIO_INPUT | PIN_INT_BOTH) // SBC Wake 
+#define GPIO_INT8 	(PIN_PTC8  | GPIO_INPUT | PIN_INT_BOTH) // GATE_RS
+#define GPIO_INT9 	(PIN_PTA11 | GPIO_INPUT | PIN_INT_BOTH) // SBC_LIMP
+#define GPIO_INT10 	(PIN_PTC9  | GPIO_INPUT | PIN_INT_BOTH) // BCC_FAULT
+#define GPIO_INT11 	(PIN_PTA13 | GPIO_INPUT | PIN_INT_BOTH) // NFC_ED
+#define GPIO_INT12	(PIN_PTA5  | GPIO_INPUT | PIN_INT_BOTH) // RST_N
+
+
+//#define GPIO_INTn (PIN_PTC9 | GPIO_INPUT | PIN_INT_RISING)	// BCC_FAULT
+
+
+// #define NUM_OF_GPIO_IN  1//1 /* Amount of GPIO input pins */
+// #define NUM_OF_GPIO_OUT 2 /* Amount of GPIO output pins */
+// #define NUM_OF_GPIO_INT 1 //1 /* Amount of GPIO interrupt pins */
+
+// // these need to be added in the array in s32k1xx_gpio.c: in the g_gpioinputs, g_gpiooutputs or g_gpiointinputs
+// #define GPIO_IN1  (PIN_PTC8  | GPIO_INPUT) 	// GATE_RS
+
+// #define GPIO_OUT1 (PIN_PTC1  | GPIO_OUTPUT) // GATE_CTRL_CP
+// #define GPIO_OUT2 (PIN_PTC2  | GPIO_OUTPUT) // GATE_CTRL_D
+
+// // for interrupt use PIN_INT_BOTH, PIN_INT_RISING, PIN_INT_FALLING or another define from s32k1xx_pinirq.c
+// #define GPIO_INT1 (PIN_PTC3  | GPIO_INPUT | PIN_INT_BOTH) // OVERCURRENT
+// #define GPIO_OUT2 (PIN_PTC2  | GPIO_OUTPUT)
+// #define GPIO_OUT3 (PIN_PTC2  | GPIO_OUTPUT)
+// #define GPIO_OUT4 (PIN_PTC2  | GPIO_OUTPUT)
+// #define GPIO_OUT5 (PIN_PTC2  | GPIO_OUTPUT)
+// #define GPIO_OUT6 (PIN_PTC2  | GPIO_OUTPUT)
+
+//#define GPIO_INT2 (PIN_PTA12 | GPIO_INPUT | PIN_INT_RISING)
+
+/* SPI chip selects */
+
+/* Count of peripheral clock user configurations */
+
+#define NUM_OF_PERIPHERAL_CLOCKS_0 12
+
+/****************************************************************************
+ * Public Types
+ ****************************************************************************/
+
+/****************************************************************************
+ * Public Data
+ ****************************************************************************/
+
+#ifndef __ASSEMBLY__
+
+/* User peripheral configuration structure 0 */
+
+extern const struct peripheral_clock_config_s g_peripheral_clockconfig0[];
+
+/****************************************************************************
+ * Public Function Prototypes
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: s32k1xx_bringup
+ *
+ * Description:
+ *   Perform architecture-specific initialization
+ *
+ *   CONFIG_BOARD_LATE_INITIALIZE=y :
+ *     Called from board_late_initialize().
+ *
+ *   CONFIG_BOARD_LATE_INITIALIZE=y && CONFIG_LIB_BOARDCTL=y :
+ *     Called from the NSH library
+ *
+ ****************************************************************************/
+
+int s32k1xx_bringup(void);
+
+#ifdef CONFIG_DEV_GPIO
+/****************************************************************************
+ * Name: s32k1xx_gpio_initialize
+ *
+ * Description:
+ *   Initialize GPIO drivers for use with /apps/examples/gpio
+ *
+ ****************************************************************************/
+
+int s32k1xx_gpio_initialize(void);
+#endif
+
+/****************************************************************************
+ * Name: s32k1xx_spidev_initialize
+ *
+ * Description:
+ *   Called to configure SPI chip select GPIO pins for the RDDRONE-BMS772
+ *   board.
+ *
+ ****************************************************************************/
+
+#ifdef CONFIG_S32K1XX_LPSPI
+void s32k1xx_spidev_initialize(void);
+#endif
+
+#endif /* __ASSEMBLY__ */
+#endif /* __BOARDS_ARM_S32K1XX_RDDRONE_BMS772_SRC_RDDRONE_BMS772_H */
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_appinit.c b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_appinit.c
new file mode 100644
index 0000000000..145c8dd558
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_appinit.c
@@ -0,0 +1,94 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_appinit.c
+ *
+ *   Copyright (C) 2019 Gregory Nutt. All rights reserved.
+ *   Author: Gregory Nutt <gnutt@nuttx.org>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include <nuttx/board.h>
+
+#include "rddrone-bms772.h"
+
+/****************************************************************************
+ * Pre-processor Definitions
+ ****************************************************************************/
+
+#ifndef OK
+#  define OK 0
+#endif
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: board_app_initialize
+ *
+ * Description:
+ *   Perform application specific initialization.  This function is never
+ *   called directly from application code, but only indirectly via the
+ *   (non-standard) boardctl() interface using the command BOARDIOC_INIT.
+ *
+ * Input Parameters:
+ *   arg - The boardctl() argument is passed to the board_app_initialize()
+ *         implementation without modification.  The argument has no
+ *         meaning to NuttX; the meaning of the argument is a contract
+ *         between the board-specific initialization logic and the
+ *         matching application logic.  The value could be such things as a
+ *         mode enumeration value, a set of DIP switch switch settings, a
+ *         pointer to configuration data read from a file or serial FLASH,
+ *         or whatever you would like to do with it.  Every implementation
+ *         should accept zero/NULL as a default configuration.
+ *
+ * Returned Value:
+ *   Zero (OK) is returned on success; a negated errno value is returned on
+ *   any failure to indicate the nature of the failure.
+ *
+ ****************************************************************************/
+
+int board_app_initialize(uintptr_t arg)
+{
+#ifdef CONFIG_BOARD_LATE_INITIALIZE
+  /* Board initialization already performed by board_late_initialize() */
+
+  return OK;
+#else
+  /* Perform board-specific initialization */
+
+  return s32k1xx_bringup();
+#endif
+}
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_autoleds.c b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_autoleds.c
new file mode 100644
index 0000000000..3cda4ef8bd
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_autoleds.c
@@ -0,0 +1,165 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_autoleds.c
+ *
+ *   Copyright (C) 2019 Gregory Nutt. All rights reserved.
+ *   Author: Gregory Nutt <gnutt@nuttx.org>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/* The RDDRONE-BMS772 has one RGB LED:
+ *
+ *   RedLED   PTD16 (FTM0 CH1)
+ *   GreenLED PTB13 (FTM0 CH1)
+ *   BlueLED  PTD15 (FTM0 CH0)
+ *
+ * An output of '1' illuminates the LED.
+ *
+ * If CONFIG_ARCH_LEDs is defined, then NuttX will control the LED on board
+ * the Freedom K66F.  The following definitions describe how NuttX controls
+ * the LEDs:
+ *
+ *   SYMBOL                Meaning                 LED state
+ *                                                 RED   GREEN  BLUE
+ *   -------------------  -----------------------  -----------------
+ *   LED_STARTED          NuttX has been started    OFF  OFF  OFF
+ *   LED_HEAPALLOCATE     Heap has been allocated   OFF  OFF  ON
+ *   LED_IRQSENABLED      Interrupts enabled        OFF  OFF  ON
+ *   LED_STACKCREATED     Idle stack created        OFF  ON   OFF
+ *   LED_INIRQ            In an interrupt          (no change)
+ *   LED_SIGNAL           In a signal handler      (no change)
+ *   LED_ASSERTION        An assertion failed      (no change)
+ *   LED_PANIC            The system has crashed    FLASH OFF OFF
+ *   LED_IDLE             K66 is in sleep mode     (Optional, not used)
+ */
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include <stdint.h>
+#include <stdbool.h>
+#include <debug.h>
+
+#include <nuttx/board.h>
+#include <arch/board/board.h>
+
+#include "arm_arch.h"
+#include "arm_internal.h"
+
+#include "s32k1xx_pin.h"
+#include "rddrone-bms772.h"
+
+#include <arch/board/board.h>
+
+#ifdef CONFIG_ARCH_LEDS
+
+/****************************************************************************
+ * Pre-processor Definitions
+ ****************************************************************************/
+
+/* Summary of all possible settings */
+
+#define LED_NOCHANGE      0 /* LED_IRQSENABLED, LED_INIRQ, LED_SIGNAL, LED_ASSERTION */
+#define LED_OFF_OFF_OFF   1 /* LED_STARTED */
+#define LED_OFF_OFF_ON    2 /* LED_HEAPALLOCATE */
+#define LED_OFF_ON_OFF    3 /* LED_STACKCREATED */
+#define LED_ON_OFF_OFF    4 /* LED_PANIC */
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: board_autoled_initialize
+ ****************************************************************************/
+
+void board_autoled_initialize(void)
+{
+  /* Configure LED GPIOs for output */
+
+  s32k1xx_pinconfig(GPIO_LED_R);
+  s32k1xx_pinconfig(GPIO_LED_G);
+  s32k1xx_pinconfig(GPIO_LED_B);
+}
+
+/****************************************************************************
+ * Name: board_autoled_on
+ ****************************************************************************/
+
+void board_autoled_on(int led)
+{
+  if (led != LED_NOCHANGE)
+    {
+      bool redon   = false;
+      bool greenon = false;
+      bool blueon  = false;
+
+      switch (led)
+        {
+          default:
+          case LED_OFF_OFF_OFF:
+            break;
+
+          case LED_OFF_OFF_ON:
+            blueon = true;
+            break;
+
+          case LED_OFF_ON_OFF:
+            greenon = true;
+            break;
+
+          case LED_ON_OFF_OFF:
+            redon = true;
+            break;
+        }
+
+      s32k1xx_gpiowrite(GPIO_LED_R, redon);
+      s32k1xx_gpiowrite(GPIO_LED_G, greenon);
+      s32k1xx_gpiowrite(GPIO_LED_B, blueon);
+    }
+}
+
+/****************************************************************************
+ * Name: board_autoled_off
+ ****************************************************************************/
+
+void board_autoled_off(int led)
+{
+  if (led == LED_ON_OFF_OFF)
+    {
+      s32k1xx_gpiowrite(GPIO_LED_R, true);
+      s32k1xx_gpiowrite(GPIO_LED_G, false);
+      s32k1xx_gpiowrite(GPIO_LED_B, false);
+    }
+}
+
+#endif /* CONFIG_ARCH_LEDS */
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_boot.c b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_boot.c
new file mode 100644
index 0000000000..01fb4945bd
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_boot.c
@@ -0,0 +1,93 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_boot.c
+ *
+ *   Copyright (C) 2019 Gregory Nutt. All rights reserved.
+ *   Author: Gregory Nutt <gnutt@nuttx.org>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include <debug.h>
+
+#include <nuttx/board.h>
+
+#include "rddrone-bms772.h"
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: s32k1xx_board_initialize
+ *
+ * Description:
+ *   All S32K1XX architectures must provide the following entry point.  This
+ *   entry point is called early in the initialization -- after all memory
+ *   has been configured and mapped but before any devices have been
+ *   initialized.
+ *
+ ****************************************************************************/
+
+void s32k1xx_board_initialize(void)
+{
+#ifdef CONFIG_ARCH_LEDS
+  /* Configure on-board LEDs if LED support has been selected. */
+
+  board_autoled_initialize();
+#endif
+}
+
+/****************************************************************************
+ * Name: board_late_initialize
+ *
+ * Description:
+ *   If CONFIG_BOARD_LATE_INITIALIZE is selected, then an additional
+ *   initialization call will be performed in the boot-up sequence to a
+ *   function called board_late_initialize().  board_late_initialize() will
+ *   be called immediately after up_initialize() is called and just before
+ *   the initial application is started.  This additional initialization
+ *   phase may be used, for example, to initialize board-specific device
+ *   drivers.
+ *
+ ****************************************************************************/
+
+#ifdef CONFIG_BOARD_LATE_INITIALIZE
+void board_late_initialize(void)
+{
+  /* Perform board-specific initialization */
+
+  s32k1xx_bringup();
+}
+#endif
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_bringup.c b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_bringup.c
new file mode 100644
index 0000000000..04ed807709
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_bringup.c
@@ -0,0 +1,181 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_bringup.c
+ *
+ *   Copyright (C) 2019 Gregory Nutt. All rights reserved.
+ *   Author: Gregory Nutt <gnutt@nuttx.org>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include <sys/types.h>
+#include <sys/mount.h>
+#include <syslog.h>
+
+#ifdef CONFIG_BUTTONS
+#  include <nuttx/input/buttons.h>
+#endif
+
+#ifdef CONFIG_USERLED
+#  include <nuttx/leds/userled.h>
+#endif
+
+#ifdef CONFIG_I2C_DRIVER
+#  include "s32k1xx_pin.h"
+#  include <nuttx/i2c/i2c_master.h>
+#  include "s32k1xx_lpi2c.h"
+#endif
+
+#ifdef CONFIG_S32K1XX_EEEPROM
+#  include "s32k1xx_eeeprom.h"
+#endif
+
+#include "rddrone-bms772.h"
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: s32k1xx_bringup
+ *
+ * Description:
+ *   Perform architecture-specific initialization
+ *
+ *   CONFIG_BOARD_LATE_INITIALIZE=y :
+ *     Called from board_late_initialize().
+ *
+ *   CONFIG_BOARD_LATE_INITIALIZE=n && CONFIG_LIB_BOARDCTL=y :
+ *     Called from the NSH library
+ *
+ ****************************************************************************/
+
+int s32k1xx_bringup(void)
+{
+  int ret = OK;
+
+#ifdef CONFIG_BUTTONS
+  /* Register the BUTTON driver */
+
+  ret = btn_lower_initialize("/dev/buttons");
+  if (ret < 0)
+    {
+      syslog(LOG_ERR, "ERROR: btn_lower_initialize() failed: %d\n", ret);
+    }
+#endif
+
+#ifdef CONFIG_USERLED
+  /* Register the LED driver */
+
+  ret = userled_lower_initialize("/dev/userleds");
+  if (ret < 0)
+    {
+      syslog(LOG_ERR, "ERROR: userled_lower_initialize() failed: %d\n", ret);
+    }
+#endif
+
+#ifdef CONFIG_FS_PROCFS
+  /* Mount the procfs file system */
+
+  ret = mount(NULL, "/proc", "procfs", 0, NULL);
+  if (ret < 0)
+    {
+      syslog(LOG_ERR, "ERROR: Failed to mount procfs at /proc: %d\n", ret);
+    }
+#endif
+
+#ifdef CONFIG_DEV_GPIO
+  ret = s32k1xx_gpio_initialize();
+  if (ret < 0)
+    {
+      syslog(LOG_ERR, "ERROR: Failed to initialize GPIO driver: %d\n", ret);
+    }
+#endif
+
+#ifdef CONFIG_PWM
+  /* Initialize PWM and register the PWM device. */
+
+  ret = s32k1xx_pwm_setup();
+  if (ret < 0)
+    {
+      syslog(LOG_ERR, "ERROR: s32k1xx_pwm_setup() failed: %d\n", ret);
+    }
+#endif
+
+#ifdef CONFIG_S32K1XX_LPSPI
+  /* Configure SPI chip selects if 1) SPI is not disabled, and 2) the weak
+   * function s32k1xx_spidev_initialize() has been brought into the link.
+   */
+
+  s32k1xx_spidev_initialize();
+#endif
+
+#if defined(CONFIG_S32K1XX_LPI2C0) && defined(CONFIG_I2C_DRIVER)
+  FAR struct i2c_master_s *i2c;
+
+  i2c = s32k1xx_i2cbus_initialize(0);
+  if (i2c == NULL)
+    {
+      serr("ERROR: Failed to get I2C%d interface\n", bus);
+    }
+  else
+    {
+      ret = i2c_register(i2c, 0);
+      if (ret < 0)
+        {
+          serr("ERROR: Failed to register I2C%d driver: %d\n", bus, ret);
+          s32k1xx_i2cbus_uninitialize(i2c);
+        }
+    }
+#endif
+
+#ifdef CONFIG_S32K1XX_PROGMEM
+  FAR struct mtd_dev_s *mtd;
+  int minor = 0;
+
+  mtd = progmem_initialize();
+  if (!mtd)
+    {
+      syslog(LOG_ERR, "ERROR: progmem_initialize failed\n");
+    }
+#endif
+
+#ifdef CONFIG_S32K1XX_EEEPROM
+      /* Register EEEPROM block device */
+
+      s32k1xx_eeeprom_register(0, 4096);
+#endif
+
+  return ret;
+}
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_buttons.c b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_buttons.c
new file mode 100644
index 0000000000..e8c464ed63
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_buttons.c
@@ -0,0 +1,164 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_buttons.c
+ *
+ *   Copyright (C) 2019 Gregory Nutt. All rights reserved.
+ *   Author: Gregory Nutt <gnutt@nuttx.org>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/* The rddrone-bms772 supports one button:
+ *
+ *   SW1 PTC14
+ */
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include <stdint.h>
+#include <errno.h>
+
+#include <nuttx/arch.h>
+#include <nuttx/board.h>
+
+#include "s32k1xx_pin.h"
+#include "rddrone-bms772.h"
+
+#include <arch/board/board.h>
+
+#ifdef CONFIG_ARCH_BUTTONS
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: board_button_initialize
+ *
+ * Description:
+ *   board_button_initialize() must be called to initialize button resources.
+ *   After that, board_buttons() may be called to collect the current state
+ *   of all buttons or board_button_irq() may be called to register button
+ *   interrupt handlers.
+ *
+ ****************************************************************************/
+
+uint32_t board_button_initialize(void)
+{
+  /* Configure the GPIO pins as interrupting inputs. */
+
+  s32k1xx_pinconfig(GPIO_SW1);
+  return NUM_BUTTONS;
+}
+
+/****************************************************************************
+ * Name: board_buttons
+ ****************************************************************************/
+
+uint32_t board_buttons(void)
+{
+  uint32_t ret = 0;
+
+  if (s32k1xx_gpioread(GPIO_SW1))
+    {
+      ret |= BUTTON_SW1_BIT;
+    }
+
+  // if (s32k1xx_gpioread(GPIO_SW3))
+  //   {
+  //     ret |= BUTTON_SW3_BIT;
+  //   }
+
+  return ret;
+}
+
+/****************************************************************************
+ * Button support.
+ *
+ * Description:
+ *   board_button_initialize() must be called to initialize button resources.
+ *   After that, board_buttons() may be called to collect the current state
+ *   of all buttons or board_button_irq() may be called to register button
+ *   interrupt handlers.
+ *
+ *   After board_button_initialize() has been called, board_buttons() may be
+ *   called to collect the state of all buttons.  board_buttons() returns a
+ *   32-bit bit set with each bit associated with a button.  See the
+ *   BUTTON_*_BIT definitions in board.h for the meaning of each bit.
+ *
+ *   board_button_irq() may be called to register an interrupt handler that
+ *   will be called when a button is depressed or released.  The ID value is
+ *   a button enumeration value that uniquely identifies a button resource.
+ *   See the BUTTON_* definitions in board.h for the meaning of enumeration
+ *   value.
+ *
+ ****************************************************************************/
+
+#ifdef CONFIG_ARCH_IRQBUTTONS
+int board_button_irq(int id, xcpt_t irqhandler, FAR void *arg)
+{
+  uint32_t pinset;
+  int ret;
+
+  /* Map the button id to the GPIO bit set. */
+
+  if (id == BUTTON_SW1)
+    {
+      pinset = GPIO_SW1;
+    }
+  // else if (id == BUTTON_SW3)
+  //   {
+  //     pinset = GPIO_SW3;
+  //   }
+  else
+    {
+      return -EINVAL;
+    }
+
+  /* The button has already been configured as an interrupting input (by
+   * board_button_initialize() above).
+   *
+   * Attach the new button handler.
+   */
+
+  ret = s32k1xx_pinirqattach(pinset, irqhandler, NULL);
+  if (ret >= 0)
+    {
+      /* Then make sure that interrupts are enabled on the pin */
+
+      s32k1xx_pinirqenable(pinset);
+    }
+
+  return ret;
+}
+#endif
+#endif /* CONFIG_ARCH_BUTTONS */
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_clockconfig.c b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_clockconfig.c
new file mode 100644
index 0000000000..e62cecbc7f
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_clockconfig.c
@@ -0,0 +1,217 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_clockconfig.c
+ *
+ *   Copyright (C) 2019 Gregory Nutt. All rights reserved.
+ *   Author: Gregory Nutt <gnutt@nuttx.org>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Most of the settings within this file derives from NXP sample code for
+ * the S32K1XX MCUs.  That sample code has this licensing information:
+ *
+ *   Copyright (c) 2013 - 2015, Freescale Semiconductor, Inc.
+ *   Copyright 2016-2018 NXP
+ *   All rights reserved.
+ *
+ * THIS SOFTWARE IS PROVIDED BY NXP "AS IS" AND ANY EXPRESSED OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL NXP OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include <stdint.h>
+#include <stdbool.h>
+
+#include "s32k1xx_clockconfig.h"
+#include "s32k1xx_start.h"
+#include "rddrone-bms772.h"
+
+/****************************************************************************
+ * Public Data
+ ****************************************************************************/
+
+/* Each S32K1XX board must provide the following initialized structure.
+ * This is needed to establish the initial board clocking.
+ */
+
+const struct clock_configuration_s g_initial_clkconfig =
+{
+  .scg =
+  {
+    .sirc          =
+    {
+      .range       = SCG_SIRC_RANGE_HIGH,      /* RANGE - High range (8 MHz) */
+      .div1        = SCG_ASYNC_CLOCK_DIV_BY_1, /* SIRCDIV1 */
+      .div2        = SCG_ASYNC_CLOCK_DIV_BY_1, /* SIRCDIV2 */
+      .initialize  = true,  /* Initialize */
+      .stopmode    = false, /* SIRCSTEN */
+      .lowpower    = true,  /* SIRCLPEN */
+      .locked      = false, /* LK */
+    },
+    .firc          =
+    {
+      .range       = SCG_FIRC_RANGE_48M,       /* RANGE */
+      .div1        = SCG_ASYNC_CLOCK_DIV_BY_1, /* FIRCDIV1 */
+      .div2        = SCG_ASYNC_CLOCK_DIV_BY_1, /* FIRCDIV2 */
+      .initialize  = true,  /* Initialize */
+      .regulator   = true,  /* FIRCREGOFF */
+      .locked      = false, /* LK */
+    },
+    .sosc          =
+    {
+      .mode        = SCG_SOSC_MONITOR_DISABLE, /* SOSCCM */
+      .gain        = SCG_SOSC_GAIN_LOW,        /* HGO */
+      .range       = SCG_SOSC_RANGE_HIGH,      /* RANGE */
+      .extref      = SCG_SOSC_REF_OSC,         /* EREFS */
+      .div1        = SCG_ASYNC_CLOCK_DIV_BY_1, /* SOSCDIV1 */
+      .div2        = SCG_ASYNC_CLOCK_DIV_BY_1, /* SOSCDIV2 */
+      .initialize  = true,  /* Initialize */
+      .locked      = false, /* LK */
+    },
+    .spll          =
+    {
+      .mode        = SCG_SPLL_MONITOR_DISABLE, /* SPLLCM */
+      .div1        = SCG_ASYNC_CLOCK_DIV_BY_1, /* SPLLDIV1 */
+      .div2        = SCG_ASYNC_CLOCK_DIV_BY_1, /* SPLLDIV2 */
+      .prediv      = 4,     /* PREDIV */
+      .mult        = 40,    /* MULT */
+      .src         = 0,     /* SOURCE */
+      .initialize  = true,  /* Initialize */
+      .locked      = false, /* LK */
+    },
+    .rtc           =
+    {
+      .initialize  = true, /* Initialize */
+      .clkin       = 0,    /* RTC_CLKIN */
+    },
+    .clockout      =
+    {
+      .source      = SCG_CLOCKOUT_SRC_FIRC, /* SCG CLKOUTSEL */
+      .initialize  = true, /* Initialize */
+    },
+    .clockmode     =
+    {
+      .rccr        = /* RCCR - Run Clock Control Register */
+      {
+        .src       = SCG_SYSTEM_CLOCK_SRC_SYS_PLL, /* SCS */
+        .divslow   = 3, /* DIVSLOW, range 1..16 */
+        .divbus    = 2, /* DIVBUS, range 1..16 */
+        .divcore   = 2, /* DIVCORE, range 1..16 */
+      },
+      .vccr        = /* VCCR - VLPR Clock Control Register */
+      {
+        .src       = SCG_SYSTEM_CLOCK_SRC_SIRC, /* SCS */
+        .divslow   = 4, /* DIVSLOW, range 1..16 */
+        .divbus    = 1, /* DIVBUS, range 1..16 */
+        .divcore   = 2, /* DIVCORE, range 1..16 */
+      },
+      .hccr        =
+      {
+        .src       = SCG_SYSTEM_CLOCK_SRC_SYS_PLL, /* SCS */
+        .divslow   = 3, /* DIVSLOW, range 1..16 */
+        .divbus    = 2, /* DIVBUS, range 1..16 */
+        .divcore   = 2, /* DIVCORE, range 1..16 */
+      },
+      .initialize  = true, /* Initialize */
+    },
+  },
+  .sim             =
+  {
+    .clockout      = /* Clock Out configuration. */
+    {
+      .source      = SIM_CLKOUT_SEL_SYSTEM_SCG_CLKOUT, /* CLKOUTSEL */
+      .divider     = 1,     /* CLKOUTDIV, range 1..8 */
+      .initialize  = true,  /* Initialize */
+      .enable      = false, /* CLKOUTEN */
+    },
+    .lpoclk        = /* Low Power Clock configuration. */
+    {
+      .rtc_source  = SIM_RTCCLK_SEL_LPO_32K, /* RTCCLKSEL */
+      .lpo_source  = SIM_LPO_CLK_SEL_LPO_128K,    /* LPOCLKSEL */
+      .initialize  = true, /* Initialize */
+      .lpo32k      = true, /* LPO32KCLKEN */
+      .lpo1k       = true, /* LPO1KCLKEN */
+    },
+    .tclk          = /* TCLK CLOCK configuration. */
+    {
+      .tclkfreq[0] = 0,    /* TCLK0 */
+      .tclkfreq[1] = 0,    /* TCLK1 */
+      .tclkfreq[2] = 0,    /* TCLK2 */
+      .initialize  = true, /* Initialize */
+    },
+    .platgate      = /* Platform Gate Clock configuration. */
+    {
+      .initialize  = true, /* Initialize */
+      .mscm        = true, /* CGCMSCM */
+      .mpu         = true, /* CGCMPU */
+      .dma         = true, /* CGCDMA */
+      .erm         = true, /* CGCERM */
+      .eim         = true, /* CGCEIM */
+    },
+    .traceclk      = /* Debug trace Clock Configuration. */
+    {
+      .source      = CLOCK_TRACE_SRC_CORE_CLK, /* TRACECLK_SEL */
+      .divider     = 1,     /* TRACEDIV, range 1..8 */
+      .initialize  = true,  /* Initialize */
+      .enable      = true,  /* TRACEDIVEN */
+      .fraction    = false, /* TRACEFRAC */
+    },
+  },
+  .pcc             =
+  {
+    .count         = NUM_OF_PERIPHERAL_CLOCKS_0, /* Number peripheral clock configurations */
+    .pclks         = g_peripheral_clockconfig0,  /* Peripheral clock configurations */
+  },
+  .pmc             =
+  {
+    .lpoclk        = /* Low Power Clock configuration. */
+    {
+      .trim        = 0,    /* Trimming value for LPO */
+      .initialize  = true, /* Initialize */
+      .enable      = true, /* Enable/disable LPO */
+    },
+  },
+};
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_gpio.c b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_gpio.c
new file mode 100644
index 0000000000..50ada4dfa8
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_gpio.c
@@ -0,0 +1,399 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_gpio.c
+ *
+ *   Copyright (C) 2017-2018 Gregory Nutt. All rights reserved.
+ *   Copyright (C) 2017 Alan Carvalho de Assis. All rights reserved.
+ *   Author:  Alan Carvalho de Assis <acassis@gmail.com>
+ *
+ * Based on: boards/imxrt1050-evk/src/imxrt_gpio.c
+ *
+ *   Author:  Pavlina Koleva <pavlinaikoleva19@gmail.com>
+ *   Modified by: Ivan Ucherdzhiev <ivanucherdjiev@gmail.com>
+ *
+ * Also based on: boards/arm/stm32/stm32f103-minimum/src/stm32_gpio.c
+ *
+ *   Author:  Alan Carvalho de Assis <acassis@gmail.com>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include <stdbool.h>
+#include <assert.h>
+#include <debug.h>
+
+#include <nuttx/clock.h>
+#include <nuttx/wdog.h>
+#include <nuttx/ioexpander/gpio.h>
+
+#include <arch/board/board.h>
+
+#include "chip.h"
+
+#include <s32k1xx_pin.h>
+#include "rddrone-bms772.h"
+
+#if defined(CONFIG_DEV_GPIO) && !defined(CONFIG_GPIO_LOWER_HALF)
+
+/****************************************************************************
+ * Private Types
+ ****************************************************************************/
+
+struct s32k1xx_gpio_dev_s
+{
+  struct gpio_dev_s gpio;
+  uint8_t id;
+};
+
+struct s32k1xx_gpint_dev_s
+{
+  struct s32k1xx_gpio_dev_s s32k1xx_gpio;
+  pin_interrupt_t callback;
+};
+
+/****************************************************************************
+ * Private Function Prototypes
+ ****************************************************************************/
+#if NUM_OF_GPIO_IN > 0 
+static int gpin_read(FAR struct gpio_dev_s *dev, FAR bool *value);
+#endif
+
+#if NUM_OF_GPIO_OUT > 0 
+static int gpout_read(FAR struct gpio_dev_s *dev, FAR bool *value);
+static int gpout_write(FAR struct gpio_dev_s *dev, bool value);
+#endif
+
+#if NUM_OF_GPIO_INT > 0 
+static int gpint_read(FAR struct gpio_dev_s *dev, FAR bool *value);
+static int gpint_attach(FAR struct gpio_dev_s *dev,
+                        pin_interrupt_t callback);
+static int gpint_enable(FAR struct gpio_dev_s *dev, bool enable);
+#endif
+
+/****************************************************************************
+ * Private Data
+ ****************************************************************************/
+#if NUM_OF_GPIO_IN > 0 
+static const struct gpio_operations_s gpin_ops =
+{
+  .go_read   = gpin_read,
+  .go_write  = NULL,
+  .go_attach = NULL,
+  .go_enable = NULL,
+};
+#endif
+
+#if NUM_OF_GPIO_OUT > 0 
+static const struct gpio_operations_s gpout_ops =
+{
+  .go_read   = gpout_read,
+  .go_write  = gpout_write,
+  .go_attach = NULL,
+  .go_enable = NULL,
+};
+#endif
+
+#if NUM_OF_GPIO_INT > 0 
+static const struct gpio_operations_s gpint_ops =
+{
+  .go_read   = gpint_read,
+  .go_write  = NULL,
+  .go_attach = gpint_attach,
+  .go_enable = gpint_enable,
+};
+#endif
+
+#if NUM_OF_GPIO_IN > 0 
+static struct s32k1xx_gpio_dev_s g_gpin[NUM_OF_GPIO_IN];
+
+/*WARNING IF THIS CHANGES CHANGE gpio.h 
+          and the define of GPIO_x in rddrone-bms772.h
+          and the NUM_OF_GPIO_x in rddrone-bms772.h
+*/
+/* This array maps the GPIO pins used as INPUT */
+static const uint32_t g_gpioinputs[NUM_OF_GPIO_IN] =
+{
+  //GPIO_IN0//, GPIO_IN1//, GPIO_IN2, GPIO_IN3, GPIO_IN4
+};
+#endif
+
+#if NUM_OF_GPIO_OUT > 0 
+static struct s32k1xx_gpio_dev_s g_gpout[NUM_OF_GPIO_OUT];
+
+/*WARNING IF THIS CHANGES CHANGE gpio.h 
+          and the define of GPIO_x in rddrone-bms772.h
+          and the NUM_OF_GPIO_x in rddrone-bms772.h
+*/
+/* This array maps the GPIO pins used as OUTPUT */
+static const uint32_t g_gpiooutputs[NUM_OF_GPIO_OUT] =
+{
+  GPIO_OUT0, GPIO_OUT1, GPIO_OUT2, GPIO_OUT3, GPIO_OUT4, GPIO_OUT5//, GPIO_OUT6//, GPIO_OUT7, GPIO_OUT8, GPIO_OUT9
+};
+#endif
+
+#if NUM_OF_GPIO_INT > 0 
+static struct s32k1xx_gpint_dev_s g_gpint[NUM_OF_GPIO_INT];
+
+/*WARNING IF THIS CHANGES CHANGE gpio.h  
+          and the define of GPIO_x in rddrone-bms772.h
+          and the NUM_OF_GPIO_x in rddrone-bms772.h
+*/
+/* This array maps the GPIO pins used as OUTPUT */
+static const uint32_t g_gpiointinputs[NUM_OF_GPIO_INT] =
+{
+ // GPIO_INT2//GPIO_INT10
+  //GPIO_INT5, GPIO_INT6,
+  GPIO_INT6, GPIO_INT7, GPIO_INT8, GPIO_INT9, GPIO_INT10, GPIO_INT11 ,GPIO_INT12//, GPIO_INT13, 
+};
+#endif
+
+// #if NUM_OF_GPIO_IN > 0
+// static const uint32_t g_gpioinputs[NUM_OF_GPIO_IN] =
+// {
+//   GPIO_IN1,
+// };
+// static struct s32k1xx_gpio_dev_s g_gpin[NUM_OF_GPIO_IN];
+// #endif
+
+// /* This array maps the GPIO pins used as OUTPUT */
+// #if NUM_OF_GPIO_OUT > 0
+// static const uint32_t g_gpiooutputs[NUM_OF_GPIO_OUT] =
+// {
+//   GPIO_OUT1, GPIO_OUT2
+// };
+// static struct s32k1xx_gpio_dev_s g_gpout[NUM_OF_GPIO_OUT];
+// #endif
+
+// /* This array maps the GPIO pins used as interrupt pins */
+// #if NUM_OF_GPIO_INT > 0
+// static const uint32_t g_gpiointinputs[NUM_OF_GPIO_INT] =
+// {
+//   GPIO_INT1,
+// };
+// static struct s32k1xx_gpint_dev_s g_gpint[NUM_OF_GPIO_INT];
+// #endif
+
+/****************************************************************************
+ * Private Functions
+ ****************************************************************************/
+#if NUM_OF_GPIO_INT > 0 
+static int s32k1xx_gpio_interrupt(int irq, void *context, void *arg)
+{
+  FAR struct s32k1xx_gpint_dev_s *s32k1xx_gpint =
+    (FAR struct s32k1xx_gpint_dev_s *)arg;
+
+  DEBUGASSERT(s32k1xx_gpint != NULL && s32k1xx_gpint->callback != NULL);
+  gpioinfo("Interrupt! callback=%p\n", s32k1xx_gpint->callback);
+
+  s32k1xx_gpint->callback(&s32k1xx_gpint->s32k1xx_gpio.gpio,
+                           s32k1xx_gpint->s32k1xx_gpio.id);
+  return OK;
+}
+#endif
+
+#if NUM_OF_GPIO_IN > 0 
+static int gpin_read(FAR struct gpio_dev_s *dev, FAR bool *value)
+{
+  FAR struct s32k1xx_gpio_dev_s *s32k1xx_gpio =
+    (FAR struct s32k1xx_gpio_dev_s *)dev;
+
+  DEBUGASSERT(s32k1xx_gpio != NULL && value != NULL);
+  DEBUGASSERT(s32k1xx_gpio->id < NUM_OF_GPIO_IN);
+  gpioinfo("Reading...\n");
+
+  *value = s32k1xx_gpioread(g_gpioinputs[s32k1xx_gpio->id]);
+  return OK;
+}
+#endif
+
+#if NUM_OF_GPIO_OUT > 0 
+static int gpout_read(FAR struct gpio_dev_s *dev, FAR bool *value)
+{
+  FAR struct s32k1xx_gpio_dev_s *s32k1xx_gpio =
+    (FAR struct s32k1xx_gpio_dev_s *)dev;
+
+  DEBUGASSERT(s32k1xx_gpio != NULL && value != NULL);
+  DEBUGASSERT(s32k1xx_gpio->id < NUM_OF_GPIO_OUT);
+  gpioinfo("Reading...\n");
+
+  *value = s32k1xx_gpioread(g_gpiooutputs[s32k1xx_gpio->id]);
+  return OK;
+}
+
+static int gpout_write(FAR struct gpio_dev_s *dev, bool value)
+{
+  FAR struct s32k1xx_gpio_dev_s *s32k1xx_gpio =
+    (FAR struct s32k1xx_gpio_dev_s *)dev;
+
+  DEBUGASSERT(s32k1xx_gpio != NULL);
+  DEBUGASSERT(s32k1xx_gpio->id < NUM_OF_GPIO_OUT);
+  gpioinfo("Writing %d\n", (int)value);
+
+  s32k1xx_gpiowrite(g_gpiooutputs[s32k1xx_gpio->id], value);
+  return OK;
+}
+
+#endif
+
+#if NUM_OF_GPIO_INT > 0 
+static int gpint_read(FAR struct gpio_dev_s *dev, FAR bool *value)
+{
+  FAR struct s32k1xx_gpint_dev_s *s32k1xx_gpint =
+    (FAR struct s32k1xx_gpint_dev_s *)dev;
+
+  DEBUGASSERT(s32k1xx_gpint != NULL && value != NULL);
+  DEBUGASSERT(s32k1xx_gpint->s32k1xx_gpio.id < NUM_OF_GPIO_INT);
+  gpioinfo("Reading int pin...\n");
+
+  *value = s32k1xx_gpioread(g_gpiointinputs[s32k1xx_gpint->s32k1xx_gpio.id]);
+  return OK;
+}
+
+static int gpint_attach(FAR struct gpio_dev_s *dev, pin_interrupt_t callback)
+{
+  FAR struct s32k1xx_gpint_dev_s *s32k1xx_gpint =
+    (FAR struct s32k1xx_gpint_dev_s *)dev;
+
+  gpioinfo("Attaching the callback\n");
+  s32k1xx_pinirqattach(g_gpiointinputs[s32k1xx_gpint->s32k1xx_gpio.id],
+                       s32k1xx_gpio_interrupt,
+                       &g_gpint[s32k1xx_gpint->s32k1xx_gpio.id]);
+
+  gpioinfo("Attach %p\n", callback);
+  s32k1xx_gpint->callback = callback;
+  return OK;
+}
+
+static int gpint_enable(FAR struct gpio_dev_s *dev, bool enable)
+{
+  FAR struct s32k1xx_gpint_dev_s *s32k1xx_gpint =
+    (FAR struct s32k1xx_gpint_dev_s *)dev;
+
+  if (enable)
+    {
+      if (s32k1xx_gpint->callback != NULL)
+        {
+          gpioinfo("Enabling the interrupt\n");
+          s32k1xx_pinirqenable(
+            g_gpiointinputs[s32k1xx_gpint->s32k1xx_gpio.id]);
+        }
+    }
+  else
+    {
+      gpioinfo("Disable the interrupt\n");
+      s32k1xx_pinirqdisable(g_gpiointinputs[s32k1xx_gpint->s32k1xx_gpio.id]);
+    }
+
+  return OK;
+}
+#endif
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: s32k1xx_gpio_initialize
+ *
+ * Description:
+ *   Initialize GPIO drivers for use with /apps/examples/gpio
+ *
+ ****************************************************************************/
+
+int s32k1xx_gpio_initialize(void)
+{
+  int i;
+  int pincount = 0;
+
+#if NUM_OF_GPIO_IN > 0
+  for (i = 0; i < NUM_OF_GPIO_IN; i++)
+    {
+      /* Setup and register the GPIO pin */
+
+      g_gpin[i].gpio.gp_pintype = GPIO_INPUT_PIN;
+      g_gpin[i].gpio.gp_ops     = &gpin_ops;
+      g_gpin[i].id              = i;
+
+      gpio_pin_register(&g_gpin[i].gpio, pincount);
+
+      /* Configure the pin that will be used as input */
+
+      s32k1xx_pinconfig(g_gpioinputs[i]);
+
+      pincount++;
+    }
+#endif
+
+#if NUM_OF_GPIO_OUT > 0
+  for (i = 0; i < NUM_OF_GPIO_OUT; i++)
+    {
+      /* Setup and register the GPIO pin */
+
+      g_gpout[i].gpio.gp_pintype = GPIO_OUTPUT_PIN;
+      g_gpout[i].gpio.gp_ops     = &gpout_ops;
+      g_gpout[i].id              = i;
+
+      gpio_pin_register(&g_gpout[i].gpio, pincount);
+
+      /* Configure the pin that will be used as output */
+
+      s32k1xx_gpiowrite(g_gpiooutputs[i], 0);
+      s32k1xx_pinconfig(g_gpiooutputs[i]);
+
+      pincount++;
+    }
+#endif
+
+#if NUM_OF_GPIO_INT > 0
+  for (i = 0; i < NUM_OF_GPIO_INT; i++)
+    {
+      /* Setup and register the GPIO pin */
+
+      g_gpint[i].s32k1xx_gpio.gpio.gp_pintype = GPIO_INTERRUPT_PIN;
+      g_gpint[i].s32k1xx_gpio.gpio.gp_ops     = &gpint_ops;
+      g_gpint[i].s32k1xx_gpio.id              = i;
+
+      gpio_pin_register(&g_gpint[i].s32k1xx_gpio.gpio, pincount);
+
+      /* Configure the pin that will be used as interrupt input */
+
+      s32k1xx_pinconfig(g_gpiointinputs[i]);
+
+      pincount++;
+    }
+#endif
+
+  return 0;
+}
+#endif /* CONFIG_DEV_GPIO && !CONFIG_GPIO_LOWER_HALF */
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_periphclocks.c b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_periphclocks.c
new file mode 100644
index 0000000000..e393208ed3
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_periphclocks.c
@@ -0,0 +1,159 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_periphclks.c
+ *
+ *   Copyright (C) 2019 Gregory Nutt. All rights reserved.
+ *   Author: Gregory Nutt <gnutt@nuttx.org>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *  notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *  notice, this list of conditions and the following disclaimer in
+ *  the documentation and/or other materials provided with the
+ *  distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *  used to endorse or promote products derived from this software
+ *  without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Most of the settings within this file derives from NXP sample code for
+ * the S32K1XX MCUs.  That sample code has this licensing information:
+ *
+ *   Copyright (c) 2013 - 2015, Freescale Semiconductor, Inc.
+ *   Copyright 2016-2018 NXP
+ *   All rights reserved.
+ *
+ * THIS SOFTWARE IS PROVIDED BY NXP "AS IS" AND ANY EXPRESSED OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL NXP OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include "s32k1xx_periphclocks.h"
+#include "rddrone-bms772.h"
+
+/****************************************************************************
+ * Public Data
+ ****************************************************************************/
+
+/* Each S32K1XX board must provide the following initialized structure.
+ * This is needed to establish the initial peripheral clocking.
+ */
+
+const struct peripheral_clock_config_s g_peripheral_clockconfig0[] =
+{
+  {
+    .clkname = FLEXCAN0_CLK,
+#ifdef CONFIG_S32K1XX_FLEXCAN0
+    .clkgate = true,
+#else
+    .clkgate = false,
+#endif
+  },
+  {
+    .clkname = LPI2C0_CLK,
+#ifdef CONFIG_S32K1XX_LPI2C0
+    .clkgate = true,
+#else
+    .clkgate = false,
+#endif
+    .clksrc  = CLK_SRC_SIRC_DIV2,
+  },
+  {
+    .clkname = LPSPI0_CLK,
+#ifdef CONFIG_S32K1XX_LPSPI0
+    .clkgate = true,
+#else
+    .clkgate = false,
+#endif
+    .clksrc  = CLK_SRC_SIRC_DIV2,
+  },
+  {
+    .clkname = LPSPI1_CLK,
+#ifdef CONFIG_S32K1XX_LPSPI1
+    .clkgate = true,
+#else
+    .clkgate = false,
+#endif
+    .clksrc  = CLK_SRC_SIRC_DIV2,
+  },
+  {
+    .clkname = LPUART0_CLK,
+#ifdef CONFIG_S32K1XX_LPUART0
+    .clkgate = true,
+#else
+    .clkgate = false,
+#endif
+    .clksrc  = CLK_SRC_SIRC_DIV2,
+  },
+  {
+    .clkname = LPUART1_CLK,
+#ifdef CONFIG_S32K1XX_LPUART1
+    .clkgate = true,
+#else
+    .clkgate = false,
+#endif
+    .clksrc  = CLK_SRC_SIRC_DIV2,
+  },
+  {
+    .clkname = PORTA_CLK,
+    .clkgate = true,
+  },
+  {
+    .clkname = PORTB_CLK,
+    .clkgate = true,
+  },
+  {
+    .clkname = PORTC_CLK,
+    .clkgate = true,
+  },
+  {
+    .clkname = PORTD_CLK,
+    .clkgate = true,
+  },
+  {
+    .clkname = PORTE_CLK,
+    .clkgate = true,
+  },
+  {
+    .clkname = RTC0_CLK,
+#ifdef CONFIG_S32K1XX_RTC
+    .clkgate = true,
+#else
+    .clkgate = false,
+#endif
+  },
+};
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_reset.c b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_reset.c
new file mode 100644
index 0000000000..85bf55147b
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_reset.c
@@ -0,0 +1,77 @@
+/****************************************************************************
+ * boards/arm/kinetis/freedom-k66f/src/k66_reset.c
+ *
+ *   Copyright (C) 2019 Gregory Nutt. All rights reserved.
+ *   Author: Gregory Nutt <gnutt@nuttx.org>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include <nuttx/arch.h>
+#include <nuttx/board.h>
+
+#ifdef CONFIG_BOARDCTL_RESET
+
+/****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: board_reset
+ *
+ * Description:
+ *   Reset board.  Support for this function is required by board-level
+ *   logic if CONFIG_BOARDCTL_RESET is selected.
+ *
+ * Input Parameters:
+ *   status - Status information provided with the reset event.  This
+ *            meaning of this status information is board-specific.  If not
+ *            used by a board, the value zero may be provided in calls to
+ *            board_reset().
+ *
+ * Returned Value:
+ *   If this function returns, then it was not possible to power-off the
+ *   board due to some constraints.  The return value int this case is a
+ *   board-specific reason for the failure to shutdown.
+ *
+ ****************************************************************************/
+
+int board_reset(int status)
+{
+  up_systemreset();
+  return 0;
+}
+
+#endif /* CONFIG_BOARDCTL_RESET */
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_spi.c b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_spi.c
new file mode 100644
index 0000000000..cb3c0848e6
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_spi.c
@@ -0,0 +1,168 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_spi.c
+ *
+ *   Copyright (C) 2018 Gregory Nutt. All rights reserved.
+ *   Author: Ivan Ucherdzhiev <ivanucherdjiev@gmail.com>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include <stdint.h>
+#include <stdbool.h>
+#include <errno.h>
+#include <debug.h>
+
+#include <nuttx/spi/spi.h>
+#include <nuttx/spi/spi_transfer.h>
+#include <arch/board/board.h>
+
+#include "arm_arch.h"
+
+#include "s32k1xx_config.h"
+#include "s32k1xx_lpspi.h"
+#include "s32k1xx_pin.h"
+#include "rddrone-bms772.h"
+
+#if defined(CONFIG_S32K1XX_LPSPI0) || defined(CONFIG_S32K1XX_LPSPI1)
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: s32k1xx_spidev_initialize
+ *
+ * Description:
+ *   Called to configure SPI chip select GPIO pins for the RDDRONE-BMS772
+ *   board.
+ *
+ ****************************************************************************/
+
+void weak_function s32k1xx_spidev_initialize(void)
+{
+#ifdef CONFIG_S32K1XX_LPSPI0
+  s32k1xx_pinconfig(PIN_LPSPI0_PCS);
+
+#ifdef CONFIG_SPI_DRIVER
+  struct spi_dev_s *g_lpspi0;
+  g_lpspi0 = s32k1xx_lpspibus_initialize(0);
+
+  if (!g_lpspi0)
+    {
+      spierr("ERROR: [boot] FAILED to initialize LPSPI0\n");
+    }
+
+  spi_register(g_lpspi0, 0);
+#endif
+#endif
+
+#ifdef CONFIG_S32K1XX_LPSPI1
+  s32k1xx_pinconfig(PIN_LPSPI1_PCS);
+
+#ifdef CONFIG_SPI_DRIVER
+  struct spi_dev_s *g_lpspi1;
+  g_lpspi1 = s32k1xx_lpspibus_initialize(1);
+
+  if (!g_lpspi1)
+    {
+      spierr("ERROR: [boot] FAILED to initialize LPSPI1\n");
+    }
+
+  spi_register(g_lpspi1, 1);
+#endif
+#endif
+}
+
+/****************************************************************************
+ * Name:  s32k1xx_lpspi0/1select and s32k1xx_lpspi0/1status
+ *
+ * Description:
+ *   The external functions, s32k1xx_lpspi0/1select and
+ *   s32k1xx_lpspi0/1status must be provided by board-specific logic.
+ *   They are implementations of the select and status methods of the SPI
+ *   interface defined by struct spi_ops_s (see include/nuttx/spi/spi.h).
+ *   All other methods (including s32k1xx_lpspibus_initialize()) are provided
+ *   by common logic.  To use this common SPI logic on your board:
+ *
+ *   1. Provide logic in s32k1xx_boardinitialize() to configure SPI chip
+ *      select pins.
+ *   2. Provide s32k1xx_lpspi0/1select() and s32k1xx_lpspi0/1status()
+ *      functions in your board-specific logic.  These functions will perform
+ *      chip selection and status operations using GPIOs in the way your
+ *      board is configured.
+ *   3. Add a calls to s32k1xx_lpspibus_initialize() in your low level
+ *      application initialization logic
+ *   4. The handle returned by s32k1xx_lpspibus_initialize() may then be used
+ *      to bind the SPI driver to higher level logic (e.g., calling
+ *      mmcsd_spislotinitialize(), for example, will bind the SPI driver to
+ *      the SPI MMC/SD driver).
+ *
+ ****************************************************************************/
+
+#ifdef CONFIG_S32K1XX_LPSPI0
+void s32k1xx_lpspi0select(FAR struct spi_dev_s *dev, uint32_t devid,
+                        bool selected)
+{
+  spiinfo("devid: %d CS: %s\n", (int)devid,
+          selected ? "assert" : "de-assert");
+
+  // don't use gpiowrite since it is not configured as a GPIO but hardware CS is used
+  // s32k1xx_gpiowrite(PIN_LPSPI0_PCS, !selected);
+}
+
+uint8_t s32k1xx_lpspi0status(FAR struct spi_dev_s *dev, uint32_t devid)
+{
+  return 0;
+}
+#endif
+
+#ifdef CONFIG_S32K1XX_LPSPI1
+void s32k1xx_lpspi1select(FAR struct spi_dev_s *dev,
+                        uint32_t devid, bool selected)
+{
+  spiinfo("devid: %d CS: %s\n", (int)devid,
+          selected ? "assert" : "de-assert");
+
+  // don't use gpiowrite since it is not configured as a GPIO but hardware CS is used
+  // s32k1xx_gpiowrite(PIN_LPSPI1_PCS, !selected);
+}
+
+uint8_t s32k1xx_lpspi1status(FAR struct spi_dev_s *dev, uint32_t devid)
+{
+  return 0;
+}
+#endif
+
+#endif /* CONFIG_S32K1XX_LPSPI0 || CONFIG_S32K1XX_LPSPI01 */
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_userleds.c b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_userleds.c
new file mode 100644
index 0000000000..92607ccae9
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_userleds.c
@@ -0,0 +1,138 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_userleds.c
+ *
+ *   Copyright (C) 2019 Gregory Nutt. All rights reserved.
+ *   Author: Gregory Nutt <gnutt@nuttx.org>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include <stdint.h>
+#include <stdbool.h>
+#include <debug.h>
+
+#include <nuttx/board.h>
+
+#include "arm_arch.h"
+#include "arm_internal.h"
+
+#include "s32k1xx_pin.h"
+#include "rddrone-bms772.h"
+
+#include <arch/board/board.h>
+
+#ifndef CONFIG_ARCH_LEDS
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: board_userled_initialize
+ ****************************************************************************/
+
+uint32_t board_userled_initialize(void)
+{
+  /* Configure LED GPIOs for output */
+
+  s32k1xx_pinconfig(GPIO_LED_R);
+  s32k1xx_pinconfig(GPIO_LED_G);
+  s32k1xx_pinconfig(GPIO_LED_B);
+  return BOARD_NLEDS;
+}
+
+/****************************************************************************
+ * Name: board_userled
+ ****************************************************************************/
+
+void board_userled(int led, bool ledon)
+{
+  uint32_t ledcfg;
+
+  if (led == BOARD_LED_R)
+    {
+      ledcfg = GPIO_LED_R;
+    }
+  else if (led == BOARD_LED_G)
+    {
+      ledcfg = GPIO_LED_G;
+    }
+  else if (led == BOARD_LED_B)
+    {
+      ledcfg = GPIO_LED_B;
+    }
+  else
+    {
+      return;
+    }
+
+  s32k1xx_gpiowrite(ledcfg, !ledon); /* High illuminates */
+}
+
+/****************************************************************************
+ * Name: board_userled_all
+ ****************************************************************************/
+
+void board_userled_all(uint32_t ledset)
+{
+  /* Low illuminates */
+
+  s32k1xx_gpiowrite(GPIO_LED_R, (ledset & BOARD_LED_R_BIT) == 0);
+  s32k1xx_gpiowrite(GPIO_LED_G, (ledset & BOARD_LED_G_BIT) == 0);
+  s32k1xx_gpiowrite(GPIO_LED_B, (ledset & BOARD_LED_B_BIT) == 0);
+}
+
+/****************************************************************************
+ * Name: board_userled_checkall
+ ****************************************************************************/
+
+void board_userled_checkall(uint32_t *ledset)
+{
+  // check if not pointer
+  if(ledset)
+  {
+    /* Low illuminates */
+
+    // clear the LED bits
+    *ledset &= ~(BOARD_LED_R_BIT + BOARD_LED_G_BIT + BOARD_LED_B_BIT);
+
+    // set the bit led bit to 1 if the LED is on
+    *ledset |= (((!s32k1xx_gpioread(GPIO_LED_R)) & 1) << BOARD_LED_R);// & BOARD_LED_R_BIT;
+    *ledset |= (((!s32k1xx_gpioread(GPIO_LED_G)) & 1) << BOARD_LED_G);// & BOARD_LED_G_BIT;
+    *ledset |= (((!s32k1xx_gpioread(GPIO_LED_B)) & 1) << BOARD_LED_B);// & BOARD_LED_B_BIT;
+  }
+}
+
+#endif /* !CONFIG_ARCH_LEDS */
diff --git a/net/can/can_callback.c b/net/can/can_callback.c
index f8f0fae1d2..4a623e9fe4 100644
--- a/net/can/can_callback.c
+++ b/net/can/can_callback.c
@@ -137,7 +137,7 @@ uint16_t can_callback(FAR struct net_driver_s *dev,
 
       /* Try to lock the network when successfull send data to the listener */
 
-      if (net_trylock() == OK)
+      if (up_interrupt_context() == false && net_trylock() == OK)
         {
           flags = devif_conn_event(dev, conn, flags, conn->list);
           net_unlock();
@@ -234,7 +234,9 @@ uint16_t can_datahandler(FAR struct can_conn_s *conn, FAR uint8_t *buffer,
    * available.
    */
 
-  can_readahead_signal(conn);
+  if(up_interrupt_context() == false) {
+      can_readahead_signal(conn);
+  }
 #endif
   return buflen;
 }
diff --git a/net/can/can_setsockopt.c b/net/can/can_setsockopt.c
index b5c4576e87..3cc82a154b 100644
--- a/net/can/can_setsockopt.c
+++ b/net/can/can_setsockopt.c
@@ -76,7 +76,7 @@ int can_setsockopt(FAR struct socket *psock, int option,
   int ret = OK;
   int count = 0;
 
-  DEBUGASSERT(psock != NULL && value != NULL && psock->s_conn != NULL);
+  DEBUGASSERT(psock != NULL && (value_len == 0 || value != NULL) && psock->s_conn != NULL);
   conn = (FAR struct can_conn_s *)psock->s_conn;
 
   if (psock->s_type != SOCK_RAW)
diff --git a/net/devif/devif_poll.c b/net/devif/devif_poll.c
index ffffed463e..079ff85d39 100644
--- a/net/devif/devif_poll.c
+++ b/net/devif/devif_poll.c
@@ -260,11 +260,14 @@ static int devif_poll_can_connections(FAR struct net_driver_s *dev,
     {
       /* Perform the packet TX poll */
 
-      can_poll(dev, can_conn);
+      if(dev == can_conn->dev)
+        {
+          can_poll(dev, can_conn);
 
-      /* Call back into the driver */
+          /* Call back into the driver */
 
-      bstop = callback(dev);
+          bstop = callback(dev);
+        }
     }
 
   return bstop;
diff --git a/net/utils/net_lock.c b/net/utils/net_lock.c
index 645a5cc9be..478ae1d1bd 100644
--- a/net/utils/net_lock.c
+++ b/net/utils/net_lock.c
@@ -247,9 +247,7 @@ int net_lock(void)
 
 int net_trylock(void)
 {
-#ifdef CONFIG_SMP
   irqstate_t flags = enter_critical_section();
-#endif
   pid_t me = getpid();
   int ret = OK;
 
@@ -263,7 +261,23 @@ int net_trylock(void)
     }
   else
     {
-      ret = nxsem_trywait(&g_netlock);
+      if (g_netlock.semcount > 0)
+        {
+          /* Take a semaphore count.  Note that we cannot do this in
+           * in the orthodox way by calling nxsem_wait() or nxsem_trywait()
+           * because this function may be called from an interrupt
+           * handler. Fortunately we know that semephore is free thus we take it.
+           */
+
+          g_netlock.semcount--;
+          ret = OK;
+        }
+      else
+        {
+          /* Semaphore is not available */
+          ret = -EAGAIN;
+        }
+
       if (ret >= 0)
         {
           /* Now this thread holds the semaphore */
@@ -273,9 +287,7 @@ int net_trylock(void)
         }
     }
 
-#ifdef CONFIG_SMP
   leave_critical_section(flags);
-#endif
   return ret;
 }
 
diff --git a/sched/Makefile b/sched/Makefile
index 2ac0743056..e83223d8de 100644
--- a/sched/Makefile
+++ b/sched/Makefile
@@ -32,6 +32,7 @@ include pthread/Make.defs
 include sched/Make.defs
 include semaphore/Make.defs
 include signal/Make.defs
+include systemview/Make.defs
 include task/Make.defs
 include timer/Make.defs
 include wdog/Make.defs
diff --git a/sched/init/nx_start.c b/sched/init/nx_start.c
index 927f8ff954..91758be875 100644
--- a/sched/init/nx_start.c
+++ b/sched/init/nx_start.c
@@ -76,6 +76,8 @@
 #include "group/group.h"
 #include "init/init.h"
 
+#include "systemview/SEGGER_SYSVIEW_NuttX.h"
+
 /****************************************************************************
  * Pre-processor Definitions
  ****************************************************************************/
@@ -803,6 +805,8 @@ void nx_start(void)
 
 #endif /* CONFIG_SMP */
 
+  TRACE_INIT();
+
   /* Bring Up the System ****************************************************/
 
   /* The OS is fully initialized and we are beginning multi-tasking */
diff --git a/sched/irq/irq_dispatch.c b/sched/irq/irq_dispatch.c
index 49be385613..03ae04ca62 100644
--- a/sched/irq/irq_dispatch.c
+++ b/sched/irq/irq_dispatch.c
@@ -49,6 +49,9 @@
 #include "clock/clock.h"
 #include "sched/sched.h"
 
+
+#include "systemview/SEGGER_SYSVIEW_NuttX.h"
+
 /****************************************************************************
  * Pre-processor Definitions
  ****************************************************************************/
@@ -139,6 +142,9 @@ void irq_dispatch(int irq, FAR void *context)
   FAR void *arg = NULL;
   unsigned int ndx = irq;
 
+
+  TRACE_ISR_ENTER();
+
 #if NR_IRQS > 0
   if ((unsigned)irq < NR_IRQS)
     {
@@ -183,6 +189,13 @@ void irq_dispatch(int irq, FAR void *context)
   CALL_VECTOR(ndx, vector, irq, context, arg);
   UNUSED(ndx);
 
+  if (g_running_tasks[this_cpu()] != this_task()) {
+    TRACE_ISR_EXIT_TO_SCHEDULER();
+    TRACE_TASK_START(this_task()->pid);
+  } else {
+    TRACE_ISR_EXIT();
+  }
+
 #ifdef CONFIG_SCHED_INSTRUMENTATION_IRQHANDLER
   /* Notify that we are leaving from the interrupt handler */
 
diff --git a/sched/pthread/pthread_create.c b/sched/pthread/pthread_create.c
index 1b836f50a0..3d89995cc1 100644
--- a/sched/pthread/pthread_create.c
+++ b/sched/pthread/pthread_create.c
@@ -45,6 +45,8 @@
 #include "clock/clock.h"
 #include "pthread/pthread.h"
 
+#include "systemview/SEGGER_SYSVIEW_NuttX.h"
+
 /****************************************************************************
  * Public Data
  ****************************************************************************/
@@ -235,6 +237,8 @@ int pthread_create(FAR pthread_t *thread, FAR const pthread_attr_t *attr,
   int ret;
   bool group_joined = false;
 
+  TRACE_API_PTHREAD_CREATE(thread, attr, start_routine, arg);
+
   /* If attributes were not supplied, use the default attributes */
 
   if (!attr)
@@ -592,6 +596,10 @@ int pthread_create(FAR pthread_t *thread, FAR const pthread_attr_t *attr,
       goto errout_with_join;
     }
 
+  TRACE_TASK_CREATED(pid, ptcb->cmn.name, ptcb->cmn.base_priority, ptcb->cmn.adj_stack_ptr, ptcb->cmn.adj_stack_size);
+
+  TRACE_API_PTHREAD_CREATE_RETURN(ret);
+
   return ret;
 
 errout_with_join:
@@ -608,5 +616,8 @@ errout_with_tcb:
     }
 
   nxsched_release_tcb((FAR struct tcb_s *)ptcb, TCB_FLAG_TTYPE_PTHREAD);
+
+  TRACE_API_PTHREAD_CREATE_RETURN(errcode);
+
   return errcode;
 }
diff --git a/sched/pthread/pthread_exit.c b/sched/pthread/pthread_exit.c
index b77f2c8a5c..55955dea20 100644
--- a/sched/pthread/pthread_exit.c
+++ b/sched/pthread/pthread_exit.c
@@ -55,6 +55,8 @@
 #include "task/task.h"
 #include "pthread/pthread.h"
 
+#include "systemview/SEGGER_SYSVIEW_NuttX.h"
+
 /****************************************************************************
  * Public Functions
  ****************************************************************************/
@@ -136,6 +138,8 @@ void pthread_exit(FAR void *exit_value)
 
   nxtask_exithook(tcb, EXIT_SUCCESS, false);
 
+  TRACE_TASK_TERMINATE(tcb->pid);
+
   /* Then just exit, retaining all file descriptors and without
    * calling atexit() functions.
    */
diff --git a/sched/sched/sched_addblocked.c b/sched/sched/sched_addblocked.c
index 3965f61193..b3ed65d6c2 100644
--- a/sched/sched/sched_addblocked.c
+++ b/sched/sched/sched_addblocked.c
@@ -44,6 +44,8 @@
 
 #include "sched/sched.h"
 
+#include "systemview/SEGGER_SYSVIEW_NuttX.h"
+
 /****************************************************************************
  * Public Functions
  ****************************************************************************/
@@ -77,6 +79,14 @@ void nxsched_add_blocked(FAR struct tcb_s *btcb, tstate_t task_state)
   DEBUGASSERT(task_state >= FIRST_BLOCKED_STATE &&
               task_state <= LAST_BLOCKED_STATE);
 
+#ifdef CONFIG_SMP
+  /* Lock the tasklists before accessing */
+
+  irqstate_t lock = nxsched_lock_tasklist();
+#endif
+
+  TRACE_TASK_BLOCK(btcb->pid, task_state);
+
   /* Add the TCB to the blocked task list associated with this state. */
 
   tasklist = TLIST_BLOCKED(task_state);
@@ -96,6 +106,12 @@ void nxsched_add_blocked(FAR struct tcb_s *btcb, tstate_t task_state)
       dq_addlast((FAR dq_entry_t *)btcb, tasklist);
     }
 
+#ifdef CONFIG_SMP
+  /* Unlock the tasklists */
+
+  nxsched_unlock_tasklist(lock);
+#endif
+
   /* Make sure the TCB's state corresponds to the list */
 
   btcb->task_state = task_state;
diff --git a/sched/sched/sched_addreadytorun.c b/sched/sched/sched_addreadytorun.c
index 0d610b5315..e16e70fefd 100644
--- a/sched/sched/sched_addreadytorun.c
+++ b/sched/sched/sched_addreadytorun.c
@@ -47,6 +47,8 @@
 #include "irq/irq.h"
 #include "sched/sched.h"
 
+#include "systemview/SEGGER_SYSVIEW_NuttX.h"
+
 /****************************************************************************
  * Public Functions
  ****************************************************************************/
@@ -85,6 +87,8 @@ bool nxsched_add_readytorun(FAR struct tcb_s *btcb)
   FAR struct tcb_s *rtcb = this_task();
   bool ret;
 
+  TRACE_TASK_READY(btcb->pid);
+
   /* Check if pre-emption is disabled for the current running task and if
    * the new ready-to-run task would cause the current running task to be
    * pre-empted.  NOTE that IRQs disabled implies that pre-emption is
diff --git a/sched/sched/sched_resumescheduler.c b/sched/sched/sched_resumescheduler.c
index fc9fe26568..e377ec1696 100644
--- a/sched/sched/sched_resumescheduler.c
+++ b/sched/sched/sched_resumescheduler.c
@@ -48,6 +48,8 @@
 #include "irq/irq.h"
 #include "sched/sched.h"
 
+#include "systemview/SEGGER_SYSVIEW_NuttX.h"
+
 #if CONFIG_RR_INTERVAL > 0 || defined(CONFIG_SCHED_RESUMESCHEDULER)
 
 /****************************************************************************
diff --git a/sched/semaphore/sem_trywait.c b/sched/semaphore/sem_trywait.c
index 90ffcddabf..61012185f3 100644
--- a/sched/semaphore/sem_trywait.c
+++ b/sched/semaphore/sem_trywait.c
@@ -85,8 +85,12 @@ int nxsem_trywait(FAR sem_t *sem)
 
   /* This API should not be called from interrupt handlers */
 
-  DEBUGASSERT(sem != NULL && up_interrupt_context() == false);
+  DEBUGASSERT(sem != NULL);
+  
+  /* DEBUGASSERT(sem != NULL && up_interrupt_context() == false); */
 
+  /* To be discussed this call is non-blocking thus can be called from a ISR */
+ 
   if (sem != NULL)
     {
       /* The following operations must be performed with interrupts disabled
diff --git a/sched/systemview/Global.h b/sched/systemview/Global.h
new file mode 100644
index 0000000000..6e978bc92b
--- /dev/null
+++ b/sched/systemview/Global.h
@@ -0,0 +1,113 @@
+/*********************************************************************
+*                    SEGGER Microcontroller GmbH                     *
+*                        The Embedded Experts                        *
+**********************************************************************
+*                                                                    *
+*            (c) 1995 - 2019 SEGGER Microcontroller GmbH             *
+*                                                                    *
+*       www.segger.com     Support: support@segger.com               *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SEGGER SystemView * Real-time application analysis           *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+* All rights reserved.                                               *
+*                                                                    *
+* SEGGER strongly recommends to not make any changes                 *
+* to or modify the source code of this software in order to stay     *
+* compatible with the SystemView and RTT protocol, and J-Link.       *
+*                                                                    *
+* Redistribution and use in source and binary forms, with or         *
+* without modification, are permitted provided that the following    *
+* condition is met:                                                  *
+*                                                                    *
+* o Redistributions of source code must retain the above copyright   *
+*   notice, this condition and the following disclaimer.             *
+*                                                                    *
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
+* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
+* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
+* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
+* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
+* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
+* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
+* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
+* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
+* DAMAGE.                                                            *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SystemView version: V3.12                                    *
+*                                                                    *
+**********************************************************************
+----------------------------------------------------------------------
+File    : Global.h
+Purpose : Global types
+          In case your application already has a Global.h, you should
+          merge the files. In order to use Segger code, the types
+          U8, U16, U32, I8, I16, I32 need to be defined in Global.h;
+          additional definitions do not hurt.
+Revision: $Rev: 12501 $
+---------------------------END-OF-HEADER------------------------------
+*/
+
+#ifndef GLOBAL_H            // Guard against multiple inclusion
+#define GLOBAL_H
+
+#define U8    unsigned char
+#define I8    signed char
+#define U16   unsigned short
+#define I16   signed short
+#ifdef __x86_64__
+#define U32   unsigned
+#define I32   int
+#else
+#define U32   unsigned long
+#define I32   signed long
+#endif
+
+//
+// CC_NO_LONG_SUPPORT can be defined to compile test
+// without long support for compilers that do not
+// support C99 and its long type.
+//
+#ifdef CC_NO_LONG_SUPPORT
+  #define PTR_ADDR  U32
+#else  // Supports long type.
+#if defined(_WIN32) && !defined(__clang__) && !defined(__MINGW32__)
+  //
+  // Microsoft VC6 compiler related
+  //
+  #define U64   unsigned __int64
+  #define U128  unsigned __int128
+  #define I64   __int64
+  #define I128  __int128
+  #if _MSC_VER <= 1200
+    #define U64_C(x) x##UI64
+  #else
+    #define U64_C(x) x##ULL
+  #endif
+#else
+  //
+  // C99 compliant compiler
+  //
+  #define U64   unsigned long long
+  #define I64   signed long long
+  #define U64_C(x) x##ULL
+#endif
+
+#if (defined(_WIN64) || defined(__LP64__))  // 64-bit symbols used by Visual Studio and GCC, maybe others as well.
+  #define PTR_ADDR  U64
+#else
+  #define PTR_ADDR  U32
+#endif
+#endif  // Supports long type.
+
+#endif                      // Avoid multiple inclusion
+
+/*************************** End of file ****************************/
diff --git a/sched/systemview/Kconfig b/sched/systemview/Kconfig
new file mode 100644
index 0000000000..7d22459232
--- /dev/null
+++ b/sched/systemview/Kconfig
@@ -0,0 +1,66 @@
+#
+# For a description of the syntax of this configuration file,
+# see the file kconfig-language.txt in the NuttX tools repository.
+#
+
+menuconfig SYSTEMVIEW_ENABLE
+	bool "Enable SystemView Instrumentation"
+	default n
+    ---help---
+        Enable instrumentation of the scheduler using SEGGER SystemView.
+
+if SYSTEMVIEW_ENABLE
+config SYSTEMVIEW_APP_NAME
+    string "Application Name"
+    default "NuttX start project"
+config SYSTEMVIEW_DEVICE_NAME
+    string "Device Name"
+    default "Cortex-M3/M4/M7"
+config SYSTEMVIEW_CPU_FREQ
+    int "CPU Frequency [Hz]"
+    default 168000000
+config SYSTEMVIEW_TIMESTAMP_FREQ
+    int "Timestamp Frequency [Hz]"
+    default 168000000
+config SYSTEMVIEW_RES_ID_BASE
+    hex "Resource ID Base"
+    default 0x00000000
+config SYSTEMVIEW_RES_ID_SHIFT
+    int "Resource ID Shift"
+    default 0
+config SYSTEMVIEW_START_ON_INIT
+    bool "Start Recording on Init"
+    default n
+config SYSTEMVIEW_SYSDESC_0
+    string "System Description 0"
+    default "I#11=SVC,I#15=SysTick"
+config SYSTEMVIEW_SYSDESC_1
+    string "System Description 1"
+config SYSTEMVIEW_SYSDESC_2
+    string "System Description 2"
+config SYSTEMVIEW_RECORD_API
+    bool "Record APIs"
+    default y
+config SYSTEMVIEW_RECORD_ISR
+    bool "Record Interrupts"
+    default y
+config SYSTEMVIEW_BUFFER_SIZE
+    int "SystemView Buffer Size"
+    default 8192
+config SYSTEMVIEW_RTT_CHANNEL
+    int "SystemView RTT Channel"
+    default 1
+config SYSTEMVIEW_USE_STATIC_BUFFER
+    bool "Use static event buffer"
+    default y
+config SYSTEMVIEW_POST_MORTEM_MODE
+    bool "Enable Post-Mortem Mode"
+    default n
+config SYSTEMVIEW_MAX_NOF_TASKS
+    int "Maximum Number of Tasks"
+    default 16
+    ---help---
+        Maximum number of Tasks to be recorded by Systemview.
+        If more tasks are created, their information is not added to the list, i.e. not recorded.
+        
+endif # SYSTEMVIEW_ENABLE
diff --git a/sched/systemview/Make.defs b/sched/systemview/Make.defs
new file mode 100644
index 0000000000..2ab5602b29
--- /dev/null
+++ b/sched/systemview/Make.defs
@@ -0,0 +1,47 @@
+############################################################################
+# sched/systemview/Make.defs
+#
+#   Copyright (C) 2014, 2018 Gregory Nutt. All rights reserved.
+#   Author: Gregory Nutt <gnutt@nuttx.org>
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in
+#    the documentation and/or other materials provided with the
+#    distribution.
+# 3. Neither the name NuttX nor the names of its contributors may be
+#    used to endorse or promote products derived from this software
+#    without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+# OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+# AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+############################################################################
+
+ifeq ($(CONFIG_SYSTEMVIEW_ENABLE),y)
+
+ASRCS += SEGGER_RTT_ASM_ARMv7M.S
+
+CSRCS += SEGGER_RTT.c SEGGER_RTT_printf.c SEGGER_SYSVIEW.c SEGGER_SYSVIEW_Config_NuttX.c SEGGER_SYSVIEW_NuttX.c
+
+endif
+
+# Include systemview build support
+
+DEPPATH += --dep-path systemview
+VPATH += :systemview
diff --git a/sched/systemview/Makefile b/sched/systemview/Makefile
new file mode 100644
index 0000000000..95cb4439a4
--- /dev/null
+++ b/sched/systemview/Makefile
@@ -0,0 +1,76 @@
+############################################################################
+# systemview/Makefile
+##
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in
+#    the documentation and/or other materials provided with the
+#    distribution.
+# 3. Neither the name NuttX nor the names of its contributors may be
+#    used to endorse or promote products derived from this software
+#    without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+# OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+# AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+############################################################################
+
+-include $(TOPDIR)/Make.defs
+
+ASRCS = SEGGER_RTT_ASM_ARMv7M.S
+AOBJS = $(ASRCS:.S=$(OBJEXT))
+
+CSRCS = SEGGER_RTT.c SEGGER_RTT_printf.c SEGGER_SYSVIEW.c SEGGER_SYSVIEW_Config_NuttX.c SEGGER_SYSVIEW_NuttX.c
+
+DEPPATH = --dep-path .
+VPATH = .
+
+COBJS = $(CSRCS:.c=$(OBJEXT))
+
+SRCS = $(ASRCS) $(CSRCS)
+OBJS = $(AOBJS) $(COBJS)
+
+BIN = libsystemview$(LIBEXT)
+
+all: $(BIN)
+.PHONY: depend clean distclean
+
+$(AOBJS): %$(OBJEXT): %.S
+	$(call ASSEMBLE, $<, $@)
+
+$(COBJS): %$(OBJEXT): %.c
+	$(call COMPILE, $<, $@)
+
+$(BIN):	$(OBJS)
+	$(call ARCHIVE, $@, $(OBJS))
+
+.depend: Makefile $(SRCS)
+	$(Q) $(MKDEP) $(DEPPATH) "$(CC)" -- $(CFLAGS) -- $(SRCS) >Make.dep
+	$(Q) touch $@
+
+depend: .depend
+
+clean:
+	$(call DELFILE, $(BIN))
+	$(call CLEAN)
+
+distclean: clean
+	$(call DELFILE, Make.dep)
+	$(call DELFILE, .depend)
+
+-include Make.dep
diff --git a/sched/systemview/SEGGER.h b/sched/systemview/SEGGER.h
new file mode 100644
index 0000000000..a2b43065fd
--- /dev/null
+++ b/sched/systemview/SEGGER.h
@@ -0,0 +1,248 @@
+/*********************************************************************
+*                    SEGGER Microcontroller GmbH                     *
+*                        The Embedded Experts                        *
+**********************************************************************
+*                                                                    *
+*            (c) 1995 - 2019 SEGGER Microcontroller GmbH             *
+*                                                                    *
+*       www.segger.com     Support: support@segger.com               *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SEGGER SystemView * Real-time application analysis           *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+* All rights reserved.                                               *
+*                                                                    *
+* SEGGER strongly recommends to not make any changes                 *
+* to or modify the source code of this software in order to stay     *
+* compatible with the SystemView and RTT protocol, and J-Link.       *
+*                                                                    *
+* Redistribution and use in source and binary forms, with or         *
+* without modification, are permitted provided that the following    *
+* condition is met:                                                  *
+*                                                                    *
+* o Redistributions of source code must retain the above copyright   *
+*   notice, this condition and the following disclaimer.             *
+*                                                                    *
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
+* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
+* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
+* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
+* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
+* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
+* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
+* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
+* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
+* DAMAGE.                                                            *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SystemView version: V3.12                                    *
+*                                                                    *
+**********************************************************************
+----------------------------------------------------------------------
+File    : SEGGER.h
+Purpose : Global types etc & general purpose utility functions
+Revision: $Rev: 18102 $
+---------------------------END-OF-HEADER------------------------------
+*/
+
+#ifndef SEGGER_H            // Guard against multiple inclusion
+#define SEGGER_H
+
+#include <stdarg.h>         // For va_list.
+#include "Global.h"         // Type definitions: U8, U16, U32, I8, I16, I32
+
+#if defined(__cplusplus)
+extern "C" {     /* Make sure we have C-declarations in C++ programs */
+#endif
+
+/*********************************************************************
+*
+*       Keywords/specifiers
+*
+**********************************************************************
+*/
+
+#ifndef INLINE
+  #if (defined(__ICCARM__) || defined(__RX) || defined(__ICCRX__))
+    //
+    // Other known compilers.
+    //
+    #define INLINE  inline
+  #else
+    #if (defined(_WIN32) && !defined(__clang__))
+      //
+      // Microsoft VC6 and newer.
+      // Force inlining without cost checking.
+      //
+      #define INLINE  __forceinline
+    #elif defined(__GNUC__) || defined(__clang__)
+      //
+      // Force inlining with GCC + clang
+      //
+      #define INLINE inline __attribute__((always_inline))
+    #elif (defined(__CC_ARM))
+      //
+      // Force inlining with ARMCC (Keil)
+      //
+      #define INLINE  __inline
+    #else
+      //
+      // Unknown compilers.
+      //
+      #define INLINE
+    #endif
+  #endif
+#endif
+
+/*********************************************************************
+*
+*       Function-like macros
+*
+**********************************************************************
+*/
+
+#define SEGGER_COUNTOF(a)          (sizeof((a))/sizeof((a)[0]))
+#define SEGGER_MIN(a,b)            (((a) < (b)) ? (a) : (b))
+#define SEGGER_MAX(a,b)            (((a) > (b)) ? (a) : (b))
+
+#ifndef   SEGGER_USE_PARA                   // Some compiler complain about unused parameters.
+  #define SEGGER_USE_PARA(Para) (void)Para  // This works for most compilers.
+#endif
+
+#define SEGGER_ADDR2PTR(Type, Addr)  (/*lint -e(923) -e(9078)*/((Type*)((PTR_ADDR)(Addr))))    // Allow cast from address to pointer.
+#define SEGGER_PTR2ADDR(p)           (/*lint -e(923) -e(9078)*/((PTR_ADDR)(p)))                // Allow cast from pointer to address.
+#define SEGGER_PTR2PTR(Type, p)      (/*lint -e(740) -e(826) -e(9079) -e(9087)*/((Type*)(p)))  // Allow cast from one pointer type to another (ignore different size).
+#define SEGGER_PTR_DISTANCE(p0, p1)  (SEGGER_PTR2ADDR(p0) - SEGGER_PTR2ADDR(p1))
+
+/*********************************************************************
+*
+*       Defines
+*
+**********************************************************************
+*/
+
+#define SEGGER_PRINTF_FLAG_ADJLEFT    (1 << 0)
+#define SEGGER_PRINTF_FLAG_SIGNFORCE  (1 << 1)
+#define SEGGER_PRINTF_FLAG_SIGNSPACE  (1 << 2)
+#define SEGGER_PRINTF_FLAG_PRECEED    (1 << 3)
+#define SEGGER_PRINTF_FLAG_ZEROPAD    (1 << 4)
+#define SEGGER_PRINTF_FLAG_NEGATIVE   (1 << 5)
+
+/*********************************************************************
+*
+*       Types
+*
+**********************************************************************
+*/
+
+typedef struct {
+  char* pBuffer;
+  int   BufferSize;
+  int   Cnt;
+} SEGGER_BUFFER_DESC;
+
+typedef struct {
+  unsigned int CacheLineSize;                             // 0: No Cache. Most Systems such as ARM9 use a 32 bytes cache line size.
+  void (*pfDMB)       (void);                             // Optional DMB function for Data Memory Barrier to make sure all memory operations are completed.
+  void (*pfClean)     (void *p, unsigned long NumBytes);  // Optional clean function for cached memory.
+  void (*pfInvalidate)(void *p, unsigned long NumBytes);  // Optional invalidate function for cached memory.
+} SEGGER_CACHE_CONFIG;
+
+typedef struct SEGGER_SNPRINTF_CONTEXT_struct SEGGER_SNPRINTF_CONTEXT;
+
+struct SEGGER_SNPRINTF_CONTEXT_struct {
+  void*               pContext;                       // Application specific context.
+  SEGGER_BUFFER_DESC* pBufferDesc;                    // Buffer descriptor to use for output.
+  void (*pfFlush)(SEGGER_SNPRINTF_CONTEXT* pContext); // Callback executed once the buffer is full. Callback decides if the buffer gets cleared to store more or not.
+};
+
+typedef struct {
+  void (*pfStoreChar)       (SEGGER_BUFFER_DESC* pBufferDesc, SEGGER_SNPRINTF_CONTEXT* pContext, char c);
+  int  (*pfPrintUnsigned)   (SEGGER_BUFFER_DESC* pBufferDesc, SEGGER_SNPRINTF_CONTEXT* pContext, U32 v, unsigned Base, char Flags, int Width, int Precision);
+  int  (*pfPrintInt)        (SEGGER_BUFFER_DESC* pBufferDesc, SEGGER_SNPRINTF_CONTEXT* pContext, I32 v, unsigned Base, char Flags, int Width, int Precision);
+} SEGGER_PRINTF_API;
+
+typedef void (*SEGGER_pFormatter)(SEGGER_BUFFER_DESC* pBufferDesc, SEGGER_SNPRINTF_CONTEXT* pContext, const SEGGER_PRINTF_API* pApi, va_list* pParamList, char Lead, int Width, int Precision);
+
+typedef struct SEGGER_PRINTF_FORMATTER {
+  struct SEGGER_PRINTF_FORMATTER* pNext;              // Pointer to next formatter.
+  SEGGER_pFormatter               pfFormatter;        // Formatter function.
+  char                            Specifier;          // Format specifier.
+} SEGGER_PRINTF_FORMATTER;
+
+typedef struct {
+  U32 (*pfGetHPTimestamp)(void);          // Mandatory, pfGetHPTimestamp
+  int (*pfGetUID)        (U8 abUID[16]);  // Optional,  pfGetUID
+} SEGGER_BSP_API;
+
+/*********************************************************************
+*
+*       Utility functions
+*
+**********************************************************************
+*/
+
+//
+// Memory operations.
+//
+void SEGGER_ARM_memcpy(void* pDest, const void* pSrc, int NumBytes);
+void SEGGER_memcpy    (void* pDest, const void* pSrc, unsigned NumBytes);
+void SEGGER_memxor    (void* pDest, const void* pSrc, unsigned NumBytes);
+
+//
+// String functions.
+//
+int      SEGGER_atoi       (const char* s);
+int      SEGGER_isalnum    (int c);
+int      SEGGER_isalpha    (int c);
+unsigned SEGGER_strlen     (const char* s);
+int      SEGGER_tolower    (int c);
+int      SEGGER_strcasecmp (const char* sText1, const char* sText2);
+int      SEGGER_strncasecmp(const char *sText1, const char *sText2, unsigned Count);
+
+//
+// Buffer/printf related.
+//
+void SEGGER_StoreChar    (SEGGER_BUFFER_DESC* pBufferDesc, char c);
+void SEGGER_PrintUnsigned(SEGGER_BUFFER_DESC* pBufferDesc, U32 v, unsigned Base, int Precision);
+void SEGGER_PrintInt     (SEGGER_BUFFER_DESC* pBufferDesc, I32 v, unsigned Base, int Precision);
+int  SEGGER_snprintf     (char* pBuffer, int BufferSize, const char* sFormat, ...);
+int  SEGGER_vsnprintf    (char* pBuffer, int BufferSize, const char* sFormat, va_list ParamList);
+int  SEGGER_vsnprintfEx  (SEGGER_SNPRINTF_CONTEXT* pContext, const char* sFormat, va_list ParamList);
+
+int  SEGGER_PRINTF_AddFormatter       (SEGGER_PRINTF_FORMATTER* pFormatter, SEGGER_pFormatter pfFormatter, char c);
+void SEGGER_PRINTF_AddDoubleFormatter (void);
+void SEGGER_PRINTF_AddIPFormatter     (void);
+void SEGGER_PRINTF_AddBLUEFormatter   (void);
+void SEGGER_PRINTF_AddCONNECTFormatter(void);
+void SEGGER_PRINTF_AddSSLFormatter    (void);
+void SEGGER_PRINTF_AddSSHFormatter    (void);
+void SEGGER_PRINTF_AddHTMLFormatter   (void);
+
+//
+// BSP abstraction API.
+//
+int  SEGGER_BSP_GetUID  (U8 abUID[16]);
+int  SEGGER_BSP_GetUID32(U32* pUID);
+void SEGGER_BSP_SetAPI  (const SEGGER_BSP_API* pAPI);
+void SEGGER_BSP_SeedUID (void);
+
+//
+// Other API.
+//
+void SEGGER_VERSION_GetString(char acText[8], unsigned Version);
+
+#if defined(__cplusplus)
+}                /* Make sure we have C-declarations in C++ programs */
+#endif
+
+#endif                      // Avoid multiple inclusion
+
+/*************************** End of file ****************************/
diff --git a/sched/systemview/SEGGER_RTT.c b/sched/systemview/SEGGER_RTT.c
new file mode 100644
index 0000000000..b5a6eafc44
--- /dev/null
+++ b/sched/systemview/SEGGER_RTT.c
@@ -0,0 +1,2009 @@
+/*********************************************************************
+*                    SEGGER Microcontroller GmbH                     *
+*                        The Embedded Experts                        *
+**********************************************************************
+*                                                                    *
+*            (c) 1995 - 2019 SEGGER Microcontroller GmbH             *
+*                                                                    *
+*       www.segger.com     Support: support@segger.com               *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SEGGER SystemView * Real-time application analysis           *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+* All rights reserved.                                               *
+*                                                                    *
+* SEGGER strongly recommends to not make any changes                 *
+* to or modify the source code of this software in order to stay     *
+* compatible with the SystemView and RTT protocol, and J-Link.       *
+*                                                                    *
+* Redistribution and use in source and binary forms, with or         *
+* without modification, are permitted provided that the following    *
+* condition is met:                                                  *
+*                                                                    *
+* o Redistributions of source code must retain the above copyright   *
+*   notice, this condition and the following disclaimer.             *
+*                                                                    *
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
+* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
+* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
+* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
+* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
+* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
+* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
+* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
+* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
+* DAMAGE.                                                            *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SystemView version: V3.12                                    *
+*                                                                    *
+**********************************************************************
+---------------------------END-OF-HEADER------------------------------
+File    : SEGGER_RTT.c
+Purpose : Implementation of SEGGER real-time transfer (RTT) which
+          allows real-time communication on targets which support
+          debugger memory accesses while the CPU is running.
+Revision: $Rev: 17697 $
+
+Additional information:
+          Type "int" is assumed to be 32-bits in size
+          H->T    Host to target communication
+          T->H    Target to host communication
+
+          RTT channel 0 is always present and reserved for Terminal usage.
+          Name is fixed to "Terminal"
+
+          Effective buffer size: SizeOfBuffer - 1
+
+          WrOff == RdOff:       Buffer is empty
+          WrOff == (RdOff - 1): Buffer is full
+          WrOff >  RdOff:       Free space includes wrap-around
+          WrOff <  RdOff:       Used space includes wrap-around
+          (WrOff == (SizeOfBuffer - 1)) && (RdOff == 0):  
+                                Buffer full and wrap-around after next byte
+
+
+----------------------------------------------------------------------
+*/
+
+#include "SEGGER_RTT.h"
+
+#include <string.h>                 // for memcpy
+
+/*********************************************************************
+*
+*       Configuration, default values
+*
+**********************************************************************
+*/
+
+#ifndef   BUFFER_SIZE_UP
+  #define BUFFER_SIZE_UP                                  1024  // Size of the buffer for terminal output of target, up to host
+#endif
+
+#ifndef   BUFFER_SIZE_DOWN
+  #define BUFFER_SIZE_DOWN                                16    // Size of the buffer for terminal input to target from host (Usually keyboard input)
+#endif
+
+#ifndef   SEGGER_RTT_MAX_NUM_UP_BUFFERS
+  #define SEGGER_RTT_MAX_NUM_UP_BUFFERS                    2    // Number of up-buffers (T->H) available on this target
+#endif
+
+#ifndef   SEGGER_RTT_MAX_NUM_DOWN_BUFFERS
+  #define SEGGER_RTT_MAX_NUM_DOWN_BUFFERS                  2    // Number of down-buffers (H->T) available on this target
+#endif
+
+#ifndef SEGGER_RTT_BUFFER_SECTION
+  #if defined(SEGGER_RTT_SECTION)
+    #define SEGGER_RTT_BUFFER_SECTION SEGGER_RTT_SECTION
+  #endif
+#endif
+
+#ifndef   SEGGER_RTT_ALIGNMENT
+  #define SEGGER_RTT_ALIGNMENT                            0
+#endif
+
+#ifndef   SEGGER_RTT_BUFFER_ALIGNMENT
+  #define SEGGER_RTT_BUFFER_ALIGNMENT                     0
+#endif
+
+#ifndef   SEGGER_RTT_MODE_DEFAULT
+  #define SEGGER_RTT_MODE_DEFAULT                         SEGGER_RTT_MODE_NO_BLOCK_SKIP
+#endif
+
+#ifndef   SEGGER_RTT_LOCK
+  #define SEGGER_RTT_LOCK()
+#endif
+
+#ifndef   SEGGER_RTT_UNLOCK
+  #define SEGGER_RTT_UNLOCK()
+#endif
+
+#ifndef   STRLEN
+  #define STRLEN(a)                                       strlen((a))
+#endif
+
+#ifndef   STRCPY
+  #define STRCPY(pDest, pSrc, NumBytes)                   strcpy((pDest), (pSrc))
+#endif
+
+#ifndef   SEGGER_RTT_MEMCPY_USE_BYTELOOP
+  #define SEGGER_RTT_MEMCPY_USE_BYTELOOP                  0
+#endif
+
+#ifndef   SEGGER_RTT_MEMCPY
+  #ifdef  MEMCPY
+    #define SEGGER_RTT_MEMCPY(pDest, pSrc, NumBytes)      MEMCPY((pDest), (pSrc), (NumBytes))
+  #else
+    #define SEGGER_RTT_MEMCPY(pDest, pSrc, NumBytes)      memcpy((pDest), (pSrc), (NumBytes))
+  #endif
+#endif
+
+#ifndef   MIN
+  #define MIN(a, b)         (((a) < (b)) ? (a) : (b))
+#endif
+
+#ifndef   MAX
+  #define MAX(a, b)         (((a) > (b)) ? (a) : (b))
+#endif
+//
+// For some environments, NULL may not be defined until certain headers are included
+//
+#ifndef NULL
+  #define NULL 0
+#endif
+
+/*********************************************************************
+*
+*       Defines, fixed
+*
+**********************************************************************
+*/
+#if (defined __ICCARM__) || (defined __ICCRX__)
+  #define RTT_PRAGMA(P) _Pragma(#P)
+#endif
+
+#if SEGGER_RTT_ALIGNMENT || SEGGER_RTT_BUFFER_ALIGNMENT
+  #if (defined __GNUC__)
+    #define SEGGER_RTT_ALIGN(Var, Alignment) Var __attribute__ ((aligned (Alignment)))
+  #elif (defined __ICCARM__) || (defined __ICCRX__)
+    #define PRAGMA(A) _Pragma(#A)
+#define SEGGER_RTT_ALIGN(Var, Alignment) RTT_PRAGMA(data_alignment=Alignment) \
+                                  Var
+  #elif (defined __CC_ARM)
+    #define SEGGER_RTT_ALIGN(Var, Alignment) Var __attribute__ ((aligned (Alignment)))
+  #else
+    #error "Alignment not supported for this compiler."
+  #endif
+#else
+  #define SEGGER_RTT_ALIGN(Var, Alignment) Var
+#endif
+
+#if defined(SEGGER_RTT_SECTION) || defined (SEGGER_RTT_BUFFER_SECTION)
+  #if (defined __GNUC__)
+    #define SEGGER_RTT_PUT_SECTION(Var, Section) __attribute__ ((section (Section))) Var
+  #elif (defined __ICCARM__) || (defined __ICCRX__)
+#define SEGGER_RTT_PUT_SECTION(Var, Section) RTT_PRAGMA(location=Section) \
+                                        Var
+  #elif (defined __CC_ARM)
+    #define SEGGER_RTT_PUT_SECTION(Var, Section) __attribute__ ((section (Section), zero_init))  Var
+  #else
+    #error "Section placement not supported for this compiler."
+  #endif
+#else
+  #define SEGGER_RTT_PUT_SECTION(Var, Section) Var
+#endif
+
+
+#if SEGGER_RTT_ALIGNMENT
+  #define SEGGER_RTT_CB_ALIGN(Var)  SEGGER_RTT_ALIGN(Var, SEGGER_RTT_ALIGNMENT)
+#else
+  #define SEGGER_RTT_CB_ALIGN(Var)  Var
+#endif
+
+#if SEGGER_RTT_BUFFER_ALIGNMENT
+  #define SEGGER_RTT_BUFFER_ALIGN(Var)  SEGGER_RTT_ALIGN(Var, SEGGER_RTT_BUFFER_ALIGNMENT)
+#else
+  #define SEGGER_RTT_BUFFER_ALIGN(Var)  Var
+#endif
+
+
+#if defined(SEGGER_RTT_SECTION)
+  #define SEGGER_RTT_PUT_CB_SECTION(Var) SEGGER_RTT_PUT_SECTION(Var, SEGGER_RTT_SECTION)
+#else
+  #define SEGGER_RTT_PUT_CB_SECTION(Var) Var
+#endif
+
+#if defined(SEGGER_RTT_BUFFER_SECTION)
+  #define SEGGER_RTT_PUT_BUFFER_SECTION(Var) SEGGER_RTT_PUT_SECTION(Var, SEGGER_RTT_BUFFER_SECTION)
+#else
+  #define SEGGER_RTT_PUT_BUFFER_SECTION(Var) Var
+#endif
+
+/*********************************************************************
+*
+*       Static const data
+*
+**********************************************************************
+*/
+
+static unsigned char _aTerminalId[16] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
+
+/*********************************************************************
+*
+*       Static data
+*
+**********************************************************************
+*/
+//
+// RTT Control Block and allocate buffers for channel 0
+//
+SEGGER_RTT_PUT_CB_SECTION(SEGGER_RTT_CB_ALIGN(SEGGER_RTT_CB _SEGGER_RTT));
+
+SEGGER_RTT_PUT_BUFFER_SECTION(SEGGER_RTT_BUFFER_ALIGN(static char _acUpBuffer  [BUFFER_SIZE_UP]));
+SEGGER_RTT_PUT_BUFFER_SECTION(SEGGER_RTT_BUFFER_ALIGN(static char _acDownBuffer[BUFFER_SIZE_DOWN]));
+
+static unsigned char _ActiveTerminal;
+
+/*********************************************************************
+*
+*       Static functions
+*
+**********************************************************************
+*/
+
+/*********************************************************************
+*
+*       _DoInit()
+*
+*  Function description
+*    Initializes the control block an buffers.
+*    May only be called via INIT() to avoid overriding settings.
+*
+*/
+#define INIT()  do {                                            \
+                  if (_SEGGER_RTT.acID[0] == '\0') { _DoInit(); }  \
+                } while (0)
+static void _DoInit(void) {
+  SEGGER_RTT_CB* p;
+  //
+  // Initialize control block
+  //
+  p = &_SEGGER_RTT;
+  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
+  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
+  //
+  // Initialize up buffer 0
+  //
+  p->aUp[0].sName         = "Terminal";
+  p->aUp[0].pBuffer       = _acUpBuffer;
+  p->aUp[0].SizeOfBuffer  = sizeof(_acUpBuffer);
+  p->aUp[0].RdOff         = 0u;
+  p->aUp[0].WrOff         = 0u;
+  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
+  //
+  // Initialize down buffer 0
+  //
+  p->aDown[0].sName         = "Terminal";
+  p->aDown[0].pBuffer       = _acDownBuffer;
+  p->aDown[0].SizeOfBuffer  = sizeof(_acDownBuffer);
+  p->aDown[0].RdOff         = 0u;
+  p->aDown[0].WrOff         = 0u;
+  p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
+  //
+  // Finish initialization of the control block.
+  // Copy Id string in three steps to make sure "SEGGER RTT" is not found
+  // in initializer memory (usually flash) by J-Link
+  //
+  STRCPY(&p->acID[7], "RTT", 9);
+  STRCPY(&p->acID[0], "SEGGER", 7);
+  p->acID[6] = ' ';
+}
+
+/*********************************************************************
+*
+*       _WriteBlocking()
+*
+*  Function description
+*    Stores a specified number of characters in SEGGER RTT ring buffer
+*    and updates the associated write pointer which is periodically
+*    read by the host.
+*    The caller is responsible for managing the write chunk sizes as
+*    _WriteBlocking() will block until all data has been posted successfully.
+*
+*  Parameters
+*    pRing        Ring buffer to post to.
+*    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
+*    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
+*
+*  Return value
+*    >= 0 - Number of bytes written into buffer.
+*/
+static unsigned _WriteBlocking(SEGGER_RTT_BUFFER_UP* pRing, const char* pBuffer, unsigned NumBytes) {
+  unsigned NumBytesToWrite;
+  unsigned NumBytesWritten;
+  unsigned RdOff;
+  unsigned WrOff;
+#if SEGGER_RTT_MEMCPY_USE_BYTELOOP
+  char*    pDst;
+#endif
+  //
+  // Write data to buffer and handle wrap-around if necessary
+  //
+  NumBytesWritten = 0u;
+  WrOff = pRing->WrOff;
+  do {
+    RdOff = pRing->RdOff;                         // May be changed by host (debug probe) in the meantime
+    if (RdOff > WrOff) {
+      NumBytesToWrite = RdOff - WrOff - 1u;
+    } else {
+      NumBytesToWrite = pRing->SizeOfBuffer - (WrOff - RdOff + 1u);
+    }
+    NumBytesToWrite = MIN(NumBytesToWrite, (pRing->SizeOfBuffer - WrOff));      // Number of bytes that can be written until buffer wrap-around
+    NumBytesToWrite = MIN(NumBytesToWrite, NumBytes);
+#if SEGGER_RTT_MEMCPY_USE_BYTELOOP
+    pDst = pRing->pBuffer + WrOff;
+    NumBytesWritten += NumBytesToWrite;
+    NumBytes        -= NumBytesToWrite;
+    WrOff           += NumBytesToWrite;
+    while (NumBytesToWrite--) {
+      *pDst++ = *pBuffer++;
+    };
+#else
+    SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pBuffer, NumBytesToWrite);
+    NumBytesWritten += NumBytesToWrite;
+    pBuffer         += NumBytesToWrite;
+    NumBytes        -= NumBytesToWrite;
+    WrOff           += NumBytesToWrite;
+#endif
+    if (WrOff == pRing->SizeOfBuffer) {
+      WrOff = 0u;
+    }
+    pRing->WrOff = WrOff;
+  } while (NumBytes);
+  //
+  return NumBytesWritten;
+}
+
+/*********************************************************************
+*
+*       _WriteNoCheck()
+*
+*  Function description
+*    Stores a specified number of characters in SEGGER RTT ring buffer
+*    and updates the associated write pointer which is periodically
+*    read by the host.
+*    It is callers responsibility to make sure data actually fits in buffer.
+*
+*  Parameters
+*    pRing        Ring buffer to post to.
+*    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
+*    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
+*
+*  Notes
+*    (1) If there might not be enough space in the "Up"-buffer, call _WriteBlocking
+*/
+static void _WriteNoCheck(SEGGER_RTT_BUFFER_UP* pRing, const char* pData, unsigned NumBytes) {
+  unsigned NumBytesAtOnce;
+  unsigned WrOff;
+  unsigned Rem;
+#if SEGGER_RTT_MEMCPY_USE_BYTELOOP
+  char*    pDst;
+#endif
+
+  WrOff = pRing->WrOff;
+  Rem = pRing->SizeOfBuffer - WrOff;
+  if (Rem > NumBytes) {
+    //
+    // All data fits before wrap around
+    //
+#if SEGGER_RTT_MEMCPY_USE_BYTELOOP
+    pDst = pRing->pBuffer + WrOff;
+    WrOff += NumBytes;
+    while (NumBytes--) {
+      *pDst++ = *pData++;
+    };
+    pRing->WrOff = WrOff;
+#else
+    SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pData, NumBytes);
+    pRing->WrOff = WrOff + NumBytes;
+#endif
+  } else {
+    //
+    // We reach the end of the buffer, so need to wrap around
+    //
+#if SEGGER_RTT_MEMCPY_USE_BYTELOOP
+    pDst = pRing->pBuffer + WrOff;
+    NumBytesAtOnce = Rem;
+    while (NumBytesAtOnce--) {
+      *pDst++ = *pData++;
+    };
+    pDst = pRing->pBuffer;
+    NumBytesAtOnce = NumBytes - Rem;
+    while (NumBytesAtOnce--) {
+      *pDst++ = *pData++;
+    };
+    pRing->WrOff = NumBytes - Rem;
+#else
+    NumBytesAtOnce = Rem;
+    SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pData, NumBytesAtOnce);
+    NumBytesAtOnce = NumBytes - Rem;
+    SEGGER_RTT_MEMCPY(pRing->pBuffer, pData + Rem, NumBytesAtOnce);
+    pRing->WrOff = NumBytesAtOnce;
+#endif
+  }
+}
+
+/*********************************************************************
+*
+*       _PostTerminalSwitch()
+*
+*  Function description
+*    Switch terminal to the given terminal ID.  It is the caller's
+*    responsibility to ensure the terminal ID is correct and there is
+*    enough space in the buffer for this to complete successfully.
+*
+*  Parameters
+*    pRing        Ring buffer to post to.
+*    TerminalId   Terminal ID to switch to.
+*/
+static void _PostTerminalSwitch(SEGGER_RTT_BUFFER_UP* pRing, unsigned char TerminalId) {
+  unsigned char ac[2];
+
+  ac[0] = 0xFFu;
+  ac[1] = _aTerminalId[TerminalId];  // Caller made already sure that TerminalId does not exceed our terminal limit
+  _WriteBlocking(pRing, (const char*)ac, 2u);
+}
+
+/*********************************************************************
+*
+*       _GetAvailWriteSpace()
+*
+*  Function description
+*    Returns the number of bytes that can be written to the ring
+*    buffer without blocking.
+*
+*  Parameters
+*    pRing        Ring buffer to check.
+*
+*  Return value
+*    Number of bytes that are free in the buffer.
+*/
+static unsigned _GetAvailWriteSpace(SEGGER_RTT_BUFFER_UP* pRing) {
+  unsigned RdOff;
+  unsigned WrOff;
+  unsigned r;
+  //
+  // Avoid warnings regarding volatile access order.  It's not a problem
+  // in this case, but dampen compiler enthusiasm.
+  //
+  RdOff = pRing->RdOff;
+  WrOff = pRing->WrOff;
+  if (RdOff <= WrOff) {
+    r = pRing->SizeOfBuffer - 1u - WrOff + RdOff;
+  } else {
+    r = RdOff - WrOff - 1u;
+  }
+  return r;
+}
+
+/*********************************************************************
+*
+*       Public code
+*
+**********************************************************************
+*/
+/*********************************************************************
+*
+*       SEGGER_RTT_ReadUpBufferNoLock()
+*
+*  Function description
+*    Reads characters from SEGGER real-time-terminal control block
+*    which have been previously stored by the application.
+*    Do not lock against interrupts and multiple access.
+*    Used to do the same operation that J-Link does, to transfer 
+*    RTT data via other channels, such as TCP/IP or UART.
+*
+*  Parameters
+*    BufferIndex  Index of Up-buffer to be used.
+*    pBuffer      Pointer to buffer provided by target application, to copy characters from RTT-up-buffer to.
+*    BufferSize   Size of the target application buffer.
+*
+*  Return value
+*    Number of bytes that have been read.
+*
+*  Additional information
+*    This function must not be called when J-Link might also do RTT.
+*/
+unsigned SEGGER_RTT_ReadUpBufferNoLock(unsigned BufferIndex, void* pData, unsigned BufferSize) {
+  unsigned                NumBytesRem;
+  unsigned                NumBytesRead;
+  unsigned                RdOff;
+  unsigned                WrOff;
+  unsigned char*          pBuffer;
+  SEGGER_RTT_BUFFER_UP*   pRing;
+#if SEGGER_RTT_MEMCPY_USE_BYTELOOP
+  const char*             pSrc;
+#endif
+  //
+  INIT();
+  pRing = &_SEGGER_RTT.aUp[BufferIndex];
+  pBuffer = (unsigned char*)pData;
+  RdOff = pRing->RdOff;
+  WrOff = pRing->WrOff;
+  NumBytesRead = 0u;
+  //
+  // Read from current read position to wrap-around of buffer, first
+  //
+  if (RdOff > WrOff) {
+    NumBytesRem = pRing->SizeOfBuffer - RdOff;
+    NumBytesRem = MIN(NumBytesRem, BufferSize);
+#if SEGGER_RTT_MEMCPY_USE_BYTELOOP
+    pSrc = pRing->pBuffer + RdOff;
+    NumBytesRead += NumBytesRem;
+    BufferSize   -= NumBytesRem;
+    RdOff        += NumBytesRem;
+    while (NumBytesRem--) {
+      *pBuffer++ = *pSrc++;
+    };
+#else
+    SEGGER_RTT_MEMCPY(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
+    NumBytesRead += NumBytesRem;
+    pBuffer      += NumBytesRem;
+    BufferSize   -= NumBytesRem;
+    RdOff        += NumBytesRem;
+#endif
+    //
+    // Handle wrap-around of buffer
+    //
+    if (RdOff == pRing->SizeOfBuffer) {
+      RdOff = 0u;
+    }
+  }
+  //
+  // Read remaining items of buffer
+  //
+  NumBytesRem = WrOff - RdOff;
+  NumBytesRem = MIN(NumBytesRem, BufferSize);
+  if (NumBytesRem > 0u) {
+#if SEGGER_RTT_MEMCPY_USE_BYTELOOP
+    pSrc = pRing->pBuffer + RdOff;
+    NumBytesRead += NumBytesRem;
+    BufferSize   -= NumBytesRem;
+    RdOff        += NumBytesRem;
+    while (NumBytesRem--) {
+      *pBuffer++ = *pSrc++;
+    };
+#else
+    SEGGER_RTT_MEMCPY(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
+    NumBytesRead += NumBytesRem;
+    pBuffer      += NumBytesRem;
+    BufferSize   -= NumBytesRem;
+    RdOff        += NumBytesRem;
+#endif
+  }
+  //
+  // Update read offset of buffer
+  //
+  if (NumBytesRead) {
+    pRing->RdOff = RdOff;
+  }
+  //
+  return NumBytesRead;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_ReadNoLock()
+*
+*  Function description
+*    Reads characters from SEGGER real-time-terminal control block
+*    which have been previously stored by the host.
+*    Do not lock against interrupts and multiple access.
+*
+*  Parameters
+*    BufferIndex  Index of Down-buffer to be used (e.g. 0 for "Terminal").
+*    pBuffer      Pointer to buffer provided by target application, to copy characters from RTT-down-buffer to.
+*    BufferSize   Size of the target application buffer.
+*
+*  Return value
+*    Number of bytes that have been read.
+*/
+unsigned SEGGER_RTT_ReadNoLock(unsigned BufferIndex, void* pData, unsigned BufferSize) {
+  unsigned                NumBytesRem;
+  unsigned                NumBytesRead;
+  unsigned                RdOff;
+  unsigned                WrOff;
+  unsigned char*          pBuffer;
+  SEGGER_RTT_BUFFER_DOWN* pRing;
+#if SEGGER_RTT_MEMCPY_USE_BYTELOOP
+  const char*             pSrc;
+#endif
+  //
+  INIT();
+  pRing = &_SEGGER_RTT.aDown[BufferIndex];
+  pBuffer = (unsigned char*)pData;
+  RdOff = pRing->RdOff;
+  WrOff = pRing->WrOff;
+  NumBytesRead = 0u;
+  //
+  // Read from current read position to wrap-around of buffer, first
+  //
+  if (RdOff > WrOff) {
+    NumBytesRem = pRing->SizeOfBuffer - RdOff;
+    NumBytesRem = MIN(NumBytesRem, BufferSize);
+#if SEGGER_RTT_MEMCPY_USE_BYTELOOP
+    pSrc = pRing->pBuffer + RdOff;
+    NumBytesRead += NumBytesRem;
+    BufferSize   -= NumBytesRem;
+    RdOff        += NumBytesRem;
+    while (NumBytesRem--) {
+      *pBuffer++ = *pSrc++;
+    };
+#else
+    SEGGER_RTT_MEMCPY(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
+    NumBytesRead += NumBytesRem;
+    pBuffer      += NumBytesRem;
+    BufferSize   -= NumBytesRem;
+    RdOff        += NumBytesRem;
+#endif
+    //
+    // Handle wrap-around of buffer
+    //
+    if (RdOff == pRing->SizeOfBuffer) {
+      RdOff = 0u;
+    }
+  }
+  //
+  // Read remaining items of buffer
+  //
+  NumBytesRem = WrOff - RdOff;
+  NumBytesRem = MIN(NumBytesRem, BufferSize);
+  if (NumBytesRem > 0u) {
+#if SEGGER_RTT_MEMCPY_USE_BYTELOOP
+    pSrc = pRing->pBuffer + RdOff;
+    NumBytesRead += NumBytesRem;
+    BufferSize   -= NumBytesRem;
+    RdOff        += NumBytesRem;
+    while (NumBytesRem--) {
+      *pBuffer++ = *pSrc++;
+    };
+#else
+    SEGGER_RTT_MEMCPY(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
+    NumBytesRead += NumBytesRem;
+    pBuffer      += NumBytesRem;
+    BufferSize   -= NumBytesRem;
+    RdOff        += NumBytesRem;
+#endif
+  }
+  if (NumBytesRead) {
+    pRing->RdOff = RdOff;
+  }
+  //
+  return NumBytesRead;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_ReadUpBuffer
+*
+*  Function description
+*    Reads characters from SEGGER real-time-terminal control block
+*    which have been previously stored by the application.
+*    Used to do the same operation that J-Link does, to transfer 
+*    RTT data via other channels, such as TCP/IP or UART.
+*
+*  Parameters
+*    BufferIndex  Index of Up-buffer to be used.
+*    pBuffer      Pointer to buffer provided by target application, to copy characters from RTT-up-buffer to.
+*    BufferSize   Size of the target application buffer.
+*
+*  Return value
+*    Number of bytes that have been read.
+*
+*  Additional information
+*    This function must not be called when J-Link might also do RTT.
+*    This function locks against all other RTT operations. I.e. during
+*    the read operation, writing is also locked.
+*    If only one consumer reads from the up buffer, 
+*    call sEGGER_RTT_ReadUpBufferNoLock() instead.
+*/
+unsigned SEGGER_RTT_ReadUpBuffer(unsigned BufferIndex, void* pBuffer, unsigned BufferSize) {
+  unsigned NumBytesRead;
+  //
+  SEGGER_RTT_LOCK();
+  //
+  // Call the non-locking read function
+  //
+  NumBytesRead = SEGGER_RTT_ReadUpBufferNoLock(BufferIndex, pBuffer, BufferSize);
+  //
+  // Finish up.
+  //
+  SEGGER_RTT_UNLOCK();
+  //
+  return NumBytesRead;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_Read
+*
+*  Function description
+*    Reads characters from SEGGER real-time-terminal control block
+*    which have been previously stored by the host.
+*
+*  Parameters
+*    BufferIndex  Index of Down-buffer to be used (e.g. 0 for "Terminal").
+*    pBuffer      Pointer to buffer provided by target application, to copy characters from RTT-down-buffer to.
+*    BufferSize   Size of the target application buffer.
+*
+*  Return value
+*    Number of bytes that have been read.
+*/
+unsigned SEGGER_RTT_Read(unsigned BufferIndex, void* pBuffer, unsigned BufferSize) {
+  unsigned NumBytesRead;
+  //
+  SEGGER_RTT_LOCK();
+  //
+  // Call the non-locking read function
+  //
+  NumBytesRead = SEGGER_RTT_ReadNoLock(BufferIndex, pBuffer, BufferSize);
+  //
+  // Finish up.
+  //
+  SEGGER_RTT_UNLOCK();
+  //
+  return NumBytesRead;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_WriteWithOverwriteNoLock
+*
+*  Function description
+*    Stores a specified number of characters in SEGGER RTT
+*    control block.
+*    SEGGER_RTT_WriteWithOverwriteNoLock does not lock the application 
+*    and overwrites data if the data does not fit into the buffer.
+*
+*  Parameters
+*    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
+*    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
+*    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
+*
+*  Notes
+*    (1) If there is not enough space in the "Up"-buffer, data is overwritten.
+*    (2) For performance reasons this function does not call Init()
+*        and may only be called after RTT has been initialized.
+*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
+*    (3) Do not use SEGGER_RTT_WriteWithOverwriteNoLock if a J-Link 
+*        connection reads RTT data.
+*/
+void SEGGER_RTT_WriteWithOverwriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
+  const char*           pData;
+  SEGGER_RTT_BUFFER_UP* pRing;
+  unsigned              Avail;
+#if SEGGER_RTT_MEMCPY_USE_BYTELOOP
+  char*                 pDst;
+#endif
+
+  pData = (const char *)pBuffer;
+  //
+  // Get "to-host" ring buffer and copy some elements into local variables.
+  //
+  pRing = &_SEGGER_RTT.aUp[BufferIndex];
+  //
+  // Check if we will overwrite data and need to adjust the RdOff.
+  //
+  if (pRing->WrOff == pRing->RdOff) {
+    Avail = pRing->SizeOfBuffer - 1u;
+  } else if ( pRing->WrOff < pRing->RdOff) {
+    Avail = pRing->RdOff - pRing->WrOff - 1u;
+  } else {
+    Avail = pRing->RdOff - pRing->WrOff - 1u + pRing->SizeOfBuffer;
+  }
+  if (NumBytes > Avail) {
+    pRing->RdOff += (NumBytes - Avail);
+    while (pRing->RdOff >= pRing->SizeOfBuffer) {
+      pRing->RdOff -= pRing->SizeOfBuffer;
+    }
+  }
+  //
+  // Write all data, no need to check the RdOff, but possibly handle multiple wrap-arounds
+  //
+  Avail = pRing->SizeOfBuffer - pRing->WrOff;
+  do {
+    if (Avail > NumBytes) {
+      //
+      // Last round
+      //
+#if SEGGER_RTT_MEMCPY_USE_BYTELOOP
+      pDst = pRing->pBuffer + pRing->WrOff;
+      Avail = NumBytes;
+      while (NumBytes--) {
+        *pDst++ = *pData++;
+      };
+      pRing->WrOff += Avail;
+#else
+      SEGGER_RTT_MEMCPY(pRing->pBuffer + pRing->WrOff, pData, NumBytes);
+      pRing->WrOff += NumBytes;
+#endif
+      break;
+    } else {
+      //
+      //  Wrap-around necessary, write until wrap-around and reset WrOff
+      //
+#if SEGGER_RTT_MEMCPY_USE_BYTELOOP
+      pDst = pRing->pBuffer + pRing->WrOff;
+      NumBytes -= Avail;
+      while (Avail--) {
+        *pDst++ = *pData++;
+      };
+      pRing->WrOff = 0;
+#else
+      SEGGER_RTT_MEMCPY(pRing->pBuffer + pRing->WrOff, pData, Avail);
+      pData += Avail;
+      pRing->WrOff = 0;
+      NumBytes -= Avail;
+#endif
+      Avail = (pRing->SizeOfBuffer - 1);
+    }
+  } while (NumBytes);
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_WriteSkipNoLock
+*
+*  Function description
+*    Stores a specified number of characters in SEGGER RTT
+*    control block which is then read by the host.
+*    SEGGER_RTT_WriteSkipNoLock does not lock the application and
+*    skips all data, if the data does not fit into the buffer.
+*
+*  Parameters
+*    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
+*    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
+*    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
+*                 MUST be > 0!!!
+*                 This is done for performance reasons, so no initial check has do be done.
+*
+*  Return value
+*    1: Data has been copied
+*    0: No space, data has not been copied
+*
+*  Notes
+*    (1) If there is not enough space in the "Up"-buffer, all data is dropped.
+*    (2) For performance reasons this function does not call Init()
+*        and may only be called after RTT has been initialized.
+*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
+*/
+#if (RTT_USE_ASM == 0)
+unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
+  const char*           pData;
+  SEGGER_RTT_BUFFER_UP* pRing;
+  unsigned              Avail;
+  unsigned              RdOff;
+  unsigned              WrOff;
+  unsigned              Rem;
+  //
+  // Cases:
+  //   1) RdOff <= WrOff => Space until wrap-around is sufficient
+  //   2) RdOff <= WrOff => Space after wrap-around needed (copy in 2 chunks)
+  //   3) RdOff <  WrOff => No space in buf
+  //   4) RdOff >  WrOff => Space is sufficient
+  //   5) RdOff >  WrOff => No space in buf
+  //
+  // 1) is the most common case for large buffers and assuming that J-Link reads the data fast enough
+  //
+  pData = (const char *)pBuffer;
+  pRing = &_SEGGER_RTT.aUp[BufferIndex];
+  RdOff = pRing->RdOff;
+  WrOff = pRing->WrOff;
+  if (RdOff <= WrOff) {                                 // Case 1), 2) or 3)
+    Avail = pRing->SizeOfBuffer - WrOff - 1u;           // Space until wrap-around (assume 1 byte not usable for case that RdOff == 0)
+    if (Avail >= NumBytes) {                            // Case 1)?
+CopyStraight:
+      memcpy(pRing->pBuffer + WrOff, pData, NumBytes);
+      pRing->WrOff = WrOff + NumBytes;
+      return 1;
+    }
+    Avail += RdOff;                                     // Space incl. wrap-around
+    if (Avail >= NumBytes) {                            // Case 2? => If not, we have case 3) (does not fit)
+      Rem = pRing->SizeOfBuffer - WrOff;                // Space until end of buffer
+      memcpy(pRing->pBuffer + WrOff, pData, Rem);       // Copy 1st chunk
+      NumBytes -= Rem;
+      //
+      // Special case: First check that assumed RdOff == 0 calculated that last element before wrap-around could not be used
+      // But 2nd check (considering space until wrap-around and until RdOff) revealed that RdOff is not 0, so we can use the last element
+      // In this case, we may use a copy straight until buffer end anyway without needing to copy 2 chunks
+      // Therefore, check if 2nd memcpy is necessary at all
+      //
+      if (NumBytes) {
+        memcpy(pRing->pBuffer, pData + Rem, NumBytes);
+      }
+      pRing->WrOff = NumBytes;
+      return 1;
+    }
+  } else {                                             // Potential case 4)
+    Avail = RdOff - WrOff - 1u;
+    if (Avail >= NumBytes) {                           // Case 4)? => If not, we have case 5) (does not fit)
+      goto CopyStraight;
+    }
+  }
+  return 0;     // No space in buffer
+}
+#endif
+
+/*********************************************************************
+*
+*       SEGGER_RTT_WriteDownBufferNoLock
+*
+*  Function description
+*    Stores a specified number of characters in SEGGER RTT
+*    control block inside a <Down> buffer.
+*    SEGGER_RTT_WriteDownBufferNoLock does not lock the application.
+*    Used to do the same operation that J-Link does, to transfer 
+*    RTT data from other channels, such as TCP/IP or UART.
+*
+*  Parameters
+*    BufferIndex  Index of "Down"-buffer to be used.
+*    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
+*    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
+*
+*  Return value
+*    Number of bytes which have been stored in the "Down"-buffer.
+*
+*  Notes
+*    (1) Data is stored according to buffer flags.
+*    (2) For performance reasons this function does not call Init()
+*        and may only be called after RTT has been initialized.
+*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
+*
+*  Additional information
+*    This function must not be called when J-Link might also do RTT.
+*/
+unsigned SEGGER_RTT_WriteDownBufferNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
+  unsigned                Status;
+  unsigned                Avail;
+  const char*             pData;
+  SEGGER_RTT_BUFFER_UP*   pRing;
+
+  pData = (const char *)pBuffer;
+  //
+  // Get "to-target" ring buffer.
+  // It is save to cast that to a "to-host" buffer. Up and Down buffer differ in volatility of offsets that might be modified by J-Link.
+  //
+  pRing = (SEGGER_RTT_BUFFER_UP*)&_SEGGER_RTT.aDown[BufferIndex];
+  //
+  // How we output depends upon the mode...
+  //
+  switch (pRing->Flags) {
+  case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
+    //
+    // If we are in skip mode and there is no space for the whole
+    // of this output, don't bother.
+    //
+    Avail = _GetAvailWriteSpace(pRing);
+    if (Avail < NumBytes) {
+      Status = 0u;
+    } else {
+      Status = NumBytes;
+      _WriteNoCheck(pRing, pData, NumBytes);
+    }
+    break;
+  case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
+    //
+    // If we are in trim mode, trim to what we can output without blocking.
+    //
+    Avail = _GetAvailWriteSpace(pRing);
+    Status = Avail < NumBytes ? Avail : NumBytes;
+    _WriteNoCheck(pRing, pData, Status);
+    break;
+  case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
+    //
+    // If we are in blocking mode, output everything.
+    //
+    Status = _WriteBlocking(pRing, pData, NumBytes);
+    break;
+  default:
+    Status = 0u;
+    break;
+  }
+  //
+  // Finish up.
+  //
+  return Status;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_WriteNoLock
+*
+*  Function description
+*    Stores a specified number of characters in SEGGER RTT
+*    control block which is then read by the host.
+*    SEGGER_RTT_WriteNoLock does not lock the application.
+*
+*  Parameters
+*    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
+*    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
+*    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
+*
+*  Return value
+*    Number of bytes which have been stored in the "Up"-buffer.
+*
+*  Notes
+*    (1) Data is stored according to buffer flags.
+*    (2) For performance reasons this function does not call Init()
+*        and may only be called after RTT has been initialized.
+*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
+*/
+unsigned SEGGER_RTT_WriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
+  unsigned              Status;
+  unsigned              Avail;
+  const char*           pData;
+  SEGGER_RTT_BUFFER_UP* pRing;
+
+  pData = (const char *)pBuffer;
+  //
+  // Get "to-host" ring buffer.
+  //
+  pRing = &_SEGGER_RTT.aUp[BufferIndex];
+  //
+  // How we output depends upon the mode...
+  //
+  switch (pRing->Flags) {
+  case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
+    //
+    // If we are in skip mode and there is no space for the whole
+    // of this output, don't bother.
+    //
+    Avail = _GetAvailWriteSpace(pRing);
+    if (Avail < NumBytes) {
+      Status = 0u;
+    } else {
+      Status = NumBytes;
+      _WriteNoCheck(pRing, pData, NumBytes);
+    }
+    break;
+  case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
+    //
+    // If we are in trim mode, trim to what we can output without blocking.
+    //
+    Avail = _GetAvailWriteSpace(pRing);
+    Status = Avail < NumBytes ? Avail : NumBytes;
+    _WriteNoCheck(pRing, pData, Status);
+    break;
+  case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
+    //
+    // If we are in blocking mode, output everything.
+    //
+    Status = _WriteBlocking(pRing, pData, NumBytes);
+    break;
+  default:
+    Status = 0u;
+    break;
+  }
+  //
+  // Finish up.
+  //
+  return Status;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_WriteDownBuffer
+*
+*  Function description
+*    Stores a specified number of characters in SEGGER RTT control block in a <Down> buffer.
+*
+*  Parameters
+*    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
+*    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
+*    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
+*
+*  Return value
+*    Number of bytes which have been stored in the "Down"-buffer.
+*
+*  Notes
+*    (1) Data is stored according to buffer flags.
+*
+*  Additional information
+*    This function must not be called when J-Link might also do RTT.
+*    This function locks against all other RTT operations. I.e. during
+*    the write operation, writing from the application is also locked.
+*    If only one consumer writes to the down buffer, 
+*    call SEGGER_RTT_WriteDownBufferNoLock() instead.
+*/
+unsigned SEGGER_RTT_WriteDownBuffer(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
+  unsigned Status;
+  //
+  INIT();
+  SEGGER_RTT_LOCK();
+  //
+  // Call the non-locking write function
+  //
+  Status = SEGGER_RTT_WriteDownBufferNoLock(BufferIndex, pBuffer, NumBytes);
+  //
+  // Finish up.
+  //
+  SEGGER_RTT_UNLOCK();
+  //
+  return Status;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_Write
+*
+*  Function description
+*    Stores a specified number of characters in SEGGER RTT
+*    control block which is then read by the host.
+*
+*  Parameters
+*    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
+*    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
+*    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
+*
+*  Return value
+*    Number of bytes which have been stored in the "Up"-buffer.
+*
+*  Notes
+*    (1) Data is stored according to buffer flags.
+*/
+unsigned SEGGER_RTT_Write(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
+  unsigned Status;
+  //
+  INIT();
+  SEGGER_RTT_LOCK();
+  //
+  // Call the non-locking write function
+  //
+  Status = SEGGER_RTT_WriteNoLock(BufferIndex, pBuffer, NumBytes);
+  //
+  // Finish up.
+  //
+  SEGGER_RTT_UNLOCK();
+  //
+  return Status;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_WriteString
+*
+*  Function description
+*    Stores string in SEGGER RTT control block.
+*    This data is read by the host.
+*
+*  Parameters
+*    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
+*    s            Pointer to string.
+*
+*  Return value
+*    Number of bytes which have been stored in the "Up"-buffer.
+*
+*  Notes
+*    (1) Data is stored according to buffer flags.
+*    (2) String passed to this function has to be \0 terminated
+*    (3) \0 termination character is *not* stored in RTT buffer
+*/
+unsigned SEGGER_RTT_WriteString(unsigned BufferIndex, const char* s) {
+  unsigned Len;
+
+  Len = STRLEN(s);
+  return SEGGER_RTT_Write(BufferIndex, s, Len);
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_PutCharSkipNoLock
+*
+*  Function description
+*    Stores a single character/byte in SEGGER RTT buffer.
+*    SEGGER_RTT_PutCharSkipNoLock does not lock the application and
+*    skips the byte, if it does not fit into the buffer.
+*
+*  Parameters
+*    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
+*    c            Byte to be stored.
+*
+*  Return value
+*    Number of bytes which have been stored in the "Up"-buffer.
+*
+*  Notes
+*    (1) If there is not enough space in the "Up"-buffer, the character is dropped.
+*    (2) For performance reasons this function does not call Init()
+*        and may only be called after RTT has been initialized.
+*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
+*/
+
+unsigned SEGGER_RTT_PutCharSkipNoLock(unsigned BufferIndex, char c) {
+  SEGGER_RTT_BUFFER_UP* pRing;
+  unsigned              WrOff;
+  unsigned              Status;
+  //
+  // Get "to-host" ring buffer.
+  //
+  pRing = &_SEGGER_RTT.aUp[BufferIndex];
+  //
+  // Get write position and handle wrap-around if necessary
+  //
+  WrOff = pRing->WrOff + 1;
+  if (WrOff == pRing->SizeOfBuffer) {
+    WrOff = 0;
+  }
+  //
+  // Output byte if free space is available
+  //
+  if (WrOff != pRing->RdOff) {
+    pRing->pBuffer[pRing->WrOff] = c;
+    pRing->WrOff = WrOff;
+    Status = 1;
+  } else {
+    Status = 0;
+  }
+  //
+  return Status;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_PutCharSkip
+*
+*  Function description
+*    Stores a single character/byte in SEGGER RTT buffer.
+*
+*  Parameters
+*    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
+*    c            Byte to be stored.
+*
+*  Return value
+*    Number of bytes which have been stored in the "Up"-buffer.
+*
+*  Notes
+*    (1) If there is not enough space in the "Up"-buffer, the character is dropped.
+*/
+
+unsigned SEGGER_RTT_PutCharSkip(unsigned BufferIndex, char c) {
+  SEGGER_RTT_BUFFER_UP* pRing;
+  unsigned              WrOff;
+  unsigned              Status;
+  //
+  // Prepare
+  //
+  INIT();
+  SEGGER_RTT_LOCK();
+  //
+  // Get "to-host" ring buffer.
+  //
+  pRing = &_SEGGER_RTT.aUp[BufferIndex];
+  //
+  // Get write position and handle wrap-around if necessary
+  //
+  WrOff = pRing->WrOff + 1;
+  if (WrOff == pRing->SizeOfBuffer) {
+    WrOff = 0;
+  }
+  //
+  // Output byte if free space is available
+  //
+  if (WrOff != pRing->RdOff) {
+    pRing->pBuffer[pRing->WrOff] = c;
+    pRing->WrOff = WrOff;
+    Status = 1;
+  } else {
+    Status = 0;
+  }
+  //
+  // Finish up.
+  //
+  SEGGER_RTT_UNLOCK();
+  //
+  return Status;
+}
+
+ /*********************************************************************
+*
+*       SEGGER_RTT_PutChar
+*
+*  Function description
+*    Stores a single character/byte in SEGGER RTT buffer.
+*
+*  Parameters
+*    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
+*    c            Byte to be stored.
+*
+*  Return value
+*    Number of bytes which have been stored in the "Up"-buffer.
+*
+*  Notes
+*    (1) Data is stored according to buffer flags.
+*/
+
+unsigned SEGGER_RTT_PutChar(unsigned BufferIndex, char c) {
+  SEGGER_RTT_BUFFER_UP* pRing;
+  unsigned              WrOff;
+  unsigned              Status;
+  //
+  // Prepare
+  //
+  INIT();
+  SEGGER_RTT_LOCK();
+  //
+  // Get "to-host" ring buffer.
+  //
+  pRing = &_SEGGER_RTT.aUp[BufferIndex];
+  //
+  // Get write position and handle wrap-around if necessary
+  //
+  WrOff = pRing->WrOff + 1;
+  if (WrOff == pRing->SizeOfBuffer) {
+    WrOff = 0;
+  }
+  //
+  // Wait for free space if mode is set to blocking
+  //
+  if (pRing->Flags == SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL) {
+    while (WrOff == pRing->RdOff) {
+      ;
+    }
+  }
+  //
+  // Output byte if free space is available
+  //
+  if (WrOff != pRing->RdOff) {
+    pRing->pBuffer[pRing->WrOff] = c;
+    pRing->WrOff = WrOff;
+    Status = 1;
+  } else {
+    Status = 0;
+  }
+  //
+  // Finish up.
+  //
+  SEGGER_RTT_UNLOCK();
+  //
+  return Status;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_GetKey
+*
+*  Function description
+*    Reads one character from the SEGGER RTT buffer.
+*    Host has previously stored data there.
+*
+*  Return value
+*    <  0 -   No character available (buffer empty).
+*    >= 0 -   Character which has been read. (Possible values: 0 - 255)
+*
+*  Notes
+*    (1) This function is only specified for accesses to RTT buffer 0.
+*/
+int SEGGER_RTT_GetKey(void) {
+  char c;
+  int r;
+
+  r = (int)SEGGER_RTT_Read(0u, &c, 1u);
+  if (r == 1) {
+    r = (int)(unsigned char)c;
+  } else {
+    r = -1;
+  }
+  return r;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_WaitKey
+*
+*  Function description
+*    Waits until at least one character is avaible in the SEGGER RTT buffer.
+*    Once a character is available, it is read and this function returns.
+*
+*  Return value
+*    >=0 -   Character which has been read.
+*
+*  Notes
+*    (1) This function is only specified for accesses to RTT buffer 0
+*    (2) This function is blocking if no character is present in RTT buffer
+*/
+int SEGGER_RTT_WaitKey(void) {
+  int r;
+
+  do {
+    r = SEGGER_RTT_GetKey();
+  } while (r < 0);
+  return r;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_HasKey
+*
+*  Function description
+*    Checks if at least one character for reading is available in the SEGGER RTT buffer.
+*
+*  Return value
+*    == 0 -     No characters are available to read.
+*    == 1 -     At least one character is available.
+*
+*  Notes
+*    (1) This function is only specified for accesses to RTT buffer 0
+*/
+int SEGGER_RTT_HasKey(void) {
+  unsigned RdOff;
+  int r;
+
+  INIT();
+  RdOff = _SEGGER_RTT.aDown[0].RdOff;
+  if (RdOff != _SEGGER_RTT.aDown[0].WrOff) {
+    r = 1;
+  } else {
+    r = 0;
+  }
+  return r;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_HasData
+*
+*  Function description
+*    Check if there is data from the host in the given buffer.
+*
+*  Return value:
+*  ==0:  No data
+*  !=0:  Data in buffer
+*
+*/
+unsigned SEGGER_RTT_HasData(unsigned BufferIndex) {
+  SEGGER_RTT_BUFFER_DOWN* pRing;
+  unsigned                v;
+
+  pRing = &_SEGGER_RTT.aDown[BufferIndex];
+  v = pRing->WrOff;
+  return v - pRing->RdOff;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_HasDataUp
+*
+*  Function description
+*    Check if there is data remaining to be sent in the given buffer.
+*
+*  Return value:
+*  ==0:  No data
+*  !=0:  Data in buffer
+*
+*/
+unsigned SEGGER_RTT_HasDataUp(unsigned BufferIndex) {
+  SEGGER_RTT_BUFFER_UP* pRing;
+  unsigned                v;
+
+  pRing = &_SEGGER_RTT.aUp[BufferIndex];
+  v = pRing->RdOff;
+  return pRing->WrOff - v;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_AllocDownBuffer
+*
+*  Function description
+*    Run-time configuration of the next down-buffer (H->T).
+*    The next buffer, which is not used yet is configured.
+*    This includes: Buffer address, size, name, flags, ...
+*
+*  Parameters
+*    sName        Pointer to a constant name string.
+*    pBuffer      Pointer to a buffer to be used.
+*    BufferSize   Size of the buffer.
+*    Flags        Operating modes. Define behavior if buffer is full (not enough space for entire message).
+*
+*  Return value
+*    >= 0 - O.K. Buffer Index
+*     < 0 - Error
+*/
+int SEGGER_RTT_AllocDownBuffer(const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
+  int BufferIndex;
+
+  INIT();
+  SEGGER_RTT_LOCK();
+  BufferIndex = 0;
+  do {
+    if (_SEGGER_RTT.aDown[BufferIndex].pBuffer == NULL) {
+      break;
+    }
+    BufferIndex++;
+  } while (BufferIndex < _SEGGER_RTT.MaxNumDownBuffers);
+  if (BufferIndex < _SEGGER_RTT.MaxNumDownBuffers) {
+    _SEGGER_RTT.aDown[BufferIndex].sName        = sName;
+    _SEGGER_RTT.aDown[BufferIndex].pBuffer      = (char*)pBuffer;
+    _SEGGER_RTT.aDown[BufferIndex].SizeOfBuffer = BufferSize;
+    _SEGGER_RTT.aDown[BufferIndex].RdOff        = 0u;
+    _SEGGER_RTT.aDown[BufferIndex].WrOff        = 0u;
+    _SEGGER_RTT.aDown[BufferIndex].Flags        = Flags;
+  } else {
+    BufferIndex = -1;
+  }
+  SEGGER_RTT_UNLOCK();
+  return BufferIndex;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_AllocUpBuffer
+*
+*  Function description
+*    Run-time configuration of the next up-buffer (T->H).
+*    The next buffer, which is not used yet is configured.
+*    This includes: Buffer address, size, name, flags, ...
+*
+*  Parameters
+*    sName        Pointer to a constant name string.
+*    pBuffer      Pointer to a buffer to be used.
+*    BufferSize   Size of the buffer.
+*    Flags        Operating modes. Define behavior if buffer is full (not enough space for entire message).
+*
+*  Return value
+*    >= 0 - O.K. Buffer Index
+*     < 0 - Error
+*/
+int SEGGER_RTT_AllocUpBuffer(const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
+  int BufferIndex;
+
+  INIT();
+  SEGGER_RTT_LOCK();
+  BufferIndex = 0;
+  do {
+    if (_SEGGER_RTT.aUp[BufferIndex].pBuffer == NULL) {
+      break;
+    }
+    BufferIndex++;
+  } while (BufferIndex < _SEGGER_RTT.MaxNumUpBuffers);
+  if (BufferIndex < _SEGGER_RTT.MaxNumUpBuffers) {
+    _SEGGER_RTT.aUp[BufferIndex].sName        = sName;
+    _SEGGER_RTT.aUp[BufferIndex].pBuffer      = (char*)pBuffer;
+    _SEGGER_RTT.aUp[BufferIndex].SizeOfBuffer = BufferSize;
+    _SEGGER_RTT.aUp[BufferIndex].RdOff        = 0u;
+    _SEGGER_RTT.aUp[BufferIndex].WrOff        = 0u;
+    _SEGGER_RTT.aUp[BufferIndex].Flags        = Flags;
+  } else {
+    BufferIndex = -1;
+  }
+  SEGGER_RTT_UNLOCK();
+  return BufferIndex;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_ConfigUpBuffer
+*
+*  Function description
+*    Run-time configuration of a specific up-buffer (T->H).
+*    Buffer to be configured is specified by index.
+*    This includes: Buffer address, size, name, flags, ...
+*
+*  Parameters
+*    BufferIndex  Index of the buffer to configure.
+*    sName        Pointer to a constant name string.
+*    pBuffer      Pointer to a buffer to be used.
+*    BufferSize   Size of the buffer.
+*    Flags        Operating modes. Define behavior if buffer is full (not enough space for entire message).
+*
+*  Return value
+*    >= 0 - O.K.
+*     < 0 - Error
+*
+*  Additional information
+*    Buffer 0 is configured on compile-time.
+*    May only be called once per buffer.
+*    Buffer name and flags can be reconfigured using the appropriate functions.
+*/
+int SEGGER_RTT_ConfigUpBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
+  int r;
+
+  INIT();
+  if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumUpBuffers) {
+    SEGGER_RTT_LOCK();
+    if (BufferIndex > 0u) {
+      _SEGGER_RTT.aUp[BufferIndex].sName        = sName;
+      _SEGGER_RTT.aUp[BufferIndex].pBuffer      = (char*)pBuffer;
+      _SEGGER_RTT.aUp[BufferIndex].SizeOfBuffer = BufferSize;
+      _SEGGER_RTT.aUp[BufferIndex].RdOff        = 0u;
+      _SEGGER_RTT.aUp[BufferIndex].WrOff        = 0u;
+    }
+    _SEGGER_RTT.aUp[BufferIndex].Flags          = Flags;
+    SEGGER_RTT_UNLOCK();
+    r =  0;
+  } else {
+    r = -1;
+  }
+  return r;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_ConfigDownBuffer
+*
+*  Function description
+*    Run-time configuration of a specific down-buffer (H->T).
+*    Buffer to be configured is specified by index.
+*    This includes: Buffer address, size, name, flags, ...
+*
+*  Parameters
+*    BufferIndex  Index of the buffer to configure.
+*    sName        Pointer to a constant name string.
+*    pBuffer      Pointer to a buffer to be used.
+*    BufferSize   Size of the buffer.
+*    Flags        Operating modes. Define behavior if buffer is full (not enough space for entire message).
+*
+*  Return value
+*    >= 0  O.K.
+*     < 0  Error
+*
+*  Additional information
+*    Buffer 0 is configured on compile-time.
+*    May only be called once per buffer.
+*    Buffer name and flags can be reconfigured using the appropriate functions.
+*/
+int SEGGER_RTT_ConfigDownBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
+  int r;
+
+  INIT();
+  if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumDownBuffers) {
+    SEGGER_RTT_LOCK();
+    if (BufferIndex > 0u) {
+      _SEGGER_RTT.aDown[BufferIndex].sName        = sName;
+      _SEGGER_RTT.aDown[BufferIndex].pBuffer      = (char*)pBuffer;
+      _SEGGER_RTT.aDown[BufferIndex].SizeOfBuffer = BufferSize;
+      _SEGGER_RTT.aDown[BufferIndex].RdOff        = 0u;
+      _SEGGER_RTT.aDown[BufferIndex].WrOff        = 0u;
+    }
+    _SEGGER_RTT.aDown[BufferIndex].Flags          = Flags;
+    SEGGER_RTT_UNLOCK();
+    r =  0;
+  } else {
+    r = -1;
+  }
+  return r;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_SetNameUpBuffer
+*
+*  Function description
+*    Run-time configuration of a specific up-buffer name (T->H).
+*    Buffer to be configured is specified by index.
+*
+*  Parameters
+*    BufferIndex  Index of the buffer to renamed.
+*    sName        Pointer to a constant name string.
+*
+*  Return value
+*    >= 0  O.K.
+*     < 0  Error
+*/
+int SEGGER_RTT_SetNameUpBuffer(unsigned BufferIndex, const char* sName) {
+  int r;
+
+  INIT();
+  if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumUpBuffers) {
+    SEGGER_RTT_LOCK();
+    _SEGGER_RTT.aUp[BufferIndex].sName = sName;
+    SEGGER_RTT_UNLOCK();
+    r =  0;
+  } else {
+    r = -1;
+  }
+  return r;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_SetNameDownBuffer
+*
+*  Function description
+*    Run-time configuration of a specific Down-buffer name (T->H).
+*    Buffer to be configured is specified by index.
+*
+*  Parameters
+*    BufferIndex  Index of the buffer to renamed.
+*    sName        Pointer to a constant name string.
+*
+*  Return value
+*    >= 0  O.K.
+*     < 0  Error
+*/
+int SEGGER_RTT_SetNameDownBuffer(unsigned BufferIndex, const char* sName) {
+  int r;
+
+  INIT();
+  if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumDownBuffers) {
+    SEGGER_RTT_LOCK();
+    _SEGGER_RTT.aDown[BufferIndex].sName = sName;
+    SEGGER_RTT_UNLOCK();
+    r =  0;
+  } else {
+    r = -1;
+  }
+  return r;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_SetFlagsUpBuffer
+*
+*  Function description
+*    Run-time configuration of specific up-buffer flags (T->H).
+*    Buffer to be configured is specified by index.
+*
+*  Parameters
+*    BufferIndex  Index of the buffer.
+*    Flags        Flags to set for the buffer.
+*
+*  Return value
+*    >= 0  O.K.
+*     < 0  Error
+*/
+int SEGGER_RTT_SetFlagsUpBuffer(unsigned BufferIndex, unsigned Flags) {
+  int r;
+
+  INIT();
+  if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumUpBuffers) {
+    SEGGER_RTT_LOCK();
+    _SEGGER_RTT.aUp[BufferIndex].Flags = Flags;
+    SEGGER_RTT_UNLOCK();
+    r =  0;
+  } else {
+    r = -1;
+  }
+  return r;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_SetFlagsDownBuffer
+*
+*  Function description
+*    Run-time configuration of specific Down-buffer flags (T->H).
+*    Buffer to be configured is specified by index.
+*
+*  Parameters
+*    BufferIndex  Index of the buffer to renamed.
+*    Flags        Flags to set for the buffer.
+*
+*  Return value
+*    >= 0  O.K.
+*     < 0  Error
+*/
+int SEGGER_RTT_SetFlagsDownBuffer(unsigned BufferIndex, unsigned Flags) {
+  int r;
+
+  INIT();
+  if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumDownBuffers) {
+    SEGGER_RTT_LOCK();
+    _SEGGER_RTT.aDown[BufferIndex].Flags = Flags;
+    SEGGER_RTT_UNLOCK();
+    r =  0;
+  } else {
+    r = -1;
+  }
+  return r;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_Init
+*
+*  Function description
+*    Initializes the RTT Control Block.
+*    Should be used in RAM targets, at start of the application.
+*
+*/
+void SEGGER_RTT_Init (void) {
+  _DoInit();
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_SetTerminal
+*
+*  Function description
+*    Sets the terminal to be used for output on channel 0.
+*
+*  Parameters
+*    TerminalId  Index of the terminal.
+*
+*  Return value
+*    >= 0  O.K.
+*     < 0  Error (e.g. if RTT is configured for non-blocking mode and there was no space in the buffer to set the new terminal Id)
+*/
+int SEGGER_RTT_SetTerminal (unsigned char TerminalId) {
+  unsigned char         ac[2];
+  SEGGER_RTT_BUFFER_UP* pRing;
+  unsigned Avail;
+  int r;
+  //
+  INIT();
+  //
+  r = 0;
+  ac[0] = 0xFFu;
+  if (TerminalId < sizeof(_aTerminalId)) { // We only support a certain number of channels
+    ac[1] = _aTerminalId[TerminalId];
+    pRing = &_SEGGER_RTT.aUp[0];    // Buffer 0 is always reserved for terminal I/O, so we can use index 0 here, fixed
+    SEGGER_RTT_LOCK();    // Lock to make sure that no other task is writing into buffer, while we are and number of free bytes in buffer does not change downwards after checking and before writing
+    if ((pRing->Flags & SEGGER_RTT_MODE_MASK) == SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL) {
+      _ActiveTerminal = TerminalId;
+      _WriteBlocking(pRing, (const char*)ac, 2u);
+    } else {                                                                            // Skipping mode or trim mode? => We cannot trim this command so handling is the same for both modes
+      Avail = _GetAvailWriteSpace(pRing);
+      if (Avail >= 2) {
+        _ActiveTerminal = TerminalId;    // Only change active terminal in case of success
+        _WriteNoCheck(pRing, (const char*)ac, 2u);
+      } else {
+        r = -1;
+      }
+    }
+    SEGGER_RTT_UNLOCK();
+  } else {
+    r = -1;
+  }
+  return r;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_TerminalOut
+*
+*  Function description
+*    Writes a string to the given terminal
+*     without changing the terminal for channel 0.
+*
+*  Parameters
+*    TerminalId   Index of the terminal.
+*    s            String to be printed on the terminal.
+*
+*  Return value
+*    >= 0 - Number of bytes written.
+*     < 0 - Error.
+*
+*/
+int SEGGER_RTT_TerminalOut (unsigned char TerminalId, const char* s) {
+  int                   Status;
+  unsigned              FragLen;
+  unsigned              Avail;
+  SEGGER_RTT_BUFFER_UP* pRing;
+  //
+  INIT();
+  //
+  // Validate terminal ID.
+  //
+  if (TerminalId < (char)sizeof(_aTerminalId)) { // We only support a certain number of channels
+    //
+    // Get "to-host" ring buffer.
+    //
+    pRing = &_SEGGER_RTT.aUp[0];
+    //
+    // Need to be able to change terminal, write data, change back.
+    // Compute the fixed and variable sizes.
+    //
+    FragLen = STRLEN(s);
+    //
+    // How we output depends upon the mode...
+    //
+    SEGGER_RTT_LOCK();
+    Avail = _GetAvailWriteSpace(pRing);
+    switch (pRing->Flags & SEGGER_RTT_MODE_MASK) {
+    case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
+      //
+      // If we are in skip mode and there is no space for the whole
+      // of this output, don't bother switching terminals at all.
+      //
+      if (Avail < (FragLen + 4u)) {
+        Status = 0;
+      } else {
+        _PostTerminalSwitch(pRing, TerminalId);
+        Status = (int)_WriteBlocking(pRing, s, FragLen);
+        _PostTerminalSwitch(pRing, _ActiveTerminal);
+      }
+      break;
+    case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
+      //
+      // If we are in trim mode and there is not enough space for everything,
+      // trim the output but always include the terminal switch.  If no room
+      // for terminal switch, skip that totally.
+      //
+      if (Avail < 4u) {
+        Status = -1;
+      } else {
+        _PostTerminalSwitch(pRing, TerminalId);
+        Status = (int)_WriteBlocking(pRing, s, (FragLen < (Avail - 4u)) ? FragLen : (Avail - 4u));
+        _PostTerminalSwitch(pRing, _ActiveTerminal);
+      }
+      break;
+    case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
+      //
+      // If we are in blocking mode, output everything.
+      //
+      _PostTerminalSwitch(pRing, TerminalId);
+      Status = (int)_WriteBlocking(pRing, s, FragLen);
+      _PostTerminalSwitch(pRing, _ActiveTerminal);
+      break;
+    default:
+      Status = -1;
+      break;
+    }
+    //
+    // Finish up.
+    //
+    SEGGER_RTT_UNLOCK();
+  } else {
+    Status = -1;
+  }
+  return Status;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_GetAvailWriteSpace
+*
+*  Function description
+*    Returns the number of bytes available in the ring buffer.
+*
+*  Parameters
+*    BufferIndex  Index of the up buffer.
+*
+*  Return value
+*    Number of bytes that are free in the selected up buffer.
+*/
+unsigned SEGGER_RTT_GetAvailWriteSpace (unsigned BufferIndex){
+  return _GetAvailWriteSpace(&_SEGGER_RTT.aUp[BufferIndex]);
+}
+
+
+/*********************************************************************
+*
+*       SEGGER_RTT_GetBytesInBuffer()
+*
+*  Function description
+*    Returns the number of bytes currently used in the up buffer.
+*
+*  Parameters
+*    BufferIndex  Index of the up buffer.
+*
+*  Return value
+*    Number of bytes that are used in the buffer.
+*/
+unsigned SEGGER_RTT_GetBytesInBuffer(unsigned BufferIndex) {
+  unsigned RdOff;
+  unsigned WrOff;
+  unsigned r;
+  //
+  // Avoid warnings regarding volatile access order.  It's not a problem
+  // in this case, but dampen compiler enthusiasm.
+  //
+  RdOff = _SEGGER_RTT.aUp[BufferIndex].RdOff;
+  WrOff = _SEGGER_RTT.aUp[BufferIndex].WrOff;
+  if (RdOff <= WrOff) {
+    r = WrOff - RdOff;
+  } else {
+    r = _SEGGER_RTT.aUp[BufferIndex].SizeOfBuffer - (WrOff - RdOff);
+  }
+  return r;
+}
+
+/*************************** End of file ****************************/
diff --git a/sched/systemview/SEGGER_RTT.h b/sched/systemview/SEGGER_RTT.h
new file mode 100644
index 0000000000..f01651b364
--- /dev/null
+++ b/sched/systemview/SEGGER_RTT.h
@@ -0,0 +1,325 @@
+/*********************************************************************
+*                    SEGGER Microcontroller GmbH                     *
+*                        The Embedded Experts                        *
+**********************************************************************
+*                                                                    *
+*            (c) 1995 - 2019 SEGGER Microcontroller GmbH             *
+*                                                                    *
+*       www.segger.com     Support: support@segger.com               *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SEGGER SystemView * Real-time application analysis           *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+* All rights reserved.                                               *
+*                                                                    *
+* SEGGER strongly recommends to not make any changes                 *
+* to or modify the source code of this software in order to stay     *
+* compatible with the SystemView and RTT protocol, and J-Link.       *
+*                                                                    *
+* Redistribution and use in source and binary forms, with or         *
+* without modification, are permitted provided that the following    *
+* condition is met:                                                  *
+*                                                                    *
+* o Redistributions of source code must retain the above copyright   *
+*   notice, this condition and the following disclaimer.             *
+*                                                                    *
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
+* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
+* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
+* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
+* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
+* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
+* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
+* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
+* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
+* DAMAGE.                                                            *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SystemView version: V3.12                                    *
+*                                                                    *
+**********************************************************************
+---------------------------END-OF-HEADER------------------------------
+File    : SEGGER_RTT.h
+Purpose : Implementation of SEGGER real-time transfer which allows
+          real-time communication on targets which support debugger 
+          memory accesses while the CPU is running.
+Revision: $Rev: 17697 $
+----------------------------------------------------------------------
+*/
+
+#ifndef SEGGER_RTT_H
+#define SEGGER_RTT_H
+
+#include "SEGGER_RTT_Conf.h"
+
+
+
+/*********************************************************************
+*
+*       Defines, defaults
+*
+**********************************************************************
+*/
+#ifndef RTT_USE_ASM
+  #if (defined __SES_ARM)                       // SEGGER Embedded Studio
+    #define _CC_HAS_RTT_ASM_SUPPORT 1
+  #elif (defined __CROSSWORKS_ARM)              // Rowley Crossworks
+    #define _CC_HAS_RTT_ASM_SUPPORT 1
+  #elif (defined __GNUC__)                      // GCC
+    #define _CC_HAS_RTT_ASM_SUPPORT 1
+  #elif (defined __clang__)                     // Clang compiler
+    #define _CC_HAS_RTT_ASM_SUPPORT 1
+  #elif (defined __IASMARM__)                   // IAR assembler
+    #define _CC_HAS_RTT_ASM_SUPPORT 1
+  #elif (defined __ICCARM__)                    // IAR compiler
+    #define _CC_HAS_RTT_ASM_SUPPORT 1
+  #else
+    #define _CC_HAS_RTT_ASM_SUPPORT 0
+  #endif
+  #if (defined __ARM_ARCH_7M__)                 // Cortex-M3/4
+    #define _CORE_HAS_RTT_ASM_SUPPORT 1
+  #elif (defined __ARM_ARCH_7EM__)              // Cortex-M7
+    #define _CORE_HAS_RTT_ASM_SUPPORT 1
+  #elif (defined __ARM_ARCH_8M_MAIN__)          // Cortex-M33
+    #define _CORE_HAS_RTT_ASM_SUPPORT 1
+  #elif (defined __ARM7M__)                     // IAR Cortex-M3/4
+    #if (__CORE__ == __ARM7M__)
+      #define _CORE_HAS_RTT_ASM_SUPPORT 1
+    #else
+      #define _CORE_HAS_RTT_ASM_SUPPORT 0
+    #endif
+  #elif (defined __ARM7EM__)                    // IAR Cortex-M7
+    #if (__CORE__ == __ARM7EM__)
+      #define _CORE_HAS_RTT_ASM_SUPPORT 1
+    #else
+      #define _CORE_HAS_RTT_ASM_SUPPORT 0
+    #endif
+  #else
+    #define _CORE_HAS_RTT_ASM_SUPPORT 0
+  #endif
+  //
+  // If IDE and core support the ASM version, enable ASM version by default
+  //
+  #if (_CC_HAS_RTT_ASM_SUPPORT && _CORE_HAS_RTT_ASM_SUPPORT)
+    #define RTT_USE_ASM                           (1)
+  #else
+    #define RTT_USE_ASM                           (0)
+  #endif
+#endif
+
+#ifndef SEGGER_RTT_ASM  // defined when SEGGER_RTT.h is included from assembly file
+#include <stdlib.h>
+#include <stdarg.h>
+
+/*********************************************************************
+*
+*       Defines, fixed
+*
+**********************************************************************
+*/
+
+/*********************************************************************
+*
+*       Types
+*
+**********************************************************************
+*/
+
+//
+// Description for a circular buffer (also called "ring buffer")
+// which is used as up-buffer (T->H)
+//
+typedef struct {
+  const     char*    sName;         // Optional name. Standard names so far are: "Terminal", "SysView", "J-Scope_t4i4"
+            char*    pBuffer;       // Pointer to start of buffer
+            unsigned SizeOfBuffer;  // Buffer size in bytes. Note that one byte is lost, as this implementation does not fill up the buffer in order to avoid the problem of being unable to distinguish between full and empty.
+            unsigned WrOff;         // Position of next item to be written by either target.
+  volatile  unsigned RdOff;         // Position of next item to be read by host. Must be volatile since it may be modified by host.
+            unsigned Flags;         // Contains configuration flags
+} SEGGER_RTT_BUFFER_UP;
+
+//
+// Description for a circular buffer (also called "ring buffer")
+// which is used as down-buffer (H->T)
+//
+typedef struct {
+  const     char*    sName;         // Optional name. Standard names so far are: "Terminal", "SysView", "J-Scope_t4i4"
+            char*    pBuffer;       // Pointer to start of buffer
+            unsigned SizeOfBuffer;  // Buffer size in bytes. Note that one byte is lost, as this implementation does not fill up the buffer in order to avoid the problem of being unable to distinguish between full and empty.
+  volatile  unsigned WrOff;         // Position of next item to be written by host. Must be volatile since it may be modified by host.
+            unsigned RdOff;         // Position of next item to be read by target (down-buffer).
+            unsigned Flags;         // Contains configuration flags
+} SEGGER_RTT_BUFFER_DOWN;
+
+//
+// RTT control block which describes the number of buffers available
+// as well as the configuration for each buffer
+//
+//
+typedef struct {
+  char                    acID[16];                                 // Initialized to "SEGGER RTT"
+  int                     MaxNumUpBuffers;                          // Initialized to SEGGER_RTT_MAX_NUM_UP_BUFFERS (type. 2)
+  int                     MaxNumDownBuffers;                        // Initialized to SEGGER_RTT_MAX_NUM_DOWN_BUFFERS (type. 2)
+  SEGGER_RTT_BUFFER_UP    aUp[SEGGER_RTT_MAX_NUM_UP_BUFFERS];       // Up buffers, transferring information up from target via debug probe to host
+  SEGGER_RTT_BUFFER_DOWN  aDown[SEGGER_RTT_MAX_NUM_DOWN_BUFFERS];   // Down buffers, transferring information down from host via debug probe to target
+} SEGGER_RTT_CB;
+
+/*********************************************************************
+*
+*       Global data
+*
+**********************************************************************
+*/
+extern SEGGER_RTT_CB _SEGGER_RTT;
+
+/*********************************************************************
+*
+*       RTT API functions
+*
+**********************************************************************
+*/
+#ifdef __cplusplus
+  extern "C" {
+#endif
+int          SEGGER_RTT_AllocDownBuffer         (const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags);
+int          SEGGER_RTT_AllocUpBuffer           (const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags);
+int          SEGGER_RTT_ConfigUpBuffer          (unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags);
+int          SEGGER_RTT_ConfigDownBuffer        (unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags);
+int          SEGGER_RTT_GetKey                  (void);
+unsigned     SEGGER_RTT_HasData                 (unsigned BufferIndex);
+int          SEGGER_RTT_HasKey                  (void);
+unsigned     SEGGER_RTT_HasDataUp               (unsigned BufferIndex);
+void         SEGGER_RTT_Init                    (void);
+unsigned     SEGGER_RTT_Read                    (unsigned BufferIndex,       void* pBuffer, unsigned BufferSize);
+unsigned     SEGGER_RTT_ReadNoLock              (unsigned BufferIndex,       void* pData,   unsigned BufferSize);
+int          SEGGER_RTT_SetNameDownBuffer       (unsigned BufferIndex, const char* sName);
+int          SEGGER_RTT_SetNameUpBuffer         (unsigned BufferIndex, const char* sName);
+int          SEGGER_RTT_SetFlagsDownBuffer      (unsigned BufferIndex, unsigned Flags);
+int          SEGGER_RTT_SetFlagsUpBuffer        (unsigned BufferIndex, unsigned Flags);
+int          SEGGER_RTT_WaitKey                 (void);
+unsigned     SEGGER_RTT_Write                   (unsigned BufferIndex, const void* pBuffer, unsigned NumBytes);
+unsigned     SEGGER_RTT_WriteNoLock             (unsigned BufferIndex, const void* pBuffer, unsigned NumBytes);
+unsigned     SEGGER_RTT_WriteSkipNoLock         (unsigned BufferIndex, const void* pBuffer, unsigned NumBytes);
+unsigned     SEGGER_RTT_ASM_WriteSkipNoLock     (unsigned BufferIndex, const void* pBuffer, unsigned NumBytes);
+unsigned     SEGGER_RTT_WriteString             (unsigned BufferIndex, const char* s);
+void         SEGGER_RTT_WriteWithOverwriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes);
+unsigned     SEGGER_RTT_PutChar                 (unsigned BufferIndex, char c);
+unsigned     SEGGER_RTT_PutCharSkip             (unsigned BufferIndex, char c);
+unsigned     SEGGER_RTT_PutCharSkipNoLock       (unsigned BufferIndex, char c);
+unsigned     SEGGER_RTT_GetAvailWriteSpace      (unsigned BufferIndex);
+unsigned     SEGGER_RTT_GetBytesInBuffer        (unsigned BufferIndex);
+//
+// Function macro for performance optimization
+//
+#define      SEGGER_RTT_HASDATA(n)       (_SEGGER_RTT.aDown[n].WrOff - _SEGGER_RTT.aDown[n].RdOff)
+
+#if RTT_USE_ASM
+  #define SEGGER_RTT_WriteSkipNoLock  SEGGER_RTT_ASM_WriteSkipNoLock
+#endif
+
+/*********************************************************************
+*
+*       RTT transfer functions to send RTT data via other channels.
+*
+**********************************************************************
+*/
+unsigned     SEGGER_RTT_ReadUpBuffer            (unsigned BufferIndex, void* pBuffer, unsigned BufferSize);
+unsigned     SEGGER_RTT_ReadUpBufferNoLock      (unsigned BufferIndex, void* pData, unsigned BufferSize);
+unsigned     SEGGER_RTT_WriteDownBuffer         (unsigned BufferIndex, const void* pBuffer, unsigned NumBytes);
+unsigned     SEGGER_RTT_WriteDownBufferNoLock   (unsigned BufferIndex, const void* pBuffer, unsigned NumBytes);
+
+#define      SEGGER_RTT_HASDATA_UP(n)    (_SEGGER_RTT.aUp[n].WrOff - _SEGGER_RTT.aUp[n].RdOff)
+
+/*********************************************************************
+*
+*       RTT "Terminal" API functions
+*
+**********************************************************************
+*/
+int     SEGGER_RTT_SetTerminal        (unsigned char TerminalId);
+int     SEGGER_RTT_TerminalOut        (unsigned char TerminalId, const char* s);
+
+/*********************************************************************
+*
+*       RTT printf functions (require SEGGER_RTT_printf.c)
+*
+**********************************************************************
+*/
+int SEGGER_RTT_printf(unsigned BufferIndex, const char * sFormat, ...);
+int SEGGER_RTT_vprintf(unsigned BufferIndex, const char * sFormat, va_list * pParamList);
+
+#ifdef __cplusplus
+  }
+#endif
+
+#endif // ifndef(SEGGER_RTT_ASM)
+
+/*********************************************************************
+*
+*       Defines
+*
+**********************************************************************
+*/
+
+//
+// Operating modes. Define behavior if buffer is full (not enough space for entire message)
+//
+#define SEGGER_RTT_MODE_NO_BLOCK_SKIP         (0)     // Skip. Do not block, output nothing. (Default)
+#define SEGGER_RTT_MODE_NO_BLOCK_TRIM         (1)     // Trim: Do not block, output as much as fits.
+#define SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL    (2)     // Block: Wait until there is space in the buffer.
+#define SEGGER_RTT_MODE_MASK                  (3)
+
+//
+// Control sequences, based on ANSI.
+// Can be used to control color, and clear the screen
+//
+#define RTT_CTRL_RESET                "\x1B[0m"         // Reset to default colors
+#define RTT_CTRL_CLEAR                "\x1B[2J"         // Clear screen, reposition cursor to top left
+
+#define RTT_CTRL_TEXT_BLACK           "\x1B[2;30m"
+#define RTT_CTRL_TEXT_RED             "\x1B[2;31m"
+#define RTT_CTRL_TEXT_GREEN           "\x1B[2;32m"
+#define RTT_CTRL_TEXT_YELLOW          "\x1B[2;33m"
+#define RTT_CTRL_TEXT_BLUE            "\x1B[2;34m"
+#define RTT_CTRL_TEXT_MAGENTA         "\x1B[2;35m"
+#define RTT_CTRL_TEXT_CYAN            "\x1B[2;36m"
+#define RTT_CTRL_TEXT_WHITE           "\x1B[2;37m"
+
+#define RTT_CTRL_TEXT_BRIGHT_BLACK    "\x1B[1;30m"
+#define RTT_CTRL_TEXT_BRIGHT_RED      "\x1B[1;31m"
+#define RTT_CTRL_TEXT_BRIGHT_GREEN    "\x1B[1;32m"
+#define RTT_CTRL_TEXT_BRIGHT_YELLOW   "\x1B[1;33m"
+#define RTT_CTRL_TEXT_BRIGHT_BLUE     "\x1B[1;34m"
+#define RTT_CTRL_TEXT_BRIGHT_MAGENTA  "\x1B[1;35m"
+#define RTT_CTRL_TEXT_BRIGHT_CYAN     "\x1B[1;36m"
+#define RTT_CTRL_TEXT_BRIGHT_WHITE    "\x1B[1;37m"
+
+#define RTT_CTRL_BG_BLACK             "\x1B[24;40m"
+#define RTT_CTRL_BG_RED               "\x1B[24;41m"
+#define RTT_CTRL_BG_GREEN             "\x1B[24;42m"
+#define RTT_CTRL_BG_YELLOW            "\x1B[24;43m"
+#define RTT_CTRL_BG_BLUE              "\x1B[24;44m"
+#define RTT_CTRL_BG_MAGENTA           "\x1B[24;45m"
+#define RTT_CTRL_BG_CYAN              "\x1B[24;46m"
+#define RTT_CTRL_BG_WHITE             "\x1B[24;47m"
+
+#define RTT_CTRL_BG_BRIGHT_BLACK      "\x1B[4;40m"
+#define RTT_CTRL_BG_BRIGHT_RED        "\x1B[4;41m"
+#define RTT_CTRL_BG_BRIGHT_GREEN      "\x1B[4;42m"
+#define RTT_CTRL_BG_BRIGHT_YELLOW     "\x1B[4;43m"
+#define RTT_CTRL_BG_BRIGHT_BLUE       "\x1B[4;44m"
+#define RTT_CTRL_BG_BRIGHT_MAGENTA    "\x1B[4;45m"
+#define RTT_CTRL_BG_BRIGHT_CYAN       "\x1B[4;46m"
+#define RTT_CTRL_BG_BRIGHT_WHITE      "\x1B[4;47m"
+
+
+#endif
+
+/*************************** End of file ****************************/
diff --git a/sched/systemview/SEGGER_RTT_ASM_ARMv7M.S b/sched/systemview/SEGGER_RTT_ASM_ARMv7M.S
new file mode 100644
index 0000000000..0c0eae1c25
--- /dev/null
+++ b/sched/systemview/SEGGER_RTT_ASM_ARMv7M.S
@@ -0,0 +1,235 @@
+/*********************************************************************
+*                   (c) SEGGER Microcontroller GmbH                  *
+*                        The Embedded Experts                        *
+*                           www.segger.com                           *
+**********************************************************************
+
+-------------------------- END-OF-HEADER -----------------------------
+
+File    : SEGGER_RTT_ASM_ARMv7M.S
+Purpose : Assembler implementation of RTT functions for ARMv7M
+
+Additional information:
+  This module is written to be assembler-independent and works with
+  GCC and clang (Embedded Studio) and IAR.
+*/
+
+#define SEGGER_RTT_ASM      // Used to control processed input from header file
+#include "SEGGER_RTT.h"
+
+/*********************************************************************
+*
+*       Defines, fixed
+*
+**********************************************************************
+*/
+#define _CCIAR   0
+#define _CCCLANG 1
+
+#if (defined __SES_ARM) || (defined __GNUC__) || (defined __clang__)
+  #define _CC_TYPE             _CCCLANG
+  #define _PUB_SYM             .global
+  #define _EXT_SYM             .extern
+  #define _END                 .end
+  #define _WEAK                .weak
+  #define _THUMB_FUNC          .thumb_func
+  #define _THUMB_CODE          .code 16
+  #define _WORD                .word
+  #define _SECTION(Sect, Type, AlignExp) .section Sect ##, "ax"
+  #define _ALIGN(Exp)          .align Exp 
+  #define _PLACE_LITS          .ltorg
+  #define _DATA_SECT_START 
+  #define _C_STARTUP           _start
+  #define _STACK_END           __stack_end__
+  #define _RAMFUNC
+  //
+  // .text     => Link to flash
+  // .fast     => Link to RAM
+  // OtherSect => Usually link to RAM
+  // Alignment is 2^x
+  //
+#elif defined (__IASMARM__)
+  #define _CC_TYPE             _CCIAR
+  #define _PUB_SYM             PUBLIC
+  #define _EXT_SYM             EXTERN
+  #define _END                 END
+  #define _WEAK                _WEAK
+  #define _THUMB_FUNC
+  #define _THUMB_CODE          THUMB
+  #define _WORD                DCD
+  #define _SECTION(Sect, Type, AlignExp) SECTION Sect ## : ## Type ## :REORDER:NOROOT ## (AlignExp)
+  #define _ALIGN(Exp)          alignrom Exp 
+  #define _PLACE_LITS
+  #define _DATA_SECT_START     DATA
+  #define _C_STARTUP           __iar_program_start
+  #define _STACK_END           sfe(CSTACK)
+  #define _RAMFUNC             SECTION_TYPE SHT_PROGBITS, SHF_WRITE | SHF_EXECINSTR
+  //
+  // .text     => Link to flash
+  // .textrw   => Link to RAM
+  // OtherSect => Usually link to RAM
+  // NOROOT    => Allows linker to throw away the function, if not referenced
+  // Alignment is 2^x
+  //
+#endif
+
+#if (_CC_TYPE == _CCIAR)
+        NAME SEGGER_RTT_ASM_ARMv7M
+#else
+        .syntax unified
+#endif
+
+#if defined (RTT_USE_ASM) && (RTT_USE_ASM == 1)
+        #define SHT_PROGBITS 0x1
+
+/*********************************************************************
+*
+*       Public / external symbols
+*
+**********************************************************************
+*/
+
+        _EXT_SYM __aeabi_memcpy
+        _EXT_SYM __aeabi_memcpy4
+        _EXT_SYM _SEGGER_RTT
+
+        _PUB_SYM SEGGER_RTT_ASM_WriteSkipNoLock
+
+/*********************************************************************
+*
+*       SEGGER_RTT_WriteSkipNoLock
+*
+*  Function description
+*    Stores a specified number of characters in SEGGER RTT
+*    control block which is then read by the host.
+*    SEGGER_RTT_WriteSkipNoLock does not lock the application and
+*    skips all data, if the data does not fit into the buffer.
+*
+*  Parameters
+*    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
+*    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
+*    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
+*                 MUST be > 0!!!
+*                 This is done for performance reasons, so no initial check has do be done.
+*
+*  Return value
+*    1: Data has been copied
+*    0: No space, data has not been copied
+*
+*  Notes
+*    (1) If there is not enough space in the "Up"-buffer, all data is dropped.
+*    (2) For performance reasons this function does not call Init()
+*        and may only be called after RTT has been initialized.
+*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
+*/
+        _SECTION(.text, CODE, 2)
+        _ALIGN(2)
+        _THUMB_FUNC
+SEGGER_RTT_ASM_WriteSkipNoLock:   // unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pData, unsigned NumBytes) {
+        //
+        // Cases:
+        //   1) RdOff <= WrOff => Space until wrap-around is sufficient
+        //   2) RdOff <= WrOff => Space after wrap-around needed (copy in 2 chunks)
+        //   3) RdOff <  WrOff => No space in buf
+        //   4) RdOff >  WrOff => Space is sufficient
+        //   5) RdOff >  WrOff => No space in buf
+        //
+        // 1) is the most common case for large buffers and assuming that J-Link reads the data fast enough
+        //
+        // Register usage:
+        //   R0 Temporary needed as RdOff, <Tmp> register later on
+        //   R1 pData
+        //   R2 <NumBytes>
+        //   R3 <Tmp> register. Hold free for subroutine calls
+        //   R4 <Rem>
+        //   R5 pRing->pBuffer
+        //   R6 pRing (Points to active struct SEGGER_RTT_BUFFER_DOWN)
+        //   R7 WrOff
+        //
+        PUSH     {R4-R7}
+        ADD      R3,R0,R0, LSL #+1
+        LDR.W    R0,=_SEGGER_RTT                 // pRing = &_SEGGER_RTT.aUp[BufferIndex];
+        ADD      R0,R0,R3, LSL #+3
+        ADD      R6,R0,#+24
+        LDR      R0,[R6, #+16]                   // RdOff = pRing->RdOff;
+        LDR      R7,[R6, #+12]                   // WrOff = pRing->WrOff;
+        LDR      R5,[R6, #+4]                    // pRing->pBuffer
+        CMP      R7,R0
+        BCC.N    _CheckCase4                     // if (RdOff <= WrOff) {                           => Case 1), 2) or 3)
+        //
+        // Handling for case 1, later on identical to case 4
+        //
+        LDR      R3,[R6, #+8]                    //  Avail = pRing->SizeOfBuffer - WrOff - 1u;      => Space until wrap-around (assume 1 byte not usable for case that RdOff == 0)
+        SUBS     R4,R3,R7                        // <Rem> (Used in case we jump into case 2 afterwards)
+        SUBS     R3,R4,#+1                       // <Avail>
+        CMP      R3,R2
+        BCC.N    _CheckCase2                     // if (Avail >= NumBytes) {  => Case 1)?
+_Case4:
+        ADDS     R5,R7,R5                        // pBuffer += WrOff
+        ADDS     R0,R2,R7                        // v = WrOff + NumBytes
+        //
+        // 2x unrolling for the copy loop that is used most of the time
+        // This is a special optimization for small SystemView packets and makes them even faster
+        //
+        _ALIGN(2)
+_LoopCopyStraight:                               // memcpy(pRing->pBuffer + WrOff, pData, NumBytes);
+        LDRB     R3,[R1], #+1
+        STRB     R3,[R5], #+1                    // *pDest++ = *pSrc++
+        SUBS     R2,R2,#+1
+        BEQ      _CSDone
+        LDRB     R3,[R1], #+1
+        STRB     R3,[R5], #+1                    // *pDest++ = *pSrc++
+        SUBS     R2,R2,#+1
+        BNE      _LoopCopyStraight
+_CSDone:
+        STR      R0,[R6, #+12]                   // pRing->WrOff = WrOff + NumBytes;
+        MOVS     R0,#+1
+        POP      {R4-R7}
+        BX       LR                              // Return 1
+_CheckCase2:
+        ADDS     R0,R0,R3                        // Avail += RdOff; => Space incl. wrap-around
+        CMP      R0,R2
+        BCC.N    _Case3                          // if (Avail >= NumBytes) {           => Case 2? => If not, we have case 3) (does not fit)
+        //
+        // Handling for case 2
+        //
+        ADDS     R0,R7,R5                        // v = pRing->pBuffer + WrOff => Do not change pRing->pBuffer here because 2nd chunk needs org. value
+        SUBS     R2,R2,R4                        // NumBytes -= Rem;  (Rem = pRing->SizeOfBuffer - WrOff; => Space until end of buffer)
+_LoopCopyBeforeWrapAround:                       // memcpy(pRing->pBuffer + WrOff, pData, Rem); => Copy 1st chunk
+        LDRB     R3,[R1], #+1
+        STRB     R3,[R0], #+1                    // *pDest++ = *pSrc++
+        SUBS     R4,R4,#+1
+        BNE      _LoopCopyBeforeWrapAround
+        //
+        // Special case: First check that assumed RdOff == 0 calculated that last element before wrap-around could not be used
+        // But 2nd check (considering space until wrap-around and until RdOff) revealed that RdOff is not 0, so we can use the last element
+        // In this case, we may use a copy straight until buffer end anyway without needing to copy 2 chunks
+        // Therefore, check if 2nd memcpy is necessary at all
+        //
+        ADDS     R4,R2,#+0                       // Save <NumBytes> (needed as counter in loop but must be written to <WrOff> after the loop). Also use this inst to update the flags to skip 2nd loop if possible
+        BEQ.N    _No2ChunkNeeded                 // if (NumBytes) {
+_LoopCopyAfterWrapAround:                        // memcpy(pRing->pBuffer, pData + Rem, NumBytes);
+        LDRB     R3,[R1], #+1                    // pData already points to the next src byte due to copy loop increment before this loop
+        STRB     R3,[R5], #+1                    // *pDest++ = *pSrc++
+        SUBS     R2,R2,#+1
+        BNE      _LoopCopyAfterWrapAround
+_No2ChunkNeeded:
+        STR      R4,[R6, #+12]                   // pRing->WrOff = NumBytes; => Must be written after copying data because J-Link may read control block asynchronously while writing into buffer
+        MOVS     R0,#+1
+        POP      {R4-R7}
+        BX       LR                              // Return 1
+_CheckCase4:
+        SUBS     R0,R0,R7
+        SUBS     R0,R0,#+1                       // Avail = RdOff - WrOff - 1u;
+        CMP      R0,R2
+        BCS.N    _Case4                          // if (Avail >= NumBytes) {      => Case 4) == 1) ? => If not, we have case 5) == 3) (does not fit)
+_Case3:
+        MOVS     R0,#+0
+        POP      {R4-R7}
+        BX       LR                              // Return 0
+        _PLACE_LITS
+
+#endif  // defined (RTT_USE_ASM) && (RTT_USE_ASM == 1)
+        _END
+
+/*************************** End of file ****************************/
diff --git a/sched/systemview/SEGGER_RTT_Conf.h b/sched/systemview/SEGGER_RTT_Conf.h
new file mode 100644
index 0000000000..03804c8c62
--- /dev/null
+++ b/sched/systemview/SEGGER_RTT_Conf.h
@@ -0,0 +1,388 @@
+/*********************************************************************
+*                    SEGGER Microcontroller GmbH                     *
+*                        The Embedded Experts                        *
+**********************************************************************
+*                                                                    *
+*            (c) 1995 - 2019 SEGGER Microcontroller GmbH             *
+*                                                                    *
+*       www.segger.com     Support: support@segger.com               *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SEGGER SystemView * Real-time application analysis           *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+* All rights reserved.                                               *
+*                                                                    *
+* SEGGER strongly recommends to not make any changes                 *
+* to or modify the source code of this software in order to stay     *
+* compatible with the SystemView and RTT protocol, and J-Link.       *
+*                                                                    *
+* Redistribution and use in source and binary forms, with or         *
+* without modification, are permitted provided that the following    *
+* condition is met:                                                  *
+*                                                                    *
+* o Redistributions of source code must retain the above copyright   *
+*   notice, this condition and the following disclaimer.             *
+*                                                                    *
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
+* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
+* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
+* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
+* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
+* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
+* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
+* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
+* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
+* DAMAGE.                                                            *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SystemView version: V3.12                                    *
+*                                                                    *
+**********************************************************************
+---------------------------END-OF-HEADER------------------------------
+File    : SEGGER_RTT_Conf.h
+Purpose : Implementation of SEGGER real-time transfer (RTT) which
+          allows real-time communication on targets which support
+          debugger memory accesses while the CPU is running.
+Revision: $Rev: 18601 $
+
+*/
+
+#ifndef SEGGER_RTT_CONF_H
+#define SEGGER_RTT_CONF_H
+
+#ifdef __IAR_SYSTEMS_ICC__
+  #include <intrinsics.h>
+#endif
+
+/*********************************************************************
+*
+*       Defines, configurable
+*
+**********************************************************************
+*/
+#ifndef   SEGGER_RTT_MAX_NUM_UP_BUFFERS
+  #define SEGGER_RTT_MAX_NUM_UP_BUFFERS             (3)     // Max. number of up-buffers (T->H) available on this target    (Default: 3)
+#endif
+
+#ifndef   SEGGER_RTT_MAX_NUM_DOWN_BUFFERS
+  #define SEGGER_RTT_MAX_NUM_DOWN_BUFFERS           (3)     // Max. number of down-buffers (H->T) available on this target  (Default: 3)
+#endif
+
+#ifndef   BUFFER_SIZE_UP
+  #define BUFFER_SIZE_UP                            (1024)  // Size of the buffer for terminal output of target, up to host (Default: 1k)
+#endif
+
+#ifndef   BUFFER_SIZE_DOWN
+  #define BUFFER_SIZE_DOWN                          (16)    // Size of the buffer for terminal input to target from host (Usually keyboard input) (Default: 16)
+#endif
+
+#ifndef   SEGGER_RTT_PRINTF_BUFFER_SIZE
+  #define SEGGER_RTT_PRINTF_BUFFER_SIZE             (64u)    // Size of buffer for RTT printf to bulk-send chars via RTT     (Default: 64)
+#endif
+
+#ifndef   SEGGER_RTT_MODE_DEFAULT
+  #define SEGGER_RTT_MODE_DEFAULT                   SEGGER_RTT_MODE_NO_BLOCK_SKIP // Mode for pre-initialized terminal channel (buffer 0)
+#endif
+
+/*********************************************************************
+*
+*       RTT memcpy configuration
+*
+*       memcpy() is good for large amounts of data, 
+*       but the overhead is big for small amounts, which are usually stored via RTT.
+*       With SEGGER_RTT_MEMCPY_USE_BYTELOOP a simple byte loop can be used instead.
+*
+*       SEGGER_RTT_MEMCPY() can be used to replace standard memcpy() in RTT functions.
+*       This is may be required with memory access restrictions, 
+*       such as on Cortex-A devices with MMU.
+*/
+#ifndef   SEGGER_RTT_MEMCPY_USE_BYTELOOP
+  #define SEGGER_RTT_MEMCPY_USE_BYTELOOP              0 // 0: Use memcpy/SEGGER_RTT_MEMCPY, 1: Use a simple byte-loop
+#endif
+//
+// Example definition of SEGGER_RTT_MEMCPY to external memcpy with GCC toolchains and Cortex-A targets
+//
+//#if ((defined __SES_ARM) || (defined __CROSSWORKS_ARM) || (defined __GNUC__)) && (defined (__ARM_ARCH_7A__))  
+//  #define SEGGER_RTT_MEMCPY(pDest, pSrc, NumBytes)      SEGGER_memcpy((pDest), (pSrc), (NumBytes))
+//#endif
+
+//
+// Target is not allowed to perform other RTT operations while string still has not been stored completely.
+// Otherwise we would probably end up with a mixed string in the buffer.
+// If using  RTT from within interrupts, multiple tasks or multi processors, define the SEGGER_RTT_LOCK() and SEGGER_RTT_UNLOCK() function here.
+//
+// SEGGER_RTT_MAX_INTERRUPT_PRIORITY can be used in the sample lock routines on Cortex-M3/4.
+// Make sure to mask all interrupts which can send RTT data, i.e. generate SystemView events, or cause task switches.
+// When high-priority interrupts must not be masked while sending RTT data, SEGGER_RTT_MAX_INTERRUPT_PRIORITY needs to be adjusted accordingly.
+// (Higher priority = lower priority number)
+// Default value for embOS: 128u
+// Default configuration in FreeRTOS: configMAX_SYSCALL_INTERRUPT_PRIORITY: ( configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY << (8 - configPRIO_BITS) )
+// In case of doubt mask all interrupts: 1 << (8 - BASEPRI_PRIO_BITS) i.e. 1 << 5 when 3 bits are implemented in NVIC
+// or define SEGGER_RTT_LOCK() to completely disable interrupts.
+//
+#ifndef   SEGGER_RTT_MAX_INTERRUPT_PRIORITY
+  #define SEGGER_RTT_MAX_INTERRUPT_PRIORITY         (0x20)   // Interrupt priority to lock on SEGGER_RTT_LOCK on Cortex-M3/4 (Default: 0x20)
+#endif
+
+/*********************************************************************
+*
+*       RTT lock configuration for SEGGER Embedded Studio,
+*       Rowley CrossStudio and GCC
+*/
+#if ((defined(__SES_ARM) || defined(__SES_RISCV) || defined(__CROSSWORKS_ARM) || defined(__GNUC__) || defined(__clang__)) && !defined (__CC_ARM) && !defined(WIN32))
+  #if (defined(__ARM_ARCH_6M__) || defined(__ARM_ARCH_8M_BASE__))
+    #define SEGGER_RTT_LOCK()   {                                                                   \
+                                    unsigned int LockState;                                         \
+                                  __asm volatile ("mrs   %0, primask  \n\t"                         \
+                                                  "movs  r1, $1       \n\t"                         \
+                                                  "msr   primask, r1  \n\t"                         \
+                                                  : "=r" (LockState)                                \
+                                                  :                                                 \
+                                                  : "r1"                                            \
+                                                  );
+
+    #define SEGGER_RTT_UNLOCK()   __asm volatile ("msr   primask, %0  \n\t"                         \
+                                                  :                                                 \
+                                                  : "r" (LockState)                                 \
+                                                  :                                                 \
+                                                  );                                                \
+                                }
+  #elif (defined(__ARM_ARCH_7M__) || defined(__ARM_ARCH_7EM__) || defined(__ARM_ARCH_8M_MAIN__))
+    #ifndef   SEGGER_RTT_MAX_INTERRUPT_PRIORITY
+      #define SEGGER_RTT_MAX_INTERRUPT_PRIORITY   (0x20)
+    #endif
+    #define SEGGER_RTT_LOCK()   {                                                                   \
+                                    unsigned int LockState;                                         \
+                                  __asm volatile ("mrs   %0, basepri  \n\t"                         \
+                                                  "mov   r1, %1       \n\t"                         \
+                                                  "msr   basepri, r1  \n\t"                         \
+                                                  : "=r" (LockState)                                \
+                                                  : "i"(SEGGER_RTT_MAX_INTERRUPT_PRIORITY)          \
+                                                  : "r1"                                            \
+                                                  );
+
+    #define SEGGER_RTT_UNLOCK()   __asm volatile ("msr   basepri, %0  \n\t"                         \
+                                                  :                                                 \
+                                                  : "r" (LockState)                                 \
+                                                  :                                                 \
+                                                  );                                                \
+                                }
+
+  #elif defined(__ARM_ARCH_7A__)
+    #define SEGGER_RTT_LOCK() {                                                \
+                                 unsigned int LockState;                       \
+                                 __asm volatile ("mrs r1, CPSR \n\t"           \
+                                                 "mov %0, r1 \n\t"             \
+                                                 "orr r1, r1, #0xC0 \n\t"      \
+                                                 "msr CPSR_c, r1 \n\t"         \
+                                                 : "=r" (LockState)            \
+                                                 :                             \
+                                                 : "r1"                        \
+                                                 );
+
+    #define SEGGER_RTT_UNLOCK() __asm volatile ("mov r0, %0 \n\t"              \
+                                                "mrs r1, CPSR \n\t"            \
+                                                "bic r1, r1, #0xC0 \n\t"       \
+                                                "and r0, r0, #0xC0 \n\t"       \
+                                                "orr r1, r1, r0 \n\t"          \
+                                                "msr CPSR_c, r1 \n\t"          \
+                                                :                              \
+                                                : "r" (LockState)              \
+                                                : "r0", "r1"                   \
+                                                );                             \
+                            }
+  #elif defined(__riscv) || defined(__riscv_xlen)
+    #define SEGGER_RTT_LOCK()  {                                               \
+                                 unsigned int LockState;                       \
+                                 __asm volatile ("csrr  %0, mstatus  \n\t"     \
+                                                 "csrci mstatus, 8   \n\t"     \
+                                                 "andi  %0, %0,  8   \n\t"     \
+                                                 : "=r" (LockState)            \
+                                                 :                             \
+                                                 :                             \
+                                                );
+                               
+  #define SEGGER_RTT_UNLOCK()    __asm volatile ("csrr  a1, mstatus  \n\t"     \
+                                                 "or    %0, %0, a1   \n\t"     \
+                                                 "csrs  mstatus, %0  \n\t"     \
+                                                 :                             \
+                                                 : "r"  (LockState)            \
+                                                 : "a1"                        \
+                                                );                             \
+                               }
+  #else
+    #define SEGGER_RTT_LOCK()
+    #define SEGGER_RTT_UNLOCK()
+  #endif
+#endif
+
+/*********************************************************************
+*
+*       RTT lock configuration for IAR EWARM
+*/
+#ifdef __ICCARM__
+  #if (defined (__ARM6M__)          && (__CORE__ == __ARM6M__))             ||                      \
+      (defined (__ARM8M_BASELINE__) && (__CORE__ == __ARM8M_BASELINE__))
+    #define SEGGER_RTT_LOCK()   {                                                                   \
+                                  unsigned int LockState;                                           \
+                                  LockState = __get_PRIMASK();                                      \
+                                  __set_PRIMASK(1);
+
+    #define SEGGER_RTT_UNLOCK()   __set_PRIMASK(LockState);                                         \
+                                }
+  #elif (defined (__ARM7EM__)         && (__CORE__ == __ARM7EM__))          ||                      \
+        (defined (__ARM7M__)          && (__CORE__ == __ARM7M__))           ||                      \
+        (defined (__ARM8M_MAINLINE__) && (__CORE__ == __ARM8M_MAINLINE__))  ||                      \
+        (defined (__ARM8M_MAINLINE__) && (__CORE__ == __ARM8M_MAINLINE__))
+    #ifndef   SEGGER_RTT_MAX_INTERRUPT_PRIORITY
+      #define SEGGER_RTT_MAX_INTERRUPT_PRIORITY   (0x20)
+    #endif
+    #define SEGGER_RTT_LOCK()   {                                                                   \
+                                  unsigned int LockState;                                           \
+                                  LockState = __get_BASEPRI();                                      \
+                                  __set_BASEPRI(SEGGER_RTT_MAX_INTERRUPT_PRIORITY);
+
+    #define SEGGER_RTT_UNLOCK()   __set_BASEPRI(LockState);                                         \
+                                }
+  #endif
+#endif
+
+/*********************************************************************
+*
+*       RTT lock configuration for IAR RX
+*/
+#ifdef __ICCRX__
+  #define SEGGER_RTT_LOCK()   {                                                                     \
+                                unsigned long LockState;                                            \
+                                LockState = __get_interrupt_state();                                \
+                                __disable_interrupt();
+
+  #define SEGGER_RTT_UNLOCK()   __set_interrupt_state(LockState);                                   \
+                              }
+#endif
+
+/*********************************************************************
+*
+*       RTT lock configuration for IAR RL78
+*/
+#ifdef __ICCRL78__
+  #define SEGGER_RTT_LOCK()   {                                                                     \
+                                __istate_t LockState;                                               \
+                                LockState = __get_interrupt_state();                                \
+                                __disable_interrupt();
+
+  #define SEGGER_RTT_UNLOCK()   __set_interrupt_state(LockState);                                   \
+                              }
+#endif
+
+/*********************************************************************
+*
+*       RTT lock configuration for KEIL ARM
+*/
+#ifdef __CC_ARM
+  #if (defined __TARGET_ARCH_6S_M)
+    #define SEGGER_RTT_LOCK()   {                                                                   \
+                                  unsigned int LockState;                                           \
+                                  register unsigned char PRIMASK __asm( "primask");                 \
+                                  LockState = PRIMASK;                                              \
+                                  PRIMASK = 1u;                                                     \
+                                  __schedule_barrier();
+
+    #define SEGGER_RTT_UNLOCK()   PRIMASK = LockState;                                              \
+                                  __schedule_barrier();                                             \
+                                }
+  #elif (defined(__TARGET_ARCH_7_M) || defined(__TARGET_ARCH_7E_M))
+    #ifndef   SEGGER_RTT_MAX_INTERRUPT_PRIORITY
+      #define SEGGER_RTT_MAX_INTERRUPT_PRIORITY   (0x20)
+    #endif
+    #define SEGGER_RTT_LOCK()   {                                                                   \
+                                  unsigned int LockState;                                           \
+                                  register unsigned char BASEPRI __asm( "basepri");                 \
+                                  LockState = BASEPRI;                                              \
+                                  BASEPRI = SEGGER_RTT_MAX_INTERRUPT_PRIORITY;                      \
+                                  __schedule_barrier();
+
+    #define SEGGER_RTT_UNLOCK()   BASEPRI = LockState;                                              \
+                                  __schedule_barrier();                                             \
+                                }
+  #endif
+#endif
+
+/*********************************************************************
+*
+*       RTT lock configuration for TI ARM
+*/
+#ifdef __TI_ARM__
+  #if defined (__TI_ARM_V6M0__)
+    #define SEGGER_RTT_LOCK()   {                                                                   \
+                                  unsigned int LockState;                                           \
+                                  LockState = __get_PRIMASK();                                      \
+                                  __set_PRIMASK(1);
+
+    #define SEGGER_RTT_UNLOCK()   __set_PRIMASK(LockState);                                         \
+                                }
+  #elif (defined (__TI_ARM_V7M3__) || defined (__TI_ARM_V7M4__))
+    #ifndef   SEGGER_RTT_MAX_INTERRUPT_PRIORITY
+      #define SEGGER_RTT_MAX_INTERRUPT_PRIORITY   (0x20)
+    #endif
+    #define SEGGER_RTT_LOCK()   {                                                                   \
+                                  unsigned int LockState;                                           \
+                                  LockState = _set_interrupt_priority(SEGGER_RTT_MAX_INTERRUPT_PRIORITY);
+
+    #define SEGGER_RTT_UNLOCK()   _set_interrupt_priority(LockState);                               \
+                                }
+  #endif
+#endif
+
+/*********************************************************************
+*
+*       RTT lock configuration for CCRX
+*/
+#ifdef __RX
+  #define SEGGER_RTT_LOCK()   {                                                                     \
+                                unsigned long LockState;                                            \
+                                LockState = get_psw() & 0x010000;                                   \
+                                clrpsw_i();                           
+                                    
+  #define SEGGER_RTT_UNLOCK()   set_psw(get_psw() | LockState);                                     \
+                              }
+#endif
+
+/*********************************************************************
+*
+*       RTT lock configuration for embOS Simulation on Windows
+*       (Can also be used for generic RTT locking with embOS)
+*/
+#if defined(WIN32) || defined(SEGGER_RTT_LOCK_EMBOS)
+
+void OS_SIM_EnterCriticalSection(void);
+void OS_SIM_LeaveCriticalSection(void);
+
+#define SEGGER_RTT_LOCK()       {                                                                   \
+                                  OS_SIM_EnterCriticalSection();
+
+#define SEGGER_RTT_UNLOCK()       OS_SIM_LeaveCriticalSection();                                    \
+                                }
+#endif
+
+/*********************************************************************
+*
+*       RTT lock configuration fallback
+*/
+#ifndef   SEGGER_RTT_LOCK
+  #define SEGGER_RTT_LOCK()                // Lock RTT (nestable)   (i.e. disable interrupts)
+#endif
+
+#ifndef   SEGGER_RTT_UNLOCK
+  #define SEGGER_RTT_UNLOCK()              // Unlock RTT (nestable) (i.e. enable previous interrupt lock state)
+#endif
+
+#endif
+/*************************** End of file ****************************/
diff --git a/sched/systemview/SEGGER_RTT_printf.c b/sched/systemview/SEGGER_RTT_printf.c
new file mode 100644
index 0000000000..85ab7eca3b
--- /dev/null
+++ b/sched/systemview/SEGGER_RTT_printf.c
@@ -0,0 +1,504 @@
+/*********************************************************************
+*                    SEGGER Microcontroller GmbH                     *
+*                        The Embedded Experts                        *
+**********************************************************************
+*                                                                    *
+*            (c) 1995 - 2019 SEGGER Microcontroller GmbH             *
+*                                                                    *
+*       www.segger.com     Support: support@segger.com               *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SEGGER SystemView * Real-time application analysis           *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+* All rights reserved.                                               *
+*                                                                    *
+* SEGGER strongly recommends to not make any changes                 *
+* to or modify the source code of this software in order to stay     *
+* compatible with the SystemView and RTT protocol, and J-Link.       *
+*                                                                    *
+* Redistribution and use in source and binary forms, with or         *
+* without modification, are permitted provided that the following    *
+* condition is met:                                                  *
+*                                                                    *
+* o Redistributions of source code must retain the above copyright   *
+*   notice, this condition and the following disclaimer.             *
+*                                                                    *
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
+* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
+* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
+* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
+* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
+* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
+* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
+* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
+* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
+* DAMAGE.                                                            *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SystemView version: V3.12                                    *
+*                                                                    *
+**********************************************************************
+---------------------------END-OF-HEADER------------------------------
+File    : SEGGER_RTT_printf.c
+Purpose : Replacement for printf to write formatted data via RTT
+Revision: $Rev: 17697 $
+----------------------------------------------------------------------
+*/
+#include "SEGGER_RTT.h"
+#include "SEGGER_RTT_Conf.h"
+
+/*********************************************************************
+*
+*       Defines, configurable
+*
+**********************************************************************
+*/
+
+#ifndef SEGGER_RTT_PRINTF_BUFFER_SIZE
+  #define SEGGER_RTT_PRINTF_BUFFER_SIZE (64)
+#endif
+
+#include <stdlib.h>
+#include <stdarg.h>
+
+
+#define FORMAT_FLAG_LEFT_JUSTIFY   (1u << 0)
+#define FORMAT_FLAG_PAD_ZERO       (1u << 1)
+#define FORMAT_FLAG_PRINT_SIGN     (1u << 2)
+#define FORMAT_FLAG_ALTERNATE      (1u << 3)
+
+/*********************************************************************
+*
+*       Types
+*
+**********************************************************************
+*/
+
+typedef struct {
+  char*     pBuffer;
+  unsigned  BufferSize;
+  unsigned  Cnt;
+
+  int   ReturnValue;
+
+  unsigned RTTBufferIndex;
+} SEGGER_RTT_PRINTF_DESC;
+
+/*********************************************************************
+*
+*       Function prototypes
+*
+**********************************************************************
+*/
+
+/*********************************************************************
+*
+*       Static code
+*
+**********************************************************************
+*/
+/*********************************************************************
+*
+*       _StoreChar
+*/
+static void _StoreChar(SEGGER_RTT_PRINTF_DESC * p, char c) {
+  unsigned Cnt;
+
+  Cnt = p->Cnt;
+  if ((Cnt + 1u) <= p->BufferSize) {
+    *(p->pBuffer + Cnt) = c;
+    p->Cnt = Cnt + 1u;
+    p->ReturnValue++;
+  }
+  //
+  // Write part of string, when the buffer is full
+  //
+  if (p->Cnt == p->BufferSize) {
+    if (SEGGER_RTT_Write(p->RTTBufferIndex, p->pBuffer, p->Cnt) != p->Cnt) {
+      p->ReturnValue = -1;
+    } else {
+      p->Cnt = 0u;
+    }
+  }
+}
+
+/*********************************************************************
+*
+*       _PrintUnsigned
+*/
+static void _PrintUnsigned(SEGGER_RTT_PRINTF_DESC * pBufferDesc, unsigned v, unsigned Base, unsigned NumDigits, unsigned FieldWidth, unsigned FormatFlags) {
+  static const char _aV2C[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
+  unsigned Div;
+  unsigned Digit;
+  unsigned Number;
+  unsigned Width;
+  char c;
+
+  Number = v;
+  Digit = 1u;
+  //
+  // Get actual field width
+  //
+  Width = 1u;
+  while (Number >= Base) {
+    Number = (Number / Base);
+    Width++;
+  }
+  if (NumDigits > Width) {
+    Width = NumDigits;
+  }
+  //
+  // Print leading chars if necessary
+  //
+  if ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u) {
+    if (FieldWidth != 0u) {
+      if (((FormatFlags & FORMAT_FLAG_PAD_ZERO) == FORMAT_FLAG_PAD_ZERO) && (NumDigits == 0u)) {
+        c = '0';
+      } else {
+        c = ' ';
+      }
+      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
+        FieldWidth--;
+        _StoreChar(pBufferDesc, c);
+        if (pBufferDesc->ReturnValue < 0) {
+          break;
+        }
+      }
+    }
+  }
+  if (pBufferDesc->ReturnValue >= 0) {
+    //
+    // Compute Digit.
+    // Loop until Digit has the value of the highest digit required.
+    // Example: If the output is 345 (Base 10), loop 2 times until Digit is 100.
+    //
+    while (1) {
+      if (NumDigits > 1u) {       // User specified a min number of digits to print? => Make sure we loop at least that often, before checking anything else (> 1 check avoids problems with NumDigits being signed / unsigned)
+        NumDigits--;
+      } else {
+        Div = v / Digit;
+        if (Div < Base) {        // Is our divider big enough to extract the highest digit from value? => Done
+          break;
+        }
+      }
+      Digit *= Base;
+    }
+    //
+    // Output digits
+    //
+    do {
+      Div = v / Digit;
+      v -= Div * Digit;
+      _StoreChar(pBufferDesc, _aV2C[Div]);
+      if (pBufferDesc->ReturnValue < 0) {
+        break;
+      }
+      Digit /= Base;
+    } while (Digit);
+    //
+    // Print trailing spaces if necessary
+    //
+    if ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == FORMAT_FLAG_LEFT_JUSTIFY) {
+      if (FieldWidth != 0u) {
+        while ((FieldWidth != 0u) && (Width < FieldWidth)) {
+          FieldWidth--;
+          _StoreChar(pBufferDesc, ' ');
+          if (pBufferDesc->ReturnValue < 0) {
+            break;
+          }
+        }
+      }
+    }
+  }
+}
+
+/*********************************************************************
+*
+*       _PrintInt
+*/
+static void _PrintInt(SEGGER_RTT_PRINTF_DESC * pBufferDesc, int v, unsigned Base, unsigned NumDigits, unsigned FieldWidth, unsigned FormatFlags) {
+  unsigned Width;
+  int Number;
+
+  Number = (v < 0) ? -v : v;
+
+  //
+  // Get actual field width
+  //
+  Width = 1u;
+  while (Number >= (int)Base) {
+    Number = (Number / (int)Base);
+    Width++;
+  }
+  if (NumDigits > Width) {
+    Width = NumDigits;
+  }
+  if ((FieldWidth > 0u) && ((v < 0) || ((FormatFlags & FORMAT_FLAG_PRINT_SIGN) == FORMAT_FLAG_PRINT_SIGN))) {
+    FieldWidth--;
+  }
+
+  //
+  // Print leading spaces if necessary
+  //
+  if ((((FormatFlags & FORMAT_FLAG_PAD_ZERO) == 0u) || (NumDigits != 0u)) && ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u)) {
+    if (FieldWidth != 0u) {
+      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
+        FieldWidth--;
+        _StoreChar(pBufferDesc, ' ');
+        if (pBufferDesc->ReturnValue < 0) {
+          break;
+        }
+      }
+    }
+  }
+  //
+  // Print sign if necessary
+  //
+  if (pBufferDesc->ReturnValue >= 0) {
+    if (v < 0) {
+      v = -v;
+      _StoreChar(pBufferDesc, '-');
+    } else if ((FormatFlags & FORMAT_FLAG_PRINT_SIGN) == FORMAT_FLAG_PRINT_SIGN) {
+      _StoreChar(pBufferDesc, '+');
+    } else {
+
+    }
+    if (pBufferDesc->ReturnValue >= 0) {
+      //
+      // Print leading zeros if necessary
+      //
+      if (((FormatFlags & FORMAT_FLAG_PAD_ZERO) == FORMAT_FLAG_PAD_ZERO) && ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u) && (NumDigits == 0u)) {
+        if (FieldWidth != 0u) {
+          while ((FieldWidth != 0u) && (Width < FieldWidth)) {
+            FieldWidth--;
+            _StoreChar(pBufferDesc, '0');
+            if (pBufferDesc->ReturnValue < 0) {
+              break;
+            }
+          }
+        }
+      }
+      if (pBufferDesc->ReturnValue >= 0) {
+        //
+        // Print number without sign
+        //
+        _PrintUnsigned(pBufferDesc, (unsigned)v, Base, NumDigits, FieldWidth, FormatFlags);
+      }
+    }
+  }
+}
+
+/*********************************************************************
+*
+*       Public code
+*
+**********************************************************************
+*/
+/*********************************************************************
+*
+*       SEGGER_RTT_vprintf
+*
+*  Function description
+*    Stores a formatted string in SEGGER RTT control block.
+*    This data is read by the host.
+*
+*  Parameters
+*    BufferIndex  Index of "Up"-buffer to be used. (e.g. 0 for "Terminal")
+*    sFormat      Pointer to format string
+*    pParamList   Pointer to the list of arguments for the format string
+*
+*  Return values
+*    >= 0:  Number of bytes which have been stored in the "Up"-buffer.
+*     < 0:  Error
+*/
+int SEGGER_RTT_vprintf(unsigned BufferIndex, const char * sFormat, va_list * pParamList) {
+  char c;
+  SEGGER_RTT_PRINTF_DESC BufferDesc;
+  int v;
+  unsigned NumDigits;
+  unsigned FormatFlags;
+  unsigned FieldWidth;
+  char acBuffer[SEGGER_RTT_PRINTF_BUFFER_SIZE];
+
+  BufferDesc.pBuffer        = acBuffer;
+  BufferDesc.BufferSize     = SEGGER_RTT_PRINTF_BUFFER_SIZE;
+  BufferDesc.Cnt            = 0u;
+  BufferDesc.RTTBufferIndex = BufferIndex;
+  BufferDesc.ReturnValue    = 0;
+
+  do {
+    c = *sFormat;
+    sFormat++;
+    if (c == 0u) {
+      break;
+    }
+    if (c == '%') {
+      //
+      // Filter out flags
+      //
+      FormatFlags = 0u;
+      v = 1;
+      do {
+        c = *sFormat;
+        switch (c) {
+        case '-': FormatFlags |= FORMAT_FLAG_LEFT_JUSTIFY; sFormat++; break;
+        case '0': FormatFlags |= FORMAT_FLAG_PAD_ZERO;     sFormat++; break;
+        case '+': FormatFlags |= FORMAT_FLAG_PRINT_SIGN;   sFormat++; break;
+        case '#': FormatFlags |= FORMAT_FLAG_ALTERNATE;    sFormat++; break;
+        default:  v = 0; break;
+        }
+      } while (v);
+      //
+      // filter out field with
+      //
+      FieldWidth = 0u;
+      do {
+        c = *sFormat;
+        if ((c < '0') || (c > '9')) {
+          break;
+        }
+        sFormat++;
+        FieldWidth = (FieldWidth * 10u) + ((unsigned)c - '0');
+      } while (1);
+
+      //
+      // Filter out precision (number of digits to display)
+      //
+      NumDigits = 0u;
+      c = *sFormat;
+      if (c == '.') {
+        sFormat++;
+        do {
+          c = *sFormat;
+          if ((c < '0') || (c > '9')) {
+            break;
+          }
+          sFormat++;
+          NumDigits = NumDigits * 10u + ((unsigned)c - '0');
+        } while (1);
+      }
+      //
+      // Filter out length modifier
+      //
+      c = *sFormat;
+      do {
+        if ((c == 'l') || (c == 'h')) {
+          sFormat++;
+          c = *sFormat;
+        } else {
+          break;
+        }
+      } while (1);
+      //
+      // Handle specifiers
+      //
+      switch (c) {
+      case 'c': {
+        char c0;
+        v = va_arg(*pParamList, int);
+        c0 = (char)v;
+        _StoreChar(&BufferDesc, c0);
+        break;
+      }
+      case 'd':
+        v = va_arg(*pParamList, int);
+        _PrintInt(&BufferDesc, v, 10u, NumDigits, FieldWidth, FormatFlags);
+        break;
+      case 'u':
+        v = va_arg(*pParamList, int);
+        _PrintUnsigned(&BufferDesc, (unsigned)v, 10u, NumDigits, FieldWidth, FormatFlags);
+        break;
+      case 'x':
+      case 'X':
+        v = va_arg(*pParamList, int);
+        _PrintUnsigned(&BufferDesc, (unsigned)v, 16u, NumDigits, FieldWidth, FormatFlags);
+        break;
+      case 's':
+        {
+          const char * s = va_arg(*pParamList, const char *);
+          do {
+            c = *s;
+            s++;
+            if (c == '\0') {
+              break;
+            }
+           _StoreChar(&BufferDesc, c);
+          } while (BufferDesc.ReturnValue >= 0);
+        }
+        break;
+      case 'p':
+        v = va_arg(*pParamList, int);
+        _PrintUnsigned(&BufferDesc, (unsigned)v, 16u, 8u, 8u, 0u);
+        break;
+      case '%':
+        _StoreChar(&BufferDesc, '%');
+        break;
+      default:
+        break;
+      }
+      sFormat++;
+    } else {
+      _StoreChar(&BufferDesc, c);
+    }
+  } while (BufferDesc.ReturnValue >= 0);
+
+  if (BufferDesc.ReturnValue > 0) {
+    //
+    // Write remaining data, if any
+    //
+    if (BufferDesc.Cnt != 0u) {
+      SEGGER_RTT_Write(BufferIndex, acBuffer, BufferDesc.Cnt);
+    }
+    BufferDesc.ReturnValue += (int)BufferDesc.Cnt;
+  }
+  return BufferDesc.ReturnValue;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_printf
+*
+*  Function description
+*    Stores a formatted string in SEGGER RTT control block.
+*    This data is read by the host.
+*
+*  Parameters
+*    BufferIndex  Index of "Up"-buffer to be used. (e.g. 0 for "Terminal")
+*    sFormat      Pointer to format string, followed by the arguments for conversion
+*
+*  Return values
+*    >= 0:  Number of bytes which have been stored in the "Up"-buffer.
+*     < 0:  Error
+*
+*  Notes
+*    (1) Conversion specifications have following syntax:
+*          %[flags][FieldWidth][.Precision]ConversionSpecifier
+*    (2) Supported flags:
+*          -: Left justify within the field width
+*          +: Always print sign extension for signed conversions
+*          0: Pad with 0 instead of spaces. Ignored when using '-'-flag or precision
+*        Supported conversion specifiers:
+*          c: Print the argument as one char
+*          d: Print the argument as a signed integer
+*          u: Print the argument as an unsigned integer
+*          x: Print the argument as an hexadecimal integer
+*          s: Print the string pointed to by the argument
+*          p: Print the argument as an 8-digit hexadecimal integer. (Argument shall be a pointer to void.)
+*/
+int SEGGER_RTT_printf(unsigned BufferIndex, const char * sFormat, ...) {
+  int r;
+  va_list ParamList;
+
+  va_start(ParamList, sFormat);
+  r = SEGGER_RTT_vprintf(BufferIndex, sFormat, &ParamList);
+  va_end(ParamList);
+  return r;
+}
+/*************************** End of file ****************************/
diff --git a/sched/systemview/SEGGER_SYSVIEW.c b/sched/systemview/SEGGER_SYSVIEW.c
new file mode 100644
index 0000000000..e2f3657a30
--- /dev/null
+++ b/sched/systemview/SEGGER_SYSVIEW.c
@@ -0,0 +1,2945 @@
+/*********************************************************************
+*                    SEGGER Microcontroller GmbH                     *
+*                        The Embedded Experts                        *
+**********************************************************************
+*                                                                    *
+*            (c) 1995 - 2019 SEGGER Microcontroller GmbH             *
+*                                                                    *
+*       www.segger.com     Support: support@segger.com               *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SEGGER SystemView * Real-time application analysis           *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+* All rights reserved.                                               *
+*                                                                    *
+* SEGGER strongly recommends to not make any changes                 *
+* to or modify the source code of this software in order to stay     *
+* compatible with the SystemView and RTT protocol, and J-Link.       *
+*                                                                    *
+* Redistribution and use in source and binary forms, with or         *
+* without modification, are permitted provided that the following    *
+* condition is met:                                                  *
+*                                                                    *
+* o Redistributions of source code must retain the above copyright   *
+*   notice, this condition and the following disclaimer.             *
+*                                                                    *
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
+* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
+* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
+* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
+* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
+* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
+* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
+* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
+* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
+* DAMAGE.                                                            *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SystemView version: V3.12                                    *
+*                                                                    *
+**********************************************************************
+-------------------------- END-OF-HEADER -----------------------------
+
+File    : SEGGER_SYSVIEW.c
+Purpose : System visualization API implementation.
+Revision: $Rev: 17331 $
+
+Additional information:
+  Packet format:
+    Packets with IDs 0..23 are standard packets with known structure.
+    For efficiency, they do *NOT* contain a length field.
+    <ID><Data><TimeStampDelta>
+
+    Packets with IDs 24..31 are standard packets with extendible
+    structure and contain a length field.
+    <ID><Lenght><Data><TimeStampDelta>
+    
+    Packet ID 31 is used for SystemView extended events.
+    <ID><Lenght><ID_EX><Data><TimeStampDelta>
+
+    Packets with IDs >= 32 always contain a length field.
+    <ID><Length><Data><TimeStampDelta>
+
+  Packet IDs:
+       0..  31 : Standard packets, known by SystemView.
+      32..1023 : OS-definable packets, described in a SystemView description file.
+    1024..2047 : User-definable packets, described in a SystemView description file.
+    2048..32767: Undefined.
+
+  Data encoding:
+    Basic types (int, short, char, ...):
+      Basic types are encoded little endian with most-significant bit variant
+      encoding.
+      Each encoded byte contains 7 data bits [6:0] and the MSB continuation bit.
+      The continuation bit indicates whether the next byte belongs to the data
+      (bit set) or this is the last byte (bit clear).
+      The most significant bits of data are encoded first, proceeding to the
+      least significant bits in the final byte (little endian).
+
+      Example encoding:
+        Data: 0x1F4 (500)
+        Encoded: 0xF4 (First 7 data bits 74 | Continuation bit)
+                 0x03 (Second 7 data bits 03, no continuation)
+
+        Data: 0xFFFFFFFF
+        Encoded: 0xFF 0xFF 0xFF 0xFF 0x0F
+
+        Data: 0xA2 (162),   0x03 (3), 0x7000
+        Encoded: 0xA2 0x01  0x03      0x80 0xE0 0x01
+
+    Byte arrays and strings:
+      Byte arrays and strings are encoded as <NumBytes> followed by the raw data.
+      NumBytes is encoded as a basic type with a theoretical maximum of 4G.
+
+      Example encoding:
+        Data: "Hello World\0" (0x48 0x65 0x6C 0x6C 0x6F 0x20 0x57 0x6F 0x72 0x6C 0x64 0x00)
+        Encoded: 0x0B 0x48 0x65 0x6C 0x6C 0x6F 0x20 0x57 0x6F 0x72 0x6C 0x64
+
+  Examples packets:
+  01 F4 03 80 80 10 // Overflow packet. Data is a single U32.
+                       This packet means: 500 packets lost, Timestamp is 0x40000
+
+  02 0F 50          // ISR(15) Enter. Timestamp 80 (0x50)
+
+  03 20             // ISR Exit. Timestamp 32 (0x20) (Shortest possible packet.)
+
+  Sample code for user defined Packets:
+    #define MY_ID   0x400                // Any value between 0x400 and 0x7FF
+    void SendMyPacket(unsigned Para0, unsigned Para1, const char* s) {
+      U8  aPacket[SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32 + MAX_STR_LEN + 1];
+      U8* pPayload;
+      //
+      pPayload = SEGGER_SYSVIEW_PPREPARE_PACKET(aPacket);               // Prepare the packet for SystemView
+      pPayload = SEGGER_SYSVIEW_EncodeU32(pPayload, Para0);             // Add the first parameter to the packet
+      pPayload = SEGGER_SYSVIEW_EncodeU32(pPayload, Para1);             // Add the second parameter to the packet
+      pPayload = SEGGER_SYSVIEW_EncodeString(pPayload, s, MAX_STR_LEN); // Add the string to the packet
+      //
+      SEGGER_SYSVIEW_SendPacket(&aPacket[0], pPayload, MY_ID);          // Send the packet with EventId = MY_ID
+    }
+
+    #define MY_ID_1 0x401
+    void SendOnePara(unsigned Para0) {
+      SEGGER_SYSVIEW_RecordU32(MY_ID_1, Para0);
+    }
+
+*/
+
+/*********************************************************************
+*
+*       #include section
+*
+**********************************************************************
+*/
+
+#include "SEGGER_SYSVIEW_Int.h"
+#include "SEGGER_RTT.h"
+#include <string.h>
+#include <stdlib.h>
+#include <stdarg.h>
+
+/*********************************************************************
+*
+*       Defines, fixed
+*
+**********************************************************************
+*/
+#if SEGGER_SYSVIEW_ID_SHIFT
+  #define SHRINK_ID(Id)   (((Id) - _SYSVIEW_Globals.RAMBaseAddress) >> SEGGER_SYSVIEW_ID_SHIFT)
+#else
+  #define SHRINK_ID(Id)   ((Id) - _SYSVIEW_Globals.RAMBaseAddress)
+#endif
+
+#if SEGGER_SYSVIEW_RTT_CHANNEL > 0
+  #define CHANNEL_ID_UP   SEGGER_SYSVIEW_RTT_CHANNEL
+  #define CHANNEL_ID_DOWN SEGGER_SYSVIEW_RTT_CHANNEL
+#else
+  #define CHANNEL_ID_UP   _SYSVIEW_Globals.UpChannel
+  #define CHANNEL_ID_DOWN _SYSVIEW_Globals.DownChannel
+#endif
+
+/*********************************************************************
+*
+*       Defines, configurable
+*
+**********************************************************************
+*/
+// Timestamps may be less than full 32-bits, in which case we need to zero
+// the unused bits to properly handle overflows.
+// Note that this is a quite common scenario, as a 32-bit time such as
+// SysTick might be scaled down to reduce bandwith
+// or a 16-bit hardware time might be used.
+#if SEGGER_SYSVIEW_TIMESTAMP_BITS < 32  // Eliminate unused bits in case hardware timestamps are less than 32 bits
+  #define MAKE_DELTA_32BIT(Delta) Delta <<= 32 - SEGGER_SYSVIEW_TIMESTAMP_BITS; \
+                                  Delta >>= 32 - SEGGER_SYSVIEW_TIMESTAMP_BITS;
+#else
+  #define MAKE_DELTA_32BIT(Delta)
+#endif
+
+
+/*********************************************************************
+*
+*       Defines, fixed
+*
+**********************************************************************
+*/
+#define ENABLE_STATE_OFF        0
+#define ENABLE_STATE_ON         1
+#define ENABLE_STATE_DROPPING   2
+
+#define FORMAT_FLAG_LEFT_JUSTIFY   (1u << 0)
+#define FORMAT_FLAG_PAD_ZERO       (1u << 1)
+#define FORMAT_FLAG_PRINT_SIGN     (1u << 2)
+#define FORMAT_FLAG_ALTERNATE      (1u << 3)
+
+#define MODULE_EVENT_OFFSET        (512)
+
+/*********************************************************************
+*
+*       Types, local
+*
+**********************************************************************
+*/
+typedef struct {
+  U8*       pBuffer;
+  U8*       pPayload;
+  U8*       pPayloadStart;
+  U32       Options;
+  unsigned  Cnt;
+} SEGGER_SYSVIEW_PRINTF_DESC;
+
+typedef struct {
+        U8                      EnableState;   // 0: Disabled, 1: Enabled, (2: Dropping)
+        U8                      UpChannel;
+        U8                      RecursionCnt;
+        U32                     SysFreq;
+        U32                     CPUFreq;
+        U32                     LastTxTimeStamp;
+        U32                     RAMBaseAddress;
+#if (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
+        U32                     PacketCount;
+#else
+        U32                     DropCount;
+        U8                      DownChannel;
+#endif
+        U32                     DisabledEvents;
+  const SEGGER_SYSVIEW_OS_API*  pOSAPI;
+        SEGGER_SYSVIEW_SEND_SYS_DESC_FUNC*   pfSendSysDesc;
+} SEGGER_SYSVIEW_GLOBALS;
+
+/*********************************************************************
+*
+*       Function prototypes, required
+*
+**********************************************************************
+*/
+static void _SendPacket(U8* pStartPacket, U8* pEndPacket, unsigned int EventId);
+
+/*********************************************************************
+*
+*       Static data
+*
+**********************************************************************
+*/
+static const U8 _abSync[10] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+
+#ifdef SEGGER_SYSVIEW_SECTION
+  #if (defined __GNUC__)
+    __attribute__ ((section (SEGGER_SYSVIEW_SECTION))) static char _UpBuffer  [SEGGER_SYSVIEW_RTT_BUFFER_SIZE];
+    #if (SEGGER_SYSVIEW_POST_MORTEM_MODE != 1)
+    __attribute__ ((section (SEGGER_SYSVIEW_SECTION))) static char _DownBuffer[8];  // Small, fixed-size buffer, for back-channel comms
+    #endif
+  #elif (defined __ICCARM__) || (defined __ICCRX__)
+    #pragma location=SEGGER_SYSVIEW_SECTION
+    static char _UpBuffer  [SEGGER_SYSVIEW_RTT_BUFFER_SIZE];
+    #pragma location=SEGGER_SYSVIEW_SECTION
+    static char _DownBuffer[8];  // Small, fixed-size buffer, for back-channel comms
+  #elif (defined __CC_ARM)
+    __attribute__ ((section (SEGGER_SYSVIEW_SECTION), zero_init)) static char _UpBuffer  [SEGGER_SYSVIEW_RTT_BUFFER_SIZE];
+    #if (SEGGER_SYSVIEW_POST_MORTEM_MODE != 1)
+    __attribute__ ((section (SEGGER_SYSVIEW_SECTION), zero_init)) static char _DownBuffer[8];  // Small, fixed-size buffer, for back-channel comms
+    #endif
+  #else
+    static char _UpBuffer  [SEGGER_SYSVIEW_RTT_BUFFER_SIZE];
+    #if (SEGGER_SYSVIEW_POST_MORTEM_MODE != 1)
+    static char _DownBuffer[8];  // Small, fixed-size buffer, for back-channel comms
+    #endif
+  #endif
+#else
+    static char _UpBuffer  [SEGGER_SYSVIEW_RTT_BUFFER_SIZE];
+    #if (SEGGER_SYSVIEW_POST_MORTEM_MODE != 1)
+    static char _DownBuffer[8];  // Small, fixed-size buffer, for back-channel comms
+    #endif
+#endif
+
+static SEGGER_SYSVIEW_GLOBALS _SYSVIEW_Globals;
+
+static SEGGER_SYSVIEW_MODULE* _pFirstModule;
+static U8                     _NumModules;
+
+/*********************************************************************
+*
+*       Static code
+*
+**********************************************************************
+*/
+
+#define ENCODE_U32(pDest, Value) {                                                  \
+                                   U8* pSysviewPointer;                             \
+                                   U32 SysViewData;                                 \
+                                   pSysviewPointer = pDest;                         \
+                                   SysViewData = Value;                             \
+                                   while(SysViewData > 0x7F) {                      \
+                                     *pSysviewPointer++ = (U8)(SysViewData | 0x80); \
+                                     SysViewData >>= 7;                             \
+                                   };                                               \
+                                   *pSysviewPointer++ = (U8)SysViewData;            \
+                                   pDest = pSysviewPointer;                         \
+                                 };
+
+
+
+#if (SEGGER_SYSVIEW_USE_STATIC_BUFFER == 1)
+static U8 _aPacket[SEGGER_SYSVIEW_MAX_PACKET_SIZE];
+
+#define RECORD_START(PacketSize)  SEGGER_SYSVIEW_LOCK();                            \
+                                  pPayloadStart = _PreparePacket(_aPacket);
+
+#define RECORD_END()              SEGGER_SYSVIEW_UNLOCK()
+
+#else
+
+#define RECORD_START(PacketSize)  U8 aPacket[(PacketSize)];                         \
+                                  pPayloadStart = _PreparePacket(aPacket);          \
+
+#define RECORD_END()
+
+#endif
+
+/*********************************************************************
+*
+*       _EncodeData()
+*
+*  Function description
+*    Encode a byte buffer in variable-length format.
+*
+*  Parameters
+*    pPayload - Pointer to where string will be encoded.
+*    pSrc     - Pointer to data buffer to be encoded.
+*    NumBytes - Number of bytes in the buffer to be encoded.
+*
+*  Return value
+*    Pointer to the byte following the value, i.e. the first free
+*    byte in the payload and the next position to store payload
+*    content.
+*
+*  Additional information
+*    The data is encoded as a count byte followed by the contents
+*    of the data buffer.
+*    Make sure NumBytes + 1 bytes are free for the payload.
+*/
+static U8* _EncodeData(U8* pPayload, const char* pSrc, unsigned int NumBytes) {
+  unsigned int n;
+  //
+  n = 0;
+  *pPayload++ = NumBytes;
+  while (n < NumBytes) {
+    *pPayload++ = *pSrc++;
+    n++;
+  }
+  return pPayload;
+}
+
+/*********************************************************************
+*
+*       _EncodeStr()
+*
+*  Function description
+*    Encode a string in variable-length format.
+*
+*  Parameters
+*    pPayload - Pointer to where string will be encoded.
+*    pText    - String to encode.
+*    Limit    - Maximum number of characters to encode from string.
+*
+*  Return value
+*    Pointer to the byte following the value, i.e. the first free
+*    byte in the payload and the next position to store payload
+*    content.
+*
+*  Additional information
+*    The string is encoded as a count byte followed by the contents
+*    of the string.
+*    No more than 1 + Limit bytes will be encoded to the payload.
+*/
+static U8 *_EncodeStr(U8 *pPayload, const char *pText, unsigned int Limit) {
+  unsigned int n;
+  unsigned int Len;
+  //
+  // Compute string len
+  //
+  Len = 0;
+  while(*(pText + Len) != 0) {
+    Len++;
+  }
+  if (Len > Limit) {
+    Len = Limit;
+  }
+  //
+  // Write Len
+  //
+  if (Len < 255)  {
+    *pPayload++ = Len; 
+  } else {
+    *pPayload++ = 255;
+    *pPayload++ = (Len & 255);
+    *pPayload++ = ((Len >> 8) & 255);
+  }
+  //
+  // copy string
+  //
+  n = 0;
+  while (n < Len) {
+    *pPayload++ = *pText++;
+    n++;
+  }
+  return pPayload;
+}
+
+/*********************************************************************
+*
+*       _PreparePacket()
+*
+*  Function description
+*    Prepare a SystemView event packet header.
+*
+*  Parameters
+*    pPacket - Pointer to start of packet to initialize.
+*
+*  Return value
+*    Pointer to first byte of packet payload.
+*
+*  Additional information
+*    The payload length and evnetId are not initialized.
+*    PreparePacket only reserves space for them and they are
+*    computed and filled in by the sending function.
+*/
+static U8* _PreparePacket(U8* pPacket) {
+  return pPacket + 4;
+}
+
+/*********************************************************************
+*
+*       _HandleIncomingPacket()
+*
+*  Function description
+*    Read an incoming command from the down channel and process it.
+*
+*  Additional information
+*    This function is called each time after sending a packet.
+*    Processing incoming packets is done asynchronous. SystemView might
+*    already have sent event packets after the host has sent a command.
+*/
+#if (SEGGER_SYSVIEW_POST_MORTEM_MODE != 1)
+static void _HandleIncomingPacket(void) {
+  U8  Cmd;
+  int Status;
+  //
+  Status = SEGGER_RTT_ReadNoLock(CHANNEL_ID_DOWN, &Cmd, 1);
+  if (Status > 0) {
+    switch (Cmd) {
+    case SEGGER_SYSVIEW_COMMAND_ID_START:
+      SEGGER_SYSVIEW_Start();
+      break;
+    case SEGGER_SYSVIEW_COMMAND_ID_STOP:
+      SEGGER_SYSVIEW_Stop();
+      break;
+    case SEGGER_SYSVIEW_COMMAND_ID_GET_SYSTIME:
+      SEGGER_SYSVIEW_RecordSystime();
+      break;
+    case SEGGER_SYSVIEW_COMMAND_ID_GET_TASKLIST:
+      SEGGER_SYSVIEW_SendTaskList();
+      break;
+    case SEGGER_SYSVIEW_COMMAND_ID_GET_SYSDESC:
+      SEGGER_SYSVIEW_GetSysDesc();
+      break;
+    case SEGGER_SYSVIEW_COMMAND_ID_GET_NUMMODULES:
+      SEGGER_SYSVIEW_SendNumModules();
+      break;
+    case SEGGER_SYSVIEW_COMMAND_ID_GET_MODULEDESC:
+      SEGGER_SYSVIEW_SendModuleDescription();
+      break;
+    case SEGGER_SYSVIEW_COMMAND_ID_GET_MODULE:
+      Status = SEGGER_RTT_ReadNoLock(CHANNEL_ID_DOWN, &Cmd, 1);
+      if (Status > 0) {
+        SEGGER_SYSVIEW_SendModule(Cmd);
+      }
+      break;
+    default:
+      if (Cmd >= 128) { // Unknown extended command. Dummy read its parameter.
+        SEGGER_RTT_ReadNoLock(CHANNEL_ID_DOWN, &Cmd, 1);
+      }
+      break;
+    }
+  }
+}
+#endif // (SEGGER_SYSVIEW_POST_MORTEM_MODE != 1)
+
+/*********************************************************************
+*
+*       _TrySendOverflowPacket()
+*
+*  Function description
+*    Try to transmit an SystemView Overflow packet containing the
+*    number of dropped packets.
+*
+*  Additional information
+*    Format as follows:
+*      01 <DropCnt><TimeStamp>  Max. packet len is 1 + 5 + 5 = 11
+*
+*    Example packets sent
+*      01 20 40
+*
+*  Return value
+*    !=0:  Success, Message sent (stored in RTT-Buffer)
+*    ==0:  Buffer full, Message *NOT* stored
+*
+*/
+#if (SEGGER_SYSVIEW_POST_MORTEM_MODE != 1)
+static int _TrySendOverflowPacket(void) {
+  U32 TimeStamp;
+  I32 Delta;
+  int Status;
+  U8  aPacket[11];
+  U8* pPayload;
+
+  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
+  pPayload   = &aPacket[1];
+  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
+  //
+  // Compute time stamp delta and append it to packet.
+  //
+  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
+  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
+  MAKE_DELTA_32BIT(Delta);
+  ENCODE_U32(pPayload, Delta);
+  //
+  // Try to store packet in RTT buffer and update time stamp when this was successful
+  //
+  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
+  SEGGER_SYSVIEW_ON_EVENT_RECORDED(pPayload - aPacket);
+  if (Status) {
+    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
+    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
+  } else {
+    _SYSVIEW_Globals.DropCount++;
+  }
+  //
+  return Status;
+}
+#endif  // (SEGGER_SYSVIEW_POST_MORTEM_MODE != 1)
+
+/*********************************************************************
+*
+*       _SendSyncInfo()
+*
+*  Function description
+*    Send SystemView sync packet and system information in 
+*    post mortem mode.
+*
+*  Additional information
+*    Sync is 10 * 0x00 without timestamp
+*/
+#if (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
+static void _SendSyncInfo(void) {
+  //
+  // Add sync packet ( 10 * 0x00)
+  // Send system description
+  // Send system time
+  // Send task list
+  // Send module description
+  // Send module information
+  //
+  SEGGER_RTT_WriteWithOverwriteNoLock(CHANNEL_ID_UP, _abSync, 10);
+  SEGGER_SYSVIEW_ON_EVENT_RECORDED(10);
+  SEGGER_SYSVIEW_RecordVoid(SYSVIEW_EVTID_TRACE_START);
+  {
+    U8* pPayload;
+    U8* pPayloadStart;
+    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 4 * SEGGER_SYSVIEW_QUANTA_U32);
+    //
+    pPayload = pPayloadStart;
+    ENCODE_U32(pPayload, _SYSVIEW_Globals.SysFreq);
+    ENCODE_U32(pPayload, _SYSVIEW_Globals.CPUFreq);
+    ENCODE_U32(pPayload, _SYSVIEW_Globals.RAMBaseAddress);
+    ENCODE_U32(pPayload, SEGGER_SYSVIEW_ID_SHIFT);
+    _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_INIT);
+    RECORD_END();
+  }
+  if (_SYSVIEW_Globals.pfSendSysDesc) {
+    _SYSVIEW_Globals.pfSendSysDesc();
+  }
+  SEGGER_SYSVIEW_RecordSystime();
+  SEGGER_SYSVIEW_SendTaskList();
+  if (_NumModules > 0) {
+    int n;
+    SEGGER_SYSVIEW_SendNumModules();
+    for (n = 0; n < _NumModules; n++) {
+      SEGGER_SYSVIEW_SendModule(n);
+    }
+    SEGGER_SYSVIEW_SendModuleDescription();
+  }
+}
+#endif  // (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
+
+/*********************************************************************
+*
+*       _SendPacket()
+*
+*  Function description
+*    Send a SystemView packet over RTT. RTT channel and mode are
+*    configured by macros when the SystemView component is initialized.
+*    This function takes care of maintaining the packet drop count
+*    and sending overflow packets when necessary.
+*    The packet must be passed without Id and Length because this
+*    function prepends it to the packet before transmission.
+*
+*  Parameters
+*    pStartPacket - Pointer to start of packet payload.
+*                   There must be at least 4 bytes free to prepend Id and Length.
+*    pEndPacket   - Pointer to end of packet payload.
+*    EventId      - Id of the event to send.
+*
+*/
+static void _SendPacket(U8* pStartPacket, U8* pEndPacket, unsigned int EventId) {
+  unsigned int  NumBytes;
+  U32           TimeStamp;
+  U32           Delta;
+#if (SEGGER_SYSVIEW_POST_MORTEM_MODE != 1)
+  int           Status;
+#endif
+
+#if (SEGGER_SYSVIEW_USE_STATIC_BUFFER == 0)
+  SEGGER_SYSVIEW_LOCK();
+#endif
+
+#if (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
+  if (_SYSVIEW_Globals.EnableState == 0) {
+    goto SendDone;
+  }
+#else
+  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
+    goto Send;
+  }
+  if (_SYSVIEW_Globals.EnableState == 0) {
+    goto SendDone;
+  }
+  //
+  // Handle buffer full situations:
+  // Have packets been dropped before because buffer was full?
+  // In this case try to send and overflow packet.
+  //
+  if (_SYSVIEW_Globals.EnableState == 2) {
+    _TrySendOverflowPacket();
+    if (_SYSVIEW_Globals.EnableState != 1) {
+      goto SendDone;
+    }
+  }
+Send:
+#endif
+  //
+  // Check if event is disabled from being recorded.
+  //
+  if (EventId < 32) {
+    if (_SYSVIEW_Globals.DisabledEvents & ((U32)1u << EventId)) {
+      goto SendDone;
+    }
+  }
+  //
+  // Prepare actual packet.
+  // If it is a known packet, prepend eventId only,
+  // otherwise prepend packet length and eventId.
+  //
+  if (EventId < 24) {
+    *--pStartPacket = EventId;
+  } else {
+    NumBytes = pEndPacket - pStartPacket;
+    if (NumBytes > 127) {
+      *--pStartPacket = (NumBytes >> 7);
+      *--pStartPacket = NumBytes | 0x80;
+    } else {
+      *--pStartPacket = NumBytes;
+    }
+    if (EventId > 127) {
+      *--pStartPacket = (EventId >> 7);
+      *--pStartPacket = EventId | 0x80;
+    } else {
+      *--pStartPacket = EventId;
+    }
+  }
+  //
+  // Compute time stamp delta and append it to packet.
+  //
+  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
+  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
+  MAKE_DELTA_32BIT(Delta);
+  ENCODE_U32(pEndPacket, Delta);
+#if (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
+  //
+  // Store packet in RTT buffer by overwriting old data and update time stamp
+  //
+  SEGGER_RTT_WriteWithOverwriteNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
+  SEGGER_SYSVIEW_ON_EVENT_RECORDED(pEndPacket - pStartPacket);
+  _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
+#else
+  //
+  // Try to store packet in RTT buffer and update time stamp when this was successful
+  //
+  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
+  SEGGER_SYSVIEW_ON_EVENT_RECORDED(pEndPacket - pStartPacket);
+  if (Status) {
+    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
+  } else {
+    _SYSVIEW_Globals.EnableState++; // EnableState has been 1, will be 2. Always.
+  }
+#endif
+
+#if (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
+  //
+  // Add sync and system information periodically if we are in post mortem mode
+  //
+  if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
+    _SYSVIEW_Globals.RecursionCnt = 1;
+    if (_SYSVIEW_Globals.PacketCount++ & (1 << SEGGER_SYSVIEW_SYNC_PERIOD_SHIFT)) {
+      _SendSyncInfo();
+      _SYSVIEW_Globals.PacketCount = 0;
+    }
+    _SYSVIEW_Globals.RecursionCnt = 0;
+  }
+SendDone:
+  ; // Avoid "label at end of compound statement" error when using static buffer
+#else
+SendDone:
+  //
+  // Check if host is sending data which needs to be processed.
+  // Note that since this code is called for every packet, it is very time critical, so we do
+  // only what is really needed here, which is checking if there is any data
+  //
+  if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
+    if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
+      _SYSVIEW_Globals.RecursionCnt = 1;
+      _HandleIncomingPacket();
+      _SYSVIEW_Globals.RecursionCnt = 0;
+    }
+  }
+#endif
+  //
+#if (SEGGER_SYSVIEW_USE_STATIC_BUFFER == 0)
+  SEGGER_SYSVIEW_UNLOCK();  // We are done. Unlock and return
+#endif
+}
+
+#ifndef SEGGER_SYSVIEW_EXCLUDE_PRINTF // Define in project to avoid warnings about variable parameter list
+/*********************************************************************
+*
+*       _VPrintHost()
+*
+*  Function description
+*    Send a format string and its parameters to the host.
+*
+*  Parameters
+*    s            Pointer to format string.
+*    Options      Options to be sent to the host.
+*    pParamList   Pointer to the list of arguments for the format string.
+*/
+static int _VPrintHost(const char* s, U32 Options, va_list* pParamList) {
+  U32         aParas[SEGGER_SYSVIEW_MAX_ARGUMENTS];
+  U32*        pParas;
+  U32         NumArguments;
+  const char* p;
+  char        c;
+  U8*         pPayload;
+  U8*         pPayloadStart;
+#if SEGGER_SYSVIEW_PRINTF_IMPLICIT_FORMAT
+  U8 HasNonScalar;
+  
+  HasNonScalar = 0;
+#endif  
+  //
+  // Count number of arguments by counting '%' characters in string.
+  // If enabled, check for non-scalar modifier flags to format string on the target.
+  //
+  p = s;
+  NumArguments = 0;
+  for (;;) {
+    c = *p++;
+    if (c == 0) {
+      break;
+    }
+    if (c == '%') {
+      c = *p;
+#if SEGGER_SYSVIEW_PRINTF_IMPLICIT_FORMAT == 0
+      aParas[NumArguments++] = va_arg(*pParamList, int);
+      if (NumArguments == SEGGER_SYSVIEW_MAX_ARGUMENTS) {
+        break;
+      }
+#else
+      if (c == 's') {
+        HasNonScalar = 1;
+        break;
+      } else {
+        aParas[NumArguments++] = va_arg(*pParamList, int);
+        if (NumArguments == SEGGER_SYSVIEW_MAX_ARGUMENTS) {
+          break;
+        }
+      }
+#endif
+    }
+  }
+
+#if SEGGER_SYSVIEW_PRINTF_IMPLICIT_FORMAT
+  if (HasNonScalar) {
+    return -1;
+  }
+#endif
+  //
+  // Send string and parameters to host
+  //
+  {
+    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_MAX_STRING_LEN + 2 * SEGGER_SYSVIEW_QUANTA_U32 + SEGGER_SYSVIEW_MAX_ARGUMENTS * SEGGER_SYSVIEW_QUANTA_U32);
+    pPayload = _EncodeStr(pPayloadStart, s, SEGGER_SYSVIEW_MAX_STRING_LEN);
+    ENCODE_U32(pPayload, Options);
+    ENCODE_U32(pPayload, NumArguments);
+    pParas = aParas;
+    while (NumArguments--) {
+      ENCODE_U32(pPayload, (*pParas));
+      pParas++;
+    }
+    _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
+    RECORD_END();
+  }
+  return 0;
+}
+
+/*********************************************************************
+*
+*       _StoreChar()
+*
+*  Function description
+*    Stores a character in the printf-buffer and sends the buffer when
+*     it is filled.
+*
+*  Parameters
+*    p            Pointer to the buffer description.
+*    c            Character to be printed.
+*/
+static void _StoreChar(SEGGER_SYSVIEW_PRINTF_DESC * p, char c) {
+  unsigned int  Cnt;
+  U8*           pPayload;
+  U32           Options;
+
+  Cnt = p->Cnt;
+  if ((Cnt + 1u) <= SEGGER_SYSVIEW_MAX_STRING_LEN) {
+    *(p->pPayload++) = c;
+    p->Cnt = Cnt + 1u;
+  }
+  //
+  // Write part of string, when the buffer is full
+  //
+  if (p->Cnt == SEGGER_SYSVIEW_MAX_STRING_LEN) {
+    *(p->pPayloadStart) = p->Cnt;
+    pPayload = p->pPayload;
+    Options = p->Options;
+    ENCODE_U32(pPayload, Options);
+    ENCODE_U32(pPayload, 0);
+    _SendPacket(p->pPayloadStart, pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
+    p->pPayloadStart = _PreparePacket(p->pBuffer);
+    p->pPayload = p->pPayloadStart + 1u;
+    p->Cnt = 0u;
+  }
+}
+
+/*********************************************************************
+*
+*       _PrintUnsigned()
+*
+*  Function description
+*    Print an unsigned integer with the given formatting into the 
+*     formatted string.
+*
+*  Parameters
+*    pBufferDesc  Pointer to the buffer description.
+*    v            Value to be printed.
+*    Base         Base of the value.
+*    NumDigits    Number of digits to be printed.
+*    FieldWidth   Width of the printed field.
+*    FormatFlags  Flags for formatting the value.
+*/
+static void _PrintUnsigned(SEGGER_SYSVIEW_PRINTF_DESC * pBufferDesc, unsigned int v, unsigned int Base, unsigned int NumDigits, unsigned int FieldWidth, unsigned int FormatFlags) {
+  static const char _aV2C[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
+  unsigned int      Div;
+  unsigned int      Digit;
+  unsigned int      Number;
+  unsigned int      Width;
+  char              c;
+
+  Number = v;
+  Digit = 1u;
+  //
+  // Get actual field width
+  //
+  Width = 1u;
+  while (Number >= Base) {
+    Number = (Number / Base);
+    Width++;
+  }
+  if (NumDigits > Width) {
+    Width = NumDigits;
+  }
+  //
+  // Print leading chars if necessary
+  //
+  if ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u) {
+    if (FieldWidth != 0u) {
+      if (((FormatFlags & FORMAT_FLAG_PAD_ZERO) == FORMAT_FLAG_PAD_ZERO) && (NumDigits == 0u)) {
+        c = '0';
+      } else {
+        c = ' ';
+      }
+      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
+        FieldWidth--;
+        _StoreChar(pBufferDesc, c);
+      }
+    }
+  }
+  //
+  // Compute Digit.
+  // Loop until Digit has the value of the highest digit required.
+  // Example: If the output is 345 (Base 10), loop 2 times until Digit is 100.
+  //
+  while (1) {
+    if (NumDigits > 1u) {       // User specified a min number of digits to print? => Make sure we loop at least that often, before checking anything else (> 1 check avoids problems with NumDigits being signed / unsigned)
+      NumDigits--;
+    } else {
+      Div = v / Digit;
+      if (Div < Base) {        // Is our divider big enough to extract the highest digit from value? => Done
+        break;
+      }
+    }
+    Digit *= Base;
+  }
+  //
+  // Output digits
+  //
+  do {
+    Div = v / Digit;
+    v -= Div * Digit;
+    _StoreChar(pBufferDesc, _aV2C[Div]);
+    Digit /= Base;
+  } while (Digit);
+  //
+  // Print trailing spaces if necessary
+  //
+  if ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == FORMAT_FLAG_LEFT_JUSTIFY) {
+    if (FieldWidth != 0u) {
+      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
+        FieldWidth--;
+        _StoreChar(pBufferDesc, ' ');
+      }
+    }
+  }
+}
+
+/*********************************************************************
+*
+*       _PrintInt()
+*
+*  Function description
+*    Print a signed integer with the given formatting into the 
+*     formatted string.
+*
+*  Parameters
+*    pBufferDesc  Pointer to the buffer description.
+*    v            Value to be printed.
+*    Base         Base of the value.
+*    NumDigits    Number of digits to be printed.
+*    FieldWidth   Width of the printed field.
+*    FormatFlags  Flags for formatting the value.
+*/
+static void _PrintInt(SEGGER_SYSVIEW_PRINTF_DESC * pBufferDesc, int v, unsigned int Base, unsigned int NumDigits, unsigned int FieldWidth, unsigned int FormatFlags) {
+  unsigned int  Width;
+  int           Number;
+
+  Number = (v < 0) ? -v : v;
+
+  //
+  // Get actual field width
+  //
+  Width = 1u;
+  while (Number >= (int)Base) {
+    Number = (Number / (int)Base);
+    Width++;
+  }
+  if (NumDigits > Width) {
+    Width = NumDigits;
+  }
+  if ((FieldWidth > 0u) && ((v < 0) || ((FormatFlags & FORMAT_FLAG_PRINT_SIGN) == FORMAT_FLAG_PRINT_SIGN))) {
+    FieldWidth--;
+  }
+
+  //
+  // Print leading spaces if necessary
+  //
+  if ((((FormatFlags & FORMAT_FLAG_PAD_ZERO) == 0u) || (NumDigits != 0u)) && ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u)) {
+    if (FieldWidth != 0u) {
+      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
+        FieldWidth--;
+        _StoreChar(pBufferDesc, ' ');
+      }
+    }
+  }
+  //
+  // Print sign if necessary
+  //
+  if (v < 0) {
+    v = -v;
+    _StoreChar(pBufferDesc, '-');
+  } else if ((FormatFlags & FORMAT_FLAG_PRINT_SIGN) == FORMAT_FLAG_PRINT_SIGN) {
+    _StoreChar(pBufferDesc, '+');
+  } else {
+
+  }
+  //
+  // Print leading zeros if necessary
+  //
+  if (((FormatFlags & FORMAT_FLAG_PAD_ZERO) == FORMAT_FLAG_PAD_ZERO) && ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u) && (NumDigits == 0u)) {
+    if (FieldWidth != 0u) {
+      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
+        FieldWidth--;
+        _StoreChar(pBufferDesc, '0');
+      }
+    }
+  }
+  //
+  // Print number without sign
+  //
+  _PrintUnsigned(pBufferDesc, (unsigned int)v, Base, NumDigits, FieldWidth, FormatFlags);
+}
+
+/*********************************************************************
+*
+*       _VPrintTarget()
+*
+*  Function description
+*    Stores a formatted string.
+*    This data is read by the host.
+*
+*  Parameters
+*    sFormat      Pointer to format string.
+*    Options      Options to be sent to the host.
+*    pParamList   Pointer to the list of arguments for the format string.
+*/
+static void _VPrintTarget(const char* sFormat, U32 Options, va_list* pParamList) {
+  SEGGER_SYSVIEW_PRINTF_DESC BufferDesc;
+  char          c;
+  int           v;
+  unsigned int  NumDigits;
+  unsigned int  FormatFlags;
+  unsigned int  FieldWidth;
+  U8*           pPayloadStart;
+#if SEGGER_SYSVIEW_USE_STATIC_BUFFER == 0
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_MAX_STRING_LEN + 1 + 2 * SEGGER_SYSVIEW_QUANTA_U32);
+  SEGGER_SYSVIEW_LOCK();
+#else
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_MAX_STRING_LEN + 1 + 2 * SEGGER_SYSVIEW_QUANTA_U32);
+#endif
+
+#if SEGGER_SYSVIEW_USE_STATIC_BUFFER == 0
+  BufferDesc.pBuffer        = aPacket;
+#else
+  BufferDesc.pBuffer        = _aPacket;
+#endif
+  BufferDesc.Cnt            = 0u;
+  BufferDesc.pPayloadStart  = pPayloadStart;
+  BufferDesc.pPayload       = BufferDesc.pPayloadStart + 1u;
+  BufferDesc.Options        =  Options;
+
+  do {
+    c = *sFormat;
+    sFormat++;
+    if (c == 0u) {
+      break;
+    }
+    if (c == '%') {
+      //
+      // Filter out flags
+      //
+      FormatFlags = 0u;
+      v = 1;
+      do {
+        c = *sFormat;
+        switch (c) {
+        case '-': FormatFlags |= FORMAT_FLAG_LEFT_JUSTIFY; sFormat++; break;
+        case '0': FormatFlags |= FORMAT_FLAG_PAD_ZERO;     sFormat++; break;
+        case '+': FormatFlags |= FORMAT_FLAG_PRINT_SIGN;   sFormat++; break;
+        case '#': FormatFlags |= FORMAT_FLAG_ALTERNATE;    sFormat++; break;
+        default:  v = 0; break;
+        }
+      } while (v);
+      //
+      // filter out field with
+      //
+      FieldWidth = 0u;
+      do {
+        c = *sFormat;
+        if ((c < '0') || (c > '9')) {
+          break;
+        }
+        sFormat++;
+        FieldWidth = (FieldWidth * 10u) + ((unsigned int)c - '0');
+      } while (1);
+
+      //
+      // Filter out precision (number of digits to display)
+      //
+      NumDigits = 0u;
+      c = *sFormat;
+      if (c == '.') {
+        sFormat++;
+        do {
+          c = *sFormat;
+          if ((c < '0') || (c > '9')) {
+            break;
+          }
+          sFormat++;
+          NumDigits = NumDigits * 10u + ((unsigned int)c - '0');
+        } while (1);
+      }
+      //
+      // Filter out length modifier
+      //
+      c = *sFormat;
+      do {
+        if ((c == 'l') || (c == 'h')) {
+          c = *sFormat;
+          sFormat++;
+        } else {
+          break;
+        }
+      } while (1);
+      //
+      // Handle specifiers
+      //
+      switch (c) {
+      case 'c': {
+        char c0;
+        v = va_arg(*pParamList, int);
+        c0 = (char)v;
+        _StoreChar(&BufferDesc, c0);
+        break;
+      }
+      case 'd':
+        v = va_arg(*pParamList, int);
+        _PrintInt(&BufferDesc, v, 10u, NumDigits, FieldWidth, FormatFlags);
+        break;
+      case 'u':
+        v = va_arg(*pParamList, int);
+        _PrintUnsigned(&BufferDesc, (unsigned int)v, 10u, NumDigits, FieldWidth, FormatFlags);
+        break;
+      case 'x':
+      case 'X':
+        v = va_arg(*pParamList, int);
+        _PrintUnsigned(&BufferDesc, (unsigned int)v, 16u, NumDigits, FieldWidth, FormatFlags);
+        break;
+      case 'p':
+        v = va_arg(*pParamList, int);
+        _PrintUnsigned(&BufferDesc, (unsigned int)v, 16u, 8u, 8u, 0u);
+        break;
+      case '%':
+        _StoreChar(&BufferDesc, '%');
+        break;
+      default:
+        break;
+      }
+      sFormat++;
+    } else {
+      _StoreChar(&BufferDesc, c);
+    }
+  } while (*sFormat);
+
+  //
+  // Write remaining data, if any
+  //
+  if (BufferDesc.Cnt != 0u) {
+    *(BufferDesc.pPayloadStart) = BufferDesc.Cnt;
+    ENCODE_U32(BufferDesc.pPayload, BufferDesc.Options);
+    ENCODE_U32(BufferDesc.pPayload, 0);
+    _SendPacket(BufferDesc.pPayloadStart, BufferDesc.pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
+  }
+#if SEGGER_SYSVIEW_USE_STATIC_BUFFER == 0
+  SEGGER_SYSVIEW_UNLOCK();
+  RECORD_END();
+#else
+  RECORD_END();
+#endif
+}
+#endif // SEGGER_SYSVIEW_EXCLUDE_PRINTF
+
+/*********************************************************************
+*
+*       Public code
+*
+**********************************************************************
+*/
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_Init()
+*
+*  Function description
+*    Initializes the SYSVIEW module.
+*    Must be called before the Systemview Application connects to 
+*    the system.
+*
+*  Parameters
+*    SysFreq        - Frequency of timestamp, usually CPU core clock frequency.
+*    CPUFreq        - CPU core clock frequency.
+*    pOSAPI         - Pointer to the API structure for OS-specific functions.
+*    pfSendSysDesc  - Pointer to record system description callback function.
+*
+*  Additional information
+*    This function initializes the RTT channel used to transport 
+*    SEGGER SystemView packets. 
+*    The channel is assigned the label "SysView" for client software 
+*    to identify the SystemView channel.
+*
+*    The channel is configured with the macro SEGGER_SYSVIEW_RTT_CHANNEL.
+*/
+void SEGGER_SYSVIEW_Init(U32 SysFreq, U32 CPUFreq, const SEGGER_SYSVIEW_OS_API *pOSAPI, SEGGER_SYSVIEW_SEND_SYS_DESC_FUNC pfSendSysDesc) {
+#ifdef SEGGER_RTT_SECTION
+  //
+  // Explicitly initialize the RTT Control Block if it is in its dedicated section.
+  //
+  SEGGER_RTT_Init();
+#endif
+#if (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
+#if SEGGER_SYSVIEW_RTT_CHANNEL > 0
+  SEGGER_RTT_ConfigUpBuffer(SEGGER_SYSVIEW_RTT_CHANNEL, "SysView", &_UpBuffer[0],   sizeof(_UpBuffer),   SEGGER_RTT_MODE_NO_BLOCK_SKIP);
+#else
+  _SYSVIEW_Globals.UpChannel = SEGGER_RTT_AllocUpBuffer  ("SysView", &_UpBuffer[0],   sizeof(_UpBuffer),   SEGGER_RTT_MODE_NO_BLOCK_SKIP);
+#endif
+  _SYSVIEW_Globals.RAMBaseAddress   = SEGGER_SYSVIEW_ID_BASE;
+  _SYSVIEW_Globals.LastTxTimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
+  _SYSVIEW_Globals.pOSAPI           = pOSAPI;
+  _SYSVIEW_Globals.SysFreq          = SysFreq;
+  _SYSVIEW_Globals.CPUFreq          = CPUFreq;
+  _SYSVIEW_Globals.pfSendSysDesc    = pfSendSysDesc;
+  _SYSVIEW_Globals.EnableState      = 0;
+  _SYSVIEW_Globals.PacketCount      = 0;
+#else // (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
+#if SEGGER_SYSVIEW_RTT_CHANNEL > 0
+  SEGGER_RTT_ConfigUpBuffer   (SEGGER_SYSVIEW_RTT_CHANNEL, "SysView", &_UpBuffer[0],   sizeof(_UpBuffer),   SEGGER_RTT_MODE_NO_BLOCK_SKIP);
+  SEGGER_RTT_ConfigDownBuffer (SEGGER_SYSVIEW_RTT_CHANNEL, "SysView", &_DownBuffer[0], sizeof(_DownBuffer), SEGGER_RTT_MODE_NO_BLOCK_SKIP);
+#else
+  _SYSVIEW_Globals.UpChannel = SEGGER_RTT_AllocUpBuffer  ("SysView", &_UpBuffer[0],   sizeof(_UpBuffer),   SEGGER_RTT_MODE_NO_BLOCK_SKIP);
+  _SYSVIEW_Globals.DownChannel = _SYSVIEW_Globals.UpChannel;
+  SEGGER_RTT_ConfigDownBuffer (_SYSVIEW_Globals.DownChannel, "SysView", &_DownBuffer[0], sizeof(_DownBuffer), SEGGER_RTT_MODE_NO_BLOCK_SKIP);
+#endif
+  _SYSVIEW_Globals.RAMBaseAddress   = SEGGER_SYSVIEW_ID_BASE;
+  _SYSVIEW_Globals.LastTxTimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
+  _SYSVIEW_Globals.pOSAPI           = pOSAPI;
+  _SYSVIEW_Globals.SysFreq          = SysFreq;
+  _SYSVIEW_Globals.CPUFreq          = CPUFreq;
+  _SYSVIEW_Globals.pfSendSysDesc    = pfSendSysDesc;
+  _SYSVIEW_Globals.EnableState      = 0;
+#endif  // (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_SetRAMBase()
+*
+*  Function description
+*    Sets the RAM base address, which is subtracted from IDs in order
+*     to save bandwidth.
+*
+*  Parameters
+*    RAMBaseAddress - Lowest RAM Address. (i.e. 0x20000000 on most Cortex-M)
+*/
+void SEGGER_SYSVIEW_SetRAMBase(U32 RAMBaseAddress) {
+  _SYSVIEW_Globals.RAMBaseAddress = RAMBaseAddress;
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordVoid()
+*
+*  Function description
+*    Formats and sends a SystemView packet with an empty payload.
+*
+*  Parameters
+*    EventID - SystemView event ID.
+*/
+void SEGGER_SYSVIEW_RecordVoid(unsigned int EventID) {
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
+  //
+  _SendPacket(pPayloadStart, pPayloadStart, EventID);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordU32()
+*
+*  Function description
+*    Formats and sends a SystemView packet containing a single U32
+*    parameter payload.
+*
+*  Parameters
+*    EventID - SystemView event ID.
+*    Value   - The 32-bit parameter encoded to SystemView packet payload.
+*/
+void SEGGER_SYSVIEW_RecordU32(unsigned int EventID, U32 Value) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, Value);
+  _SendPacket(pPayloadStart, pPayload, EventID);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordU32x2()
+*
+*  Function description
+*    Formats and sends a SystemView packet containing 2 U32 parameter payload.
+*
+*  Parameters
+*    EventID - SystemView event ID.
+*    Para0   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para1   - The 32-bit parameter encoded to SystemView packet payload.
+*/
+void SEGGER_SYSVIEW_RecordU32x2(unsigned int EventID, U32 Para0, U32 Para1) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, Para0);
+  ENCODE_U32(pPayload, Para1);
+  _SendPacket(pPayloadStart, pPayload, EventID);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordU32x3()
+*
+*  Function description
+*    Formats and sends a SystemView packet containing 3 U32 parameter payload.
+*
+*  Parameters
+*    EventID - SystemView event ID.
+*    Para0   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para1   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para2   - The 32-bit parameter encoded to SystemView packet payload.
+*/
+void SEGGER_SYSVIEW_RecordU32x3(unsigned int EventID, U32 Para0, U32 Para1, U32 Para2) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 3 * SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, Para0);
+  ENCODE_U32(pPayload, Para1);
+  ENCODE_U32(pPayload, Para2);
+  _SendPacket(pPayloadStart, pPayload, EventID);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordU32x4()
+*
+*  Function description
+*    Formats and sends a SystemView packet containing 4 U32 parameter payload.
+*
+*  Parameters
+*    EventID - SystemView event ID.
+*    Para0   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para1   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para2   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para3   - The 32-bit parameter encoded to SystemView packet payload.
+*/
+void SEGGER_SYSVIEW_RecordU32x4(unsigned int EventID, U32 Para0, U32 Para1, U32 Para2, U32 Para3) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 4 * SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, Para0);
+  ENCODE_U32(pPayload, Para1);
+  ENCODE_U32(pPayload, Para2);
+  ENCODE_U32(pPayload, Para3);
+  _SendPacket(pPayloadStart, pPayload, EventID);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordU32x5()
+*
+*  Function description
+*    Formats and sends a SystemView packet containing 5 U32 parameter payload.
+*
+*  Parameters
+*    EventID - SystemView event ID.
+*    Para0   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para1   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para2   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para3   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para4   - The 32-bit parameter encoded to SystemView packet payload.
+*/
+void SEGGER_SYSVIEW_RecordU32x5(unsigned int EventID, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 5 * SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, Para0);
+  ENCODE_U32(pPayload, Para1);
+  ENCODE_U32(pPayload, Para2);
+  ENCODE_U32(pPayload, Para3);
+  ENCODE_U32(pPayload, Para4);
+  _SendPacket(pPayloadStart, pPayload, EventID);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordU32x6()
+*
+*  Function description
+*    Formats and sends a SystemView packet containing 6 U32 parameter payload.
+*
+*  Parameters
+*    EventID - SystemView event ID.
+*    Para0   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para1   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para2   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para3   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para4   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para5   - The 32-bit parameter encoded to SystemView packet payload.
+*/
+void SEGGER_SYSVIEW_RecordU32x6(unsigned int EventID, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4, U32 Para5) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 6 * SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, Para0);
+  ENCODE_U32(pPayload, Para1);
+  ENCODE_U32(pPayload, Para2);
+  ENCODE_U32(pPayload, Para3);
+  ENCODE_U32(pPayload, Para4);
+  ENCODE_U32(pPayload, Para5);
+  _SendPacket(pPayloadStart, pPayload, EventID);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordU32x7()
+*
+*  Function description
+*    Formats and sends a SystemView packet containing 7 U32 parameter payload.
+*
+*  Parameters
+*    EventID - SystemView event ID.
+*    Para0   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para1   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para2   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para3   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para4   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para5   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para6   - The 32-bit parameter encoded to SystemView packet payload.
+*/
+void SEGGER_SYSVIEW_RecordU32x7(unsigned int EventID, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4, U32 Para5, U32 Para6) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 7 * SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, Para0);
+  ENCODE_U32(pPayload, Para1);
+  ENCODE_U32(pPayload, Para2);
+  ENCODE_U32(pPayload, Para3);
+  ENCODE_U32(pPayload, Para4);
+  ENCODE_U32(pPayload, Para5);
+  ENCODE_U32(pPayload, Para6);
+  _SendPacket(pPayloadStart, pPayload, EventID);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordU32x8()
+*
+*  Function description
+*    Formats and sends a SystemView packet containing 8 U32 parameter payload.
+*
+*  Parameters
+*    EventID - SystemView event ID.
+*    Para0   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para1   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para2   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para3   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para4   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para5   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para6   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para7   - The 32-bit parameter encoded to SystemView packet payload.
+*/
+void SEGGER_SYSVIEW_RecordU32x8(unsigned int EventID, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4, U32 Para5, U32 Para6, U32 Para7) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 8 * SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, Para0);
+  ENCODE_U32(pPayload, Para1);
+  ENCODE_U32(pPayload, Para2);
+  ENCODE_U32(pPayload, Para3);
+  ENCODE_U32(pPayload, Para4);
+  ENCODE_U32(pPayload, Para5);
+  ENCODE_U32(pPayload, Para6);
+  ENCODE_U32(pPayload, Para7);
+  _SendPacket(pPayloadStart, pPayload, EventID);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordU32x9()
+*
+*  Function description
+*    Formats and sends a SystemView packet containing 9 U32 parameter payload.
+*
+*  Parameters
+*    EventID - SystemView event ID.
+*    Para0   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para1   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para2   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para3   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para4   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para5   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para6   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para7   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para8   - The 32-bit parameter encoded to SystemView packet payload.
+*/
+void SEGGER_SYSVIEW_RecordU32x9(unsigned int EventID, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4, U32 Para5, U32 Para6, U32 Para7, U32 Para8) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 9 * SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, Para0);
+  ENCODE_U32(pPayload, Para1);
+  ENCODE_U32(pPayload, Para2);
+  ENCODE_U32(pPayload, Para3);
+  ENCODE_U32(pPayload, Para4);
+  ENCODE_U32(pPayload, Para5);
+  ENCODE_U32(pPayload, Para6);
+  ENCODE_U32(pPayload, Para7);
+  ENCODE_U32(pPayload, Para8);
+  _SendPacket(pPayloadStart, pPayload, EventID);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordU32x10()
+*
+*  Function description
+*    Formats and sends a SystemView packet containing 10 U32 parameter payload.
+*
+*  Parameters
+*    EventID - SystemView event ID.
+*    Para0   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para1   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para2   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para3   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para4   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para5   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para6   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para7   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para8   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para9   - The 32-bit parameter encoded to SystemView packet payload.
+*/
+void SEGGER_SYSVIEW_RecordU32x10(unsigned int EventID, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4, U32 Para5, U32 Para6, U32 Para7, U32 Para8, U32 Para9) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 10 * SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, Para0);
+  ENCODE_U32(pPayload, Para1);
+  ENCODE_U32(pPayload, Para2);
+  ENCODE_U32(pPayload, Para3);
+  ENCODE_U32(pPayload, Para4);
+  ENCODE_U32(pPayload, Para5);
+  ENCODE_U32(pPayload, Para6);
+  ENCODE_U32(pPayload, Para7);
+  ENCODE_U32(pPayload, Para8);
+  ENCODE_U32(pPayload, Para9);
+  _SendPacket(pPayloadStart, pPayload, EventID);
+  RECORD_END();
+}
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordString()
+*
+*  Function description
+*    Formats and sends a SystemView packet containing a string.
+*
+*  Parameters
+*    EventID - SystemView event ID.
+*    pString - The string to be sent in the SystemView packet payload.
+*
+*  Additional information
+*    The string is encoded as a count byte followed by the contents
+*    of the string.
+*    No more than SEGGER_SYSVIEW_MAX_STRING_LEN bytes will be encoded to the payload.
+*/
+void SEGGER_SYSVIEW_RecordString(unsigned int EventID, const char* pString) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 1 + SEGGER_SYSVIEW_MAX_STRING_LEN);
+  //
+  pPayload = _EncodeStr(pPayloadStart, pString, SEGGER_SYSVIEW_MAX_STRING_LEN);
+  _SendPacket(pPayloadStart, pPayload, EventID);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_Start()
+*
+*  Function description
+*    Start recording SystemView events.
+*
+*    This function is triggered by the SystemView Application on connect.
+*    For single-shot or post-mortem mode recording, it needs to be called
+*    by the application.
+*
+*  Additional information
+*    This function enables transmission of SystemView packets recorded
+*    by subsequent trace calls and records a SystemView Start event.
+*
+*    As part of start, a SystemView Init packet is sent, containing the system
+*    frequency. The list of current tasks, the current system time and the
+*    system description string is sent, too.
+*
+*  Notes
+*    SEGGER_SYSVIEW_Start and SEGGER_SYSVIEW_Stop do not nest.
+*    When SEGGER_SYSVIEW_CAN_RESTART is 1, each received start command
+*    records the system information. This is required to enable restart
+*    of recordings when SystemView unexpectedly disconnects without sending
+*    a stop command before.
+*/
+void SEGGER_SYSVIEW_Start(void) {
+#if (SEGGER_SYSVIEW_CAN_RESTART == 0)
+  if (_SYSVIEW_Globals.EnableState == 0) {
+#endif
+    _SYSVIEW_Globals.EnableState = 1;
+#if (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
+    _SendSyncInfo();
+#else
+    SEGGER_SYSVIEW_LOCK();
+    SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, _abSync, 10);
+    SEGGER_SYSVIEW_UNLOCK();
+    SEGGER_SYSVIEW_ON_EVENT_RECORDED(10);
+    SEGGER_SYSVIEW_RecordVoid(SYSVIEW_EVTID_TRACE_START);
+    {
+      U8* pPayload;
+      U8* pPayloadStart;
+      RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 4 * SEGGER_SYSVIEW_QUANTA_U32);
+      //
+      pPayload = pPayloadStart;
+      ENCODE_U32(pPayload, _SYSVIEW_Globals.SysFreq);
+      ENCODE_U32(pPayload, _SYSVIEW_Globals.CPUFreq);
+      ENCODE_U32(pPayload, _SYSVIEW_Globals.RAMBaseAddress);
+      ENCODE_U32(pPayload, SEGGER_SYSVIEW_ID_SHIFT);
+      _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_INIT);
+      RECORD_END();
+    }
+    if (_SYSVIEW_Globals.pfSendSysDesc) {
+      _SYSVIEW_Globals.pfSendSysDesc();
+    }
+    SEGGER_SYSVIEW_RecordSystime();
+    SEGGER_SYSVIEW_SendTaskList();
+    SEGGER_SYSVIEW_SendNumModules();
+#endif
+#if (SEGGER_SYSVIEW_CAN_RESTART == 0)
+  }
+#endif
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_Stop()
+*
+*  Function description
+*    Stop recording SystemView events.
+*
+*    This function is triggered by the SystemView Application on disconnect.
+*    For single-shot or post-mortem mode recording, it can be called
+*    by the application.
+*
+*  Additional information
+*    This function disables transmission of SystemView packets recorded
+*    by subsequent trace calls.  If transmission is enabled when
+*    this function is called, a single SystemView Stop event is recorded
+*    to the trace, send, and then trace transmission is halted.
+*/
+void SEGGER_SYSVIEW_Stop(void) {
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
+  //
+  if (_SYSVIEW_Globals.EnableState) {
+    _SendPacket(pPayloadStart, pPayloadStart, SYSVIEW_EVTID_TRACE_STOP);
+    _SYSVIEW_Globals.EnableState = 0;
+  }
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_GetChannelID()
+*
+*  Function description
+*    Returns the RTT <Up> / <Down> channel ID used by SystemView.
+*/
+int SEGGER_SYSVIEW_GetChannelID(void) {
+  return CHANNEL_ID_UP;
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_GetSysDesc()
+*
+*  Function description
+*    Triggers a send of the system information and description.
+*
+*/
+void SEGGER_SYSVIEW_GetSysDesc(void) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 4 * SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, _SYSVIEW_Globals.SysFreq);
+  ENCODE_U32(pPayload, _SYSVIEW_Globals.CPUFreq);
+  ENCODE_U32(pPayload, _SYSVIEW_Globals.RAMBaseAddress);
+  ENCODE_U32(pPayload, SEGGER_SYSVIEW_ID_SHIFT);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_INIT);
+  RECORD_END();
+  if (_SYSVIEW_Globals.pfSendSysDesc) {
+    _SYSVIEW_Globals.pfSendSysDesc();
+  }
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_SendTaskInfo()
+*
+*  Function description
+*    Send a Task Info Packet, containing TaskId for identification,
+*    task priority and task name.
+*
+*  Parameters
+*    pInfo - Pointer to task information to send.
+*/
+void SEGGER_SYSVIEW_SendTaskInfo(const SEGGER_SYSVIEW_TASKINFO *pInfo) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32 + 1 + 32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, SHRINK_ID(pInfo->TaskID));
+  ENCODE_U32(pPayload, pInfo->Prio);
+  pPayload = _EncodeStr(pPayload, pInfo->sName, 32);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_INFO);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, SHRINK_ID(pInfo->TaskID));
+  ENCODE_U32(pPayload, pInfo->StackBase);
+  ENCODE_U32(pPayload, pInfo->StackSize);
+  ENCODE_U32(pPayload, 0); // Stack End, future use
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_STACK_INFO);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_SendTaskList()
+*
+*  Function description
+*    Send all tasks descriptors to the host.
+*/
+void SEGGER_SYSVIEW_SendTaskList(void) {
+  if (_SYSVIEW_Globals.pOSAPI && _SYSVIEW_Globals.pOSAPI->pfSendTaskList) {
+    _SYSVIEW_Globals.pOSAPI->pfSendTaskList();
+  }
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_SendSysDesc()
+*
+*  Function description
+*    Send the system description string to the host.
+*    The system description is used by the Systemview Application
+*    to identify the current application and handle events accordingly.
+*
+*    The system description is usually called by the system description
+*    callback, to ensure it is only sent when the SystemView Application
+*    is connected.  
+*
+*  Parameters
+*    sSysDesc - Pointer to the 0-terminated system description string.
+*
+*  Additional information
+*    One system description string may not exceed SEGGER_SYSVIEW_MAX_STRING_LEN characters.
+*    Multiple description strings can be recorded.
+*
+*    The Following items can be described in a system description string.
+*    Each item is identified by its identifier, followed by '=' and the value.
+*    Items are separated by ','.
+*/
+void SEGGER_SYSVIEW_SendSysDesc(const char *sSysDesc) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 1 + SEGGER_SYSVIEW_MAX_STRING_LEN);
+  //
+  pPayload = _EncodeStr(pPayloadStart, sSysDesc, SEGGER_SYSVIEW_MAX_STRING_LEN);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_SYSDESC);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordSystime()
+*
+*  Function description
+*    Formats and sends a SystemView Systime containing a single U64 or U32
+*    parameter payload.
+*/
+void SEGGER_SYSVIEW_RecordSystime(void) {
+  U64 Systime;
+
+  if (_SYSVIEW_Globals.pOSAPI && _SYSVIEW_Globals.pOSAPI->pfGetTime) {
+    Systime = _SYSVIEW_Globals.pOSAPI->pfGetTime();
+    SEGGER_SYSVIEW_RecordU32x2(SYSVIEW_EVTID_SYSTIME_US,
+                               (U32)(Systime),
+                               (U32)(Systime >> 32));
+  } else {
+    SEGGER_SYSVIEW_RecordU32(SYSVIEW_EVTID_SYSTIME_CYCLES, SEGGER_SYSVIEW_GET_TIMESTAMP());
+  }
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordEnterISR()
+*
+*  Function description
+*    Format and send an ISR entry event.
+*
+*  Additional information
+*    Example packets sent
+*      02 0F 50              // ISR(15) Enter. Timestamp is 80 (0x50)
+*/
+void SEGGER_SYSVIEW_RecordEnterISR(void) {
+  unsigned v;
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  v = SEGGER_SYSVIEW_GET_INTERRUPT_ID();
+  ENCODE_U32(pPayload, v);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_ISR_ENTER);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordExitISR()
+*
+*  Function description
+*    Format and send an ISR exit event.
+*
+*  Additional information
+*    Format as follows:
+*      03 <TimeStamp>        // Max. packet len is 6
+*
+*    Example packets sent
+*      03 20                // ISR Exit. Timestamp is 32 (0x20)
+*/
+void SEGGER_SYSVIEW_RecordExitISR(void) {
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
+  //
+  _SendPacket(pPayloadStart, pPayloadStart, SYSVIEW_EVTID_ISR_EXIT);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordExitISRToScheduler()
+*
+*  Function description
+*    Format and send an ISR exit into scheduler event.
+*
+*  Additional information
+*    Format as follows:
+*      18 <TimeStamp>        // Max. packet len is 6
+*
+*    Example packets sent
+*      18 20                // ISR Exit to Scheduler. Timestamp is 32 (0x20)
+*/
+void SEGGER_SYSVIEW_RecordExitISRToScheduler(void) {
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
+  //
+  _SendPacket(pPayloadStart, pPayloadStart, SYSVIEW_EVTID_ISR_TO_SCHEDULER);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordEnterTimer()
+*
+*  Function description
+*    Format and send a Timer entry event.
+*  
+*  Parameters
+*    TimerId - Id of the timer which starts.
+*/
+void SEGGER_SYSVIEW_RecordEnterTimer(U32 TimerId) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, SHRINK_ID(TimerId));
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TIMER_ENTER);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordExitTimer()
+*
+*  Function description
+*    Format and send a Timer exit event.
+*/
+void SEGGER_SYSVIEW_RecordExitTimer(void) {
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
+  //
+  _SendPacket(pPayloadStart, pPayloadStart, SYSVIEW_EVTID_TIMER_EXIT);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordEndCall()
+*
+*  Function description
+*    Format and send an End API Call event without return value.
+*  
+*  Parameters
+*    EventID - Id of API function which ends.
+*/
+void SEGGER_SYSVIEW_RecordEndCall(unsigned int EventID) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, EventID);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_END_CALL);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordEndCallU32()
+*
+*  Function description
+*    Format and send an End API Call event with return value.
+*  
+*  Parameters
+*    EventID      - Id of API function which ends.
+*    Para0        - Return value which will be returned by the API function.
+*/
+void SEGGER_SYSVIEW_RecordEndCallU32(unsigned int EventID, U32 Para0) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, EventID);
+  ENCODE_U32(pPayload, Para0);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_END_CALL);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_OnIdle()
+*
+*  Function description
+*    Record an Idle event.
+*/
+void SEGGER_SYSVIEW_OnIdle(void) {
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
+  //
+  _SendPacket(pPayloadStart, pPayloadStart, SYSVIEW_EVTID_IDLE);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_OnTaskCreate()
+*
+*  Function description
+*    Record a Task Create event.  The Task Create event corresponds
+*    to creating a task in the OS.
+*
+*  Parameters
+*    TaskId        - Task ID of created task.
+*/
+void SEGGER_SYSVIEW_OnTaskCreate(U32 TaskId) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  TaskId = SHRINK_ID(TaskId);
+  ENCODE_U32(pPayload, TaskId);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_CREATE);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_OnTaskTerminate()
+*
+*  Function description
+*    Record a Task termination event.  
+*    The Task termination event corresponds to terminating a task in 
+*    the OS. If the TaskId is the currently active task, 
+*    SEGGER_SYSVIEW_OnTaskStopExec may be used, either.
+*
+*  Parameters
+*    TaskId        - Task ID of terminated task.
+*/
+void SEGGER_SYSVIEW_OnTaskTerminate(U32 TaskId) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  TaskId = SHRINK_ID(TaskId);
+  ENCODE_U32(pPayload, TaskId);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_TERMINATE);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_OnTaskStartExec()
+*
+*  Function description
+*    Record a Task Start Execution event.  The Task Start event
+*    corresponds to when a task has started to execute rather than
+*    when it is ready to execute.
+*
+*  Parameters
+*    TaskId - Task ID of task that started to execute.
+*/
+void SEGGER_SYSVIEW_OnTaskStartExec(U32 TaskId) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  TaskId = SHRINK_ID(TaskId);
+  ENCODE_U32(pPayload, TaskId);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_START_EXEC);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_OnTaskStopExec()
+*
+*  Function description
+*    Record a Task Stop Execution event.  The Task Stop event
+*    corresponds to when a task stops executing and terminates.
+*/
+void SEGGER_SYSVIEW_OnTaskStopExec(void) {
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
+  //
+  _SendPacket(pPayloadStart, pPayloadStart, SYSVIEW_EVTID_TASK_STOP_EXEC);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_OnTaskStartReady()
+*
+*  Function description
+*    Record a Task Start Ready event.
+*
+*  Parameters
+*    TaskId - Task ID of task that started to execute.
+*/
+void SEGGER_SYSVIEW_OnTaskStartReady(U32 TaskId) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  TaskId = SHRINK_ID(TaskId);
+  ENCODE_U32(pPayload, TaskId);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_START_READY);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_OnTaskStopReady()
+*
+*  Function description
+*    Record a Task Stop Ready event.
+*
+*  Parameters
+*    TaskId - Task ID of task that completed execution.
+*    Cause  - Reason for task to stop (i.e. Idle/Sleep)
+*/
+void SEGGER_SYSVIEW_OnTaskStopReady(U32 TaskId, unsigned int Cause) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  TaskId = SHRINK_ID(TaskId);
+  ENCODE_U32(pPayload, TaskId);
+  ENCODE_U32(pPayload, Cause);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_STOP_READY);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_MarkStart()
+*
+*  Function description
+*    Record a Performance Marker Start event to start measuring runtime.
+*
+*  Parameters
+*    MarkerId  - User defined ID for the marker.
+*/
+void SEGGER_SYSVIEW_MarkStart(unsigned MarkerId) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, MarkerId);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_MARK_START);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_MarkStop()
+*
+*  Function description
+*    Record a Performance Marker Stop event to stop measuring runtime.
+*
+*  Parameters
+*    MarkerId  - User defined ID for the marker.
+*/
+void SEGGER_SYSVIEW_MarkStop(unsigned MarkerId) {
+  U8 * pPayload;
+  U8 * pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, MarkerId);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_MARK_STOP);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_Mark()
+*
+*  Function description
+*    Record a Performance Marker intermediate event.
+*
+*  Parameters
+*    MarkerId  - User defined ID for the marker.
+*/
+void SEGGER_SYSVIEW_Mark(unsigned int MarkerId) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, SYSVIEW_EVTID_EX_MARK);
+  ENCODE_U32(pPayload, MarkerId);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_EX);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_NameMarker()
+*
+*  Function description
+*    Send the name of a Performance Marker to be displayed in SystemView.
+*
+*    Marker names are usually set in the system description
+*    callback, to ensure it is only sent when the SystemView Application
+*    is connected.  
+*
+*  Parameters
+*    MarkerId   - User defined ID for the marker.
+*    sName      - Pointer to the marker name. (Max. SEGGER_SYSVIEW_MAX_STRING_LEN Bytes)
+*/
+void SEGGER_SYSVIEW_NameMarker(unsigned int MarkerId, const char* sName) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32 + 1 + SEGGER_SYSVIEW_MAX_STRING_LEN);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, SYSVIEW_EVTID_EX_NAME_MARKER);
+  ENCODE_U32(pPayload, MarkerId);
+  pPayload = _EncodeStr(pPayload, sName, SEGGER_SYSVIEW_MAX_STRING_LEN);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_EX);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_NameResource()
+*
+*  Function description
+*    Send the name of a resource to be displayed in SystemView.
+*
+*    Marker names are usually set in the system description
+*    callback, to ensure it is only sent when the SystemView Application
+*    is connected.  
+*
+*  Parameters
+*    ResourceId - Id of the resource to be named. i.e. its address.
+*    sName      - Pointer to the resource name. (Max. SEGGER_SYSVIEW_MAX_STRING_LEN Bytes)
+*/
+void SEGGER_SYSVIEW_NameResource(U32 ResourceId, const char* sName) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32 + 1 + SEGGER_SYSVIEW_MAX_STRING_LEN);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, SHRINK_ID(ResourceId));
+  pPayload = _EncodeStr(pPayload, sName, SEGGER_SYSVIEW_MAX_STRING_LEN);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_NAME_RESOURCE);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_SendPacket()
+*
+*  Function description
+*    Send an event packet.
+*
+*  Parameters
+*    pPacket      - Pointer to the start of the packet.
+*    pPayloadEnd  - Pointer to the end of the payload.
+*                   Make sure there are at least 5 bytes free after the payload.
+*    EventId      - Id of the event packet.
+*
+*  Return value
+*    !=0:  Success, Message sent.
+*    ==0:  Buffer full, Message *NOT* sent.
+*/
+int SEGGER_SYSVIEW_SendPacket(U8* pPacket, U8* pPayloadEnd, unsigned int EventId) {
+#if (SEGGER_SYSVIEW_USE_STATIC_BUFFER == 1)
+  SEGGER_SYSVIEW_LOCK();
+#endif
+  _SendPacket(pPacket + 4, pPayloadEnd, EventId);
+#if (SEGGER_SYSVIEW_USE_STATIC_BUFFER == 1)
+  SEGGER_SYSVIEW_UNLOCK();
+#endif
+  return 0;
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_EncodeU32()
+*
+*  Function description
+*    Encode a U32 in variable-length format.
+*
+*  Parameters
+*    pPayload - Pointer to where U32 will be encoded.
+*    Value    - The 32-bit value to be encoded.
+*
+*  Return value
+*    Pointer to the byte following the value, i.e. the first free
+*    byte in the payload and the next position to store payload
+*    content.
+*/
+U8* SEGGER_SYSVIEW_EncodeU32(U8* pPayload, U32 Value) {
+  ENCODE_U32(pPayload, Value);
+  return pPayload;
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_EncodeString()
+*
+*  Function description
+*    Encode a string in variable-length format.
+*
+*  Parameters
+*    pPayload - Pointer to where string will be encoded.
+*    s        - String to encode.
+*    MaxLen   - Maximum number of characters to encode from string.
+*
+*  Return value
+*    Pointer to the byte following the value, i.e. the first free
+*    byte in the payload and the next position to store payload
+*    content.
+*
+*  Additional information
+*    The string is encoded as a count byte followed by the contents
+*    of the string.
+*    No more than 1 + MaxLen bytes will be encoded to the payload.
+*/
+U8* SEGGER_SYSVIEW_EncodeString(U8* pPayload, const char* s, unsigned int MaxLen) {
+  return _EncodeStr(pPayload, s, MaxLen);
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_EncodeData()
+*
+*  Function description
+*    Encode a byte buffer in variable-length format.
+*
+*  Parameters
+*    pPayload - Pointer to where string will be encoded.
+*    pSrc     - Pointer to data buffer to be encoded.
+*    NumBytes - Number of bytes in the buffer to be encoded.
+*
+*  Return value
+*    Pointer to the byte following the value, i.e. the first free
+*    byte in the payload and the next position to store payload
+*    content.
+*
+*  Additional information
+*    The data is encoded as a count byte followed by the contents
+*    of the data buffer.
+*    Make sure NumBytes + 1 bytes are free for the payload.
+*/
+U8* SEGGER_SYSVIEW_EncodeData(U8 *pPayload, const char* pSrc, unsigned int NumBytes) {
+  return _EncodeData(pPayload, pSrc, NumBytes);
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_EncodeId()
+*
+*  Function description
+*    Encode a 32-bit Id in shrunken variable-length format.
+*
+*  Parameters
+*    pPayload - Pointer to where the Id will be encoded.
+*    Id       - The 32-bit value to be encoded.
+*
+*  Return value
+*    Pointer to the byte following the value, i.e. the first free
+*    byte in the payload and the next position to store payload
+*    content.
+*
+*  Additional information
+*    The parameters to shrink an Id can be configured in
+*    SEGGER_SYSVIEW_Conf.h and via SEGGER_SYSVIEW_SetRAMBase().
+*     SEGGER_SYSVIEW_ID_BASE: Lowest Id reported by the application.
+*       (i.e. 0x20000000 when all Ids are an address in this RAM)
+*     SEGGER_SYSVIEW_ID_SHIFT: Number of bits to shift the Id to
+*       save bandwidth. (i.e. 2 when Ids are 4 byte aligned)
+*/
+U8* SEGGER_SYSVIEW_EncodeId(U8* pPayload, U32 Id) {
+  Id = SHRINK_ID(Id);
+  ENCODE_U32(pPayload, Id);
+  return pPayload;
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_ShrinkId()
+*
+*  Function description
+*    Get the shrunken value of an Id for further processing like in
+*    SEGGER_SYSVIEW_NameResource().
+*
+*  Parameters
+*    Id       - The 32-bit value to be shrunken.
+*
+*  Return value
+*    Shrunken Id.
+*
+*  Additional information
+*    The parameters to shrink an Id can be configured in
+*    SEGGER_SYSVIEW_Conf.h and via SEGGER_SYSVIEW_SetRAMBase().
+*     SEGGER_SYSVIEW_ID_BASE: Lowest Id reported by the application.
+*       (i.e. 0x20000000 when all Ids are an address in this RAM)
+*     SEGGER_SYSVIEW_ID_SHIFT: Number of bits to shift the Id to
+*       save bandwidth. (i.e. 2 when Ids are 4 byte aligned)
+*/
+U32 SEGGER_SYSVIEW_ShrinkId(U32 Id) {
+  return SHRINK_ID(Id);
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RegisterModule()
+*
+*  Function description
+*    Register a middleware module for recording its events.
+*
+*  Parameters
+*    pModule  - The middleware module information.
+*
+*  Additional information
+*    SEGGER_SYSVIEW_MODULE elements:
+*      sDescription      - Pointer to a string containing the module name and optionally the module event description.
+*      NumEvents         - Number of events the module wants to register.
+*      EventOffset       - Offset to be added to the event Ids. Out parameter, set by this function. Do not modify after calling this function.
+*      pfSendModuleDesc  - Callback function pointer to send more detailed module description to SystemView Application.
+*      pNext             - Pointer to next registered module. Out parameter, set by this function. Do not modify after calling this function.
+*/
+void SEGGER_SYSVIEW_RegisterModule(SEGGER_SYSVIEW_MODULE* pModule) {
+  SEGGER_SYSVIEW_LOCK();
+  if (_pFirstModule == 0) {
+    //
+    // No module registered, yet.
+    // Start list with new module.
+    // EventOffset is the base offset for modules
+    //
+    pModule->EventOffset = MODULE_EVENT_OFFSET;
+    pModule->pNext = 0;
+    _pFirstModule = pModule;
+    _NumModules = 1;
+  } else {
+    //
+    // Registreded module(s) present.
+    // Prepend new module in list.
+    // EventOffset set from number of events and offset of previous module.
+    //
+    pModule->EventOffset = _pFirstModule->EventOffset + _pFirstModule->NumEvents;
+    pModule->pNext = _pFirstModule;
+    _pFirstModule = pModule;
+    _NumModules++;
+  }
+  SEGGER_SYSVIEW_SendModule(0);
+  if (pModule->pfSendModuleDesc) {
+    pModule->pfSendModuleDesc();
+  }
+  SEGGER_SYSVIEW_UNLOCK();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordModuleDescription()
+*
+*  Function description
+*    Sends detailed information of a registered module to the host.
+*
+*  Parameters
+*    pModule      - Pointer to the described module.
+*    sDescription - Pointer to a description string.
+*/
+void SEGGER_SYSVIEW_RecordModuleDescription(const SEGGER_SYSVIEW_MODULE* pModule, const char* sDescription) {
+  U8  ModuleId;
+  SEGGER_SYSVIEW_MODULE* p;
+
+  p = _pFirstModule;
+  ModuleId = 0;
+  do {
+    if (p == pModule) {
+      break;
+    }
+    ModuleId++;
+    p = p->pNext;
+  } while (p);
+  {
+    U8* pPayload;
+    U8* pPayloadStart;
+    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32 + 1 + SEGGER_SYSVIEW_MAX_STRING_LEN);
+    //
+    pPayload = pPayloadStart;
+    //
+    // Send module description
+    // Send event offset and number of events
+    //
+    ENCODE_U32(pPayload, ModuleId);
+    ENCODE_U32(pPayload, (pModule->EventOffset));
+    pPayload = _EncodeStr(pPayload, sDescription, SEGGER_SYSVIEW_MAX_STRING_LEN);
+    _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_MODULEDESC);
+    RECORD_END();
+  }
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_SendModule()
+*
+*  Function description
+*    Sends the information of a registered module to the host.
+*
+*  Parameters
+*    ModuleId   - Id of the requested module.
+*/
+void SEGGER_SYSVIEW_SendModule(U8 ModuleId) {
+  SEGGER_SYSVIEW_MODULE* pModule;
+  U32 n;
+
+  if (_pFirstModule != 0) {
+    pModule = _pFirstModule;
+    for (n = 0; n < ModuleId; n++) {
+      pModule = pModule->pNext;
+      if (pModule == 0) {
+        break;
+      }
+    }
+    if (pModule != 0) {
+      U8* pPayload;
+      U8* pPayloadStart;
+      RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32 + 1 + SEGGER_SYSVIEW_MAX_STRING_LEN);
+      //
+      pPayload = pPayloadStart;
+      //
+      // Send module description
+      // Send event offset and number of events
+      //
+      ENCODE_U32(pPayload, ModuleId);
+      ENCODE_U32(pPayload, (pModule->EventOffset));
+      pPayload = _EncodeStr(pPayload, pModule->sModule, SEGGER_SYSVIEW_MAX_STRING_LEN);
+      _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_MODULEDESC);
+      RECORD_END();
+    }
+  }
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_SendModuleDescription()
+*
+*  Function description
+*    Triggers a send of the registered module descriptions.
+*
+*/
+void SEGGER_SYSVIEW_SendModuleDescription(void) {
+  SEGGER_SYSVIEW_MODULE* pModule;
+
+  if (_pFirstModule != 0) {
+    pModule = _pFirstModule;
+    do {
+      if (pModule->pfSendModuleDesc) {
+        pModule->pfSendModuleDesc();
+      }
+      pModule = pModule->pNext;
+    } while (pModule);
+  }
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_SendNumModules()
+*
+*  Function description
+*    Send the number of registered modules to the host.
+*/
+void SEGGER_SYSVIEW_SendNumModules(void) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2*SEGGER_SYSVIEW_QUANTA_U32);
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, _NumModules);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_NUMMODULES);
+  RECORD_END();
+}
+
+#ifndef SEGGER_SYSVIEW_EXCLUDE_PRINTF // Define in project to avoid warnings about variable parameter list
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_PrintfHostEx()
+*
+*  Function description
+*    Print a string which is formatted on the host by the SystemView Application
+*    with Additional information.
+*
+*  Parameters
+*    s        - String to be formatted.
+*    Options  - Options for the string. i.e. Log level.
+*
+*  Additional information
+*    All format arguments are treated as 32-bit scalar values.
+*/
+void SEGGER_SYSVIEW_PrintfHostEx(const char* s, U32 Options, ...) {
+  va_list ParamList;
+#if SEGGER_SYSVIEW_PRINTF_IMPLICIT_FORMAT
+  int r;
+
+  va_start(ParamList, Options);
+  r = _VPrintHost(s, Options, &ParamList);
+  va_end(ParamList);
+
+  if (r == -1) {
+    va_start(ParamList, Options);
+    _VPrintTarget(s, Options, &ParamList);
+    va_end(ParamList);
+  }
+#else
+  va_start(ParamList, Options);
+  _VPrintHost(s, Options, &ParamList);
+  va_end(ParamList);
+#endif
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_PrintfHost()
+*
+*  Function description
+*    Print a string which is formatted on the host by the SystemView Application.
+*
+*  Parameters
+*    s        - String to be formatted.
+*
+*  Additional information
+*    All format arguments are treated as 32-bit scalar values.
+*/
+void SEGGER_SYSVIEW_PrintfHost(const char* s, ...) {
+  va_list ParamList;
+#if SEGGER_SYSVIEW_PRINTF_IMPLICIT_FORMAT
+  int r;
+
+  va_start(ParamList, s);
+  r = _VPrintHost(s, SEGGER_SYSVIEW_LOG, &ParamList);
+  va_end(ParamList);
+
+  if (r == -1) {
+    va_start(ParamList, s);
+    _VPrintTarget(s, SEGGER_SYSVIEW_LOG, &ParamList);
+    va_end(ParamList);
+  }
+#else
+  va_start(ParamList, s);
+  _VPrintHost(s, SEGGER_SYSVIEW_LOG, &ParamList);
+  va_end(ParamList);
+#endif
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_WarnfHost()
+*
+*  Function description
+*    Print a warnin string which is formatted on the host by 
+*    the SystemView Application.
+*
+*  Parameters
+*    s        - String to be formatted.
+*
+*  Additional information
+*    All format arguments are treated as 32-bit scalar values.
+*/
+void SEGGER_SYSVIEW_WarnfHost(const char* s, ...) {
+  va_list ParamList;
+#if SEGGER_SYSVIEW_PRINTF_IMPLICIT_FORMAT
+  int r;
+
+  va_start(ParamList, s);
+  r = _VPrintHost(s, SEGGER_SYSVIEW_WARNING, &ParamList);
+  va_end(ParamList);
+
+  if (r == -1) {
+    va_start(ParamList, s);
+    _VPrintTarget(s, SEGGER_SYSVIEW_WARNING, &ParamList);
+    va_end(ParamList);
+  }
+#else
+  va_start(ParamList, s);
+  _VPrintHost(s, SEGGER_SYSVIEW_WARNING, &ParamList);
+  va_end(ParamList);
+#endif
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_ErrorfHost()
+*
+*  Function description
+*    Print an error string which is formatted on the host by 
+*    the SystemView Application.
+*
+*  Parameters
+*    s        - String to be formatted.
+*
+*  Additional information
+*    All format arguments are treated as 32-bit scalar values.
+*/
+void SEGGER_SYSVIEW_ErrorfHost(const char* s, ...) {
+  va_list ParamList;
+#if SEGGER_SYSVIEW_PRINTF_IMPLICIT_FORMAT
+  int r;
+
+  va_start(ParamList, s);
+  r = _VPrintHost(s, SEGGER_SYSVIEW_ERROR, &ParamList);
+  va_end(ParamList);
+
+  if (r == -1) {
+    va_start(ParamList, s);
+    _VPrintTarget(s, SEGGER_SYSVIEW_ERROR, &ParamList);
+    va_end(ParamList);
+  }
+#else
+  va_start(ParamList, s);
+  _VPrintHost(s, SEGGER_SYSVIEW_ERROR, &ParamList);
+  va_end(ParamList);
+#endif
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_PrintfTargetEx()
+*
+*  Function description
+*    Print a string which is formatted on the target before sent to 
+*    the host with Additional information.
+*
+*  Parameters
+*    s        - String to be formatted.
+*    Options  - Options for the string. i.e. Log level.
+*/
+void SEGGER_SYSVIEW_PrintfTargetEx(const char* s, U32 Options, ...) {
+  va_list ParamList;
+
+  va_start(ParamList, Options);
+  _VPrintTarget(s, Options, &ParamList);
+  va_end(ParamList);
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_PrintfTarget()
+*
+*  Function description
+*    Print a string which is formatted on the target before sent to 
+*    the host.
+*
+*  Parameters
+*    s        - String to be formatted.
+*/
+void SEGGER_SYSVIEW_PrintfTarget(const char* s, ...) {
+  va_list ParamList;
+
+  va_start(ParamList, s);
+  _VPrintTarget(s, SEGGER_SYSVIEW_LOG, &ParamList);
+  va_end(ParamList);
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_WarnfTarget()
+*
+*  Function description
+*    Print a warning string which is formatted on the target before
+*    sent to the host.
+*
+*  Parameters
+*    s        - String to be formatted.
+*/
+void SEGGER_SYSVIEW_WarnfTarget(const char* s, ...) {
+  va_list ParamList;
+
+  va_start(ParamList, s);
+  _VPrintTarget(s, SEGGER_SYSVIEW_WARNING, &ParamList);
+  va_end(ParamList);
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_ErrorfTarget()
+*
+*  Function description
+*    Print an error string which is formatted on the target before
+*    sent to the host.
+*
+*  Parameters
+*    s        - String to be formatted.
+*/
+void SEGGER_SYSVIEW_ErrorfTarget(const char* s, ...) {
+  va_list ParamList;
+
+  va_start(ParamList, s);
+  _VPrintTarget(s, SEGGER_SYSVIEW_ERROR, &ParamList);
+  va_end(ParamList);
+}
+#endif // SEGGER_SYSVIEW_EXCLUDE_PRINTF
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_Print()
+*
+*  Function description
+*    Print a string to the host.
+*
+*  Parameters
+*    s        - String to sent.
+*/
+void SEGGER_SYSVIEW_Print(const char* s) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32 + SEGGER_SYSVIEW_MAX_STRING_LEN);
+  //
+  pPayload = _EncodeStr(pPayloadStart, s, SEGGER_SYSVIEW_MAX_STRING_LEN);
+  ENCODE_U32(pPayload, SEGGER_SYSVIEW_LOG);
+  ENCODE_U32(pPayload, 0);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_Warn()
+*
+*  Function description
+*    Print a warning string to the host.
+*
+*  Parameters
+*    s        - String to sent.
+*/
+void SEGGER_SYSVIEW_Warn(const char* s) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32 + SEGGER_SYSVIEW_MAX_STRING_LEN);
+  //
+  pPayload = _EncodeStr(pPayloadStart, s, SEGGER_SYSVIEW_MAX_STRING_LEN);
+  ENCODE_U32(pPayload, SEGGER_SYSVIEW_WARNING);
+  ENCODE_U32(pPayload, 0);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_Error()
+*
+*  Function description
+*    Print an error string to the host.
+*
+*  Parameters
+*    s        - String to sent.
+*/
+void SEGGER_SYSVIEW_Error(const char* s) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32 + SEGGER_SYSVIEW_MAX_STRING_LEN);
+  //
+  pPayload = _EncodeStr(pPayloadStart, s, SEGGER_SYSVIEW_MAX_STRING_LEN);
+  ENCODE_U32(pPayload, SEGGER_SYSVIEW_ERROR);
+  ENCODE_U32(pPayload, 0);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_EnableEvents()
+*
+*  Function description
+*    Enable standard SystemView events to be generated.
+*
+*  Parameters
+*    EnableMask   - Events to be enabled.
+*/
+void SEGGER_SYSVIEW_EnableEvents(U32 EnableMask) {
+  _SYSVIEW_Globals.DisabledEvents &= ~EnableMask;
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_DisableEvents()
+*
+*  Function description
+*    Disable standard SystemView events to not be generated.
+*
+*  Parameters
+*    DisableMask  - Events to be disabled.
+*/
+void SEGGER_SYSVIEW_DisableEvents(U32 DisableMask) {
+  _SYSVIEW_Globals.DisabledEvents |= DisableMask;
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_IsStarted()
+*
+*  Function description
+*    Handle incoming packets if any and check if recording is started.
+*
+*  Return value
+*      0: Recording not started.
+*    > 0: Recording started.
+*/
+int SEGGER_SYSVIEW_IsStarted(void) {
+#if (SEGGER_SYSVIEW_POST_MORTEM_MODE != 1)
+  //
+  // Check if host is sending data which needs to be processed.
+  //
+  if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
+    if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
+      _SYSVIEW_Globals.RecursionCnt = 1;
+      _HandleIncomingPacket();
+      _SYSVIEW_Globals.RecursionCnt = 0;
+    }
+  }
+#endif
+  return _SYSVIEW_Globals.EnableState;
+}
+
+
+/*************************** End of file ****************************/
diff --git a/sched/systemview/SEGGER_SYSVIEW.h b/sched/systemview/SEGGER_SYSVIEW.h
new file mode 100644
index 0000000000..26f98dbc06
--- /dev/null
+++ b/sched/systemview/SEGGER_SYSVIEW.h
@@ -0,0 +1,346 @@
+/*********************************************************************
+*                    SEGGER Microcontroller GmbH                     *
+*                        The Embedded Experts                        *
+**********************************************************************
+*                                                                    *
+*            (c) 1995 - 2019 SEGGER Microcontroller GmbH             *
+*                                                                    *
+*       www.segger.com     Support: support@segger.com               *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SEGGER SystemView * Real-time application analysis           *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+* All rights reserved.                                               *
+*                                                                    *
+* SEGGER strongly recommends to not make any changes                 *
+* to or modify the source code of this software in order to stay     *
+* compatible with the SystemView and RTT protocol, and J-Link.       *
+*                                                                    *
+* Redistribution and use in source and binary forms, with or         *
+* without modification, are permitted provided that the following    *
+* condition is met:                                                  *
+*                                                                    *
+* o Redistributions of source code must retain the above copyright   *
+*   notice, this condition and the following disclaimer.             *
+*                                                                    *
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
+* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
+* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
+* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
+* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
+* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
+* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
+* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
+* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
+* DAMAGE.                                                            *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SystemView version: V3.12                                    *
+*                                                                    *
+**********************************************************************
+-------------------------- END-OF-HEADER -----------------------------
+File    : SEGGER_SYSVIEW.h
+Purpose : System visualization API.
+Revision: $Rev: 17331 $
+*/
+
+#ifndef SEGGER_SYSVIEW_H
+#define SEGGER_SYSVIEW_H
+
+/*********************************************************************
+*
+*       #include Section
+*
+**********************************************************************
+*/
+
+#include "SEGGER.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/*********************************************************************
+*
+*       Defines, fixed
+*
+**********************************************************************
+*/
+
+#define SEGGER_SYSVIEW_MAJOR          3
+#define SEGGER_SYSVIEW_MINOR          10
+#define SEGGER_SYSVIEW_REV            0
+#define SEGGER_SYSVIEW_VERSION        ((SEGGER_SYSVIEW_MAJOR * 10000) + (SEGGER_SYSVIEW_MINOR * 100) + SEGGER_SYSVIEW_REV)
+
+#define SEGGER_SYSVIEW_INFO_SIZE      9   // Minimum size, which has to be reserved for a packet. 1-2 byte of message type, 0-2  byte of payload length, 1-5 bytes of timestamp.
+#define SEGGER_SYSVIEW_QUANTA_U32     5   // Maximum number of bytes to encode a U32, should be reserved for each 32-bit value in a packet.
+
+#define SEGGER_SYSVIEW_LOG            (0u)
+#define SEGGER_SYSVIEW_WARNING        (1u)
+#define SEGGER_SYSVIEW_ERROR          (2u)
+#define SEGGER_SYSVIEW_FLAG_APPEND    (1u << 6)
+
+#define SEGGER_SYSVIEW_PREPARE_PACKET(p)  (p) + 4
+//
+// SystemView events. First 32 IDs from 0 .. 31 are reserved for these
+//
+#define   SYSVIEW_EVTID_NOP                0  // Dummy packet.
+#define   SYSVIEW_EVTID_OVERFLOW           1
+#define   SYSVIEW_EVTID_ISR_ENTER          2
+#define   SYSVIEW_EVTID_ISR_EXIT           3
+#define   SYSVIEW_EVTID_TASK_START_EXEC    4
+#define   SYSVIEW_EVTID_TASK_STOP_EXEC     5
+#define   SYSVIEW_EVTID_TASK_START_READY   6
+#define   SYSVIEW_EVTID_TASK_STOP_READY    7
+#define   SYSVIEW_EVTID_TASK_CREATE        8
+#define   SYSVIEW_EVTID_TASK_INFO          9
+#define   SYSVIEW_EVTID_TRACE_START       10
+#define   SYSVIEW_EVTID_TRACE_STOP        11
+#define   SYSVIEW_EVTID_SYSTIME_CYCLES    12
+#define   SYSVIEW_EVTID_SYSTIME_US        13
+#define   SYSVIEW_EVTID_SYSDESC           14
+#define   SYSVIEW_EVTID_MARK_START        15
+#define   SYSVIEW_EVTID_MARK_STOP         16
+#define   SYSVIEW_EVTID_IDLE              17
+#define   SYSVIEW_EVTID_ISR_TO_SCHEDULER  18
+#define   SYSVIEW_EVTID_TIMER_ENTER       19
+#define   SYSVIEW_EVTID_TIMER_EXIT        20
+#define   SYSVIEW_EVTID_STACK_INFO        21
+#define   SYSVIEW_EVTID_MODULEDESC        22
+
+#define   SYSVIEW_EVTID_INIT              24
+#define   SYSVIEW_EVTID_NAME_RESOURCE     25
+#define   SYSVIEW_EVTID_PRINT_FORMATTED   26
+#define   SYSVIEW_EVTID_NUMMODULES        27
+#define   SYSVIEW_EVTID_END_CALL          28
+#define   SYSVIEW_EVTID_TASK_TERMINATE    29
+
+#define   SYSVIEW_EVTID_EX                31
+//
+// SystemView extended events. Sent with ID 31.
+//
+#define   SYSVIEW_EVTID_EX_MARK            0
+#define   SYSVIEW_EVTID_EX_NAME_MARKER     1
+//
+// Event masks to disable/enable events
+//
+#define   SYSVIEW_EVTMASK_NOP               (1 << SYSVIEW_EVTID_NOP)
+#define   SYSVIEW_EVTMASK_OVERFLOW          (1 << SYSVIEW_EVTID_OVERFLOW)
+#define   SYSVIEW_EVTMASK_ISR_ENTER         (1 << SYSVIEW_EVTID_ISR_ENTER)
+#define   SYSVIEW_EVTMASK_ISR_EXIT          (1 << SYSVIEW_EVTID_ISR_EXIT)
+#define   SYSVIEW_EVTMASK_TASK_START_EXEC   (1 << SYSVIEW_EVTID_TASK_START_EXEC)
+#define   SYSVIEW_EVTMASK_TASK_STOP_EXEC    (1 << SYSVIEW_EVTID_TASK_STOP_EXEC)
+#define   SYSVIEW_EVTMASK_TASK_START_READY  (1 << SYSVIEW_EVTID_TASK_START_READY)
+#define   SYSVIEW_EVTMASK_TASK_STOP_READY   (1 << SYSVIEW_EVTID_TASK_STOP_READY)
+#define   SYSVIEW_EVTMASK_TASK_CREATE       (1 << SYSVIEW_EVTID_TASK_CREATE)
+#define   SYSVIEW_EVTMASK_TASK_INFO         (1 << SYSVIEW_EVTID_TASK_INFO)
+#define   SYSVIEW_EVTMASK_TRACE_START       (1 << SYSVIEW_EVTID_TRACE_START)
+#define   SYSVIEW_EVTMASK_TRACE_STOP        (1 << SYSVIEW_EVTID_TRACE_STOP)
+#define   SYSVIEW_EVTMASK_SYSTIME_CYCLES    (1 << SYSVIEW_EVTID_SYSTIME_CYCLES)
+#define   SYSVIEW_EVTMASK_SYSTIME_US        (1 << SYSVIEW_EVTID_SYSTIME_US)
+#define   SYSVIEW_EVTMASK_SYSDESC           (1 << SYSVIEW_EVTID_SYSDESC)
+#define   SYSVIEW_EVTMASK_USER_START        (1 << SYSVIEW_EVTID_USER_START)
+#define   SYSVIEW_EVTMASK_USER_STOP         (1 << SYSVIEW_EVTID_USER_STOP)
+#define   SYSVIEW_EVTMASK_IDLE              (1 << SYSVIEW_EVTID_IDLE)
+#define   SYSVIEW_EVTMASK_ISR_TO_SCHEDULER  (1 << SYSVIEW_EVTID_ISR_TO_SCHEDULER)
+#define   SYSVIEW_EVTMASK_TIMER_ENTER       (1 << SYSVIEW_EVTID_TIMER_ENTER)
+#define   SYSVIEW_EVTMASK_TIMER_EXIT        (1 << SYSVIEW_EVTID_TIMER_EXIT)
+#define   SYSVIEW_EVTMASK_STACK_INFO        (1 << SYSVIEW_EVTID_STACK_INFO)
+#define   SYSVIEW_EVTMASK_MODULEDESC        (1 << SYSVIEW_EVTID_MODULEDESC)
+
+#define   SYSVIEW_EVTMASK_INIT              (1 << SYSVIEW_EVTID_INIT)
+#define   SYSVIEW_EVTMASK_NAME_RESOURCE     (1 << SYSVIEW_EVTID_NAME_RESOURCE)
+#define   SYSVIEW_EVTMASK_PRINT_FORMATTED   (1 << SYSVIEW_EVTID_PRINT_FORMATTED)
+#define   SYSVIEW_EVTMASK_NUMMODULES        (1 << SYSVIEW_EVTID_NUMMODULES)
+#define   SYSVIEW_EVTMASK_END_CALL          (1 << SYSVIEW_EVTID_END_CALL)
+#define   SYSVIEW_EVTMASK_TASK_TERMINATE    (1 << SYSVIEW_EVTID_TASK_TERMINATE)
+
+#define   SYSVIEW_EVTMASK_EX                (1 << SYSVIEW_EVTID_EX)
+
+#define   SYSVIEW_EVTMASK_ALL_INTERRUPTS    ( SYSVIEW_EVTMASK_ISR_ENTER           \
+                                            | SYSVIEW_EVTMASK_ISR_EXIT            \
+                                            | SYSVIEW_EVTMASK_ISR_TO_SCHEDULER)
+#define   SYSVIEW_EVTMASK_ALL_TASKS         ( SYSVIEW_EVTMASK_TASK_START_EXEC     \
+                                            | SYSVIEW_EVTMASK_TASK_STOP_EXEC      \
+                                            | SYSVIEW_EVTMASK_TASK_START_READY    \
+                                            | SYSVIEW_EVTMASK_TASK_STOP_READY     \
+                                            | SYSVIEW_EVTMASK_TASK_CREATE         \
+                                            | SYSVIEW_EVTMASK_TASK_INFO           \
+                                            | SYSVIEW_EVTMASK_STACK_INFO          \
+                                            | SYSVIEW_EVTMASK_TASK_TERMINATE)
+
+/*********************************************************************
+*
+*       Structures
+*
+**********************************************************************
+*/
+
+typedef struct {
+  U32          TaskID;
+  const char*  sName;
+  U32          Prio;
+  U32          StackBase;
+  U32          StackSize;
+} SEGGER_SYSVIEW_TASKINFO;
+
+typedef struct SEGGER_SYSVIEW_MODULE_STRUCT SEGGER_SYSVIEW_MODULE;
+
+struct SEGGER_SYSVIEW_MODULE_STRUCT {
+  const char*                   sModule;
+        U32                     NumEvents;
+        U32                     EventOffset;
+        void                    (*pfSendModuleDesc)(void);
+        SEGGER_SYSVIEW_MODULE*  pNext;
+};
+
+typedef void (SEGGER_SYSVIEW_SEND_SYS_DESC_FUNC)(void);
+
+/*********************************************************************
+*
+*       API functions
+*
+**********************************************************************
+*/
+
+typedef struct {
+  U64  (*pfGetTime)      (void);
+  void (*pfSendTaskList) (void);
+} SEGGER_SYSVIEW_OS_API;
+
+/*********************************************************************
+*
+*       Control and initialization functions
+*/
+void SEGGER_SYSVIEW_Init                          (U32 SysFreq, U32 CPUFreq, const SEGGER_SYSVIEW_OS_API *pOSAPI, SEGGER_SYSVIEW_SEND_SYS_DESC_FUNC pfSendSysDesc);
+void SEGGER_SYSVIEW_SetRAMBase                    (U32 RAMBaseAddress);
+void SEGGER_SYSVIEW_Start                         (void);
+void SEGGER_SYSVIEW_Stop                          (void);
+void SEGGER_SYSVIEW_GetSysDesc                    (void);
+void SEGGER_SYSVIEW_SendTaskList                  (void);
+void SEGGER_SYSVIEW_SendTaskInfo                  (const SEGGER_SYSVIEW_TASKINFO* pInfo);
+void SEGGER_SYSVIEW_SendSysDesc                   (const char* sSysDesc);
+int  SEGGER_SYSVIEW_IsStarted                     (void);
+int  SEGGER_SYSVIEW_GetChannelID                  (void);
+
+/*********************************************************************
+*
+*       Event recording functions
+*/
+void SEGGER_SYSVIEW_RecordVoid                    (unsigned int EventId);
+void SEGGER_SYSVIEW_RecordU32                     (unsigned int EventId, U32 Para0);
+void SEGGER_SYSVIEW_RecordU32x2                   (unsigned int EventId, U32 Para0, U32 Para1);
+void SEGGER_SYSVIEW_RecordU32x3                   (unsigned int EventId, U32 Para0, U32 Para1, U32 Para2);
+void SEGGER_SYSVIEW_RecordU32x4                   (unsigned int EventId, U32 Para0, U32 Para1, U32 Para2, U32 Para3);
+void SEGGER_SYSVIEW_RecordU32x5                   (unsigned int EventId, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4);
+void SEGGER_SYSVIEW_RecordU32x6                   (unsigned int EventId, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4, U32 Para5);
+void SEGGER_SYSVIEW_RecordU32x7                   (unsigned int EventId, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4, U32 Para5, U32 Para6);
+void SEGGER_SYSVIEW_RecordU32x8                   (unsigned int EventId, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4, U32 Para5, U32 Para6, U32 Para7);
+void SEGGER_SYSVIEW_RecordU32x9                   (unsigned int EventId, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4, U32 Para5, U32 Para6, U32 Para7, U32 Para8);
+void SEGGER_SYSVIEW_RecordU32x10                  (unsigned int EventId, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4, U32 Para5, U32 Para6, U32 Para7, U32 Para8, U32 Para9);
+void SEGGER_SYSVIEW_RecordString                  (unsigned int EventId, const char* pString);
+void SEGGER_SYSVIEW_RecordSystime                 (void);
+void SEGGER_SYSVIEW_RecordEnterISR                (void);
+void SEGGER_SYSVIEW_RecordExitISR                 (void);
+void SEGGER_SYSVIEW_RecordExitISRToScheduler      (void);
+void SEGGER_SYSVIEW_RecordEnterTimer              (U32 TimerId);
+void SEGGER_SYSVIEW_RecordExitTimer               (void);
+void SEGGER_SYSVIEW_RecordEndCall                 (unsigned int EventID);
+void SEGGER_SYSVIEW_RecordEndCallU32              (unsigned int EventID, U32 Para0);
+
+void SEGGER_SYSVIEW_OnIdle                        (void);
+void SEGGER_SYSVIEW_OnTaskCreate                  (U32 TaskId);
+void SEGGER_SYSVIEW_OnTaskTerminate               (U32 TaskId);
+void SEGGER_SYSVIEW_OnTaskStartExec               (U32 TaskId);
+void SEGGER_SYSVIEW_OnTaskStopExec                (void);
+void SEGGER_SYSVIEW_OnTaskStartReady              (U32 TaskId);
+void SEGGER_SYSVIEW_OnTaskStopReady               (U32 TaskId, unsigned int Cause);
+void SEGGER_SYSVIEW_MarkStart                     (unsigned int MarkerId);
+void SEGGER_SYSVIEW_MarkStop                      (unsigned int MarkerId);
+void SEGGER_SYSVIEW_Mark                          (unsigned int MarkerId);
+void SEGGER_SYSVIEW_NameMarker                    (unsigned int MarkerId, const char* sName);
+
+void SEGGER_SYSVIEW_NameResource                  (U32 ResourceId, const char* sName);
+
+int  SEGGER_SYSVIEW_SendPacket                    (U8* pPacket, U8* pPayloadEnd, unsigned int EventId);
+
+/*********************************************************************
+*
+*       Event parameter encoding functions
+*/
+U8*  SEGGER_SYSVIEW_EncodeU32                     (U8* pPayload, U32 Value);
+U8*  SEGGER_SYSVIEW_EncodeData                    (U8* pPayload, const char* pSrc, unsigned int Len);
+U8*  SEGGER_SYSVIEW_EncodeString                  (U8* pPayload, const char* s, unsigned int MaxLen);
+U8*  SEGGER_SYSVIEW_EncodeId                      (U8* pPayload, U32 Id);
+U32  SEGGER_SYSVIEW_ShrinkId                      (U32 Id);
+
+
+/*********************************************************************
+*
+*       Middleware module registration
+*/
+void SEGGER_SYSVIEW_RegisterModule                (SEGGER_SYSVIEW_MODULE* pModule);
+void SEGGER_SYSVIEW_RecordModuleDescription       (const SEGGER_SYSVIEW_MODULE* pModule, const char* sDescription);
+void SEGGER_SYSVIEW_SendModule                    (U8 ModuleId);
+void SEGGER_SYSVIEW_SendModuleDescription         (void);
+void SEGGER_SYSVIEW_SendNumModules                (void);
+
+/*********************************************************************
+*
+*       printf-Style functions
+*/
+#ifndef SEGGER_SYSVIEW_EXCLUDE_PRINTF // Define in project to avoid warnings about variable parameter list
+void SEGGER_SYSVIEW_PrintfHostEx                  (const char* s, U32 Options, ...);
+void SEGGER_SYSVIEW_PrintfTargetEx                (const char* s, U32 Options, ...);
+void SEGGER_SYSVIEW_PrintfHost                    (const char* s, ...);
+void SEGGER_SYSVIEW_PrintfTarget                  (const char* s, ...);
+void SEGGER_SYSVIEW_WarnfHost                     (const char* s, ...);
+void SEGGER_SYSVIEW_WarnfTarget                   (const char* s, ...);
+void SEGGER_SYSVIEW_ErrorfHost                    (const char* s, ...);
+void SEGGER_SYSVIEW_ErrorfTarget                  (const char* s, ...);
+#endif
+
+void SEGGER_SYSVIEW_Print                         (const char* s);
+void SEGGER_SYSVIEW_Warn                          (const char* s);
+void SEGGER_SYSVIEW_Error                         (const char* s);
+
+/*********************************************************************
+*
+*       Run-time configuration functions
+*/
+void SEGGER_SYSVIEW_EnableEvents                  (U32 EnableMask);
+void SEGGER_SYSVIEW_DisableEvents                 (U32 DisableMask);
+
+/*********************************************************************
+*
+*       Application-provided functions
+*/
+void SEGGER_SYSVIEW_Conf                          (void);
+U32  SEGGER_SYSVIEW_X_GetTimestamp                (void);
+U32  SEGGER_SYSVIEW_X_GetInterruptId              (void);
+
+void SEGGER_SYSVIEW_X_StartComm                   (void);
+void SEGGER_SYSVIEW_X_OnEventRecorded             (unsigned NumBytes);
+
+#ifdef __cplusplus
+}
+#endif
+
+/*********************************************************************
+*
+*       Compatibility API defines
+*/
+#define SEGGER_SYSVIEW_OnUserStart      SEGGER_SYSVIEW_MarkStart
+#define SEGGER_SYSVIEW_OnUserStop       SEGGER_SYSVIEW_MarkStop
+
+#endif
+
+/*************************** End of file ****************************/
diff --git a/sched/systemview/SEGGER_SYSVIEW_Conf.h b/sched/systemview/SEGGER_SYSVIEW_Conf.h
new file mode 100644
index 0000000000..58bc46709f
--- /dev/null
+++ b/sched/systemview/SEGGER_SYSVIEW_Conf.h
@@ -0,0 +1,203 @@
+/*********************************************************************
+*                    SEGGER Microcontroller GmbH                     *
+*                        The Embedded Experts                        *
+**********************************************************************
+*                                                                    *
+*            (c) 1995 - 2019 SEGGER Microcontroller GmbH             *
+*                                                                    *
+*       www.segger.com     Support: support@segger.com               *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SEGGER SystemView * Real-time application analysis           *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+* All rights reserved.                                               *
+*                                                                    *
+* SEGGER strongly recommends to not make any changes                 *
+* to or modify the source code of this software in order to stay     *
+* compatible with the SystemView and RTT protocol, and J-Link.       *
+*                                                                    *
+* Redistribution and use in source and binary forms, with or         *
+* without modification, are permitted provided that the following    *
+* condition is met:                                                  *
+*                                                                    *
+* o Redistributions of source code must retain the above copyright   *
+*   notice, this condition and the following disclaimer.             *
+*                                                                    *
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
+* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
+* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
+* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
+* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
+* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
+* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
+* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
+* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
+* DAMAGE.                                                            *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SystemView version: V3.12                                    *
+*                                                                    *
+**********************************************************************
+-------------------------- END-OF-HEADER -----------------------------
+
+File    : SEGGER_SYSVIEW_Conf.h
+Purpose : SEGGER SystemView configuration.
+Revision: $Rev: 17066 $
+*/
+
+#include <nuttx/config.h>
+
+#ifndef SEGGER_SYSVIEW_CONF_H
+#define SEGGER_SYSVIEW_CONF_H
+
+/*********************************************************************
+*
+*       Defines, fixed
+*
+**********************************************************************
+*/
+//
+// Constants for known core configuration
+//
+#define SEGGER_SYSVIEW_CORE_OTHER   0
+#define SEGGER_SYSVIEW_CORE_CM0     1 // Cortex-M0/M0+/M1
+#define SEGGER_SYSVIEW_CORE_CM3     2 // Cortex-M3/M4/M7
+#define SEGGER_SYSVIEW_CORE_RX      3 // Renesas RX
+
+#if (defined __SES_ARM) || (defined __CROSSWORKS_ARM) || (defined __GNUC__) || (defined __clang__)
+  #if (defined __ARM_ARCH_6M__) || (defined __ARM_ARCH_8M_BASE__)
+    #define SEGGER_SYSVIEW_CORE SEGGER_SYSVIEW_CORE_CM0
+  #elif (defined(__ARM_ARCH_7M__) || defined(__ARM_ARCH_7EM__) || defined(__ARM_ARCH_8M_MAIN__))
+    #define SEGGER_SYSVIEW_CORE SEGGER_SYSVIEW_CORE_CM3
+  #endif
+#elif defined(__ICCARM__)
+  #if (defined (__ARM6M__)          && (__CORE__ == __ARM6M__))          \
+   || (defined (__ARM8M_BASELINE__) && (__CORE__ == __ARM8M_BASELINE__))
+    #define SEGGER_SYSVIEW_CORE SEGGER_SYSVIEW_CORE_CM0
+  #elif (defined (__ARM7EM__)         && (__CORE__ == __ARM7EM__))         \
+     || (defined (__ARM7M__)          && (__CORE__ == __ARM7M__))          \
+     || (defined (__ARM8M_MAINLINE__) && (__CORE__ == __ARM8M_MAINLINE__)) \
+     || (defined (__ARM8M_MAINLINE__) && (__CORE__ == __ARM8M_MAINLINE__))
+    #define SEGGER_SYSVIEW_CORE SEGGER_SYSVIEW_CORE_CM3
+  #endif
+#elif defined(__CC_ARM)
+  #if (defined(__TARGET_ARCH_6S_M))
+    #define SEGGER_SYSVIEW_CORE SEGGER_SYSVIEW_CORE_CM0
+  #elif (defined(__TARGET_ARCH_7_M) || defined(__TARGET_ARCH_7E_M))
+    #define SEGGER_SYSVIEW_CORE SEGGER_SYSVIEW_CORE_CM3
+  #endif
+#elif defined(__TI_ARM__)
+  #ifdef __TI_ARM_V6M0__
+    #define SEGGER_SYSVIEW_CORE SEGGER_SYSVIEW_CORE_CM0
+  #elif (defined(__TI_ARM_V7M3__) || defined(__TI_ARM_V7M4__))
+    #define SEGGER_SYSVIEW_CORE SEGGER_SYSVIEW_CORE_CM3
+  #endif
+#elif defined(__ICCRX__)
+  #define SEGGER_SYSVIEW_CORE SEGGER_SYSVIEW_CORE_RX
+#elif defined(__RX)
+  #define SEGGER_SYSVIEW_CORE SEGGER_SYSVIEW_CORE_RX
+#endif
+
+#ifndef   SEGGER_SYSVIEW_CORE
+  #define SEGGER_SYSVIEW_CORE SEGGER_SYSVIEW_CORE_OTHER
+#endif
+
+#ifndef   SEGGER_SYSVIEW_ON_EVENT_RECORDED
+  #define SEGGER_SYSVIEW_ON_EVENT_RECORDED(NumBytes)                            // Needed for SystemView via non-J-Link Recorder. Macro to enable the UART or notify IP task.
+#endif
+
+/*********************************************************************
+*
+*       Defines, configurable
+*
+**********************************************************************
+*/
+/*********************************************************************
+*
+*       SystemView buffer configuration
+*/
+#ifndef   SEGGER_SYSVIEW_RTT_BUFFER_SIZE
+  #define SEGGER_SYSVIEW_RTT_BUFFER_SIZE        CONFIG_SYSTEMVIEW_BUFFER_SIZE   // Number of bytes that SystemView uses for the buffer.
+#endif
+
+#ifndef   SEGGER_SYSVIEW_RTT_CHANNEL
+  #define SEGGER_SYSVIEW_RTT_CHANNEL            CONFIG_SYSTEMVIEW_RTT_CHANNEL   // The RTT channel that SystemView will use. 0: Auto selection
+#endif
+
+#ifndef   SEGGER_SYSVIEW_USE_STATIC_BUFFER
+#ifdef CONFIG_SYSTEMVIEW_USE_STATIC_BUFFER
+  #define SEGGER_SYSVIEW_USE_STATIC_BUFFER      1                               // Use a static buffer to generate events instead of a buffer on the stack
+#else
+  #define SEGGER_SYSVIEW_USE_STATIC_BUFFER      0                               // Use a static buffer to generate events instead of a buffer on the stack
+#endif
+#endif
+
+#ifndef   SEGGER_SYSVIEW_POST_MORTEM_MODE
+#ifdef   CONFIG_SYSTEMVIEW_POST_MORTEM_MODE
+  #define SEGGER_SYSVIEW_POST_MORTEM_MODE       1                               // 1: Enable post mortem analysis mode
+#else
+  #define SEGGER_SYSVIEW_POST_MORTEM_MODE       0                               // 1: Enable post mortem analysis mode
+#endif
+#endif
+
+#ifndef   SEGGER_SYSVIEW_CAN_RESTART
+  #define SEGGER_SYSVIEW_CAN_RESTART            1                               // 1: Send the SystemView start sequence on every start command, not just on the first. Enables restart when SystemView Application disconnected unexpectedly.
+#endif
+
+/*********************************************************************
+*
+*       SystemView timestamp configuration
+*/
+#if !defined(SEGGER_SYSVIEW_GET_TIMESTAMP) && !defined(SEGGER_SYSVIEW_TIMESTAMP_BITS)
+  #if SEGGER_SYSVIEW_CORE == SEGGER_SYSVIEW_CORE_CM3
+    #define SEGGER_SYSVIEW_GET_TIMESTAMP()      (*(U32 *)(0xE0001004))          // Retrieve a system timestamp. Cortex-M cycle counter.
+    #define SEGGER_SYSVIEW_TIMESTAMP_BITS       32                              // Define number of valid bits low-order delivered by clock source
+  #else
+    #define SEGGER_SYSVIEW_GET_TIMESTAMP()      SEGGER_SYSVIEW_X_GetTimestamp() // Retrieve a system timestamp via user-defined function
+    #define SEGGER_SYSVIEW_TIMESTAMP_BITS       32                              // Define number of valid bits low-order delivered by SEGGER_SYSVIEW_X_GetTimestamp()
+  #endif
+#endif
+
+/*********************************************************************
+*
+*       SystemView Id configuration
+*/
+#ifndef   SEGGER_SYSVIEW_ID_BASE
+  #define SEGGER_SYSVIEW_ID_BASE                CONFIG_SYSTEMVIEW_RES_ID_BASE                      // Default value for the lowest Id reported by the application. Can be overridden by the application via SEGGER_SYSVIEW_SetRAMBase(). (i.e. 0x20000000 when all Ids are an address in this RAM)
+#endif
+
+#ifndef   SEGGER_SYSVIEW_ID_SHIFT
+  #define SEGGER_SYSVIEW_ID_SHIFT               CONFIG_SYSTEMVIEW_RES_ID_SHIFT                               // Number of bits to shift the Id to save bandwidth. (i.e. 2 when Ids are 4 byte aligned)
+#endif
+/*********************************************************************
+*
+*       SystemView interrupt configuration
+*/
+#ifndef SEGGER_SYSVIEW_GET_INTERRUPT_ID
+  #if SEGGER_SYSVIEW_CORE == SEGGER_SYSVIEW_CORE_CM3
+    #define SEGGER_SYSVIEW_GET_INTERRUPT_ID()      ((*(U32*)(0xE000ED04)) & 0x1FF)    // Get the currently active interrupt Id. (i.e. read Cortex-M ICSR[8:0] = active vector)
+  #elif SEGGER_SYSVIEW_CORE == SEGGER_SYSVIEW_CORE_CM0
+    #if defined(__ICCARM__)
+      #if (__VER__ > 6010000)
+        #define SEGGER_SYSVIEW_GET_INTERRUPT_ID()  (__get_IPSR())                     // Workaround for IAR, which might do a byte-access to 0xE000ED04. Read IPSR instead.
+      #else
+        #define SEGGER_SYSVIEW_GET_INTERRUPT_ID()  ((*(U32*)(0xE000ED04)) & 0x3F)     // Older versions of IAR do not include __get_IPSR, but might also not optimize to byte-access.
+      #endif
+    #else
+      #define SEGGER_SYSVIEW_GET_INTERRUPT_ID()    ((*(U32*)(0xE000ED04)) & 0x3F)     // Get the currently active interrupt Id. (i.e. read Cortex-M ICSR[5:0] = active vector)
+    #endif
+  #else
+    #define SEGGER_SYSVIEW_GET_INTERRUPT_ID()      SEGGER_SYSVIEW_X_GetInterruptId()  // Get the currently active interrupt Id from the user-provided function.
+  #endif
+#endif
+
+#endif  // SEGGER_SYSVIEW_CONF_H
+
+/*************************** End of file ****************************/
diff --git a/sched/systemview/SEGGER_SYSVIEW_ConfDefaults.h b/sched/systemview/SEGGER_SYSVIEW_ConfDefaults.h
new file mode 100644
index 0000000000..0196fbd446
--- /dev/null
+++ b/sched/systemview/SEGGER_SYSVIEW_ConfDefaults.h
@@ -0,0 +1,172 @@
+/*********************************************************************
+*                    SEGGER Microcontroller GmbH                     *
+*                        The Embedded Experts                        *
+**********************************************************************
+*                                                                    *
+*            (c) 1995 - 2019 SEGGER Microcontroller GmbH             *
+*                                                                    *
+*       www.segger.com     Support: support@segger.com               *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SEGGER SystemView * Real-time application analysis           *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+* All rights reserved.                                               *
+*                                                                    *
+* SEGGER strongly recommends to not make any changes                 *
+* to or modify the source code of this software in order to stay     *
+* compatible with the SystemView and RTT protocol, and J-Link.       *
+*                                                                    *
+* Redistribution and use in source and binary forms, with or         *
+* without modification, are permitted provided that the following    *
+* condition is met:                                                  *
+*                                                                    *
+* o Redistributions of source code must retain the above copyright   *
+*   notice, this condition and the following disclaimer.             *
+*                                                                    *
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
+* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
+* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
+* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
+* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
+* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
+* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
+* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
+* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
+* DAMAGE.                                                            *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SystemView version: V3.12                                    *
+*                                                                    *
+**********************************************************************
+-------------------------- END-OF-HEADER -----------------------------
+File    : SEGGER_SYSVIEW_ConfDefaults.h
+Purpose : Defines defaults for configurable defines used in
+          SEGGER SystemView.
+Revision: $Rev: 9599 $
+*/
+
+#ifndef SEGGER_SYSVIEW_CONFDEFAULTS_H
+#define SEGGER_SYSVIEW_CONFDEFAULTS_H
+
+/*********************************************************************
+*
+*       #include Section
+*
+**********************************************************************
+*/
+
+#include "SEGGER_SYSVIEW_Conf.h"
+#include "SEGGER_RTT_Conf.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*********************************************************************
+*
+*       Configuration defaults
+*
+**********************************************************************
+*/
+
+// Number of bytes that SystemView uses for a buffer.
+#ifndef   SEGGER_SYSVIEW_RTT_BUFFER_SIZE
+  #define SEGGER_SYSVIEW_RTT_BUFFER_SIZE    1024
+#endif
+
+// The RTT channel that SystemView will use.
+#ifndef   SEGGER_SYSVIEW_RTT_CHANNEL
+  #define SEGGER_SYSVIEW_RTT_CHANNEL        0
+#endif
+// Sanity check of RTT channel
+#if (SEGGER_SYSVIEW_RTT_CHANNEL == 0) && (SEGGER_RTT_MAX_NUM_UP_BUFFERS < 2)
+  #error "SEGGER_RTT_MAX_NUM_UP_BUFFERS in SEGGER_RTT_Conf.h has to be > 1!"
+#elif (SEGGER_SYSVIEW_RTT_CHANNEL >= SEGGER_RTT_MAX_NUM_UP_BUFFERS)
+  #error "SEGGER_RTT_MAX_NUM_UP_BUFFERS  in SEGGER_RTT_Conf.h has to be > SEGGER_SYSVIEW_RTT_CHANNEL!"
+#endif
+
+// Place the SystemView buffer into its own/the RTT section
+#if !(defined SEGGER_SYSVIEW_BUFFER_SECTION) && (defined SEGGER_RTT_SECTION)
+  #define SEGGER_SYSVIEW_BUFFER_SECTION            SEGGER_RTT_SECTION
+#endif
+
+// Retrieve a system timestamp.  This gets the Cortex-M cycle counter.
+#ifndef   SEGGER_SYSVIEW_GET_TIMESTAMP
+  #error "SEGGER_SYSVIEW_GET_TIMESTAMP has to be defined in SEGGER_SYSVIEW_Conf.h!"
+#endif
+
+// Define number of valid bits low-order delivered by clock source.
+#ifndef   SEGGER_SYSVIEW_TIMESTAMP_BITS
+  #define SEGGER_SYSVIEW_TIMESTAMP_BITS     32
+#endif
+
+// Lowest Id reported by the Application.
+#ifndef   SEGGER_SYSVIEW_ID_BASE 
+  #define SEGGER_SYSVIEW_ID_BASE            0
+#endif
+
+// Number of bits to shift Ids to save bandwidth
+#ifndef   SEGGER_SYSVIEW_ID_SHIFT
+  #define SEGGER_SYSVIEW_ID_SHIFT           0
+#endif
+
+#ifndef   SEGGER_SYSVIEW_GET_INTERRUPT_ID
+  #error "SEGGER_SYSVIEW_GET_INTERRUPT_ID has to be defined in SEGGER_SYSVIEW_Conf.h!"
+#endif
+
+#ifndef   SEGGER_SYSVIEW_MAX_ARGUMENTS
+  #define SEGGER_SYSVIEW_MAX_ARGUMENTS      16
+#endif
+
+#ifndef   SEGGER_SYSVIEW_MAX_STRING_LEN
+  #define SEGGER_SYSVIEW_MAX_STRING_LEN     128
+#endif
+
+#ifndef   SEGGER_SYSVIEW_PRINTF_IMPLICIT_FORMAT
+  #define SEGGER_SYSVIEW_PRINTF_IMPLICIT_FORMAT 0
+#endif
+
+// Use a static buffer instead of a buffer on the stack for packets
+#ifndef   SEGGER_SYSVIEW_USE_STATIC_BUFFER
+  #define SEGGER_SYSVIEW_USE_STATIC_BUFFER  1
+#endif
+
+// Maximum packet size used by SystemView for the static buffer
+#ifndef   SEGGER_SYSVIEW_MAX_PACKET_SIZE
+  #define SEGGER_SYSVIEW_MAX_PACKET_SIZE   SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_MAX_STRING_LEN + 2 * SEGGER_SYSVIEW_QUANTA_U32 + SEGGER_SYSVIEW_MAX_ARGUMENTS * SEGGER_SYSVIEW_QUANTA_U32
+#endif
+
+// Use post-mortem analysis instead of real-time analysis
+#ifndef   SEGGER_SYSVIEW_POST_MORTEM_MODE
+  #define SEGGER_SYSVIEW_POST_MORTEM_MODE   0
+#endif
+
+// Configure how frequently syncronization is sent
+#ifndef   SEGGER_SYSVIEW_SYNC_PERIOD_SHIFT
+  #define SEGGER_SYSVIEW_SYNC_PERIOD_SHIFT  8
+#endif
+
+// Lock SystemView (nestable)
+#ifndef   SEGGER_SYSVIEW_LOCK
+  #define SEGGER_SYSVIEW_LOCK()             SEGGER_RTT_LOCK()
+#endif
+
+// Unlock SystemView (nestable)
+#ifndef   SEGGER_SYSVIEW_UNLOCK
+  #define SEGGER_SYSVIEW_UNLOCK()           SEGGER_RTT_UNLOCK()
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+/*************************** End of file ****************************/
diff --git a/sched/systemview/SEGGER_SYSVIEW_Config_NuttX.c b/sched/systemview/SEGGER_SYSVIEW_Config_NuttX.c
new file mode 100644
index 0000000000..95244fd7e9
--- /dev/null
+++ b/sched/systemview/SEGGER_SYSVIEW_Config_NuttX.c
@@ -0,0 +1,194 @@
+/*********************************************************************
+*                    SEGGER Microcontroller GmbH                     *
+*                        The Embedded Experts                        *
+**********************************************************************
+*                                                                    *
+*            (c) 1995 - 2019 SEGGER Microcontroller GmbH             *
+*                                                                    *
+*       www.segger.com     Support: support@segger.com               *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SEGGER SystemView * Real-time application analysis           *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+* All rights reserved.                                               *
+*                                                                    *
+* SEGGER strongly recommends to not make any changes                 *
+* to or modify the source code of this software in order to stay     *
+* compatible with the SystemView and RTT protocol, and J-Link.       *
+*                                                                    *
+* Redistribution and use in source and binary forms, with or         *
+* without modification, are permitted provided that the following    *
+* condition is met:                                                  *
+*                                                                    *
+* o Redistributions of source code must retain the above copyright   *
+*   notice, this condition and the following disclaimer.             *
+*                                                                    *
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
+* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
+* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
+* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
+* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
+* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
+* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
+* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
+* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
+* DAMAGE.                                                            *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SystemView version: V3.12                                    *
+*                                                                    *
+**********************************************************************
+-------------------------- END-OF-HEADER -----------------------------
+
+File    : SEGGER_SYSVIEW_Config_NuttX.c
+Purpose : Sample setup configuration of SystemView with NuttX.
+Revision: $Rev$
+*/
+#include "SEGGER_SYSVIEW.h"
+#include "SEGGER_SYSVIEW_Conf.h"
+#include "SEGGER_SYSVIEW_NuttX.h"
+
+
+/*********************************************************************
+*
+*       Defines, configurable
+*
+**********************************************************************
+*/
+#ifndef CONFIG_SYSTEMVIEW_APP_NAME
+#error CONFIG_SYSTEMVIEW_APP_NAME undefined!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+#endif
+// The application name to be displayed in SystemViewer
+#ifndef   SYSVIEW_APP_NAME
+  #define SYSVIEW_APP_NAME        CONFIG_SYSTEMVIEW_APP_NAME
+#endif
+
+// The target device name
+#ifndef   SYSVIEW_DEVICE_NAME
+  #define SYSVIEW_DEVICE_NAME     CONFIG_SYSTEMVIEW_DEVICE_NAME
+#endif
+
+// Frequency of the timestamp. Must match SEGGER_SYSVIEW_Conf.h
+#ifndef   SYSVIEW_TIMESTAMP_FREQ
+  #define SYSVIEW_TIMESTAMP_FREQ  (CONFIG_SYSTEMVIEW_TIMESTAMP_FREQ)
+#endif
+
+// System Frequency. SystemcoreClock is used in most CMSIS compatible projects.
+#ifndef   SYSVIEW_CPU_FREQ
+  #define SYSVIEW_CPU_FREQ        (CONFIG_SYSTEMVIEW_CPU_FREQ)
+#endif
+
+// The lowest RAM address used for IDs (pointers)
+#ifndef   SYSVIEW_RAM_BASE
+  #define SYSVIEW_RAM_BASE        (CONFIG_SYSTEMVIEW_RES_ID_BASE)
+#endif
+
+#ifndef   SYSVIEW_SYSDESC0
+  #define SYSVIEW_SYSDESC0        CONFIG_SYSTEMVIEW_SYSDESC_0
+#endif
+
+// Define as 1 if the Cortex-M cycle counter is used as SystemView timestamp. Must match SEGGER_SYSVIEW_Conf.h
+#ifndef   USE_CYCCNT_TIMESTAMP
+  #define USE_CYCCNT_TIMESTAMP    1
+#endif
+
+// Define as 1 if the Cortex-M cycle counter is used and there might be no debugger attached while recording,
+// for example in post-mortem mode, or when recording via IP.
+#ifndef   ENABLE_DWT_CYCCNT
+  #define ENABLE_DWT_CYCCNT       (USE_CYCCNT_TIMESTAMP & SEGGER_SYSVIEW_POST_MORTEM_MODE)
+#endif
+
+// Define as 1 to immediately start recording after initialization to catch system initialization.
+#ifndef   SYSVIEW_START_ON_INIT
+#ifdef CONFIG_SYSTEMVIEW_START_ON_INIT
+  #define SYSVIEW_START_ON_INIT   1
+#else
+  #define SYSVIEW_START_ON_INIT   0
+#endif
+#endif
+
+//#ifndef   SYSVIEW_SYSDESC1
+//  #define SYSVIEW_SYSDESC1      ""
+//#endif
+
+//#ifndef   SYSVIEW_SYSDESC2
+//  #define SYSVIEW_SYSDESC2      ""
+//#endif
+
+/*********************************************************************
+*
+*       Defines, fixed
+*
+**********************************************************************
+*/
+#define DEMCR         (*(volatile U32*) (0xE000EDFCuL))  // Debug Exception and Monitor Control Register
+#define TRACEENA_BIT  (1uL << 24)                        // Trace enable bit
+#define DWT_CTRL      (*(volatile U32*) (0xE0001000uL))  // DWT Control Register
+#define NOCYCCNT_BIT  (1uL << 25)                        // Cycle counter support bit
+#define CYCCNTENA_BIT (1uL << 0)                         // Cycle counter enable bit
+
+/*********************************************************************
+*
+*       _cbSendSystemDesc()
+*
+*  Function description
+*    Sends SystemView description strings.
+*/
+static void _cbSendSystemDesc(void) {
+  SEGGER_SYSVIEW_SendSysDesc("N=" SYSVIEW_APP_NAME ",O=NuttX,D=" SYSVIEW_DEVICE_NAME );
+#ifdef SYSVIEW_SYSDESC0
+  SEGGER_SYSVIEW_SendSysDesc(SYSVIEW_SYSDESC0);
+#endif
+#ifdef SYSVIEW_SYSDESC1
+  SEGGER_SYSVIEW_SendSysDesc(SYSVIEW_SYSDESC1);
+#endif
+#ifdef SYSVIEW_SYSDESC2
+  SEGGER_SYSVIEW_SendSysDesc(SYSVIEW_SYSDESC2);
+#endif
+}
+
+/*********************************************************************
+*
+*       Global functions
+*
+**********************************************************************
+*/
+void SEGGER_SYSVIEW_Conf(void) {
+#if USE_CYCCNT_TIMESTAMP
+#if ENABLE_DWT_CYCCNT
+  //
+  // If no debugger is connected, the DWT must be enabled by the application
+  //
+  if ((DEMCR & TRACEENA_BIT) == 0) {
+    DEMCR |= TRACEENA_BIT;
+  }
+#endif
+  //
+  //  The cycle counter must be activated in order
+  //  to use time related functions.
+  //
+  if ((DWT_CTRL & NOCYCCNT_BIT) == 0) {       // Cycle counter supported?
+    if ((DWT_CTRL & CYCCNTENA_BIT) == 0) {    // Cycle counter not enabled?
+      DWT_CTRL |= CYCCNTENA_BIT;              // Enable Cycle counter
+    }
+  }
+#endif
+  SEGGER_SYSVIEW_Init(SYSVIEW_TIMESTAMP_FREQ, SYSVIEW_CPU_FREQ,
+                      &SYSVIEW_X_OS_TraceAPI, _cbSendSystemDesc);
+  SEGGER_SYSVIEW_SetRAMBase(SYSVIEW_RAM_BASE);
+
+  SYSVIEW_InitTime();
+
+#if SYSVIEW_START_ON_INIT
+  SEGGER_SYSVIEW_Start();                     // Start recording to catch system initialization.
+#endif
+}
+
+/*************************** End of file ****************************/
diff --git a/sched/systemview/SEGGER_SYSVIEW_Int.h b/sched/systemview/SEGGER_SYSVIEW_Int.h
new file mode 100644
index 0000000000..b97bbec211
--- /dev/null
+++ b/sched/systemview/SEGGER_SYSVIEW_Int.h
@@ -0,0 +1,100 @@
+/*********************************************************************
+*                    SEGGER Microcontroller GmbH                     *
+*                        The Embedded Experts                        *
+**********************************************************************
+*                                                                    *
+*            (c) 1995 - 2019 SEGGER Microcontroller GmbH             *
+*                                                                    *
+*       www.segger.com     Support: support@segger.com               *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SEGGER SystemView * Real-time application analysis           *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+* All rights reserved.                                               *
+*                                                                    *
+* SEGGER strongly recommends to not make any changes                 *
+* to or modify the source code of this software in order to stay     *
+* compatible with the SystemView and RTT protocol, and J-Link.       *
+*                                                                    *
+* Redistribution and use in source and binary forms, with or         *
+* without modification, are permitted provided that the following    *
+* condition is met:                                                  *
+*                                                                    *
+* o Redistributions of source code must retain the above copyright   *
+*   notice, this condition and the following disclaimer.             *
+*                                                                    *
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
+* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
+* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
+* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
+* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
+* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
+* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
+* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
+* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
+* DAMAGE.                                                            *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SystemView version: V3.12                                    *
+*                                                                    *
+**********************************************************************
+-------------------------- END-OF-HEADER -----------------------------
+File    : SEGGER_SYSVIEW_Int.h
+Purpose : SEGGER SystemView internal header.
+Revision: $Rev: 9599 $
+*/
+
+#ifndef SEGGER_SYSVIEW_INT_H
+#define SEGGER_SYSVIEW_INT_H
+
+/*********************************************************************
+*
+*       #include Section
+*
+**********************************************************************
+*/
+
+#include "SEGGER_SYSVIEW.h"
+#include "SEGGER_SYSVIEW_Conf.h"
+#include "SEGGER_SYSVIEW_ConfDefaults.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/*********************************************************************
+*
+*       Private data types
+*
+**********************************************************************
+*/
+//
+// Commands that Host can send to target
+//
+typedef enum {
+  SEGGER_SYSVIEW_COMMAND_ID_START = 1,
+  SEGGER_SYSVIEW_COMMAND_ID_STOP,
+  SEGGER_SYSVIEW_COMMAND_ID_GET_SYSTIME,
+  SEGGER_SYSVIEW_COMMAND_ID_GET_TASKLIST,
+  SEGGER_SYSVIEW_COMMAND_ID_GET_SYSDESC,
+  SEGGER_SYSVIEW_COMMAND_ID_GET_NUMMODULES,
+  SEGGER_SYSVIEW_COMMAND_ID_GET_MODULEDESC,
+  // Extended commands: Commands >= 128 have a second parameter
+  SEGGER_SYSVIEW_COMMAND_ID_GET_MODULE = 128
+} SEGGER_SYSVIEW_COMMAND_ID;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+/*************************** End of file ****************************/
diff --git a/sched/systemview/SEGGER_SYSVIEW_NuttX.c b/sched/systemview/SEGGER_SYSVIEW_NuttX.c
new file mode 100644
index 0000000000..586bdaeec5
--- /dev/null
+++ b/sched/systemview/SEGGER_SYSVIEW_NuttX.c
@@ -0,0 +1,269 @@
+/*********************************************************************
+*                    SEGGER Microcontroller GmbH                     *
+*                        The Embedded Experts                        *
+**********************************************************************
+*                                                                    *
+*            (c) 1995 - 2019 SEGGER Microcontroller GmbH             *
+*                                                                    *
+*       www.segger.com     Support: support@segger.com               *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SEGGER SystemView * Real-time application analysis           *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+* All rights reserved.                                               *
+*                                                                    *
+* SEGGER strongly recommends to not make any changes                 *
+* to or modify the source code of this software in order to stay     *
+* compatible with the SystemView and RTT protocol, and J-Link.       *
+*                                                                    *
+* Redistribution and use in source and binary forms, with or         *
+* without modification, are permitted provided that the following    *
+* condition is met:                                                  *
+*                                                                    *
+* o Redistributions of source code must retain the above copyright   *
+*   notice, this condition and the following disclaimer.             *
+*                                                                    *
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
+* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
+* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
+* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
+* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
+* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
+* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
+* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
+* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
+* DAMAGE.                                                            *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SystemView version: V3.12                                    *
+*                                                                    *
+**********************************************************************
+-------------------------- END-OF-HEADER -----------------------------
+
+File    : SEGGER_SYSVIEW_NuttX.c
+Purpose : Interface between NuttX and SystemView.
+Revision: $Rev $
+*/
+#include <nuttx/config.h>
+
+#include "SEGGER_SYSVIEW.h"
+#include "SEGGER_SYSVIEW_NuttX.h"
+#include "string.h" // Required for memset
+
+#include <time.h>
+
+
+#ifdef CONFIG_CLOCK_MONOTONIC
+#  define _TIME_CLOCK CLOCK_MONOTONIC
+#else
+#  define _TIME_CLOCK CLOCK_REALTIME
+#endif
+
+
+typedef struct _SYSVIEW_NUTTX_TASK_STATUS _SYSVIEW_NUTTX_TASK_STATUS;
+
+struct _SYSVIEW_NUTTX_TASK_STATUS {
+  U32         TaskID;
+  const char* sName;
+  unsigned    Priority;
+  U32         StackAddr;
+  unsigned    StackSize;
+};
+
+static _SYSVIEW_NUTTX_TASK_STATUS _aTasks[SYSVIEW_NUTTX_MAX_NOF_TASKS];
+static unsigned _NumTasks;
+
+
+static U64      _Time;
+static U64      _TimeStart;
+
+/*********************************************************************
+*
+*       _cbSendTaskList()
+*
+*  Function description
+*    This function is part of the link between NuttX and SYSVIEW.
+*    Called from SystemView when asked by the host, it uses SYSVIEW
+*    functions to send the entire task list to the host.
+*/
+static void _cbSendTaskList(void) {
+  unsigned n;
+
+  for (n = 0; n < _NumTasks; n++) {
+    SYSVIEW_SendTaskInfo(_aTasks[n].TaskID, _aTasks[n].sName, _aTasks[n].Priority, _aTasks[n].StackAddr, _aTasks[n].StackSize);
+  }
+}
+
+/*********************************************************************
+*
+*       _cbGetTime()
+*
+*  Function description
+*    This function is part of the link between FreeRTOS and SYSVIEW.
+*    Called from SystemView when asked by the host, returns the
+*    current system time in micro seconds.
+*/
+static U64 _cbGetTime(void) {
+  struct timespec TimeSpec;
+  int             r;
+
+  r = clock_gettime(_TIME_CLOCK, &TimeSpec);
+
+  if (r >= 0) {
+    _Time = (U64)TimeSpec.tv_sec;
+    _Time *= 1000000uLL;
+    _Time += TimeSpec.tv_nsec / 1000u;
+  }
+  return _Time - _TimeStart;
+}
+
+/*********************************************************************
+*
+*       Global functions
+*
+**********************************************************************
+*/
+/*********************************************************************
+*
+*       SYSVIEW_InitTime()
+*
+*  Function description
+*    Initialize system time of SystemView, to start at 0 with the initialization.
+*/
+void SYSVIEW_InitTime(void) {
+  _TimeStart = 0;
+  _TimeStart = _cbGetTime();
+}
+
+/*********************************************************************
+*
+*       SYSVIEW_AddTask()
+*
+*  Function description
+*    Add a task to the internal list and record its information.
+*/
+void SYSVIEW_AddTask(U32 TaskID, const char* sName, unsigned Priority, U32 StackAddr, unsigned StackSize) {
+  
+  if (_NumTasks >= SYSVIEW_NUTTX_MAX_NOF_TASKS) {
+    SEGGER_SYSVIEW_Warn("SYSTEMVIEW: Could not record task information. Maximum number of tasks reached.");
+    return;
+  }
+
+  _aTasks[_NumTasks].TaskID = TaskID;
+  _aTasks[_NumTasks].sName = sName;
+  _aTasks[_NumTasks].Priority = Priority;
+  _aTasks[_NumTasks].StackAddr = StackAddr;
+  _aTasks[_NumTasks].StackSize = StackSize;
+
+  _NumTasks++;
+
+  SYSVIEW_SendTaskInfo(TaskID, sName, Priority, StackAddr, StackSize);
+}
+
+/*********************************************************************
+*
+*       SYSVIEW_UpdateTask()
+*
+*  Function description
+*    Update a task in the internal list and record its information.
+*/
+void SYSVIEW_UpdateTask(U32 TaskID, const char* sName, unsigned Priority, U32 StackAddr, unsigned StackSize) {
+  unsigned n;
+
+  for (n = 0; n < _NumTasks; n++) {
+    if (_aTasks[n].TaskID == TaskID) {
+      break;
+    }
+  }
+  if (n < _NumTasks) {
+    _aTasks[n].sName = sName;
+    _aTasks[n].Priority = Priority;
+    _aTasks[n].StackAddr = StackAddr;
+    _aTasks[n].StackSize = StackSize;
+
+    SYSVIEW_SendTaskInfo(TaskID, sName, Priority, StackAddr, StackSize);
+  } else {
+    SYSVIEW_AddTask(TaskID, sName, Priority, StackAddr, StackSize);
+  }
+}
+
+/*********************************************************************
+*
+*       SYSVIEW_DeleteTask()
+*
+*  Function description
+*    Delete a task from the internal list.
+*/
+void SYSVIEW_DeleteTask(U32 TaskID) {
+  unsigned n;
+  
+  if (_NumTasks == 0) {
+    return; // Early out
+  }  
+  for (n = 0; n < _NumTasks; n++) {
+    if (_aTasks[n].TaskID == TaskID) {
+      break;
+    }
+  }
+  if (n == (_NumTasks - 1)) {  
+    //
+    // Task is last item in list.
+    // Simply zero the item and decrement number of tasks.
+    //
+    memset(&_aTasks[n], 0, sizeof(_aTasks[n]));
+    _NumTasks--;
+  } else if (n < _NumTasks) {
+    //
+    // Task is in the middle of the list.
+    // Move last item to current position and decrement number of tasks.
+    // Order of tasks does not really matter, so no need to move all following items.
+    //
+    _aTasks[n].TaskID         = _aTasks[_NumTasks - 1].TaskID;
+    _aTasks[n].sName          = _aTasks[_NumTasks - 1].sName;
+    _aTasks[n].Priority       = _aTasks[_NumTasks - 1].Priority;
+    _aTasks[n].StackAddr      = _aTasks[_NumTasks - 1].StackAddr;
+    _aTasks[n].StackSize      = _aTasks[_NumTasks - 1].StackSize;
+    memset(&_aTasks[_NumTasks - 1], 0, sizeof(_aTasks[_NumTasks - 1]));
+    _NumTasks--;
+  }
+}
+
+/*********************************************************************
+*
+*       SYSVIEW_SendTaskInfo()
+*
+*  Function description
+*    Record task information.
+*/
+void SYSVIEW_SendTaskInfo(U32 TaskID, const char* sName, unsigned Prio, U32 StackAddr, unsigned StackSize) {
+  SEGGER_SYSVIEW_TASKINFO TaskInfo;
+
+  memset(&TaskInfo, 0, sizeof(TaskInfo)); // Fill all elements with 0 to allow extending the structure in future version without breaking the code
+  TaskInfo.TaskID     = TaskID;
+  TaskInfo.sName      = sName;
+  TaskInfo.Prio       = Prio;
+  TaskInfo.StackBase  = StackAddr;
+  TaskInfo.StackSize  = StackSize;
+  SEGGER_SYSVIEW_SendTaskInfo(&TaskInfo);
+}
+
+/*********************************************************************
+*
+*       Public API structures
+*
+**********************************************************************
+*/
+// Callbacks provided to SYSTEMVIEW by FreeRTOS
+const SEGGER_SYSVIEW_OS_API SYSVIEW_X_OS_TraceAPI = {
+  _cbGetTime,
+  _cbSendTaskList,
+};
+
+/*************************** End of file ****************************/
diff --git a/sched/systemview/SEGGER_SYSVIEW_NuttX.h b/sched/systemview/SEGGER_SYSVIEW_NuttX.h
new file mode 100644
index 0000000000..b63abbaff2
--- /dev/null
+++ b/sched/systemview/SEGGER_SYSVIEW_NuttX.h
@@ -0,0 +1,156 @@
+/*********************************************************************
+*                    SEGGER Microcontroller GmbH                     *
+*                        The Embedded Experts                        *
+**********************************************************************
+*                                                                    *
+*            (c) 1995 - 2019 SEGGER Microcontroller GmbH             *
+*                                                                    *
+*       www.segger.com     Support: support@segger.com               *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SEGGER SystemView * Real-time application analysis           *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+* All rights reserved.                                               *
+*                                                                    *
+* SEGGER strongly recommends to not make any changes                 *
+* to or modify the source code of this software in order to stay     *
+* compatible with the SystemView and RTT protocol, and J-Link.       *
+*                                                                    *
+* Redistribution and use in source and binary forms, with or         *
+* without modification, are permitted provided that the following    *
+* condition is met:                                                  *
+*                                                                    *
+* o Redistributions of source code must retain the above copyright   *
+*   notice, this condition and the following disclaimer.             *
+*                                                                    *
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
+* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
+* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
+* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
+* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
+* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
+* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
+* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
+* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
+* DAMAGE.                                                            *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SystemView version: V3.12                                    *
+*                                                                    *
+**********************************************************************
+-------------------------- END-OF-HEADER -----------------------------
+
+File    : SEGGER_SYSVIEW_NuttX.h
+Purpose : Interface between NuttX and SystemView.
+Revision: $Rev: 7745 $
+*/
+
+#ifndef SYSVIEW_NUTTX_H
+#define SYSVIEW_NUTTX_H
+
+#include "SEGGER_SYSVIEW.h"
+
+/*********************************************************************
+*
+*       Defines, configurable
+*
+**********************************************************************
+*/
+#ifdef CONFIG_SYSTEMVIEW_MAX_NOF_TASKS
+  #define SYSVIEW_NUTTX_MAX_NOF_TASKS  CONFIG_SYSTEMVIEW_MAX_NOF_TASKS
+#else
+  #define SYSVIEW_NUTTX_MAX_NOF_TASKS  8
+#endif
+
+/*********************************************************************
+*
+*       Defines, fixed
+*
+**********************************************************************
+*/
+#define _SYSTEMVIEW_ID_OFFSET                              (32u)
+#define _TRACE_API_ID_TASK_CREATE                          (1u + _SYSTEMVIEW_ID_OFFSET)
+#define _TRACE_API_ID_NXTASK_CREATE                        (2u + _SYSTEMVIEW_ID_OFFSET)
+#define _TRACE_API_ID_KTHREAD_CREATE                       (3u + _SYSTEMVIEW_ID_OFFSET)
+#define _TRACE_API_ID_PTHREAD_CREATE                       (4u + _SYSTEMVIEW_ID_OFFSET)
+
+#if !defined(CONFIG_SYSTEMVIEW_ENABLE)
+  #define TRACE_INIT()
+  #define TRACE_START()
+  #define TRACE_TASK_CREATED(PID, Name, Priority, StackAddr, StackSize)
+  #define TRACE_TASK_READY(PID)
+  #define TRACE_TASK_START(pTCB)
+  #define TRACE_TASK_BLOCK(PID, State)
+  #define TRACE_TASK_TERMINATE(PID)
+#else
+  #define TRACE_INIT()                              							SEGGER_SYSVIEW_Conf()
+  #define TRACE_START()                             							SEGGER_SYSVIEW_Start()
+  #define TRACE_TASK_CREATED(PID, Name, Priority, StackAddr, StackSize) 		SEGGER_SYSVIEW_OnTaskCreate(PID); 													\
+                                                                                SYSVIEW_AddTask((U32)PID, (const char*)Name, (unsigned)Priority, (U32)StackAddr, (unsigned)StackSize)
+  #define TRACE_TASK_READY(PID)													SEGGER_SYSVIEW_OnTaskStartReady(PID)
+  #define TRACE_TASK_START(PID)  												{ if (PID == 0) { SEGGER_SYSVIEW_OnIdle(); } else { SEGGER_SYSVIEW_OnTaskStartExec(PID); } }
+  #define TRACE_TASK_BLOCK(PID, State) 											SEGGER_SYSVIEW_OnTaskStopReady(PID, (U32)State)
+  #define TRACE_TASK_TERMINATE(PID)                                             { SEGGER_SYSVIEW_OnTaskTerminate(PID); SYSVIEW_DeleteTask(PID); }
+#endif
+
+#if !defined(CONFIG_SYSTEMVIEW_ENABLE) && !defined(CONFIG_SYSTEMVIEW_RECORD_ISR)
+  #define TRACE_ISR_ENTER()
+  #define TRACE_ISR_EXIT()
+  #define TRACE_ISR_EXIT_TO_SCHEDULER()
+#else
+  #define TRACE_ISR_ENTER()                         							SEGGER_SYSVIEW_RecordEnterISR()
+  #define TRACE_ISR_EXIT()                          							SEGGER_SYSVIEW_RecordExitISR()
+  #define TRACE_ISR_EXIT_TO_SCHEDULER()             							SEGGER_SYSVIEW_RecordExitISRToScheduler()
+#endif
+
+#if !defined(CONFIG_SYSTEMVIEW_ENABLE) && !defined(CONFIG_SYSTEMVIEW_RECORD_API)
+  #define TRACE_API_TASK_CREATE(name, priority, stack_size, entry, argv)
+  #define TRACE_API_TASK_CREATE_RETURN(ret)
+  #define TRACE_API_NXTASK_CREATE(name, priority, stack_size, entry, argv)
+  #define TRACE_API_NXTASK_CREATE_RETURN(ret)
+  #define TRACE_API_KTHREAD_CREATE(name, priority, stack_size, entry, argv)
+  #define TRACE_API_KTHREAD_CREATE_RETURN(ret)
+  #define TRACE_API_PTHREAD_CREATE(thread, attr, start_routine, arg)
+  #define TRACE_API_PTHREAD_CREATE_RETURN(ret)
+#else
+  #define TRACE_API_TASK_CREATE(name, priority, stack_size, entry, argv)        SEGGER_SYSVIEW_RecordU32x5     (_TRACE_API_ID_TASK_CREATE,  (U32)name, (U32)priority, (U32)stack_size, (U32)entry, (U32)argv)
+  #define TRACE_API_TASK_CREATE_RETURN(ret)         														SEGGER_SYSVIEW_RecordEndCallU32(_TRACE_API_ID_TASK_CREATE,  ret)
+  #define TRACE_API_NXTASK_CREATE(name, priority, stack_size, entry, argv)      SEGGER_SYSVIEW_RecordU32x5     (_TRACE_API_ID_NXTASK_CREATE, (U32)name, (U32)priority, (U32)stack_size, (U32)entry, (U32)argv)
+  #define TRACE_API_NXTASK_CREATE_RETURN(ret)                                   SEGGER_SYSVIEW_RecordEndCallU32(_TRACE_API_ID_NXTASK_CREATE, ret)
+  #define TRACE_API_KTHREAD_CREATE(name, priority, stack_size, entry, argv)     SEGGER_SYSVIEW_RecordU32x5     (_TRACE_API_ID_KTHREAD_CREATE,  (U32)name, (U32)priority, (U32)stack_size, (U32)entry, (U32)argv)
+  #define TRACE_API_KTHREAD_CREATE_RETURN(ret)                                  SEGGER_SYSVIEW_RecordEndCallU32(_TRACE_API_ID_KTHREAD_CREATE,  ret)
+  #define TRACE_API_PTHREAD_CREATE(thread, attr, start_routine, arg)            SEGGER_SYSVIEW_RecordU32x4     (_TRACE_API_ID_PTHREAD_CREATE, (U32)thread, (U32)attr, (U32)start_routine, (U32)arg)
+  #define TRACE_API_PTHREAD_CREATE_RETURN(ret)                                  SEGGER_SYSVIEW_RecordEndCallU32(_TRACE_API_ID_PTHREAD_CREATE,  ret)
+#endif
+
+/*********************************************************************
+*
+*       API functions
+*
+**********************************************************************
+*/
+#ifdef __cplusplus
+extern "C" {
+#endif
+void SYSVIEW_InitTime     (void);
+void SYSVIEW_AddTask      (U32 TaskID, const char* sName, unsigned Priority, U32 StackAddr, unsigned StackSize);
+void SYSVIEW_UpdateTask   (U32 TaskID, const char* sName, unsigned Priority, U32 StackAddr, unsigned StackSize);
+void SYSVIEW_DeleteTask   (U32 TaskID);
+void SYSVIEW_SendTaskInfo (U32 TaskID, const char* sName, unsigned Priority, U32 StackAddr, unsigned StackSize);
+
+extern const SEGGER_SYSVIEW_OS_API SYSVIEW_X_OS_TraceAPI;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+/*************************** End of file ****************************/
diff --git a/sched/task/task_create.c b/sched/task/task_create.c
index 9915c5d8b6..f013b1cce9 100644
--- a/sched/task/task_create.c
+++ b/sched/task/task_create.c
@@ -38,6 +38,8 @@
 #include "group/group.h"
 #include "task/task.h"
 
+#include "systemview/SEGGER_SYSVIEW_NuttX.h"
+
 /****************************************************************************
  * Private Functions
  ****************************************************************************/
diff --git a/sched/task/task_start.c b/sched/task/task_start.c
index 1ccace2ce8..d562aa4853 100644
--- a/sched/task/task_start.c
+++ b/sched/task/task_start.c
@@ -52,6 +52,8 @@
 #include "signal/signal.h"
 #include "task/task.h"
 
+#include "systemview/SEGGER_SYSVIEW_NuttX.h"
+
 /****************************************************************************
  * Pre-processor Definitions
  ****************************************************************************/
@@ -134,6 +136,8 @@ void nxtask_start(void)
    * we have to switch to user-mode before calling the task.
    */
 
+  TRACE_TASK_START(tcb->cmn.pid);
+
 #ifndef CONFIG_BUILD_FLAT
   if ((tcb->cmn.flags & TCB_FLAG_TTYPE_MASK) != TCB_FLAG_TTYPE_KERNEL)
     {
@@ -147,6 +151,8 @@ void nxtask_start(void)
   nxtask_startup(tcb->cmn.entry.main, argc, tcb->argv);
 #endif
 
+  TRACE_TASK_TERMINATE(tcb->cmn.pid);
+
   /* Call exit() if/when the task returns */
 
   exit(exitcode);
diff --git a/tools/version.sh b/tools/version.sh
index 8467cbd133..3e5e09eb1d 100755
--- a/tools/version.sh
+++ b/tools/version.sh
@@ -86,15 +86,15 @@ done
 OUTFILE=$1
 
 if [ -z ${VERSION} ] ; then
-  VERSION=`git -C ${WD} tag --sort=taggerdate | tail -1 | cut -d'-' -f2`
+  VERSION=`git -C ${WD} describe 2>/dev/null | tail -1 | cut -d'-' -f2`
 
-  # Earlier tags used the format "major.minor", append a "0" for a patch.
+  # If the VERSION does not match X.Y.Z, retrieve version from the tag
 
-  if [[ ${VERSION} =~ ^([0-9]+[\.][0-9]+)$ ]] ; then
-    VERSION=${VERSION}.0
+  if [[ ! ${VERSION} =~ ([0-9]+)\.([0-9]+)\.([0-9]+) ]] ; then
+    VERSION=`git -C ${WD} tag --sort=v:refname | grep -E "nuttx-[0-9]+\.[0-9]+\.[0-9]+" | tail -1 | cut -d'-' -f2`
   fi
-fi
 
+fi
 # Make sure we know what is going on
 
 if [ -z ${VERSION} ] ; then
-- 
2.17.1

