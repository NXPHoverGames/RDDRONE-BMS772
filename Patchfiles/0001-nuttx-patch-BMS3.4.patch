From 48d0727b5bd9adc29ffac1814e3bf74525ccfbea Mon Sep 17 00:00:00 2001
From: Cis van Mierlo <cis.van.mierlo@nxp.com>
Date: Wed, 14 Oct 2020 16:22:25 +0200
Subject: [PATCH] nuttx patch for Spike BMS

---
 Kconfig                                       |    1 +
 arch/arm/include/s32k1xx/s32k14x_irq.h        |    2 +-
 arch/arm/src/s32k1xx/Kconfig                  |  175 +
 arch/arm/src/s32k1xx/Make.defs                |    4 +
 arch/arm/src/s32k1xx/hardware/s32k1xx_ftm.h   | 1216 ++++++-
 .../src/s32k1xx/hardware/s32k1xx_memorymap.h  |    2 +-
 arch/arm/src/s32k1xx/hardware/s32k1xx_pcc.h   |    4 +-
 arch/arm/src/s32k1xx/s32k1xx_eeeprom.c        |    4 +-
 arch/arm/src/s32k1xx/s32k1xx_eeeprom.h        |    2 +-
 arch/arm/src/s32k1xx/s32k1xx_enet.h           |   27 +-
 arch/arm/src/s32k1xx/s32k1xx_flexcan.c        |   24 +-
 arch/arm/src/s32k1xx/s32k1xx_flexcan.h        |   29 +-
 arch/arm/src/s32k1xx/s32k1xx_lpspi.c          |  224 +-
 arch/arm/src/s32k1xx/s32k1xx_pin.c            |    1 +
 arch/arm/src/s32k1xx/s32k1xx_pingpio.c        |    1 -
 arch/arm/src/s32k1xx/s32k1xx_progmem.h        |    2 +-
 arch/arm/src/s32k1xx/s32k1xx_pwm.c            |  836 +++++
 arch/arm/src/s32k1xx/s32k1xx_pwm.h            |  346 ++
 arch/arm/src/s32k1xx/s32k1xx_start.c          |    4 +
 boards/Kconfig                                |   12 +
 boards/arm/s32k1xx/rddrone-bms772/Kconfig     |    8 +
 boards/arm/s32k1xx/rddrone-bms772/README.txt  |   15 +
 .../rddrone-bms772/configs/bms/.gitignore     |    2 +
 .../rddrone-bms772/configs/bms/defconfig      |  105 +
 .../configs/bmsdebug/.gitignore               |    2 +
 .../rddrone-bms772/configs/bmsdebug/defconfig |  107 +
 .../rddrone-bms772/configs/nsh/defconfig      |   72 +
 .../rddrone-bms772/configs/nshdebug/defconfig |   74 +
 .../rddrone-bms772/configs/nshsv/defconfig    | 1540 +++++++++
 .../s32k1xx/rddrone-bms772/include/board.h    |  162 +
 .../rddrone-bms772/include/nsh_romfsimg.h     |   89 +
 .../rddrone-bms772/include/rcS.template       |   20 +
 .../s32k1xx/rddrone-bms772/scripts/Make.defs  |  108 +
 .../s32k1xx/rddrone-bms772/scripts/flash.ld   |  152 +
 .../rddrone-bms772/scripts/s32k144.cfg        |   58 +
 .../s32k1xx/rddrone-bms772/scripts/sram.ld    |  129 +
 .../arm/s32k1xx/rddrone-bms772/src/.gitignore |    2 +
 .../arm/s32k1xx/rddrone-bms772/src/Makefile   |   67 +
 .../rddrone-bms772/src/rddrone-bms772.h       |  215 ++
 .../rddrone-bms772/src/s32k1xx_appinit.c      |   94 +
 .../rddrone-bms772/src/s32k1xx_autoleds.c     |  165 +
 .../s32k1xx/rddrone-bms772/src/s32k1xx_boot.c |   93 +
 .../rddrone-bms772/src/s32k1xx_bringup.c      |  181 +
 .../rddrone-bms772/src/s32k1xx_buttons.c      |  164 +
 .../rddrone-bms772/src/s32k1xx_clockconfig.c  |  217 ++
 .../s32k1xx/rddrone-bms772/src/s32k1xx_gpio.c |  399 +++
 .../rddrone-bms772/src/s32k1xx_periphclocks.c |  159 +
 .../s32k1xx/rddrone-bms772/src/s32k1xx_spi.c  |  166 +
 .../rddrone-bms772/src/s32k1xx_userleds.c     |  117 +
 sched/Makefile                                |    1 +
 sched/init/nx_start.c                         |    4 +
 sched/irq/irq_dispatch.c                      |   13 +
 sched/pthread/pthread_create.c                |   11 +
 sched/pthread/pthread_exit.c                  |    4 +
 sched/sched/sched_addblocked.c                |    4 +
 sched/sched/sched_addreadytorun.c             |    4 +
 sched/sched/sched_resumescheduler.c           |    2 +
 sched/systemview/Global.h                     |  113 +
 sched/systemview/Kconfig                      |   66 +
 sched/systemview/Make.defs                    |   47 +
 sched/systemview/Makefile                     |   76 +
 sched/systemview/SEGGER.h                     |  248 ++
 sched/systemview/SEGGER_RTT.c                 | 2009 +++++++++++
 sched/systemview/SEGGER_RTT.h                 |  325 ++
 sched/systemview/SEGGER_RTT_ASM_ARMv7M.S      |  235 ++
 sched/systemview/SEGGER_RTT_Conf.h            |  388 +++
 sched/systemview/SEGGER_RTT_printf.c          |  504 +++
 sched/systemview/SEGGER_SYSVIEW.c             | 2945 +++++++++++++++++
 sched/systemview/SEGGER_SYSVIEW.h             |  346 ++
 sched/systemview/SEGGER_SYSVIEW_Conf.h        |  203 ++
 .../systemview/SEGGER_SYSVIEW_ConfDefaults.h  |  172 +
 .../systemview/SEGGER_SYSVIEW_Config_NuttX.c  |  194 ++
 sched/systemview/SEGGER_SYSVIEW_Int.h         |  100 +
 sched/systemview/SEGGER_SYSVIEW_NuttX.c       |  269 ++
 sched/systemview/SEGGER_SYSVIEW_NuttX.h       |  156 +
 sched/task/task_create.c                      |   24 +-
 sched/task/task_start.c                       |    6 +
 77 files changed, 15863 insertions(+), 204 deletions(-)
 create mode 100644 arch/arm/src/s32k1xx/s32k1xx_pwm.c
 create mode 100644 arch/arm/src/s32k1xx/s32k1xx_pwm.h
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/Kconfig
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/README.txt
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/configs/bms/.gitignore
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/configs/bms/defconfig
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/configs/bmsdebug/.gitignore
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/configs/bmsdebug/defconfig
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/configs/nsh/defconfig
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/configs/nshdebug/defconfig
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/configs/nshsv/defconfig
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/include/board.h
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/include/nsh_romfsimg.h
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/include/rcS.template
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/scripts/Make.defs
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/scripts/flash.ld
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/scripts/s32k144.cfg
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/scripts/sram.ld
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/src/.gitignore
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/src/Makefile
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/src/rddrone-bms772.h
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_appinit.c
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_autoleds.c
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_boot.c
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_bringup.c
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_buttons.c
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_clockconfig.c
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_gpio.c
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_periphclocks.c
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_spi.c
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_userleds.c
 create mode 100644 sched/systemview/Global.h
 create mode 100644 sched/systemview/Kconfig
 create mode 100644 sched/systemview/Make.defs
 create mode 100644 sched/systemview/Makefile
 create mode 100644 sched/systemview/SEGGER.h
 create mode 100644 sched/systemview/SEGGER_RTT.c
 create mode 100644 sched/systemview/SEGGER_RTT.h
 create mode 100644 sched/systemview/SEGGER_RTT_ASM_ARMv7M.S
 create mode 100644 sched/systemview/SEGGER_RTT_Conf.h
 create mode 100644 sched/systemview/SEGGER_RTT_printf.c
 create mode 100644 sched/systemview/SEGGER_SYSVIEW.c
 create mode 100644 sched/systemview/SEGGER_SYSVIEW.h
 create mode 100644 sched/systemview/SEGGER_SYSVIEW_Conf.h
 create mode 100644 sched/systemview/SEGGER_SYSVIEW_ConfDefaults.h
 create mode 100644 sched/systemview/SEGGER_SYSVIEW_Config_NuttX.c
 create mode 100644 sched/systemview/SEGGER_SYSVIEW_Int.h
 create mode 100644 sched/systemview/SEGGER_SYSVIEW_NuttX.c
 create mode 100644 sched/systemview/SEGGER_SYSVIEW_NuttX.h

diff --git a/Kconfig b/Kconfig
index 85ee2404c9..21d6978fdc 100644
--- a/Kconfig
+++ b/Kconfig
@@ -1756,6 +1756,7 @@ endmenu
 menu "RTOS Features"
 source sched/Kconfig
 source syscall/Kconfig
+source sched/systemview/Kconfig
 endmenu
 
 menu "Device Drivers"
diff --git a/arch/arm/include/s32k1xx/s32k14x_irq.h b/arch/arm/include/s32k1xx/s32k14x_irq.h
index b09850062d..f5159f5c72 100644
--- a/arch/arm/include/s32k1xx/s32k14x_irq.h
+++ b/arch/arm/include/s32k1xx/s32k14x_irq.h
@@ -168,7 +168,7 @@
 #define S32K1XX_IRQ_CAN2_16_31    (112)  /* CAN2 OR'ed Message buffer (16-31) */
                                          /* Reserved (113-114) */
 #define S32K1XX_IRQ_FTM0_CH0_1    (115)  /* FTM0 Channel 0/1 Interrupt */
-#define S32K1XX_IRQ_FTM0_CH2_2    (116)  /* FTM0 Channel 2/3 Interrupt */
+#define S32K1XX_IRQ_FTM0_CH2_3    (116)  /* FTM0 Channel 2/3 Interrupt */
 #define S32K1XX_IRQ_FTM0_CH4_5    (117)  /* FTM0 Channel 4/5 Interrupt */
 #define S32K1XX_IRQ_FTM0_CH6_7    (118)  /* FTM0 Channel 6/7 Interrupt */
 #define S32K1XX_IRQ_FTM0_FAULT    (119)  /* FTM0 Fault Interrupt */
diff --git a/arch/arm/src/s32k1xx/Kconfig b/arch/arm/src/s32k1xx/Kconfig
index ca29c7521a..59700aecd1 100644
--- a/arch/arm/src/s32k1xx/Kconfig
+++ b/arch/arm/src/s32k1xx/Kconfig
@@ -43,6 +43,8 @@ config ARCH_CHIP_S32K144
 config ARCH_CHIP_S32K146
 	bool "S32K146"
 	select ARCH_CHIP_S32K14X
+	select S32K1XX_HAVE_FTM4
+	select S32K1XX_HAVE_FTM5
 	select S32K1XX_HAVE_LPSPI2
 	select S32K1XX_HAVE_FLEXCAN1
 	select S32K1XX_HAVE_FLEXCAN2
@@ -53,6 +55,10 @@ config ARCH_CHIP_S32K148
 	bool "S32K148"
 	select ARCH_CHIP_S32K14X
 	select S32K1XX_HAVE_ENET
+	select S32K1XX_HAVE_FTM4
+	select S32K1XX_HAVE_FTM5
+	select S32K1XX_HAVE_FTM6
+	select S32K1XX_HAVE_FTM7
 	select S32K1XX_HAVE_LPI2C1
 	select S32K1XX_HAVE_LPSPI2
 	select S32K1XX_HAVE_SAI
@@ -76,6 +82,8 @@ config ARCH_CHIP_S32K14X
 	select ARCH_HAVE_FPU
 	select ARCH_HAVE_FETCHADD
 	select S32K1XX_HAVE_EWM
+	select S32K1XX_HAVE_FTM2
+	select S32K1XX_HAVE_FTM3
 	select S32K1XX_HAVE_SPLL
 	select S32K1XX_HAVE_HSRUN
 	select S32K1XX_HAVE_LMEM
@@ -98,6 +106,30 @@ config S32K1XX_HAVE_FIRC_CMU
 	bool
 	default n
 
+config S32K1XX_HAVE_FTM2
+	bool
+	default n
+
+config S32K1XX_HAVE_FTM3
+	bool
+	default n
+
+config S32K1XX_HAVE_FTM4
+	bool
+	default n
+
+config S32K1XX_HAVE_FTM5
+	bool
+	default n
+
+config S32K1XX_HAVE_FTM6
+	bool
+	default n
+
+config S32K1XX_HAVE_FTM7
+	bool
+	default n
+
 config S32K1XX_HAVE_HSRUN
 	bool
 	default n
@@ -140,6 +172,10 @@ config S32K1XX_HAVE_SPLL
 
 # Peripheral Group Selections
 
+config S32K1XX_FTM
+	bool
+	default n
+
 config S32K1XX_LPUART
 	bool
 	default n
@@ -190,6 +226,52 @@ config S32K1XX_FLEXCAN2
 	default n
 	depends on S32K1XX_HAVE_FLEXCAN2
 
+config S32K1XX_FTM0
+	bool "FTM0"
+	default n
+	select S32K1XX_FTM
+
+config S32K1XX_FTM1
+	bool "FTM1"
+	default n
+	select S32K1XX_FTM
+
+config S32K1XX_FTM2
+	bool "FTM2"
+	default n
+	select S32K1XX_FTM
+	depends on S32K1XX_HAVE_FTM2
+
+config S32K1XX_FTM3
+	bool "FTM3"
+	default n
+	select S32K1XX_FTM
+	depends on S32K1XX_HAVE_FTM3
+
+config S32K1XX_FTM4
+	bool "FTM4"
+	default n
+	select S32K1XX_FTM
+	depends on S32K1XX_HAVE_FTM4
+
+config S32K1XX_FTM5
+	bool "FTM5"
+	default n
+	select S32K1XX_FTM
+	depends on S32K1XX_HAVE_FTM5
+
+config S32K1XX_FTM6
+	bool "FTM6"
+	default n
+	select S32K1XX_FTM
+	depends on S32K1XX_HAVE_FTM6
+
+config S32K1XX_FTM7
+	bool "FTM7"
+	default n
+	select S32K1XX_FTM
+	depends on S32K1XX_HAVE_FTM7
+
 menuconfig S32K1XX_LPI2C0
 	bool "LPI2C0"
 	default n
@@ -265,6 +347,99 @@ config S32K1XX_EEEPROM
 
 endmenu # S32K1XX Peripheral Selection
 
+menu "S32K1XX FTM PWM Configuration"
+	depends on S32K1XX_FTM
+
+config S32K1XX_FTM0_PWM
+	bool "FTM0 PWM"
+	default n
+	depends on S32K1XX_FTM0
+
+config S32K1XX_FTM0_CHANNEL
+	int "FTM0 PWM Output Channel"
+	default 0
+	range 0 7
+	depends on S32K1XX_FTM0_PWM
+
+config S32K1XX_FTM1_PWM
+	bool "FTM1 PWM"
+	default n
+	depends on S32K1XX_FTM1
+
+config S32K1XX_FTM1_CHANNEL
+	int "FTM1 PWM Output Channel"
+	default 0
+	range 0 7
+	depends on S32K1XX_FTM1_PWM
+
+config S32K1XX_FTM2_PWM
+	bool "FTM2 PWM"
+	default n
+	depends on S32K1XX_FTM2
+
+config S32K1XX_FTM2_CHANNEL
+	int "FTM2 PWM Output Channel"
+	default 0
+	range 0 7
+	depends on S32K1XX_FTM2_PWM
+
+config S32K1XX_FTM3_PWM
+	bool "FTM3 PWM"
+	default n
+	depends on S32K1XX_FTM3
+
+config S32K1XX_FTM3_CHANNEL
+	int "FTM3 PWM Output Channel"
+	default 0
+	range 0 7
+	depends on S32K1XX_FTM3_PWM
+
+config S32K1XX_FTM4_PWM
+	bool "FTM4 PWM"
+	default n
+	depends on S32K1XX_FTM4
+
+config S32K1XX_FTM4_CHANNEL
+	int "FTM4 PWM Output Channel"
+	default 0
+	range 0 7
+	depends on S32K1XX_FTM4_PWM
+
+config S32K1XX_FTM5_PWM
+	bool "FTM5 PWM"
+	default n
+	depends on S32K1XX_FTM5
+
+config S32K1XX_FTM5_CHANNEL
+	int "FTM5 PWM Output Channel"
+	default 0
+	range 0 7
+	depends on S32K1XX_FTM5_PWM
+
+config S32K1XX_FTM6_PWM
+	bool "FTM6 PWM"
+	default n
+	depends on S32K1XX_FTM6
+
+config S32K1XX_FTM6_CHANNEL
+	int "FTM6 PWM Output Channel"
+	default 0
+	range 0 7
+	depends on S32K1XX_FTM6_PWM
+
+config S32K1XX_FTM7_PWM
+	bool "FTM7 PWM"
+	default n
+	depends on S32K1XX_FTM7
+
+config S32K1XX_FTM7_CHANNEL
+	int "FTM7 PWM Output Channel"
+	default 0
+	range 0 7
+	depends on S32K1XX_FTM7_PWM
+
+endmenu # S32K1XX FTM PWM Configuration
+
 config S32K1XX_WDT_DISABLE
 	bool "Disable watchdog on reset"
 	default y
diff --git a/arch/arm/src/s32k1xx/Make.defs b/arch/arm/src/s32k1xx/Make.defs
index 3928f305b0..46bf525019 100644
--- a/arch/arm/src/s32k1xx/Make.defs
+++ b/arch/arm/src/s32k1xx/Make.defs
@@ -58,6 +58,10 @@ ifeq ($(CONFIG_BOOT_RUNFROMFLASH),y)
 CHIP_CSRCS += s32k1xx_flashcfg.c
 endif
 
+ifeq ($(CONFIG_PWM),y)
+CHIP_CSRCS += s32k1xx_pwm.c
+endif
+
 ifeq ($(CONFIG_S32K1XX_LPUART),y)
 CHIP_CSRCS += s32k1xx_serial.c
 endif
diff --git a/arch/arm/src/s32k1xx/hardware/s32k1xx_ftm.h b/arch/arm/src/s32k1xx/hardware/s32k1xx_ftm.h
index 7cefb43808..06c483637f 100644
--- a/arch/arm/src/s32k1xx/hardware/s32k1xx_ftm.h
+++ b/arch/arm/src/s32k1xx/hardware/s32k1xx_ftm.h
@@ -1,4 +1,4 @@
-/****************************************************************************************************
+/*****************************************************************************************************
  * arch/arm/src/s32k1xx/hardware/s32k1xx_ftm.h
  *
  *   Copyright (C) 2020 Gregory Nutt. All rights reserved.
@@ -31,127 +31,1113 @@
  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  *
- ****************************************************************************************************/
+ *****************************************************************************************************/
 
 #ifndef __ARCH_ARM_SRC_S32K1XX_HARDWARE_S32K1XX_FTM_H
 #define __ARCH_ARM_SRC_S32K1XX_HARDWARE_S32K1XX_FTM_H
 
-/****************************************************************************************************
+/*****************************************************************************************************
  * Included Files
- ****************************************************************************************************/
+ *****************************************************************************************************/
 
-#include <nuttx/config.h>
-#include <hardware/s32k1xx_memorymap.h>
+#include "hardware/s32k1xx_memorymap.h"
 
-/****************************************************************************************************
+/*****************************************************************************************************
  * Pre-processor Definitions
- ****************************************************************************************************/
-
-#define S32K1XX_FTM_SC_OFFSET       0x0000 /* Status and Control offset*/
-#define S32K1XX_FTM_CNT_OFFSET      0x0004 /* Counter offset */
-#define S32K1XX_FTM_MOD_OFFSET      0x0008 /* Modulo offset */
-#define S32K1XX_FTM_C0SC_OFFSET     0x000C /* Channel 0 Status and Control offset */
-#define S32K1XX_FTM_C0V_OFFSET      0x0010 /* Channel 0 Value offset */
-#define S32K1XX_FTM_C1SC_OFFSET     0x0014 /* Channel 1 Status and Control offset */
-#define S32K1XX_FTM_C1V_OFFSET      0x0018 /* Channel 1 Value offset */
-#define S32K1XX_FTM_STATUS_OFFSET   0x0050 /* Capture and Compare Status offset */
-#define S32K1XX_FTM_COMBINE_OFFSET  0x0064 /* Combine Channel Register offset */
-#define S32K1XX_FTM_POL_OFFSET      0x0070 /* Channel Polarity offset */
-#define S32K1XX_FTM_FILTER_OFFSET   0x0078 /* Filter Control offset */
-#define S32K1XX_FTM_QDCTRL_OFFSET   0x0080 /* Quadrature Decoder Control and Status offset */
-#define S32K1XX_FTM_CONF_OFFSET     0x0084 /* Configuration offset */
-
-#define S32K1XX_FTM1_SC             (S32K1XX_FTM1_BASE + S32K1XX_FTM_SC_OFFSET)      /* FTM1 Status and Control */
-#define S32K1XX_FTM1_CNT            (S32K1XX_FTM1_BASE + S32K1XX_FTM_CNT_OFFSET)     /* FTM1 Counter */
-#define S32K1XX_FTM1_MOD            (S32K1XX_FTM1_BASE + S32K1XX_FTM_MOD_OFFSET)     /* FTM1 Modulo */
-#define S32K1XX_FTM1_C0SC           (S32K1XX_FTM1_BASE + S32K1XX_FTM_C0SC_OFFSET)    /* FTM1 Channel 0 Status and Control */
-#define S32K1XX_FTM1_C0V            (S32K1XX_FTM1_BASE + S32K1XX_FTM_C0V_OFFSET)     /* FTM1 Channel 0 Value */
-#define S32K1XX_FTM1_C1SC           (S32K1XX_FTM1_BASE + S32K1XX_FTM_C1SC_OFFSET)    /* FTM1 Channel 1 Status and Control */
-#define S32K1XX_FTM1_C1V            (S32K1XX_FTM1_BASE + S32K1XX_FTM_C1V_OFFSET)     /* FTM1 Channel 1 Value */
-#define S32K1XX_FTM1_C2SC           (S32K1XX_FTM1_BASE + S32K1XX_FTM_C2SC_OFFSET)    /* FTM1 Channel 2 Status and Control */
-#define S32K1XX_FTM1_C2V            (S32K1XX_FTM1_BASE + S32K1XX_FTM_C2V_OFFSET)     /* FTM1 Channel 2 Value */
-#define S32K1XX_FTM1_STATUS         (S32K1XX_FTM1_BASE + S32K1XX_FTM_STATUS_OFFSET)  /* FTM1 Capture and Compare Status */
-#define S32K1XX_FTM1_COMBINE        (S32K1XX_FTM1_BASE + S32K1XX_FTM_COMBINE_OFFSET) /* FTM1 Combine Channel Register offset */
-#define S32K1XX_FTM1_POL            (S32K1XX_FTM1_BASE + S32K1XX_FTM_POL_OFFSET)     /* FTM1 Channel Polarity offset */
-#define S32K1XX_FTM1_FILTER         (S32K1XX_FTM1_BASE + S32K1XX_FTM_FILTER_OFFSET)  /* FTM1 Filter Control offset */
-#define S32K1XX_FTM1_QDCTRL         (S32K1XX_FTM1_BASE + S32K1XX_FTM_QDCTRL_OFFSET)  /* FTM1 Quadrature Decoder Control and Status offset */
-#define S32K1XX_FTM1_CONF           (S32K1XX_FTM1_BASE + S32K1XX_FTM_CONF_OFFSET)    /* FTM1 Configuration */
-
-#define S32K1XX_FTM2_SC             (S32K1XX_FTM2_BASE + S32K1XX_FTM_SC_OFFSET)      /* FTM2 Status and Control */
-#define S32K1XX_FTM2_CNT            (S32K1XX_FTM2_BASE + S32K1XX_FTM_CNT_OFFSET)     /* FTM2 Counter */
-#define S32K1XX_FTM2_MOD            (S32K1XX_FTM2_BASE + S32K1XX_FTM_MOD_OFFSET)     /* FTM2 Modulo */
-#define S32K1XX_FTM2_C0SC           (S32K1XX_FTM2_BASE + S32K1XX_FTM_C0SC_OFFSET)    /* FTM2 Channel 0 Status and Control */
-#define S32K1XX_FTM2_C0V            (S32K1XX_FTM2_BASE + S32K1XX_FTM_C0V_OFFSET)     /* FTM2 Channel 0 Value */
-#define S32K1XX_FTM2_C1SC           (S32K1XX_FTM2_BASE + S32K1XX_FTM_C1SC_OFFSET)    /* FTM2 Channel 1 Status and Control */
-#define S32K1XX_FTM2_C1V            (S32K1XX_FTM2_BASE + S32K1XX_FTM_C1V_OFFSET)     /* FTM2 Channel 1 Value */
-#define S32K1XX_FTM2_C2SC           (S32K1XX_FTM2_BASE + S32K1XX_FTM_C2SC_OFFSET)    /* FTM2 Channel 2 Status and Control */
-#define S32K1XX_FTM2_C2V            (S32K1XX_FTM2_BASE + S32K1XX_FTM_C2V_OFFSET)     /* FTM2 Channel 2 Value */
-#define S32K1XX_FTM2_STATUS         (S32K1XX_FTM2_BASE + S32K1XX_FTM_STATUS_OFFSET)  /* FTM2 Capture and Compare Status */
-#define S32K1XX_FTM2_COMBINE        (S32K1XX_FTM2_BASE + S32K1XX_FTM_COMBINE_OFFSET) /* FTM2 Combine Channel Register offset */
-#define S32K1XX_FTM2_POL            (S32K1XX_FTM2_BASE + S32K1XX_FTM_POL_OFFSET)     /* FTM2 Channel Polarity offset */
-#define S32K1XX_FTM2_FILTER         (S32K1XX_FTM2_BASE + S32K1XX_FTM_FILTER_OFFSET)  /* FTM2 Filter Control offset */
-#define S32K1XX_FTM2_QDCTRL         (S32K1XX_FTM2_BASE + S32K1XX_FTM_QDCTRL_OFFSET)  /* FTM2 Quadrature Decoder Control and Status offset */
-#define S32K1XX_FTM2_CONF           (S32K1XX_FTM2_BASE + S32K1XX_FTM_CONF_OFFSET)    /* FTM2 Configuration */
-
-#define FTM_SC_PS_SHIFT             0 /* Bit 0-2: Prescaler */
-#define FTM_SC_PS_MASK              (7 << FTM_SC_PS_SHIFT)
-# define FTP_SC_PS_DIV1             (0 << FTM_SC_PS_SHIFT)
-# define FTP_SC_PS_DIV2             (1 << FTM_SC_PS_SHIFT)
-# define FTP_SC_PS_DIV4             (2 << FTM_SC_PS_SHIFT)
-# define FTP_SC_PS_DIV8             (3 << FTM_SC_PS_SHIFT)
-# define FTP_SC_PS_DIV16            (4 << FTM_SC_PS_SHIFT)
-# define FTP_SC_PS_DIV32            (5 << FTM_SC_PS_SHIFT)
-# define FTP_SC_PS_DIV64            (6 << FTM_SC_PS_SHIFT)
-# define FTP_SC_PS_DIV128           (7 << FTM_SC_PS_SHIFT)
-#define FTM_SC_CLKS_SHIFT           3 /* Bits 3-4: Clock Srouce Selection */
-#define FTM_SC_CLKS_MASK            (3 << FTM_SC_CLKS_SHIFT)
-# define FTM_SC_CLKS_DIS            (0 << FTM_SC_CLKS_SHIFT)
-# define FTM_SC_CLKS_FTM            (1 << FTM_SC_CLKS_SHIFT)
-# define FTM_SC_CLKS_FIXED          (2 << FTM_SC_CLKS_SHIFT)
-# define FTM_SC_CLKS_EXTCLK         (3 << FTM_SC_CLKS_SHIFT)
-#define FTM_SC_CPWMS                (1 << 5) /* Bit 5: Center-aligned PWM Select */
-#define FTM_SC_RIE                  (1 << 6) /* Bit 6: Reload Point Interrupt Enable */
-#define FTM_SC_RF                   (1 << 7) /* Bit 7: Reload flag */
-#define FTM_SC_TOIE                 (1 << 8) /* Bit 8: Timer Overflow Interrupt Enable */
-#define FTM_SC_TOF                  (1 << 9) /* Bit 9: Timer Overflow Flag*/
-#define FTM_SC_FLTPS_SHIFT          24       /* Bits 24-27: Filter Prescaler */
-#define FTM_SC_FLTPS_MASK           (7 << FTM_SC_FLTPS_SHIFT)
-# define FTM_SC_FLTPS_DIV1          (0 << FTM_SC_FLTPS_SHIFT)  /* Divide Clock by 1 */
-# define FTM_SC_FLTPS_DIV2          (1 << FTM_SC_FLTPS_SHIFT)  /* Divide Clock by 2 */
-# define FTM_SC_FLTPS_DIV3          (2 << FTM_SC_FLTPS_SHIFT)  /* Divide Clock by 3 */
-# define FTM_SC_FLTPS_DIV4          (3 << FTM_SC_FLTPS_SHIFT)  /* Divide Clock by 4 */
-# define FTM_SC_FLTPS_DIV5          (4 << FTM_SC_FLTPS_SHIFT)  /* Divide Clock by 5 */
-# define FTM_SC_FLTPS_DIV6          (5 << FTM_SC_FLTPS_SHIFT)  /* Divide Clock by 6 */
-# define FTM_SC_FLTPS_DIV7          (6 << FTM_SC_FLTPS_SHIFT)  /* Divide Clock by 7 */
-# define FTM_SC_FLTPS_DIV8          (7 << FTM_SC_FLTPS_SHIFT)  /* Divide Clock by 8 */
-# define FTM_SC_FLTPS_DIV9          (8 << FTM_SC_FLTPS_SHIFT)  /* Divide Clock by 9 */
-# define FTM_SC_FLTPS_DIV10         (9 << FTM_SC_FLTPS_SHIFT)  /* Divide Clock by 10 */
-# define FTM_SC_FLTPS_DIV11         (10 << FTM_SC_FLTPS_SHIFT) /* Divide Clock by 11 */
-# define FTM_SC_FLTPS_DIV12         (11 << FTM_SC_FLTPS_SHIFT) /* Divide Clock by 12 */
-# define FTM_SC_FLTPS_DIV13         (12 << FTM_SC_FLTPS_SHIFT) /* Divide Clock by 13 */
-# define FTM_SC_FLTPS_DIV14         (13 << FTM_SC_FLTPS_SHIFT) /* Divide Clock by 14 */
-# define FTM_SC_FLTPS_DIV15         (14 << FTM_SC_FLTPS_SHIFT) /* Divide Clock by 15 */
-# define FTM_SC_FLTPS_DIV16         (15 << FTM_SC_FLTPS_SHIFT) /* Divide Clock by 16 */
-
-#define FTM_CNSC_DMA                (1 << 0)  /* Bit 0: ChnN Enable DMA */
-#define FTM_CNSC_ICRST              (1 << 1)  /* Bit 1: ChnN Input capture reset */
-#define FTM_CNSC_ELSA               (1 << 2)  /* Bit 2: ChnN Edge or Level */
-#define FTM_CNSC_ELSB               (1 << 3)  /* Bit 3: ChnN Edge or Level */
-#define FTM_CNSC_MSA                (1 << 4)  /* Bit 4: ChnN Mode select */
-#define FTM_CNSC_MSB                (1 << 5)  /* Bit 5: ChnN Mode select */
-#define FTM_CNSC_CHIE               (1 << 6)  /* Bit 6: ChnN interrupt enable */
-#define FTM_CNSC_CHF                (1 << 7)  /* Bit 7: ChnN flag */
-#define FTM_CNSC_TRIGMODE           (1 << 8)  /* Bit 8: ChnN tigger mode */
-#define FTM_CNSC_CHIS               (1 << 9)  /* Bit 9: ChnN input state */
-#define FTM_CNSC_CHOV               (1 << 10) /* Bit 10: ChnN output value */
-
-#define FTM_STATUS_CH0F             (1 << 0) /* Bit 0: Chn0 event */
-#define FTM_STATUS_CH1F             (1 << 1) /* Bit 1: Chn1 event */
-#define FTM_STATUS_CH2F             (1 << 2) /* Bit 2: Chn2 event */
-#define FTM_STATUS_CH3F             (1 << 3) /* Bit 3: Chn3 event */
-#define FTM_STATUS_CH4F             (1 << 4) /* Bit 4: Chn4 event */
-#define FTM_STATUS_CH5F             (1 << 5) /* Bit 5: Chn5 event */
-#define FTM_STATUS_CH6F             (1 << 6) /* Bit 6: Chn6 event */
-#define FTM_STATUS_CH7F             (1 << 7) /* Bit 7: Chn7 event */
+ *****************************************************************************************************/
+
+/* Register Offsets **********************************************************************************/
+
+#define S32K1XX_FTM_SC_OFFSET            0x0000 /* Status And Control register offset */
+#define S32K1XX_FTM_CNT_OFFSET           0x0004 /* Counter register offset */
+#define S32K1XX_FTM_MOD_OFFSET           0x0008 /* Modulo register offset */
+#define S32K1XX_FTM_C0SC_OFFSET          0x000c /* Channel 0 Status And Control register offset */
+#define S32K1XX_FTM_C0V_OFFSET           0x0010 /* Channel 0 Value register offset */
+#define S32K1XX_FTM_C1SC_OFFSET          0x0014 /* Channel 1 Status And Control register offset */
+#define S32K1XX_FTM_C1V_OFFSET           0x0018 /* Channel 1 Value register offset */
+#define S32K1XX_FTM_C2SC_OFFSET          0x001c /* Channel 2 Status And Control register offset */
+#define S32K1XX_FTM_C2V_OFFSET           0x0020 /* Channel 2 Value register offset */
+#define S32K1XX_FTM_C3SC_OFFSET          0x0024 /* Channel 3 Status And Control register offset */
+#define S32K1XX_FTM_C3V_OFFSET           0x0028 /* Channel 3 Value register offset */
+#define S32K1XX_FTM_C4SC_OFFSET          0x002c /* Channel 4 Status And Control register offset */
+#define S32K1XX_FTM_C4V_OFFSET           0x0030 /* Channel 4 Value register offset */
+#define S32K1XX_FTM_C5SC_OFFSET          0x0034 /* Channel 5 Status And Control register offset */
+#define S32K1XX_FTM_C5V_OFFSET           0x0038 /* Channel 5 Value register offset */
+#define S32K1XX_FTM_C6SC_OFFSET          0x003c /* Channel 6 Status And Control register offset */
+#define S32K1XX_FTM_C6V_OFFSET           0x0040 /* Channel 6 Value register offset */
+#define S32K1XX_FTM_C7SC_OFFSET          0x0044 /* Channel 7 Status And Control register offset */
+#define S32K1XX_FTM_C7V_OFFSET           0x0048 /* Channel 7 Value register offset */
+#define S32K1XX_FTM_CNTIN_OFFSET         0x004c /* Counter Initial Value register offset */
+#define S32K1XX_FTM_STATUS_OFFSET        0x0050 /* Capture And Compare Status register offset */
+#define S32K1XX_FTM_MODE_OFFSET          0x0054 /* Features Mode Selection register offset */
+#define S32K1XX_FTM_SYNC_OFFSET          0x0058 /* Synchronization register offset */
+#define S32K1XX_FTM_OUTINIT_OFFSET       0x005c /* Initial State For Channels Output register offset */
+#define S32K1XX_FTM_OUTMASK_OFFSET       0x0060 /* Output Mask register offset */
+#define S32K1XX_FTM_COMBINE_OFFSET       0x0064 /* Function For Linked Channels register offset */
+#define S32K1XX_FTM_DEADTIME_OFFSET      0x0068 /* Deadtime Configuration register offset */
+#define S32K1XX_FTM_EXTTRIG_OFFSET       0x006c /* FTM External Trigger register offset */
+#define S32K1XX_FTM_POL_OFFSET           0x0070 /* Channel Polarity register offset */
+#define S32K1XX_FTM_FMS_OFFSET           0x0074 /* Fault Mode Status register offset */
+#define S32K1XX_FTM_FILTER_OFFSET        0x0078 /* Input Capture Filter Control register offset */
+#define S32K1XX_FTM_FLTCTRL_OFFSET       0x007c /* Fault Control register offset */
+#define S32K1XX_FTM_QDCTRL_OFFSET        0x0080 /* Quadrature Decoder Control And Status register offset */
+#define S32K1XX_FTM_CONF_OFFSET          0x0084 /* Configuration register offset */
+#define S32K1XX_FTM_FLTPOL_OFFSET        0x0088 /* FTM Fault Input Polarity register offset */
+#define S32K1XX_FTM_SYNCONF_OFFSET       0x008c /* Synchronization Configuration register offset */
+#define S32K1XX_FTM_INVCTRL_OFFSET       0x0090 /* FTM Inverting Control register offset */
+#define S32K1XX_FTM_SWOCTRL_OFFSET       0x0094 /* FTM Software Output Control register offset */
+#define S32K1XX_FTM_PWMLOAD_OFFSET       0x0098 /* FTM PWM Load register offset */
+#define S32K1XX_FTM_HCR_OFFSET           0x009c /* Half Cycle Register offset */
+
+#define S32K1XX_FTM_PAIR0DEADTIME_OFFSET 0x00a0 /* Pair 0 Deadtime Configuration register offset */
+#define S32K1XX_FTM_PAIR1DEADTIME_OFFSET 0x00a8 /* Pair 1 Deadtime Configuration register offset */
+#define S32K1XX_FTM_PAIR2DEADTIME_OFFSET 0x00b0 /* Pair 2 Deadtime Configuration register offset */
+#define S32K1XX_FTM_PAIR3DEADTIME_OFFSET 0x00b8 /* Pair 3 Deadtime Configuration register offset */
+
+#define S32K1XX_FTM_MOD_MIRROR_OFFSET    0x0200 /* Mirror of Modulo Value register offset */
+#define S32K1XX_FTM_C0V_MIRROR_OFFSET    0x0204 /* Mirror of Channel 0 Match Value register offset */
+#define S32K1XX_FTM_C1V_MIRROR_OFFSET    0x0208 /* Mirror of Channel 1 Match Value register offset */
+#define S32K1XX_FTM_C2V_MIRROR_OFFSET    0x020c /* Mirror of Channel 2 Match Value register offset */
+#define S32K1XX_FTM_C3V_MIRROR_OFFSET    0x0210 /* Mirror of Channel 3 Match Value register offset */
+#define S32K1XX_FTM_C4V_MIRROR_OFFSET    0x0214 /* Mirror of Channel 4 Match Value register offset */
+#define S32K1XX_FTM_C5V_MIRROR_OFFSET    0x0218 /* Mirror of Channel 5 Match Value register offset */
+#define S32K1XX_FTM_C6V_MIRROR_OFFSET    0x021c /* Mirror of Channel 6 Match Value register offset */
+#define S32K1XX_FTM_C7V_MIRROR_OFFSET    0x0220 /* Mirror of Channel 7 Match Value register offset */
+
+#define S32K1XX_FTM_CNSC_OFFSET(n)       (0x000c + (n) * 0x0008) /* Channel (n) Status And Control register offset */
+#define S32K1XX_FTM_CNV_OFFSET(n)        (0x0010 + (n) * 0x0008) /* Channel (n) Value register offset */
+
+/* Register Addresses ********************************************************************************/
+
+/* FTM0 registers */
+
+#define S32K1XX_FTM0_SC                  (S32K1XX_FTM0_BASE + S32K1XX_FTM_SC_OFFSET)       /* FTM0 Status And Control register */
+#define S32K1XX_FTM0_CNT                 (S32K1XX_FTM0_BASE + S32K1XX_FTM_CNT_OFFSET)      /* FTM0 Counter register */
+#define S32K1XX_FTM0_MOD                 (S32K1XX_FTM0_BASE + S32K1XX_FTM_MOD_OFFSET)      /* FTM0 Modulo register */
+#define S32K1XX_FTM0_C0SC                (S32K1XX_FTM0_BASE + S32K1XX_FTM_C0SC_OFFSET)     /* FTM0 Channel 0 Status And Control register */
+#define S32K1XX_FTM0_C0V                 (S32K1XX_FTM0_BASE + S32K1XX_FTM_C0V_OFFSET)      /* FTM0 Channel 0 Value register */
+#define S32K1XX_FTM0_C1SC                (S32K1XX_FTM0_BASE + S32K1XX_FTM_C1SC_OFFSET)     /* FTM0 Channel 1 Status And Control register */
+#define S32K1XX_FTM0_C1V                 (S32K1XX_FTM0_BASE + S32K1XX_FTM_C1V_OFFSET)      /* FTM0 Channel 1 Value register */
+#define S32K1XX_FTM0_C2SC                (S32K1XX_FTM0_BASE + S32K1XX_FTM_C2SC_OFFSET)     /* FTM0 Channel 2 Status And Control register */
+#define S32K1XX_FTM0_C2V                 (S32K1XX_FTM0_BASE + S32K1XX_FTM_C2V_OFFSET)      /* FTM0 Channel 2 Value register */
+#define S32K1XX_FTM0_C3SC                (S32K1XX_FTM0_BASE + S32K1XX_FTM_C3SC_OFFSET)     /* FTM0 Channel 3 Status And Control register */
+#define S32K1XX_FTM0_C3V                 (S32K1XX_FTM0_BASE + S32K1XX_FTM_C3V_OFFSET)      /* FTM0 Channel 3 Value register */
+#define S32K1XX_FTM0_C4SC                (S32K1XX_FTM0_BASE + S32K1XX_FTM_C4SC_OFFSET)     /* FTM0 Channel 4 Status And Control register */
+#define S32K1XX_FTM0_C4V                 (S32K1XX_FTM0_BASE + S32K1XX_FTM_C4V_OFFSET)      /* FTM0 Channel 4 Value register */
+#define S32K1XX_FTM0_C5SC                (S32K1XX_FTM0_BASE + S32K1XX_FTM_C5SC_OFFSET)     /* FTM0 Channel 5 Status And Control register */
+#define S32K1XX_FTM0_C5V                 (S32K1XX_FTM0_BASE + S32K1XX_FTM_C5V_OFFSET)      /* FTM0 Channel 5 Value register */
+#define S32K1XX_FTM0_C6SC                (S32K1XX_FTM0_BASE + S32K1XX_FTM_C6SC_OFFSET)     /* FTM0 Channel 6 Status And Control register */
+#define S32K1XX_FTM0_C6V                 (S32K1XX_FTM0_BASE + S32K1XX_FTM_C6V_OFFSET)      /* FTM0 Channel 6 Value register */
+#define S32K1XX_FTM0_C7SC                (S32K1XX_FTM0_BASE + S32K1XX_FTM_C7SC_OFFSET)     /* FTM0 Channel 7 Status And Control register */
+#define S32K1XX_FTM0_C7V                 (S32K1XX_FTM0_BASE + S32K1XX_FTM_C7V_OFFSET)      /* FTM0 Channel 7 Value register */
+#define S32K1XX_FTM0_CNTIN               (S32K1XX_FTM0_BASE + S32K1XX_FTM_CNTIN_OFFSET)    /* FTM0 Counter Initial Value register */
+#define S32K1XX_FTM0_STATUS              (S32K1XX_FTM0_BASE + S32K1XX_FTM_STATUS_OFFSET)   /* FTM0 Capture And Compare Status register */
+#define S32K1XX_FTM0_MODE                (S32K1XX_FTM0_BASE + S32K1XX_FTM_MODE_OFFSET)     /* FTM0 Features Mode Selection register */
+#define S32K1XX_FTM0_SYNC                (S32K1XX_FTM0_BASE + S32K1XX_FTM_SYNC_OFFSET)     /* FTM0 Synchronization register */
+#define S32K1XX_FTM0_OUTINIT             (S32K1XX_FTM0_BASE + S32K1XX_FTM_OUTINIT_OFFSET)  /* FTM0 Initial State For Channels Output register */
+#define S32K1XX_FTM0_OUTMASK             (S32K1XX_FTM0_BASE + S32K1XX_FTM_OUTMASK_OFFSET)  /* FTM0 Output Mask register */
+#define S32K1XX_FTM0_COMBINE             (S32K1XX_FTM0_BASE + S32K1XX_FTM_COMBINE_OFFSET)  /* FTM0 Function For Linked Channels register */
+#define S32K1XX_FTM0_DEADTIME            (S32K1XX_FTM0_BASE + S32K1XX_FTM_DEADTIME_OFFSET) /* FTM0 Deadtime Configuration register */
+#define S32K1XX_FTM0_EXTTRIG             (S32K1XX_FTM0_BASE + S32K1XX_FTM_EXTTRIG_OFFSET)  /* FTM0 External Trigger register */
+#define S32K1XX_FTM0_POL                 (S32K1XX_FTM0_BASE + S32K1XX_FTM_POL_OFFSET)      /* FTM0 Channel Polarity register */
+#define S32K1XX_FTM0_FMS                 (S32K1XX_FTM0_BASE + S32K1XX_FTM_FMS_OFFSET)      /* FTM0 Fault Mode Status register */
+#define S32K1XX_FTM0_FILTER              (S32K1XX_FTM0_BASE + S32K1XX_FTM_FILTER_OFFSET)   /* FTM0 Input Capture Filter Control register */
+#define S32K1XX_FTM0_FLTCTRL             (S32K1XX_FTM0_BASE + S32K1XX_FTM_FILTCTRL_OFFSET) /* FTM0 Fault Control register */
+#define S32K1XX_FTM0_QDCTRL              (S32K1XX_FTM0_BASE + S32K1XX_FTM_QDCTRL_OFFSET)   /* FTM0 Quadrature Decoder Control And Status register */
+#define S32K1XX_FTM0_CONF                (S32K1XX_FTM0_BASE + S32K1XX_FTM_CONF_OFFSET)     /* FTM0 Configuration register */
+#define S32K1XX_FTM0_FLTPOL              (S32K1XX_FTM0_BASE + S32K1XX_FTM_FLTPOL_OFFSET)   /* FTM0 Fault Input Polarity register */
+#define S32K1XX_FTM0_SYNCONF             (S32K1XX_FTM0_BASE + S32K1XX_FTM_SYNCONF_OFFSET)  /* FTM0 Synchronization Configuration register */
+#define S32K1XX_FTM0_INVCTRL             (S32K1XX_FTM0_BASE + S32K1XX_FTM_INVCTRL_OFFSET)  /* FTM0 Inverting Control register */
+#define S32K1XX_FTM0_SWOCTRL             (S32K1XX_FTM0_BASE + S32K1XX_FTM_SWOCTRL_OFFSET)  /* FTM0 Software Output Control register */
+#define S32K1XX_FTM0_PWMLOAD             (S32K1XX_FTM0_BASE + S32K1XX_FTM_PWMLOAD_OFFSET)  /* FTM0 PWM Load register */
+#define S32K1XX_FTM0_HCR                 (S32K1XX_FTM0_BASE + S32K1XX_FTM_HCR_OFFSET)      /* FTM0 Half Cycle Register */
+
+#define S32K1XX_FTM0_PAIR0DEADTIME       (S32K1XX_FTM0_BASE + S32K1XX_FTM_PAIR0DEADTIME_OFFSET) /* FTM0 Pair 0 Deadtime Configuration register */
+#define S32K1XX_FTM0_PAIR1DEADTIME       (S32K1XX_FTM0_BASE + S32K1XX_FTM_PAIR1DEADTIME_OFFSET) /* FTM0 Pair 1 Deadtime Configuration register */
+#define S32K1XX_FTM0_PAIR2DEADTIME       (S32K1XX_FTM0_BASE + S32K1XX_FTM_PAIR2DEADTIME_OFFSET) /* FTM0 Pair 2 Deadtime Configuration register */
+#define S32K1XX_FTM0_PAIR3DEADTIME       (S32K1XX_FTM0_BASE + S32K1XX_FTM_PAIR3DEADTIME_OFFSET) /* FTM0 Pair 3 Deadtime Configuration register oset */
+
+#define S32K1XX_FTM0_MOD_MIRROR          (S32K1XX_FTM0_BASE + S32K1XX_FTM_MOD_MIRROR_OFFSET) /* FTM0 Mirror of Modulo Value register */
+#define S32K1XX_FTM0_C0V_MIRROR          (S32K1XX_FTM0_BASE + S32K1XX_FTM_C0V_MIRROR_OFFSET) /* FTM0 Mirror of Channel 0 Match Value register */
+#define S32K1XX_FTM0_C1V_MIRROR          (S32K1XX_FTM0_BASE + S32K1XX_FTM_C1V_MIRROR_OFFSET) /* FTM0 Mirror of Channel 1 Match Value register */
+#define S32K1XX_FTM0_C2V_MIRROR          (S32K1XX_FTM0_BASE + S32K1XX_FTM_C2V_MIRROR_OFFSET) /* FTM0 Mirror of Channel 2 Match Value register */
+#define S32K1XX_FTM0_C3V_MIRROR          (S32K1XX_FTM0_BASE + S32K1XX_FTM_C3V_MIRROR_OFFSET) /* FTM0 Mirror of Channel 3 Match Value register */
+#define S32K1XX_FTM0_C4V_MIRROR          (S32K1XX_FTM0_BASE + S32K1XX_FTM_C4V_MIRROR_OFFSET) /* FTM0 Mirror of Channel 4 Match Value register */
+#define S32K1XX_FTM0_C5V_MIRROR          (S32K1XX_FTM0_BASE + S32K1XX_FTM_C5V_MIRROR_OFFSET) /* FTM0 Mirror of Channel 5 Match Value register */
+#define S32K1XX_FTM0_C6V_MIRROR          (S32K1XX_FTM0_BASE + S32K1XX_FTM_C6V_MIRROR_OFFSET) /* FTM0 Mirror of Channel 6 Match Value register */
+#define S32K1XX_FTM0_C7V_MIRROR          (S32K1XX_FTM0_BASE + S32K1XX_FTM_C7V_MIRROR_OFFSET) /* FTM0 Mirror of Channel 7 Match Value register */
+
+/* FTM1 registers */
+
+#define S32K1XX_FTM1_SC                  (S32K1XX_FTM1_BASE + S32K1XX_FTM_SC_OFFSET)       /* FTM1 Status And Control register */
+#define S32K1XX_FTM1_CNT                 (S32K1XX_FTM1_BASE + S32K1XX_FTM_CNT_OFFSET)      /* FTM1 Counter register */
+#define S32K1XX_FTM1_MOD                 (S32K1XX_FTM1_BASE + S32K1XX_FTM_MOD_OFFSET)      /* FTM1 Modulo register */
+#define S32K1XX_FTM1_C0SC                (S32K1XX_FTM1_BASE + S32K1XX_FTM_C0SC_OFFSET)     /* FTM1 Channel 0 Status And Control register */
+#define S32K1XX_FTM1_C0V                 (S32K1XX_FTM1_BASE + S32K1XX_FTM_C0V_OFFSET)      /* FTM1 Channel 0 Value register */
+#define S32K1XX_FTM1_C1SC                (S32K1XX_FTM1_BASE + S32K1XX_FTM_C1SC_OFFSET)     /* FTM1 Channel 1 Status And Control register */
+#define S32K1XX_FTM1_C1V                 (S32K1XX_FTM1_BASE + S32K1XX_FTM_C1V_OFFSET)      /* FTM1 Channel 1 Value register */
+#define S32K1XX_FTM1_C2SC                (S32K1XX_FTM1_BASE + S32K1XX_FTM_C2SC_OFFSET)     /* FTM1 Channel 2 Status And Control register */
+#define S32K1XX_FTM1_C2V                 (S32K1XX_FTM1_BASE + S32K1XX_FTM_C2V_OFFSET)      /* FTM1 Channel 2 Value register */
+#define S32K1XX_FTM1_C3SC                (S32K1XX_FTM1_BASE + S32K1XX_FTM_C3SC_OFFSET)     /* FTM1 Channel 3 Status And Control register */
+#define S32K1XX_FTM1_C3V                 (S32K1XX_FTM1_BASE + S32K1XX_FTM_C3V_OFFSET)      /* FTM1 Channel 3 Value register */
+#define S32K1XX_FTM1_C4SC                (S32K1XX_FTM1_BASE + S32K1XX_FTM_C4SC_OFFSET)     /* FTM1 Channel 4 Status And Control register */
+#define S32K1XX_FTM1_C4V                 (S32K1XX_FTM1_BASE + S32K1XX_FTM_C4V_OFFSET)      /* FTM1 Channel 4 Value register */
+#define S32K1XX_FTM1_C5SC                (S32K1XX_FTM1_BASE + S32K1XX_FTM_C5SC_OFFSET)     /* FTM1 Channel 5 Status And Control register */
+#define S32K1XX_FTM1_C5V                 (S32K1XX_FTM1_BASE + S32K1XX_FTM_C5V_OFFSET)      /* FTM1 Channel 5 Value register */
+#define S32K1XX_FTM1_C6SC                (S32K1XX_FTM1_BASE + S32K1XX_FTM_C6SC_OFFSET)     /* FTM1 Channel 6 Status And Control register */
+#define S32K1XX_FTM1_C6V                 (S32K1XX_FTM1_BASE + S32K1XX_FTM_C6V_OFFSET)      /* FTM1 Channel 6 Value register */
+#define S32K1XX_FTM1_C7SC                (S32K1XX_FTM1_BASE + S32K1XX_FTM_C7SC_OFFSET)     /* FTM1 Channel 7 Status And Control register */
+#define S32K1XX_FTM1_C7V                 (S32K1XX_FTM1_BASE + S32K1XX_FTM_C7V_OFFSET)      /* FTM1 Channel 7 Value register */
+#define S32K1XX_FTM1_CNTIN               (S32K1XX_FTM1_BASE + S32K1XX_FTM_CNTIN_OFFSET)    /* FTM1 Counter Initial Value register */
+#define S32K1XX_FTM1_STATUS              (S32K1XX_FTM1_BASE + S32K1XX_FTM_STATUS_OFFSET)   /* FTM1 Capture And Compare Status register */
+#define S32K1XX_FTM1_MODE                (S32K1XX_FTM1_BASE + S32K1XX_FTM_MODE_OFFSET)     /* FTM1 Features Mode Selection register */
+#define S32K1XX_FTM1_SYNC                (S32K1XX_FTM1_BASE + S32K1XX_FTM_SYNC_OFFSET)     /* FTM1 Synchronization register */
+#define S32K1XX_FTM1_OUTINIT             (S32K1XX_FTM1_BASE + S32K1XX_FTM_OUTINIT_OFFSET)  /* FTM1 Initial State For Channels Output register */
+#define S32K1XX_FTM1_OUTMASK             (S32K1XX_FTM1_BASE + S32K1XX_FTM_OUTMASK_OFFSET)  /* FTM1 Output Mask register */
+#define S32K1XX_FTM1_COMBINE             (S32K1XX_FTM1_BASE + S32K1XX_FTM_COMBINE_OFFSET)  /* FTM1 Function For Linked Channels register */
+#define S32K1XX_FTM1_DEADTIME            (S32K1XX_FTM1_BASE + S32K1XX_FTM_DEADTIME_OFFSET) /* FTM1 Deadtime Configuration register */
+#define S32K1XX_FTM1_EXTTRIG             (S32K1XX_FTM1_BASE + S32K1XX_FTM_EXTTRIG_OFFSET)  /* FTM1 External Trigger register */
+#define S32K1XX_FTM1_POL                 (S32K1XX_FTM1_BASE + S32K1XX_FTM_POL_OFFSET)      /* FTM1 Channel Polarity register */
+#define S32K1XX_FTM1_FMS                 (S32K1XX_FTM1_BASE + S32K1XX_FTM_FMS_OFFSET)      /* FTM1 Fault Mode Status register */
+#define S32K1XX_FTM1_FILTER              (S32K1XX_FTM1_BASE + S32K1XX_FTM_FILTER_OFFSET)   /* FTM1 Input Capture Filter Control register */
+#define S32K1XX_FTM1_FLTCTRL             (S32K1XX_FTM1_BASE + S32K1XX_FTM_FILTCTRL_OFFSET) /* FTM1 Fault Control register */
+#define S32K1XX_FTM1_QDCTRL              (S32K1XX_FTM1_BASE + S32K1XX_FTM_QDCTRL_OFFSET)   /* FTM1 Quadrature Decoder Control And Status register */
+#define S32K1XX_FTM1_CONF                (S32K1XX_FTM1_BASE + S32K1XX_FTM_CONF_OFFSET)     /* FTM1 Configuration register */
+#define S32K1XX_FTM1_FLTPOL              (S32K1XX_FTM1_BASE + S32K1XX_FTM_FLTPOL_OFFSET)   /* FTM1 Fault Input Polarity register */
+#define S32K1XX_FTM1_SYNCONF             (S32K1XX_FTM1_BASE + S32K1XX_FTM_SYNCONF_OFFSET)  /* FTM1 Synchronization Configuration register */
+#define S32K1XX_FTM1_INVCTRL             (S32K1XX_FTM1_BASE + S32K1XX_FTM_INVCTRL_OFFSET)  /* FTM1 Inverting Control register */
+#define S32K1XX_FTM1_SWOCTRL             (S32K1XX_FTM1_BASE + S32K1XX_FTM_SWOCTRL_OFFSET)  /* FTM1 Software Output Control register */
+#define S32K1XX_FTM1_PWMLOAD             (S32K1XX_FTM1_BASE + S32K1XX_FTM_PWMLOAD_OFFSET)  /* FTM1 PWM Load register */
+#define S32K1XX_FTM1_HCR                 (S32K1XX_FTM1_BASE + S32K1XX_FTM_HCR_OFFSET)      /* FTM1 Half Cycle Register */
+
+#define S32K1XX_FTM1_PAIR0DEADTIME       (S32K1XX_FTM1_BASE + S32K1XX_FTM_PAIR0DEADTIME_OFFSET) /* FTM1 Pair 0 Deadtime Configuration register */
+#define S32K1XX_FTM1_PAIR1DEADTIME       (S32K1XX_FTM1_BASE + S32K1XX_FTM_PAIR1DEADTIME_OFFSET) /* FTM1 Pair 1 Deadtime Configuration register */
+#define S32K1XX_FTM1_PAIR2DEADTIME       (S32K1XX_FTM1_BASE + S32K1XX_FTM_PAIR2DEADTIME_OFFSET) /* FTM1 Pair 2 Deadtime Configuration register */
+#define S32K1XX_FTM1_PAIR3DEADTIME       (S32K1XX_FTM1_BASE + S32K1XX_FTM_PAIR3DEADTIME_OFFSET) /* FTM1 Pair 3 Deadtime Configuration register oset */
+
+#define S32K1XX_FTM1_MOD_MIRROR          (S32K1XX_FTM1_BASE + S32K1XX_FTM_MOD_MIRROR_OFFSET) /* FTM1 Mirror of Modulo Value register */
+#define S32K1XX_FTM1_C0V_MIRROR          (S32K1XX_FTM1_BASE + S32K1XX_FTM_C0V_MIRROR_OFFSET) /* FTM1 Mirror of Channel 0 Match Value register */
+#define S32K1XX_FTM1_C1V_MIRROR          (S32K1XX_FTM1_BASE + S32K1XX_FTM_C1V_MIRROR_OFFSET) /* FTM1 Mirror of Channel 1 Match Value register */
+#define S32K1XX_FTM1_C2V_MIRROR          (S32K1XX_FTM1_BASE + S32K1XX_FTM_C2V_MIRROR_OFFSET) /* FTM1 Mirror of Channel 2 Match Value register */
+#define S32K1XX_FTM1_C3V_MIRROR          (S32K1XX_FTM1_BASE + S32K1XX_FTM_C3V_MIRROR_OFFSET) /* FTM1 Mirror of Channel 3 Match Value register */
+#define S32K1XX_FTM1_C4V_MIRROR          (S32K1XX_FTM1_BASE + S32K1XX_FTM_C4V_MIRROR_OFFSET) /* FTM1 Mirror of Channel 4 Match Value register */
+#define S32K1XX_FTM1_C5V_MIRROR          (S32K1XX_FTM1_BASE + S32K1XX_FTM_C5V_MIRROR_OFFSET) /* FTM1 Mirror of Channel 5 Match Value register */
+#define S32K1XX_FTM1_C6V_MIRROR          (S32K1XX_FTM1_BASE + S32K1XX_FTM_C6V_MIRROR_OFFSET) /* FTM1 Mirror of Channel 6 Match Value register */
+#define S32K1XX_FTM1_C7V_MIRROR          (S32K1XX_FTM1_BASE + S32K1XX_FTM_C7V_MIRROR_OFFSET) /* FTM1 Mirror of Channel 7 Match Value register */
+
+/* FTM2 registers */
+
+#define S32K1XX_FTM2_SC                  (S32K1XX_FTM2_BASE + S32K1XX_FTM_SC_OFFSET)       /* FTM2 Status And Control register */
+#define S32K1XX_FTM2_CNT                 (S32K1XX_FTM2_BASE + S32K1XX_FTM_CNT_OFFSET)      /* FTM2 Counter register */
+#define S32K1XX_FTM2_MOD                 (S32K1XX_FTM2_BASE + S32K1XX_FTM_MOD_OFFSET)      /* FTM2 Modulo register */
+#define S32K1XX_FTM2_C0SC                (S32K1XX_FTM2_BASE + S32K1XX_FTM_C0SC_OFFSET)     /* FTM2 Channel 0 Status And Control register */
+#define S32K1XX_FTM2_C0V                 (S32K1XX_FTM2_BASE + S32K1XX_FTM_C0V_OFFSET)      /* FTM2 Channel 0 Value register */
+#define S32K1XX_FTM2_C1SC                (S32K1XX_FTM2_BASE + S32K1XX_FTM_C1SC_OFFSET)     /* FTM2 Channel 1 Status And Control register */
+#define S32K1XX_FTM2_C1V                 (S32K1XX_FTM2_BASE + S32K1XX_FTM_C1V_OFFSET)      /* FTM2 Channel 1 Value register */
+#define S32K1XX_FTM2_C2SC                (S32K1XX_FTM2_BASE + S32K1XX_FTM_C2SC_OFFSET)     /* FTM2 Channel 2 Status And Control register */
+#define S32K1XX_FTM2_C2V                 (S32K1XX_FTM2_BASE + S32K1XX_FTM_C2V_OFFSET)      /* FTM2 Channel 2 Value register */
+#define S32K1XX_FTM2_C3SC                (S32K1XX_FTM2_BASE + S32K1XX_FTM_C3SC_OFFSET)     /* FTM2 Channel 3 Status And Control register */
+#define S32K1XX_FTM2_C3V                 (S32K1XX_FTM2_BASE + S32K1XX_FTM_C3V_OFFSET)      /* FTM2 Channel 3 Value register */
+#define S32K1XX_FTM2_C4SC                (S32K1XX_FTM2_BASE + S32K1XX_FTM_C4SC_OFFSET)     /* FTM2 Channel 4 Status And Control register */
+#define S32K1XX_FTM2_C4V                 (S32K1XX_FTM2_BASE + S32K1XX_FTM_C4V_OFFSET)      /* FTM2 Channel 4 Value register */
+#define S32K1XX_FTM2_C5SC                (S32K1XX_FTM2_BASE + S32K1XX_FTM_C5SC_OFFSET)     /* FTM2 Channel 5 Status And Control register */
+#define S32K1XX_FTM2_C5V                 (S32K1XX_FTM2_BASE + S32K1XX_FTM_C5V_OFFSET)      /* FTM2 Channel 5 Value register */
+#define S32K1XX_FTM2_C6SC                (S32K1XX_FTM2_BASE + S32K1XX_FTM_C6SC_OFFSET)     /* FTM2 Channel 6 Status And Control register */
+#define S32K1XX_FTM2_C6V                 (S32K1XX_FTM2_BASE + S32K1XX_FTM_C6V_OFFSET)      /* FTM2 Channel 6 Value register */
+#define S32K1XX_FTM2_C7SC                (S32K1XX_FTM2_BASE + S32K1XX_FTM_C7SC_OFFSET)     /* FTM2 Channel 7 Status And Control register */
+#define S32K1XX_FTM2_C7V                 (S32K1XX_FTM2_BASE + S32K1XX_FTM_C7V_OFFSET)      /* FTM2 Channel 7 Value register */
+#define S32K1XX_FTM2_CNTIN               (S32K1XX_FTM2_BASE + S32K1XX_FTM_CNTIN_OFFSET)    /* FTM2 Counter Initial Value register */
+#define S32K1XX_FTM2_STATUS              (S32K1XX_FTM2_BASE + S32K1XX_FTM_STATUS_OFFSET)   /* FTM2 Capture And Compare Status register */
+#define S32K1XX_FTM2_MODE                (S32K1XX_FTM2_BASE + S32K1XX_FTM_MODE_OFFSET)     /* FTM2 Features Mode Selection register */
+#define S32K1XX_FTM2_SYNC                (S32K1XX_FTM2_BASE + S32K1XX_FTM_SYNC_OFFSET)     /* FTM2 Synchronization register */
+#define S32K1XX_FTM2_OUTINIT             (S32K1XX_FTM2_BASE + S32K1XX_FTM_OUTINIT_OFFSET)  /* FTM2 Initial State For Channels Output register */
+#define S32K1XX_FTM2_OUTMASK             (S32K1XX_FTM2_BASE + S32K1XX_FTM_OUTMASK_OFFSET)  /* FTM2 Output Mask register */
+#define S32K1XX_FTM2_COMBINE             (S32K1XX_FTM2_BASE + S32K1XX_FTM_COMBINE_OFFSET)  /* FTM2 Function For Linked Channels register */
+#define S32K1XX_FTM2_DEADTIME            (S32K1XX_FTM2_BASE + S32K1XX_FTM_DEADTIME_OFFSET) /* FTM2 Deadtime Configuration register */
+#define S32K1XX_FTM2_EXTTRIG             (S32K1XX_FTM2_BASE + S32K1XX_FTM_EXTTRIG_OFFSET)  /* FTM2 External Trigger register */
+#define S32K1XX_FTM2_POL                 (S32K1XX_FTM2_BASE + S32K1XX_FTM_POL_OFFSET)      /* FTM2 Channel Polarity register */
+#define S32K1XX_FTM2_FMS                 (S32K1XX_FTM2_BASE + S32K1XX_FTM_FMS_OFFSET)      /* FTM2 Fault Mode Status register */
+#define S32K1XX_FTM2_FILTER              (S32K1XX_FTM2_BASE + S32K1XX_FTM_FILTER_OFFSET)   /* FTM2 Input Capture Filter Control register */
+#define S32K1XX_FTM2_FLTCTRL             (S32K1XX_FTM2_BASE + S32K1XX_FTM_FILTCTRL_OFFSET) /* FTM2 Fault Control register */
+#define S32K1XX_FTM2_QDCTRL              (S32K1XX_FTM2_BASE + S32K1XX_FTM_QDCTRL_OFFSET)   /* FTM2 Quadrature Decoder Control And Status register */
+#define S32K1XX_FTM2_CONF                (S32K1XX_FTM2_BASE + S32K1XX_FTM_CONF_OFFSET)     /* FTM2 Configuration register */
+#define S32K1XX_FTM2_FLTPOL              (S32K1XX_FTM2_BASE + S32K1XX_FTM_FLTPOL_OFFSET)   /* FTM2 Fault Input Polarity register */
+#define S32K1XX_FTM2_SYNCONF             (S32K1XX_FTM2_BASE + S32K1XX_FTM_SYNCONF_OFFSET)  /* FTM2 Synchronization Configuration register */
+#define S32K1XX_FTM2_INVCTRL             (S32K1XX_FTM2_BASE + S32K1XX_FTM_INVCTRL_OFFSET)  /* FTM2 Inverting Control register */
+#define S32K1XX_FTM2_SWOCTRL             (S32K1XX_FTM2_BASE + S32K1XX_FTM_SWOCTRL_OFFSET)  /* FTM2 Software Output Control register */
+#define S32K1XX_FTM2_PWMLOAD             (S32K1XX_FTM2_BASE + S32K1XX_FTM_PWMLOAD_OFFSET)  /* FTM2 PWM Load register */
+#define S32K1XX_FTM2_HCR                 (S32K1XX_FTM2_BASE + S32K1XX_FTM_HCR_OFFSET)      /* FTM2 Half Cycle Register */
+
+#define S32K1XX_FTM2_PAIR0DEADTIME       (S32K1XX_FTM2_BASE + S32K1XX_FTM_PAIR0DEADTIME_OFFSET) /* FTM2 Pair 0 Deadtime Configuration register */
+#define S32K1XX_FTM2_PAIR1DEADTIME       (S32K1XX_FTM2_BASE + S32K1XX_FTM_PAIR1DEADTIME_OFFSET) /* FTM2 Pair 1 Deadtime Configuration register */
+#define S32K1XX_FTM2_PAIR2DEADTIME       (S32K1XX_FTM2_BASE + S32K1XX_FTM_PAIR2DEADTIME_OFFSET) /* FTM2 Pair 2 Deadtime Configuration register */
+#define S32K1XX_FTM2_PAIR3DEADTIME       (S32K1XX_FTM2_BASE + S32K1XX_FTM_PAIR3DEADTIME_OFFSET) /* FTM2 Pair 3 Deadtime Configuration register oset */
+
+#define S32K1XX_FTM2_MOD_MIRROR          (S32K1XX_FTM2_BASE + S32K1XX_FTM_MOD_MIRROR_OFFSET) /* FTM2 Mirror of Modulo Value register */
+#define S32K1XX_FTM2_C0V_MIRROR          (S32K1XX_FTM2_BASE + S32K1XX_FTM_C0V_MIRROR_OFFSET) /* FTM2 Mirror of Channel 0 Match Value register */
+#define S32K1XX_FTM2_C1V_MIRROR          (S32K1XX_FTM2_BASE + S32K1XX_FTM_C1V_MIRROR_OFFSET) /* FTM2 Mirror of Channel 1 Match Value register */
+#define S32K1XX_FTM2_C2V_MIRROR          (S32K1XX_FTM2_BASE + S32K1XX_FTM_C2V_MIRROR_OFFSET) /* FTM2 Mirror of Channel 2 Match Value register */
+#define S32K1XX_FTM2_C3V_MIRROR          (S32K1XX_FTM2_BASE + S32K1XX_FTM_C3V_MIRROR_OFFSET) /* FTM2 Mirror of Channel 3 Match Value register */
+#define S32K1XX_FTM2_C4V_MIRROR          (S32K1XX_FTM2_BASE + S32K1XX_FTM_C4V_MIRROR_OFFSET) /* FTM2 Mirror of Channel 4 Match Value register */
+#define S32K1XX_FTM2_C5V_MIRROR          (S32K1XX_FTM2_BASE + S32K1XX_FTM_C5V_MIRROR_OFFSET) /* FTM2 Mirror of Channel 5 Match Value register */
+#define S32K1XX_FTM2_C6V_MIRROR          (S32K1XX_FTM2_BASE + S32K1XX_FTM_C6V_MIRROR_OFFSET) /* FTM2 Mirror of Channel 6 Match Value register */
+#define S32K1XX_FTM2_C7V_MIRROR          (S32K1XX_FTM2_BASE + S32K1XX_FTM_C7V_MIRROR_OFFSET) /* FTM2 Mirror of Channel 7 Match Value register */
+
+/* FTM3 registers */
+
+#define S32K1XX_FTM3_SC                  (S32K1XX_FTM3_BASE + S32K1XX_FTM_SC_OFFSET)       /* FTM3 Status And Control register */
+#define S32K1XX_FTM3_CNT                 (S32K1XX_FTM3_BASE + S32K1XX_FTM_CNT_OFFSET)      /* FTM3 Counter register */
+#define S32K1XX_FTM3_MOD                 (S32K1XX_FTM3_BASE + S32K1XX_FTM_MOD_OFFSET)      /* FTM3 Modulo register */
+#define S32K1XX_FTM3_C0SC                (S32K1XX_FTM3_BASE + S32K1XX_FTM_C0SC_OFFSET)     /* FTM3 Channel 0 Status And Control register */
+#define S32K1XX_FTM3_C0V                 (S32K1XX_FTM3_BASE + S32K1XX_FTM_C0V_OFFSET)      /* FTM3 Channel 0 Value register */
+#define S32K1XX_FTM3_C1SC                (S32K1XX_FTM3_BASE + S32K1XX_FTM_C1SC_OFFSET)     /* FTM3 Channel 1 Status And Control register */
+#define S32K1XX_FTM3_C1V                 (S32K1XX_FTM3_BASE + S32K1XX_FTM_C1V_OFFSET)      /* FTM3 Channel 1 Value register */
+#define S32K1XX_FTM3_C2SC                (S32K1XX_FTM3_BASE + S32K1XX_FTM_C2SC_OFFSET)     /* FTM3 Channel 2 Status And Control register */
+#define S32K1XX_FTM3_C2V                 (S32K1XX_FTM3_BASE + S32K1XX_FTM_C2V_OFFSET)      /* FTM3 Channel 2 Value register */
+#define S32K1XX_FTM3_C3SC                (S32K1XX_FTM3_BASE + S32K1XX_FTM_C3SC_OFFSET)     /* FTM3 Channel 3 Status And Control register */
+#define S32K1XX_FTM3_C3V                 (S32K1XX_FTM3_BASE + S32K1XX_FTM_C3V_OFFSET)      /* FTM3 Channel 3 Value register */
+#define S32K1XX_FTM3_C4SC                (S32K1XX_FTM3_BASE + S32K1XX_FTM_C4SC_OFFSET)     /* FTM3 Channel 4 Status And Control register */
+#define S32K1XX_FTM3_C4V                 (S32K1XX_FTM3_BASE + S32K1XX_FTM_C4V_OFFSET)      /* FTM3 Channel 4 Value register */
+#define S32K1XX_FTM3_C5SC                (S32K1XX_FTM3_BASE + S32K1XX_FTM_C5SC_OFFSET)     /* FTM3 Channel 5 Status And Control register */
+#define S32K1XX_FTM3_C5V                 (S32K1XX_FTM3_BASE + S32K1XX_FTM_C5V_OFFSET)      /* FTM3 Channel 5 Value register */
+#define S32K1XX_FTM3_C6SC                (S32K1XX_FTM3_BASE + S32K1XX_FTM_C6SC_OFFSET)     /* FTM3 Channel 6 Status And Control register */
+#define S32K1XX_FTM3_C6V                 (S32K1XX_FTM3_BASE + S32K1XX_FTM_C6V_OFFSET)      /* FTM3 Channel 6 Value register */
+#define S32K1XX_FTM3_C7SC                (S32K1XX_FTM3_BASE + S32K1XX_FTM_C7SC_OFFSET)     /* FTM3 Channel 7 Status And Control register */
+#define S32K1XX_FTM3_C7V                 (S32K1XX_FTM3_BASE + S32K1XX_FTM_C7V_OFFSET)      /* FTM3 Channel 7 Value register */
+#define S32K1XX_FTM3_CNTIN               (S32K1XX_FTM3_BASE + S32K1XX_FTM_CNTIN_OFFSET)    /* FTM3 Counter Initial Value register */
+#define S32K1XX_FTM3_STATUS              (S32K1XX_FTM3_BASE + S32K1XX_FTM_STATUS_OFFSET)   /* FTM3 Capture And Compare Status register */
+#define S32K1XX_FTM3_MODE                (S32K1XX_FTM3_BASE + S32K1XX_FTM_MODE_OFFSET)     /* FTM3 Features Mode Selection register */
+#define S32K1XX_FTM3_SYNC                (S32K1XX_FTM3_BASE + S32K1XX_FTM_SYNC_OFFSET)     /* FTM3 Synchronization register */
+#define S32K1XX_FTM3_OUTINIT             (S32K1XX_FTM3_BASE + S32K1XX_FTM_OUTINIT_OFFSET)  /* FTM3 Initial State For Channels Output register */
+#define S32K1XX_FTM3_OUTMASK             (S32K1XX_FTM3_BASE + S32K1XX_FTM_OUTMASK_OFFSET)  /* FTM3 Output Mask register */
+#define S32K1XX_FTM3_COMBINE             (S32K1XX_FTM3_BASE + S32K1XX_FTM_COMBINE_OFFSET)  /* FTM3 Function For Linked Channels register */
+#define S32K1XX_FTM3_DEADTIME            (S32K1XX_FTM3_BASE + S32K1XX_FTM_DEADTIME_OFFSET) /* FTM3 Deadtime Configuration register */
+#define S32K1XX_FTM3_EXTTRIG             (S32K1XX_FTM3_BASE + S32K1XX_FTM_EXTTRIG_OFFSET)  /* FTM3 External Trigger register */
+#define S32K1XX_FTM3_POL                 (S32K1XX_FTM3_BASE + S32K1XX_FTM_POL_OFFSET)      /* FTM3 Channel Polarity register */
+#define S32K1XX_FTM3_FMS                 (S32K1XX_FTM3_BASE + S32K1XX_FTM_FMS_OFFSET)      /* FTM3 Fault Mode Status register */
+#define S32K1XX_FTM3_FILTER              (S32K1XX_FTM3_BASE + S32K1XX_FTM_FILTER_OFFSET)   /* FTM3 Input Capture Filter Control register */
+#define S32K1XX_FTM3_FLTCTRL             (S32K1XX_FTM3_BASE + S32K1XX_FTM_FILTCTRL_OFFSET) /* FTM3 Fault Control register */
+#define S32K1XX_FTM3_QDCTRL              (S32K1XX_FTM3_BASE + S32K1XX_FTM_QDCTRL_OFFSET)   /* FTM3 Quadrature Decoder Control And Status register */
+#define S32K1XX_FTM3_CONF                (S32K1XX_FTM3_BASE + S32K1XX_FTM_CONF_OFFSET)     /* FTM3 Configuration register */
+#define S32K1XX_FTM3_FLTPOL              (S32K1XX_FTM3_BASE + S32K1XX_FTM_FLTPOL_OFFSET)   /* FTM3 Fault Input Polarity register */
+#define S32K1XX_FTM3_SYNCONF             (S32K1XX_FTM3_BASE + S32K1XX_FTM_SYNCONF_OFFSET)  /* FTM3 Synchronization Configuration register */
+#define S32K1XX_FTM3_INVCTRL             (S32K1XX_FTM3_BASE + S32K1XX_FTM_INVCTRL_OFFSET)  /* FTM3 Inverting Control register */
+#define S32K1XX_FTM3_SWOCTRL             (S32K1XX_FTM3_BASE + S32K1XX_FTM_SWOCTRL_OFFSET)  /* FTM3 Software Output Control register */
+#define S32K1XX_FTM3_PWMLOAD             (S32K1XX_FTM3_BASE + S32K1XX_FTM_PWMLOAD_OFFSET)  /* FTM3 PWM Load register */
+#define S32K1XX_FTM3_HCR                 (S32K1XX_FTM3_BASE + S32K1XX_FTM_HCR_OFFSET)      /* FTM3 Half Cycle Register */
+
+#define S32K1XX_FTM3_PAIR0DEADTIME       (S32K1XX_FTM3_BASE + S32K1XX_FTM_PAIR0DEADTIME_OFFSET) /* FTM3 Pair 0 Deadtime Configuration register */
+#define S32K1XX_FTM3_PAIR1DEADTIME       (S32K1XX_FTM3_BASE + S32K1XX_FTM_PAIR1DEADTIME_OFFSET) /* FTM3 Pair 1 Deadtime Configuration register */
+#define S32K1XX_FTM3_PAIR2DEADTIME       (S32K1XX_FTM3_BASE + S32K1XX_FTM_PAIR2DEADTIME_OFFSET) /* FTM3 Pair 2 Deadtime Configuration register */
+#define S32K1XX_FTM3_PAIR3DEADTIME       (S32K1XX_FTM3_BASE + S32K1XX_FTM_PAIR3DEADTIME_OFFSET) /* FTM3 Pair 3 Deadtime Configuration register oset */
+
+#define S32K1XX_FTM3_MOD_MIRROR          (S32K1XX_FTM3_BASE + S32K1XX_FTM_MOD_MIRROR_OFFSET) /* FTM3 Mirror of Modulo Value register */
+#define S32K1XX_FTM3_C0V_MIRROR          (S32K1XX_FTM3_BASE + S32K1XX_FTM_C0V_MIRROR_OFFSET) /* FTM3 Mirror of Channel 0 Match Value register */
+#define S32K1XX_FTM3_C1V_MIRROR          (S32K1XX_FTM3_BASE + S32K1XX_FTM_C1V_MIRROR_OFFSET) /* FTM3 Mirror of Channel 1 Match Value register */
+#define S32K1XX_FTM3_C2V_MIRROR          (S32K1XX_FTM3_BASE + S32K1XX_FTM_C2V_MIRROR_OFFSET) /* FTM3 Mirror of Channel 2 Match Value register */
+#define S32K1XX_FTM3_C3V_MIRROR          (S32K1XX_FTM3_BASE + S32K1XX_FTM_C3V_MIRROR_OFFSET) /* FTM3 Mirror of Channel 3 Match Value register */
+#define S32K1XX_FTM3_C4V_MIRROR          (S32K1XX_FTM3_BASE + S32K1XX_FTM_C4V_MIRROR_OFFSET) /* FTM3 Mirror of Channel 4 Match Value register */
+#define S32K1XX_FTM3_C5V_MIRROR          (S32K1XX_FTM3_BASE + S32K1XX_FTM_C5V_MIRROR_OFFSET) /* FTM3 Mirror of Channel 5 Match Value register */
+#define S32K1XX_FTM3_C6V_MIRROR          (S32K1XX_FTM3_BASE + S32K1XX_FTM_C6V_MIRROR_OFFSET) /* FTM3 Mirror of Channel 6 Match Value register */
+#define S32K1XX_FTM3_C7V_MIRROR          (S32K1XX_FTM3_BASE + S32K1XX_FTM_C7V_MIRROR_OFFSET) /* FTM3 Mirror of Channel 7 Match Value register */
+
+/* FTM4 registers */
+
+#define S32K1XX_FTM4_SC                  (S32K1XX_FTM4_BASE + S32K1XX_FTM_SC_OFFSET)       /* FTM4 Status And Control register */
+#define S32K1XX_FTM4_CNT                 (S32K1XX_FTM4_BASE + S32K1XX_FTM_CNT_OFFSET)      /* FTM4 Counter register */
+#define S32K1XX_FTM4_MOD                 (S32K1XX_FTM4_BASE + S32K1XX_FTM_MOD_OFFSET)      /* FTM4 Modulo register */
+#define S32K1XX_FTM4_C0SC                (S32K1XX_FTM4_BASE + S32K1XX_FTM_C0SC_OFFSET)     /* FTM4 Channel 0 Status And Control register */
+#define S32K1XX_FTM4_C0V                 (S32K1XX_FTM4_BASE + S32K1XX_FTM_C0V_OFFSET)      /* FTM4 Channel 0 Value register */
+#define S32K1XX_FTM4_C1SC                (S32K1XX_FTM4_BASE + S32K1XX_FTM_C1SC_OFFSET)     /* FTM4 Channel 1 Status And Control register */
+#define S32K1XX_FTM4_C1V                 (S32K1XX_FTM4_BASE + S32K1XX_FTM_C1V_OFFSET)      /* FTM4 Channel 1 Value register */
+#define S32K1XX_FTM4_C2SC                (S32K1XX_FTM4_BASE + S32K1XX_FTM_C2SC_OFFSET)     /* FTM4 Channel 2 Status And Control register */
+#define S32K1XX_FTM4_C2V                 (S32K1XX_FTM4_BASE + S32K1XX_FTM_C2V_OFFSET)      /* FTM4 Channel 2 Value register */
+#define S32K1XX_FTM4_C3SC                (S32K1XX_FTM4_BASE + S32K1XX_FTM_C3SC_OFFSET)     /* FTM4 Channel 3 Status And Control register */
+#define S32K1XX_FTM4_C3V                 (S32K1XX_FTM4_BASE + S32K1XX_FTM_C3V_OFFSET)      /* FTM4 Channel 3 Value register */
+#define S32K1XX_FTM4_C4SC                (S32K1XX_FTM4_BASE + S32K1XX_FTM_C4SC_OFFSET)     /* FTM4 Channel 4 Status And Control register */
+#define S32K1XX_FTM4_C4V                 (S32K1XX_FTM4_BASE + S32K1XX_FTM_C4V_OFFSET)      /* FTM4 Channel 4 Value register */
+#define S32K1XX_FTM4_C5SC                (S32K1XX_FTM4_BASE + S32K1XX_FTM_C5SC_OFFSET)     /* FTM4 Channel 5 Status And Control register */
+#define S32K1XX_FTM4_C5V                 (S32K1XX_FTM4_BASE + S32K1XX_FTM_C5V_OFFSET)      /* FTM4 Channel 5 Value register */
+#define S32K1XX_FTM4_C6SC                (S32K1XX_FTM4_BASE + S32K1XX_FTM_C6SC_OFFSET)     /* FTM4 Channel 6 Status And Control register */
+#define S32K1XX_FTM4_C6V                 (S32K1XX_FTM4_BASE + S32K1XX_FTM_C6V_OFFSET)      /* FTM4 Channel 6 Value register */
+#define S32K1XX_FTM4_C7SC                (S32K1XX_FTM4_BASE + S32K1XX_FTM_C7SC_OFFSET)     /* FTM4 Channel 7 Status And Control register */
+#define S32K1XX_FTM4_C7V                 (S32K1XX_FTM4_BASE + S32K1XX_FTM_C7V_OFFSET)      /* FTM4 Channel 7 Value register */
+#define S32K1XX_FTM4_CNTIN               (S32K1XX_FTM4_BASE + S32K1XX_FTM_CNTIN_OFFSET)    /* FTM4 Counter Initial Value register */
+#define S32K1XX_FTM4_STATUS              (S32K1XX_FTM4_BASE + S32K1XX_FTM_STATUS_OFFSET)   /* FTM4 Capture And Compare Status register */
+#define S32K1XX_FTM4_MODE                (S32K1XX_FTM4_BASE + S32K1XX_FTM_MODE_OFFSET)     /* FTM4 Features Mode Selection register */
+#define S32K1XX_FTM4_SYNC                (S32K1XX_FTM4_BASE + S32K1XX_FTM_SYNC_OFFSET)     /* FTM4 Synchronization register */
+#define S32K1XX_FTM4_OUTINIT             (S32K1XX_FTM4_BASE + S32K1XX_FTM_OUTINIT_OFFSET)  /* FTM4 Initial State For Channels Output register */
+#define S32K1XX_FTM4_OUTMASK             (S32K1XX_FTM4_BASE + S32K1XX_FTM_OUTMASK_OFFSET)  /* FTM4 Output Mask register */
+#define S32K1XX_FTM4_COMBINE             (S32K1XX_FTM4_BASE + S32K1XX_FTM_COMBINE_OFFSET)  /* FTM4 Function For Linked Channels register */
+#define S32K1XX_FTM4_DEADTIME            (S32K1XX_FTM4_BASE + S32K1XX_FTM_DEADTIME_OFFSET) /* FTM4 Deadtime Configuration register */
+#define S32K1XX_FTM4_EXTTRIG             (S32K1XX_FTM4_BASE + S32K1XX_FTM_EXTTRIG_OFFSET)  /* FTM4 External Trigger register */
+#define S32K1XX_FTM4_POL                 (S32K1XX_FTM4_BASE + S32K1XX_FTM_POL_OFFSET)      /* FTM4 Channel Polarity register */
+#define S32K1XX_FTM4_FMS                 (S32K1XX_FTM4_BASE + S32K1XX_FTM_FMS_OFFSET)      /* FTM4 Fault Mode Status register */
+#define S32K1XX_FTM4_FILTER              (S32K1XX_FTM4_BASE + S32K1XX_FTM_FILTER_OFFSET)   /* FTM4 Input Capture Filter Control register */
+#define S32K1XX_FTM4_FLTCTRL             (S32K1XX_FTM4_BASE + S32K1XX_FTM_FILTCTRL_OFFSET) /* FTM4 Fault Control register */
+#define S32K1XX_FTM4_QDCTRL              (S32K1XX_FTM4_BASE + S32K1XX_FTM_QDCTRL_OFFSET)   /* FTM4 Quadrature Decoder Control And Status register */
+#define S32K1XX_FTM4_CONF                (S32K1XX_FTM4_BASE + S32K1XX_FTM_CONF_OFFSET)     /* FTM4 Configuration register */
+#define S32K1XX_FTM4_FLTPOL              (S32K1XX_FTM4_BASE + S32K1XX_FTM_FLTPOL_OFFSET)   /* FTM4 Fault Input Polarity register */
+#define S32K1XX_FTM4_SYNCONF             (S32K1XX_FTM4_BASE + S32K1XX_FTM_SYNCONF_OFFSET)  /* FTM4 Synchronization Configuration register */
+#define S32K1XX_FTM4_INVCTRL             (S32K1XX_FTM4_BASE + S32K1XX_FTM_INVCTRL_OFFSET)  /* FTM4 Inverting Control register */
+#define S32K1XX_FTM4_SWOCTRL             (S32K1XX_FTM4_BASE + S32K1XX_FTM_SWOCTRL_OFFSET)  /* FTM4 Software Output Control register */
+#define S32K1XX_FTM4_PWMLOAD             (S32K1XX_FTM4_BASE + S32K1XX_FTM_PWMLOAD_OFFSET)  /* FTM4 PWM Load register */
+#define S32K1XX_FTM4_HCR                 (S32K1XX_FTM4_BASE + S32K1XX_FTM_HCR_OFFSET)      /* FTM4 Half Cycle Register */
+
+#define S32K1XX_FTM4_PAIR0DEADTIME       (S32K1XX_FTM4_BASE + S32K1XX_FTM_PAIR0DEADTIME_OFFSET) /* FTM4 Pair 0 Deadtime Configuration register */
+#define S32K1XX_FTM4_PAIR1DEADTIME       (S32K1XX_FTM4_BASE + S32K1XX_FTM_PAIR1DEADTIME_OFFSET) /* FTM4 Pair 1 Deadtime Configuration register */
+#define S32K1XX_FTM4_PAIR2DEADTIME       (S32K1XX_FTM4_BASE + S32K1XX_FTM_PAIR2DEADTIME_OFFSET) /* FTM4 Pair 2 Deadtime Configuration register */
+#define S32K1XX_FTM4_PAIR3DEADTIME       (S32K1XX_FTM4_BASE + S32K1XX_FTM_PAIR3DEADTIME_OFFSET) /* FTM4 Pair 3 Deadtime Configuration register oset */
+
+#define S32K1XX_FTM4_MOD_MIRROR          (S32K1XX_FTM4_BASE + S32K1XX_FTM_MOD_MIRROR_OFFSET) /* FTM4 Mirror of Modulo Value register */
+#define S32K1XX_FTM4_C0V_MIRROR          (S32K1XX_FTM4_BASE + S32K1XX_FTM_C0V_MIRROR_OFFSET) /* FTM4 Mirror of Channel 0 Match Value register */
+#define S32K1XX_FTM4_C1V_MIRROR          (S32K1XX_FTM4_BASE + S32K1XX_FTM_C1V_MIRROR_OFFSET) /* FTM4 Mirror of Channel 1 Match Value register */
+#define S32K1XX_FTM4_C2V_MIRROR          (S32K1XX_FTM4_BASE + S32K1XX_FTM_C2V_MIRROR_OFFSET) /* FTM4 Mirror of Channel 2 Match Value register */
+#define S32K1XX_FTM4_C3V_MIRROR          (S32K1XX_FTM4_BASE + S32K1XX_FTM_C3V_MIRROR_OFFSET) /* FTM4 Mirror of Channel 3 Match Value register */
+#define S32K1XX_FTM4_C4V_MIRROR          (S32K1XX_FTM4_BASE + S32K1XX_FTM_C4V_MIRROR_OFFSET) /* FTM4 Mirror of Channel 4 Match Value register */
+#define S32K1XX_FTM4_C5V_MIRROR          (S32K1XX_FTM4_BASE + S32K1XX_FTM_C5V_MIRROR_OFFSET) /* FTM4 Mirror of Channel 5 Match Value register */
+#define S32K1XX_FTM4_C6V_MIRROR          (S32K1XX_FTM4_BASE + S32K1XX_FTM_C6V_MIRROR_OFFSET) /* FTM4 Mirror of Channel 6 Match Value register */
+#define S32K1XX_FTM4_C7V_MIRROR          (S32K1XX_FTM4_BASE + S32K1XX_FTM_C7V_MIRROR_OFFSET) /* FTM4 Mirror of Channel 7 Match Value register */
+
+/* FTM5 registers */
+
+#define S32K1XX_FTM5_SC                  (S32K1XX_FTM5_BASE + S32K1XX_FTM_SC_OFFSET)       /* FTM5 Status And Control register */
+#define S32K1XX_FTM5_CNT                 (S32K1XX_FTM5_BASE + S32K1XX_FTM_CNT_OFFSET)      /* FTM5 Counter register */
+#define S32K1XX_FTM5_MOD                 (S32K1XX_FTM5_BASE + S32K1XX_FTM_MOD_OFFSET)      /* FTM5 Modulo register */
+#define S32K1XX_FTM5_C0SC                (S32K1XX_FTM5_BASE + S32K1XX_FTM_C0SC_OFFSET)     /* FTM5 Channel 0 Status And Control register */
+#define S32K1XX_FTM5_C0V                 (S32K1XX_FTM5_BASE + S32K1XX_FTM_C0V_OFFSET)      /* FTM5 Channel 0 Value register */
+#define S32K1XX_FTM5_C1SC                (S32K1XX_FTM5_BASE + S32K1XX_FTM_C1SC_OFFSET)     /* FTM5 Channel 1 Status And Control register */
+#define S32K1XX_FTM5_C1V                 (S32K1XX_FTM5_BASE + S32K1XX_FTM_C1V_OFFSET)      /* FTM5 Channel 1 Value register */
+#define S32K1XX_FTM5_C2SC                (S32K1XX_FTM5_BASE + S32K1XX_FTM_C2SC_OFFSET)     /* FTM5 Channel 2 Status And Control register */
+#define S32K1XX_FTM5_C2V                 (S32K1XX_FTM5_BASE + S32K1XX_FTM_C2V_OFFSET)      /* FTM5 Channel 2 Value register */
+#define S32K1XX_FTM5_C3SC                (S32K1XX_FTM5_BASE + S32K1XX_FTM_C3SC_OFFSET)     /* FTM5 Channel 3 Status And Control register */
+#define S32K1XX_FTM5_C3V                 (S32K1XX_FTM5_BASE + S32K1XX_FTM_C3V_OFFSET)      /* FTM5 Channel 3 Value register */
+#define S32K1XX_FTM5_C4SC                (S32K1XX_FTM5_BASE + S32K1XX_FTM_C4SC_OFFSET)     /* FTM5 Channel 4 Status And Control register */
+#define S32K1XX_FTM5_C4V                 (S32K1XX_FTM5_BASE + S32K1XX_FTM_C4V_OFFSET)      /* FTM5 Channel 4 Value register */
+#define S32K1XX_FTM5_C5SC                (S32K1XX_FTM5_BASE + S32K1XX_FTM_C5SC_OFFSET)     /* FTM5 Channel 5 Status And Control register */
+#define S32K1XX_FTM5_C5V                 (S32K1XX_FTM5_BASE + S32K1XX_FTM_C5V_OFFSET)      /* FTM5 Channel 5 Value register */
+#define S32K1XX_FTM5_C6SC                (S32K1XX_FTM5_BASE + S32K1XX_FTM_C6SC_OFFSET)     /* FTM5 Channel 6 Status And Control register */
+#define S32K1XX_FTM5_C6V                 (S32K1XX_FTM5_BASE + S32K1XX_FTM_C6V_OFFSET)      /* FTM5 Channel 6 Value register */
+#define S32K1XX_FTM5_C7SC                (S32K1XX_FTM5_BASE + S32K1XX_FTM_C7SC_OFFSET)     /* FTM5 Channel 7 Status And Control register */
+#define S32K1XX_FTM5_C7V                 (S32K1XX_FTM5_BASE + S32K1XX_FTM_C7V_OFFSET)      /* FTM5 Channel 7 Value register */
+#define S32K1XX_FTM5_CNTIN               (S32K1XX_FTM5_BASE + S32K1XX_FTM_CNTIN_OFFSET)    /* FTM5 Counter Initial Value register */
+#define S32K1XX_FTM5_STATUS              (S32K1XX_FTM5_BASE + S32K1XX_FTM_STATUS_OFFSET)   /* FTM5 Capture And Compare Status register */
+#define S32K1XX_FTM5_MODE                (S32K1XX_FTM5_BASE + S32K1XX_FTM_MODE_OFFSET)     /* FTM5 Features Mode Selection register */
+#define S32K1XX_FTM5_SYNC                (S32K1XX_FTM5_BASE + S32K1XX_FTM_SYNC_OFFSET)     /* FTM5 Synchronization register */
+#define S32K1XX_FTM5_OUTINIT             (S32K1XX_FTM5_BASE + S32K1XX_FTM_OUTINIT_OFFSET)  /* FTM5 Initial State For Channels Output register */
+#define S32K1XX_FTM5_OUTMASK             (S32K1XX_FTM5_BASE + S32K1XX_FTM_OUTMASK_OFFSET)  /* FTM5 Output Mask register */
+#define S32K1XX_FTM5_COMBINE             (S32K1XX_FTM5_BASE + S32K1XX_FTM_COMBINE_OFFSET)  /* FTM5 Function For Linked Channels register */
+#define S32K1XX_FTM5_DEADTIME            (S32K1XX_FTM5_BASE + S32K1XX_FTM_DEADTIME_OFFSET) /* FTM5 Deadtime Configuration register */
+#define S32K1XX_FTM5_EXTTRIG             (S32K1XX_FTM5_BASE + S32K1XX_FTM_EXTTRIG_OFFSET)  /* FTM5 External Trigger register */
+#define S32K1XX_FTM5_POL                 (S32K1XX_FTM5_BASE + S32K1XX_FTM_POL_OFFSET)      /* FTM5 Channel Polarity register */
+#define S32K1XX_FTM5_FMS                 (S32K1XX_FTM5_BASE + S32K1XX_FTM_FMS_OFFSET)      /* FTM5 Fault Mode Status register */
+#define S32K1XX_FTM5_FILTER              (S32K1XX_FTM5_BASE + S32K1XX_FTM_FILTER_OFFSET)   /* FTM5 Input Capture Filter Control register */
+#define S32K1XX_FTM5_FLTCTRL             (S32K1XX_FTM5_BASE + S32K1XX_FTM_FILTCTRL_OFFSET) /* FTM5 Fault Control register */
+#define S32K1XX_FTM5_QDCTRL              (S32K1XX_FTM5_BASE + S32K1XX_FTM_QDCTRL_OFFSET)   /* FTM5 Quadrature Decoder Control And Status register */
+#define S32K1XX_FTM5_CONF                (S32K1XX_FTM5_BASE + S32K1XX_FTM_CONF_OFFSET)     /* FTM5 Configuration register */
+#define S32K1XX_FTM5_FLTPOL              (S32K1XX_FTM5_BASE + S32K1XX_FTM_FLTPOL_OFFSET)   /* FTM5 Fault Input Polarity register */
+#define S32K1XX_FTM5_SYNCONF             (S32K1XX_FTM5_BASE + S32K1XX_FTM_SYNCONF_OFFSET)  /* FTM5 Synchronization Configuration register */
+#define S32K1XX_FTM5_INVCTRL             (S32K1XX_FTM5_BASE + S32K1XX_FTM_INVCTRL_OFFSET)  /* FTM5 Inverting Control register */
+#define S32K1XX_FTM5_SWOCTRL             (S32K1XX_FTM5_BASE + S32K1XX_FTM_SWOCTRL_OFFSET)  /* FTM5 Software Output Control register */
+#define S32K1XX_FTM5_PWMLOAD             (S32K1XX_FTM5_BASE + S32K1XX_FTM_PWMLOAD_OFFSET)  /* FTM5 PWM Load register */
+#define S32K1XX_FTM5_HCR                 (S32K1XX_FTM5_BASE + S32K1XX_FTM_HCR_OFFSET)      /* FTM5 Half Cycle Register */
+
+#define S32K1XX_FTM5_PAIR0DEADTIME       (S32K1XX_FTM5_BASE + S32K1XX_FTM_PAIR0DEADTIME_OFFSET) /* FTM5 Pair 0 Deadtime Configuration register */
+#define S32K1XX_FTM5_PAIR1DEADTIME       (S32K1XX_FTM5_BASE + S32K1XX_FTM_PAIR1DEADTIME_OFFSET) /* FTM5 Pair 1 Deadtime Configuration register */
+#define S32K1XX_FTM5_PAIR2DEADTIME       (S32K1XX_FTM5_BASE + S32K1XX_FTM_PAIR2DEADTIME_OFFSET) /* FTM5 Pair 2 Deadtime Configuration register */
+#define S32K1XX_FTM5_PAIR3DEADTIME       (S32K1XX_FTM5_BASE + S32K1XX_FTM_PAIR3DEADTIME_OFFSET) /* FTM5 Pair 3 Deadtime Configuration register oset */
+
+#define S32K1XX_FTM5_MOD_MIRROR          (S32K1XX_FTM5_BASE + S32K1XX_FTM_MOD_MIRROR_OFFSET) /* FTM5 Mirror of Modulo Value register */
+#define S32K1XX_FTM5_C0V_MIRROR          (S32K1XX_FTM5_BASE + S32K1XX_FTM_C0V_MIRROR_OFFSET) /* FTM5 Mirror of Channel 0 Match Value register */
+#define S32K1XX_FTM5_C1V_MIRROR          (S32K1XX_FTM5_BASE + S32K1XX_FTM_C1V_MIRROR_OFFSET) /* FTM5 Mirror of Channel 1 Match Value register */
+#define S32K1XX_FTM5_C2V_MIRROR          (S32K1XX_FTM5_BASE + S32K1XX_FTM_C2V_MIRROR_OFFSET) /* FTM5 Mirror of Channel 2 Match Value register */
+#define S32K1XX_FTM5_C3V_MIRROR          (S32K1XX_FTM5_BASE + S32K1XX_FTM_C3V_MIRROR_OFFSET) /* FTM5 Mirror of Channel 3 Match Value register */
+#define S32K1XX_FTM5_C4V_MIRROR          (S32K1XX_FTM5_BASE + S32K1XX_FTM_C4V_MIRROR_OFFSET) /* FTM5 Mirror of Channel 4 Match Value register */
+#define S32K1XX_FTM5_C5V_MIRROR          (S32K1XX_FTM5_BASE + S32K1XX_FTM_C5V_MIRROR_OFFSET) /* FTM5 Mirror of Channel 5 Match Value register */
+#define S32K1XX_FTM5_C6V_MIRROR          (S32K1XX_FTM5_BASE + S32K1XX_FTM_C6V_MIRROR_OFFSET) /* FTM5 Mirror of Channel 6 Match Value register */
+#define S32K1XX_FTM5_C7V_MIRROR          (S32K1XX_FTM5_BASE + S32K1XX_FTM_C7V_MIRROR_OFFSET) /* FTM5 Mirror of Channel 7 Match Value register */
+
+/* FTM6 registers */
+
+#define S32K1XX_FTM6_SC                  (S32K1XX_FTM6_BASE + S32K1XX_FTM_SC_OFFSET)       /* FTM6 Status And Control register */
+#define S32K1XX_FTM6_CNT                 (S32K1XX_FTM6_BASE + S32K1XX_FTM_CNT_OFFSET)      /* FTM6 Counter register */
+#define S32K1XX_FTM6_MOD                 (S32K1XX_FTM6_BASE + S32K1XX_FTM_MOD_OFFSET)      /* FTM6 Modulo register */
+#define S32K1XX_FTM6_C0SC                (S32K1XX_FTM6_BASE + S32K1XX_FTM_C0SC_OFFSET)     /* FTM6 Channel 0 Status And Control register */
+#define S32K1XX_FTM6_C0V                 (S32K1XX_FTM6_BASE + S32K1XX_FTM_C0V_OFFSET)      /* FTM6 Channel 0 Value register */
+#define S32K1XX_FTM6_C1SC                (S32K1XX_FTM6_BASE + S32K1XX_FTM_C1SC_OFFSET)     /* FTM6 Channel 1 Status And Control register */
+#define S32K1XX_FTM6_C1V                 (S32K1XX_FTM6_BASE + S32K1XX_FTM_C1V_OFFSET)      /* FTM6 Channel 1 Value register */
+#define S32K1XX_FTM6_C2SC                (S32K1XX_FTM6_BASE + S32K1XX_FTM_C2SC_OFFSET)     /* FTM6 Channel 2 Status And Control register */
+#define S32K1XX_FTM6_C2V                 (S32K1XX_FTM6_BASE + S32K1XX_FTM_C2V_OFFSET)      /* FTM6 Channel 2 Value register */
+#define S32K1XX_FTM6_C3SC                (S32K1XX_FTM6_BASE + S32K1XX_FTM_C3SC_OFFSET)     /* FTM6 Channel 3 Status And Control register */
+#define S32K1XX_FTM6_C3V                 (S32K1XX_FTM6_BASE + S32K1XX_FTM_C3V_OFFSET)      /* FTM6 Channel 3 Value register */
+#define S32K1XX_FTM6_C4SC                (S32K1XX_FTM6_BASE + S32K1XX_FTM_C4SC_OFFSET)     /* FTM6 Channel 4 Status And Control register */
+#define S32K1XX_FTM6_C4V                 (S32K1XX_FTM6_BASE + S32K1XX_FTM_C4V_OFFSET)      /* FTM6 Channel 4 Value register */
+#define S32K1XX_FTM6_C5SC                (S32K1XX_FTM6_BASE + S32K1XX_FTM_C5SC_OFFSET)     /* FTM6 Channel 5 Status And Control register */
+#define S32K1XX_FTM6_C5V                 (S32K1XX_FTM6_BASE + S32K1XX_FTM_C5V_OFFSET)      /* FTM6 Channel 5 Value register */
+#define S32K1XX_FTM6_C6SC                (S32K1XX_FTM6_BASE + S32K1XX_FTM_C6SC_OFFSET)     /* FTM6 Channel 6 Status And Control register */
+#define S32K1XX_FTM6_C6V                 (S32K1XX_FTM6_BASE + S32K1XX_FTM_C6V_OFFSET)      /* FTM6 Channel 6 Value register */
+#define S32K1XX_FTM6_C7SC                (S32K1XX_FTM6_BASE + S32K1XX_FTM_C7SC_OFFSET)     /* FTM6 Channel 7 Status And Control register */
+#define S32K1XX_FTM6_C7V                 (S32K1XX_FTM6_BASE + S32K1XX_FTM_C7V_OFFSET)      /* FTM6 Channel 7 Value register */
+#define S32K1XX_FTM6_CNTIN               (S32K1XX_FTM6_BASE + S32K1XX_FTM_CNTIN_OFFSET)    /* FTM6 Counter Initial Value register */
+#define S32K1XX_FTM6_STATUS              (S32K1XX_FTM6_BASE + S32K1XX_FTM_STATUS_OFFSET)   /* FTM6 Capture And Compare Status register */
+#define S32K1XX_FTM6_MODE                (S32K1XX_FTM6_BASE + S32K1XX_FTM_MODE_OFFSET)     /* FTM6 Features Mode Selection register */
+#define S32K1XX_FTM6_SYNC                (S32K1XX_FTM6_BASE + S32K1XX_FTM_SYNC_OFFSET)     /* FTM6 Synchronization register */
+#define S32K1XX_FTM6_OUTINIT             (S32K1XX_FTM6_BASE + S32K1XX_FTM_OUTINIT_OFFSET)  /* FTM6 Initial State For Channels Output register */
+#define S32K1XX_FTM6_OUTMASK             (S32K1XX_FTM6_BASE + S32K1XX_FTM_OUTMASK_OFFSET)  /* FTM6 Output Mask register */
+#define S32K1XX_FTM6_COMBINE             (S32K1XX_FTM6_BASE + S32K1XX_FTM_COMBINE_OFFSET)  /* FTM6 Function For Linked Channels register */
+#define S32K1XX_FTM6_DEADTIME            (S32K1XX_FTM6_BASE + S32K1XX_FTM_DEADTIME_OFFSET) /* FTM6 Deadtime Configuration register */
+#define S32K1XX_FTM6_EXTTRIG             (S32K1XX_FTM6_BASE + S32K1XX_FTM_EXTTRIG_OFFSET)  /* FTM6 External Trigger register */
+#define S32K1XX_FTM6_POL                 (S32K1XX_FTM6_BASE + S32K1XX_FTM_POL_OFFSET)      /* FTM6 Channel Polarity register */
+#define S32K1XX_FTM6_FMS                 (S32K1XX_FTM6_BASE + S32K1XX_FTM_FMS_OFFSET)      /* FTM6 Fault Mode Status register */
+#define S32K1XX_FTM6_FILTER              (S32K1XX_FTM6_BASE + S32K1XX_FTM_FILTER_OFFSET)   /* FTM6 Input Capture Filter Control register */
+#define S32K1XX_FTM6_FLTCTRL             (S32K1XX_FTM6_BASE + S32K1XX_FTM_FILTCTRL_OFFSET) /* FTM6 Fault Control register */
+#define S32K1XX_FTM6_QDCTRL              (S32K1XX_FTM6_BASE + S32K1XX_FTM_QDCTRL_OFFSET)   /* FTM6 Quadrature Decoder Control And Status register */
+#define S32K1XX_FTM6_CONF                (S32K1XX_FTM6_BASE + S32K1XX_FTM_CONF_OFFSET)     /* FTM6 Configuration register */
+#define S32K1XX_FTM6_FLTPOL              (S32K1XX_FTM6_BASE + S32K1XX_FTM_FLTPOL_OFFSET)   /* FTM6 Fault Input Polarity register */
+#define S32K1XX_FTM6_SYNCONF             (S32K1XX_FTM6_BASE + S32K1XX_FTM_SYNCONF_OFFSET)  /* FTM6 Synchronization Configuration register */
+#define S32K1XX_FTM6_INVCTRL             (S32K1XX_FTM6_BASE + S32K1XX_FTM_INVCTRL_OFFSET)  /* FTM6 Inverting Control register */
+#define S32K1XX_FTM6_SWOCTRL             (S32K1XX_FTM6_BASE + S32K1XX_FTM_SWOCTRL_OFFSET)  /* FTM6 Software Output Control register */
+#define S32K1XX_FTM6_PWMLOAD             (S32K1XX_FTM6_BASE + S32K1XX_FTM_PWMLOAD_OFFSET)  /* FTM6 PWM Load register */
+#define S32K1XX_FTM6_HCR                 (S32K1XX_FTM6_BASE + S32K1XX_FTM_HCR_OFFSET)      /* FTM6 Half Cycle Register */
+
+#define S32K1XX_FTM6_PAIR0DEADTIME       (S32K1XX_FTM6_BASE + S32K1XX_FTM_PAIR0DEADTIME_OFFSET) /* FTM6 Pair 0 Deadtime Configuration register */
+#define S32K1XX_FTM6_PAIR1DEADTIME       (S32K1XX_FTM6_BASE + S32K1XX_FTM_PAIR1DEADTIME_OFFSET) /* FTM6 Pair 1 Deadtime Configuration register */
+#define S32K1XX_FTM6_PAIR2DEADTIME       (S32K1XX_FTM6_BASE + S32K1XX_FTM_PAIR2DEADTIME_OFFSET) /* FTM6 Pair 2 Deadtime Configuration register */
+#define S32K1XX_FTM6_PAIR3DEADTIME       (S32K1XX_FTM6_BASE + S32K1XX_FTM_PAIR3DEADTIME_OFFSET) /* FTM6 Pair 3 Deadtime Configuration register oset */
+
+#define S32K1XX_FTM6_MOD_MIRROR          (S32K1XX_FTM6_BASE + S32K1XX_FTM_MOD_MIRROR_OFFSET) /* FTM6 Mirror of Modulo Value register */
+#define S32K1XX_FTM6_C0V_MIRROR          (S32K1XX_FTM6_BASE + S32K1XX_FTM_C0V_MIRROR_OFFSET) /* FTM6 Mirror of Channel 0 Match Value register */
+#define S32K1XX_FTM6_C1V_MIRROR          (S32K1XX_FTM6_BASE + S32K1XX_FTM_C1V_MIRROR_OFFSET) /* FTM6 Mirror of Channel 1 Match Value register */
+#define S32K1XX_FTM6_C2V_MIRROR          (S32K1XX_FTM6_BASE + S32K1XX_FTM_C2V_MIRROR_OFFSET) /* FTM6 Mirror of Channel 2 Match Value register */
+#define S32K1XX_FTM6_C3V_MIRROR          (S32K1XX_FTM6_BASE + S32K1XX_FTM_C3V_MIRROR_OFFSET) /* FTM6 Mirror of Channel 3 Match Value register */
+#define S32K1XX_FTM6_C4V_MIRROR          (S32K1XX_FTM6_BASE + S32K1XX_FTM_C4V_MIRROR_OFFSET) /* FTM6 Mirror of Channel 4 Match Value register */
+#define S32K1XX_FTM6_C5V_MIRROR          (S32K1XX_FTM6_BASE + S32K1XX_FTM_C5V_MIRROR_OFFSET) /* FTM6 Mirror of Channel 5 Match Value register */
+#define S32K1XX_FTM6_C6V_MIRROR          (S32K1XX_FTM6_BASE + S32K1XX_FTM_C6V_MIRROR_OFFSET) /* FTM6 Mirror of Channel 6 Match Value register */
+#define S32K1XX_FTM6_C7V_MIRROR          (S32K1XX_FTM6_BASE + S32K1XX_FTM_C7V_MIRROR_OFFSET) /* FTM6 Mirror of Channel 7 Match Value register */
+
+/* FTM7 registers */
+
+#define S32K1XX_FTM7_SC                  (S32K1XX_FTM7_BASE + S32K1XX_FTM_SC_OFFSET)       /* FTM7 Status And Control register */
+#define S32K1XX_FTM7_CNT                 (S32K1XX_FTM7_BASE + S32K1XX_FTM_CNT_OFFSET)      /* FTM7 Counter register */
+#define S32K1XX_FTM7_MOD                 (S32K1XX_FTM7_BASE + S32K1XX_FTM_MOD_OFFSET)      /* FTM7 Modulo register */
+#define S32K1XX_FTM7_C0SC                (S32K1XX_FTM7_BASE + S32K1XX_FTM_C0SC_OFFSET)     /* FTM7 Channel 0 Status And Control register */
+#define S32K1XX_FTM7_C0V                 (S32K1XX_FTM7_BASE + S32K1XX_FTM_C0V_OFFSET)      /* FTM7 Channel 0 Value register */
+#define S32K1XX_FTM7_C1SC                (S32K1XX_FTM7_BASE + S32K1XX_FTM_C1SC_OFFSET)     /* FTM7 Channel 1 Status And Control register */
+#define S32K1XX_FTM7_C1V                 (S32K1XX_FTM7_BASE + S32K1XX_FTM_C1V_OFFSET)      /* FTM7 Channel 1 Value register */
+#define S32K1XX_FTM7_C2SC                (S32K1XX_FTM7_BASE + S32K1XX_FTM_C2SC_OFFSET)     /* FTM7 Channel 2 Status And Control register */
+#define S32K1XX_FTM7_C2V                 (S32K1XX_FTM7_BASE + S32K1XX_FTM_C2V_OFFSET)      /* FTM7 Channel 2 Value register */
+#define S32K1XX_FTM7_C3SC                (S32K1XX_FTM7_BASE + S32K1XX_FTM_C3SC_OFFSET)     /* FTM7 Channel 3 Status And Control register */
+#define S32K1XX_FTM7_C3V                 (S32K1XX_FTM7_BASE + S32K1XX_FTM_C3V_OFFSET)      /* FTM7 Channel 3 Value register */
+#define S32K1XX_FTM7_C4SC                (S32K1XX_FTM7_BASE + S32K1XX_FTM_C4SC_OFFSET)     /* FTM7 Channel 4 Status And Control register */
+#define S32K1XX_FTM7_C4V                 (S32K1XX_FTM7_BASE + S32K1XX_FTM_C4V_OFFSET)      /* FTM7 Channel 4 Value register */
+#define S32K1XX_FTM7_C5SC                (S32K1XX_FTM7_BASE + S32K1XX_FTM_C5SC_OFFSET)     /* FTM7 Channel 5 Status And Control register */
+#define S32K1XX_FTM7_C5V                 (S32K1XX_FTM7_BASE + S32K1XX_FTM_C5V_OFFSET)      /* FTM7 Channel 5 Value register */
+#define S32K1XX_FTM7_C6SC                (S32K1XX_FTM7_BASE + S32K1XX_FTM_C6SC_OFFSET)     /* FTM7 Channel 6 Status And Control register */
+#define S32K1XX_FTM7_C6V                 (S32K1XX_FTM7_BASE + S32K1XX_FTM_C6V_OFFSET)      /* FTM7 Channel 6 Value register */
+#define S32K1XX_FTM7_C7SC                (S32K1XX_FTM7_BASE + S32K1XX_FTM_C7SC_OFFSET)     /* FTM7 Channel 7 Status And Control register */
+#define S32K1XX_FTM7_C7V                 (S32K1XX_FTM7_BASE + S32K1XX_FTM_C7V_OFFSET)      /* FTM7 Channel 7 Value register */
+#define S32K1XX_FTM7_CNTIN               (S32K1XX_FTM7_BASE + S32K1XX_FTM_CNTIN_OFFSET)    /* FTM7 Counter Initial Value register */
+#define S32K1XX_FTM7_STATUS              (S32K1XX_FTM7_BASE + S32K1XX_FTM_STATUS_OFFSET)   /* FTM7 Capture And Compare Status register */
+#define S32K1XX_FTM7_MODE                (S32K1XX_FTM7_BASE + S32K1XX_FTM_MODE_OFFSET)     /* FTM7 Features Mode Selection register */
+#define S32K1XX_FTM7_SYNC                (S32K1XX_FTM7_BASE + S32K1XX_FTM_SYNC_OFFSET)     /* FTM7 Synchronization register */
+#define S32K1XX_FTM7_OUTINIT             (S32K1XX_FTM7_BASE + S32K1XX_FTM_OUTINIT_OFFSET)  /* FTM7 Initial State For Channels Output register */
+#define S32K1XX_FTM7_OUTMASK             (S32K1XX_FTM7_BASE + S32K1XX_FTM_OUTMASK_OFFSET)  /* FTM7 Output Mask register */
+#define S32K1XX_FTM7_COMBINE             (S32K1XX_FTM7_BASE + S32K1XX_FTM_COMBINE_OFFSET)  /* FTM7 Function For Linked Channels register */
+#define S32K1XX_FTM7_DEADTIME            (S32K1XX_FTM7_BASE + S32K1XX_FTM_DEADTIME_OFFSET) /* FTM7 Deadtime Configuration register */
+#define S32K1XX_FTM7_EXTTRIG             (S32K1XX_FTM7_BASE + S32K1XX_FTM_EXTTRIG_OFFSET)  /* FTM7 External Trigger register */
+#define S32K1XX_FTM7_POL                 (S32K1XX_FTM7_BASE + S32K1XX_FTM_POL_OFFSET)      /* FTM7 Channel Polarity register */
+#define S32K1XX_FTM7_FMS                 (S32K1XX_FTM7_BASE + S32K1XX_FTM_FMS_OFFSET)      /* FTM7 Fault Mode Status register */
+#define S32K1XX_FTM7_FILTER              (S32K1XX_FTM7_BASE + S32K1XX_FTM_FILTER_OFFSET)   /* FTM7 Input Capture Filter Control register */
+#define S32K1XX_FTM7_FLTCTRL             (S32K1XX_FTM7_BASE + S32K1XX_FTM_FILTCTRL_OFFSET) /* FTM7 Fault Control register */
+#define S32K1XX_FTM7_QDCTRL              (S32K1XX_FTM7_BASE + S32K1XX_FTM_QDCTRL_OFFSET)   /* FTM7 Quadrature Decoder Control And Status register */
+#define S32K1XX_FTM7_CONF                (S32K1XX_FTM7_BASE + S32K1XX_FTM_CONF_OFFSET)     /* FTM7 Configuration register */
+#define S32K1XX_FTM7_FLTPOL              (S32K1XX_FTM7_BASE + S32K1XX_FTM_FLTPOL_OFFSET)   /* FTM7 Fault Input Polarity register */
+#define S32K1XX_FTM7_SYNCONF             (S32K1XX_FTM7_BASE + S32K1XX_FTM_SYNCONF_OFFSET)  /* FTM7 Synchronization Configuration register */
+#define S32K1XX_FTM7_INVCTRL             (S32K1XX_FTM7_BASE + S32K1XX_FTM_INVCTRL_OFFSET)  /* FTM7 Inverting Control register */
+#define S32K1XX_FTM7_SWOCTRL             (S32K1XX_FTM7_BASE + S32K1XX_FTM_SWOCTRL_OFFSET)  /* FTM7 Software Output Control register */
+#define S32K1XX_FTM7_PWMLOAD             (S32K1XX_FTM7_BASE + S32K1XX_FTM_PWMLOAD_OFFSET)  /* FTM7 PWM Load register */
+#define S32K1XX_FTM7_HCR                 (S32K1XX_FTM7_BASE + S32K1XX_FTM_HCR_OFFSET)      /* FTM7 Half Cycle Register */
+
+#define S32K1XX_FTM7_PAIR0DEADTIME       (S32K1XX_FTM7_BASE + S32K1XX_FTM_PAIR0DEADTIME_OFFSET) /* FTM7 Pair 0 Deadtime Configuration register */
+#define S32K1XX_FTM7_PAIR1DEADTIME       (S32K1XX_FTM7_BASE + S32K1XX_FTM_PAIR1DEADTIME_OFFSET) /* FTM7 Pair 1 Deadtime Configuration register */
+#define S32K1XX_FTM7_PAIR2DEADTIME       (S32K1XX_FTM7_BASE + S32K1XX_FTM_PAIR2DEADTIME_OFFSET) /* FTM7 Pair 2 Deadtime Configuration register */
+#define S32K1XX_FTM7_PAIR3DEADTIME       (S32K1XX_FTM7_BASE + S32K1XX_FTM_PAIR3DEADTIME_OFFSET) /* FTM7 Pair 3 Deadtime Configuration register oset */
+
+#define S32K1XX_FTM7_MOD_MIRROR          (S32K1XX_FTM7_BASE + S32K1XX_FTM_MOD_MIRROR_OFFSET) /* FTM7 Mirror of Modulo Value register */
+#define S32K1XX_FTM7_C0V_MIRROR          (S32K1XX_FTM7_BASE + S32K1XX_FTM_C0V_MIRROR_OFFSET) /* FTM7 Mirror of Channel 0 Match Value register */
+#define S32K1XX_FTM7_C1V_MIRROR          (S32K1XX_FTM7_BASE + S32K1XX_FTM_C1V_MIRROR_OFFSET) /* FTM7 Mirror of Channel 1 Match Value register */
+#define S32K1XX_FTM7_C2V_MIRROR          (S32K1XX_FTM7_BASE + S32K1XX_FTM_C2V_MIRROR_OFFSET) /* FTM7 Mirror of Channel 2 Match Value register */
+#define S32K1XX_FTM7_C3V_MIRROR          (S32K1XX_FTM7_BASE + S32K1XX_FTM_C3V_MIRROR_OFFSET) /* FTM7 Mirror of Channel 3 Match Value register */
+#define S32K1XX_FTM7_C4V_MIRROR          (S32K1XX_FTM7_BASE + S32K1XX_FTM_C4V_MIRROR_OFFSET) /* FTM7 Mirror of Channel 4 Match Value register */
+#define S32K1XX_FTM7_C5V_MIRROR          (S32K1XX_FTM7_BASE + S32K1XX_FTM_C5V_MIRROR_OFFSET) /* FTM7 Mirror of Channel 5 Match Value register */
+#define S32K1XX_FTM7_C6V_MIRROR          (S32K1XX_FTM7_BASE + S32K1XX_FTM_C6V_MIRROR_OFFSET) /* FTM7 Mirror of Channel 6 Match Value register */
+#define S32K1XX_FTM7_C7V_MIRROR          (S32K1XX_FTM7_BASE + S32K1XX_FTM_C7V_MIRROR_OFFSET) /* FTM7 Mirror of Channel 7 Match Value register */
+
+/* Register Bit Definitions **************************************************************************/
+
+/* Status And Control register */
+
+#define FTM_SC_PS_SHIFT                  (0)       /* Bits 0-2: Prescale Factor Selection */
+#define FTM_SC_PS_MASK                   (0x07 << FTM_SC_PS_SHIFT)
+#  define FTP_SC_PS_DIV1                 (0 << FTM_SC_PS_SHIFT) /* Divide by 1 */
+#  define FTP_SC_PS_DIV2                 (1 << FTM_SC_PS_SHIFT) /* Divide by 2 */
+#  define FTP_SC_PS_DIV4                 (2 << FTM_SC_PS_SHIFT) /* Divide by 4 */
+#  define FTP_SC_PS_DIV8                 (3 << FTM_SC_PS_SHIFT) /* Divide by 8 */
+#  define FTP_SC_PS_DIV16                (4 << FTM_SC_PS_SHIFT) /* Divide by 16 */
+#  define FTP_SC_PS_DIV32                (5 << FTM_SC_PS_SHIFT) /* Divide by 32 */
+#  define FTP_SC_PS_DIV64                (6 << FTM_SC_PS_SHIFT) /* Divide by 64 */
+#  define FTP_SC_PS_DIV128               (7 << FTM_SC_PS_SHIFT) /* Divide by 128 */
+#define FTM_SC_CLKS_SHIFT                (3)       /* Bits 3-4: Clock Source Selection */
+#define FTM_SC_CLKS_MASK                 (0x03 << FTM_SC_CLKS_SHIFT)
+#  define FTM_SC_CLKS_DIS                (0 << FTM_SC_CLKS_SHIFT) /* No clock selected. This in effect disables the FTM counter */
+#  define FTM_SC_CLKS_FTM                (1 << FTM_SC_CLKS_SHIFT) /* FTM input clock */
+#  define FTM_SC_CLKS_FIXED              (2 << FTM_SC_CLKS_SHIFT) /* Fixed frequency clock */
+#  define FTM_SC_CLKS_EXTCLK             (3 << FTM_SC_CLKS_SHIFT) /* External clock */
+#define FTM_SC_CPWMS                     (1 << 5)  /* Bit 5: Center-Aligned PWM Select */
+#define FTM_SC_RIE                       (1 << 6)  /* Bit 6: Reload Point Interrupt Enable */
+#define FTM_SC_RF                        (1 << 7)  /* Bit 7: Reload Flag */
+#define FTM_SC_TOIE                      (1 << 8)  /* Bit 8: Timer Overflow Interrupt Enable */
+#define FTM_SC_TOF                       (1 << 9)  /* Bit 9: Timer Overflow Flag */
+
+                                                   /* Bits 10-15: Reserved */
+
+#define FTM_SC_PWMEN_SHIFT               (16)      /* Bits 16-23: Channel n PWM enable bit */
+#define FTM_SC_PWMEN_MASK                (0xff << FTM_SC_PWMEN_SHIFT)
+#define FTM_SC_PWMEN(n)                  (1 << FTM_SC_PWMEN_SHIFT + (n))
+#define FTM_SC_FLTPS_SHIFT               (24)      /* Bits 24-27: Filter Prescaler */
+#define FTM_SC_FLTPS_MASK                (0x07 << FTM_SC_FLTPS_SHIFT)
+#  define FTM_SC_FLTPS_DIV1              (0 << FTM_SC_FLTPS_SHIFT)  /* Divide by 1 */
+#  define FTM_SC_FLTPS_DIV2              (1 << FTM_SC_FLTPS_SHIFT)  /* Divide by 2 */
+#  define FTM_SC_FLTPS_DIV3              (2 << FTM_SC_FLTPS_SHIFT)  /* Divide by 3 */
+#  define FTM_SC_FLTPS_DIV4              (3 << FTM_SC_FLTPS_SHIFT)  /* Divide by 4 */
+#  define FTM_SC_FLTPS_DIV5              (4 << FTM_SC_FLTPS_SHIFT)  /* Divide by 5 */
+#  define FTM_SC_FLTPS_DIV6              (5 << FTM_SC_FLTPS_SHIFT)  /* Divide by 6 */
+#  define FTM_SC_FLTPS_DIV7              (6 << FTM_SC_FLTPS_SHIFT)  /* Divide by 7 */
+#  define FTM_SC_FLTPS_DIV8              (7 << FTM_SC_FLTPS_SHIFT)  /* Divide by 8 */
+#  define FTM_SC_FLTPS_DIV9              (8 << FTM_SC_FLTPS_SHIFT)  /* Divide by 9 */
+#  define FTM_SC_FLTPS_DIV10             (9 << FTM_SC_FLTPS_SHIFT)  /* Divide by 10 */
+#  define FTM_SC_FLTPS_DIV11             (10 << FTM_SC_FLTPS_SHIFT) /* Divide by 11 */
+#  define FTM_SC_FLTPS_DIV12             (11 << FTM_SC_FLTPS_SHIFT) /* Divide by 12 */
+#  define FTM_SC_FLTPS_DIV13             (12 << FTM_SC_FLTPS_SHIFT) /* Divide by 13 */
+#  define FTM_SC_FLTPS_DIV14             (13 << FTM_SC_FLTPS_SHIFT) /* Divide by 14 */
+#  define FTM_SC_FLTPS_DIV15             (14 << FTM_SC_FLTPS_SHIFT) /* Divide by 15 */
+#  define FTM_SC_FLTPS_DIV16             (15 << FTM_SC_FLTPS_SHIFT) /* Divide by 16 */
+
+                                                   /* Bits 28-31: Reserved */
+
+/* Counter register */
+
+#define FTM_CNT_COUNT_SHIFT              (0)       /* Bits 0-15: Counter Value */
+#define FTM_CNT_COUNT_MASK               (0xff << FTM_CNT_COUNT_SHIFT)
+
+                                                   /* Bits 16-31: Reserved */
+
+/* Modulo register */
+
+#define FTM_MOD_MOD_SHIFT                (0)       /* Bits 0-15: Modulo Value */
+#define FTM_MOD_MOD_MASK                 (0xff << FTM_MOD_MOD_SHIFT)
+
+                                                   /* Bits 16-31: Reserved */
+
+/* Channel (n) Status And Control register */
+
+#define FTM_CNSC_DMA                     (1 << 0)  /* Bit 0: DMA Enable */
+#define FTM_CNSC_ICRST                   (1 << 1)  /* Bit 1: FTM Counter reset by the selected input capture event */
+#define FTM_CNSC_ELSA                    (1 << 2)  /* Bit 2: Channel (n) Edge or Level Select */
+#define FTM_CNSC_ELSB                    (1 << 3)  /* Bit 3: Channel (n) Edge or Level Select */
+#define FTM_CNSC_MSA                     (1 << 4)  /* Bit 4: Channel (n) Mode Select */
+#define FTM_CNSC_MSB                     (1 << 5)  /* Bit 5: Channel (n) Mode Select */
+#define FTM_CNSC_CHIE                    (1 << 6)  /* Bit 6: Channel (n) Interrupt Enable */
+#define FTM_CNSC_CHF                     (1 << 7)  /* Bit 7: Channel (n) flag */
+#define FTM_CNSC_TRIGMODE                (1 << 8)  /* Bit 8: Trigger Mode Control */
+#define FTM_CNSC_CHIS                    (1 << 9)  /* Bit 9: Channel (n) Input State */
+#define FTM_CNSC_CHOV                    (1 << 10) /* Bit 10: Channel (n) Output Value */
+
+                                                   /* Bits 11-31: Reserved */
+
+/* Channel (n) Value register */
+
+#define FTM_CNV_VAL_SHIFT                (0)       /* Bits 0-15: Channel Value */
+#define FTM_CNV_VAL_MASK                 (0xff << FTM_CNV_VAL_SHIFT)
+
+                                                   /* Bits 16-31: Reserved */
+
+/* Counter Initial Value register */
+
+#define FTM_CNTIN_INIT_SHIFT             (0)       /* Bits 0-15: Initial Value of the FTM Counter */
+#define FTM_CNTIN_VAL_MASK               (0xff << FTM_CNTIN_INIT_SHIFT)
+
+                                                   /* Bits 16-31: Reserved */
+
+/* Capture And Compare Status register */
+
+#define FTM_STATUS_CH0F                  (1 << 0)  /* Bit 0: Channel 0 Flag */
+#define FTM_STATUS_CH1F                  (1 << 1)  /* Bit 1: Channel 1 Flag */
+#define FTM_STATUS_CH2F                  (1 << 2)  /* Bit 2: Channel 2 Flag */
+#define FTM_STATUS_CH3F                  (1 << 3)  /* Bit 3: Channel 3 Flag */
+#define FTM_STATUS_CH4F                  (1 << 4)  /* Bit 4: Channel 4 Flag */
+#define FTM_STATUS_CH5F                  (1 << 5)  /* Bit 5: Channel 5 Flag */
+#define FTM_STATUS_CH6F                  (1 << 6)  /* Bit 6: Channel 6 Flag */
+#define FTM_STATUS_CH7F                  (1 << 7)  /* Bit 7: Channel 7 Flag */
+
+                                                   /* Bits 8-31: Reserved */
+
+/* Features Mode Selection register */
+
+#define FTM_MODE_FTMEN                   (1 << 0)  /* Bit 0: FTM Enable */
+#define FTM_MODE_INIT                    (1 << 1)  /* Bit 1: Initialize the Channels Output */
+#define FTM_MODE_WPDIS                   (1 << 2)  /* Bit 2: Write Protection Disable */
+#define FTM_MODE_PWMSYNC                 (1 << 3)  /* Bit 3: PWM Synchronization Mode */
+#define FTM_MODE_CAPTEST                 (1 << 4)  /* Bit 4: Capture Test Mode Enable */
+#define FTM_MODE_FAULTM_SHIFT            (5)       /* Bits 5-6: Fault Control Mode */
+#define FTM_MODE_FAULTM_MASK             (0x03 << FTM_MODE_FAULTM_SHIFT)
+#  define FTM_MODE_FAULTM_DIS            (0 << FTM_MODE_FAULTM_SHIFT) /* Fault control is disabled for all channels. */
+#  define FTM_MODE_FAULTM_EVEN_MAN       (1 << FTM_MODE_FAULTM_SHIFT) /* Fault control is enabled for even channels only (channels 0, 2, 4, and 6), and the selected mode is the manual fault clearing. */
+#  define FTM_MODE_FAULTM_ALL_MAN        (2 << FTM_MODE_FAULTM_SHIFT) /* Fault control is enabled for all channels, and the selected mode is the manual fault clearing. */
+#  define FTM_MODE_FAULTM_ALL_AUTO       (3 << FTM_MODE_FAULTM_SHIFT) /* Fault control is enabled for all channels, and the selected mode is the automatic fault clearing. */
+#define FTM_MODE_FAULTIE                 (1 << 7)  /* Bit 7: Fault Interrupt Enable */
+
+                                                   /* Bits 8-31: Reserved */
+
+/* Synchronization register */
+
+#define FTM_SYNC_CNTMIN                  (1 << 0)  /* Bit 0: Minimum Loading Point Enable */
+#define FTM_SYNC_CNTMAX                  (1 << 1)  /* Bit 1: Maximum Loading Point Enable */
+#define FTM_SYNC_REINIT                  (1 << 2)  /* Bit 2: FTM Counter Reinitialization by Synchronization */
+#define FTM_SYNC_SYNCHOM                 (1 << 3)  /* Bit 3: Output Mask Synchronization */
+#define FTM_SYNC_TRIG0                   (1 << 4)  /* Bit 4: PWM Synchronization Hardware Trigger 0 */
+#define FTM_SYNC_TRIG1                   (1 << 5)  /* Bit 5: PWM Synchronization Hardware Trigger 1 */
+#define FTM_SYNC_TRIG2                   (1 << 6)  /* Bit 6: PWM Synchronization Hardware Trigger 2 */
+#define FTM_SYNC_SWSYNC                  (1 << 7)  /* Bit 7: PWM Synchronization Software Trigger */
+
+                                                   /* Bit 8-31: Reserved */
+
+/* Initial State For Channels Output register */
+
+#define FTM_OUTINIT_CH0OI                (1 << 0)  /* Bit 0: Channel 0 Output Initialization Value */
+#define FTM_OUTINIT_CH1OI                (1 << 1)  /* Bit 1: Channel 1 Output Initialization Value */
+#define FTM_OUTINIT_CH2OI                (1 << 2)  /* Bit 2: Channel 2 Output Initialization Value */
+#define FTM_OUTINIT_CH3OI                (1 << 3)  /* Bit 3: Channel 3 Output Initialization Value */
+#define FTM_OUTINIT_CH4OI                (1 << 4)  /* Bit 4: Channel 4 Output Initialization Value */
+#define FTM_OUTINIT_CH5OI                (1 << 5)  /* Bit 5: Channel 5 Output Initialization Value */
+#define FTM_OUTINIT_CH6OI                (1 << 6)  /* Bit 6: Channel 6 Output Initialization Value */
+#define FTM_OUTINIT_CH7OI                (1 << 7)  /* Bit 7: Channel 7 Output Initialization Value */
+
+                                                   /* Bit 8-31: Reserved */
+
+/* Output Mask register */
+
+#define FTM_OUTMASK_CH0OM                (1 << 0)  /* Bit 0: Channel 0 Ouput Mask */
+#define FTM_OUTMASK_CH1OM                (1 << 1)  /* Bit 1: Channel 1 Ouput Mask */
+#define FTM_OUTMASK_CH2OM                (1 << 2)  /* Bit 2: Channel 2 Ouput Mask */
+#define FTM_OUTMASK_CH3OM                (1 << 3)  /* Bit 3: Channel 3 Ouput Mask */
+#define FTM_OUTMASK_CH4OM                (1 << 4)  /* Bit 4: Channel 4 Ouput Mask */
+#define FTM_OUTMASK_CH5OM                (1 << 5)  /* Bit 5: Channel 5 Ouput Mask */
+#define FTM_OUTMASK_CH6OM                (1 << 6)  /* Bit 6: Channel 6 Ouput Mask */
+#define FTM_OUTMASK_CH7OM                (1 << 7)  /* Bit 7: Channel 7 Ouput Mask */
+
+                                                   /* Bit 8-31: Reserved */
+
+/* Function For Linked Channels register */
+
+#define FTM_COMBINE_COMBINE0             (1 << 0)  /* Bit 0: Combine Mode for Channels 0 and 1 */
+#define FTM_COMBINE_COMP0                (1 << 1)  /* Bit 1: Channel 1 is Complement of Channel 0 */
+#define FTM_COMBINE_DECAPEN0             (1 << 2)  /* Bit 2: Dual Edge Capture Mode Enable for Channel 0 and 1 */
+#define FTM_COMBINE_DECAP0               (1 << 3)  /* Bit 3: Dual Edge Capture Mode Capture for Channel 0 and 1 */
+#define FTM_COMBINE_DTEN0                (1 << 4)  /* Bit 4: Deadtime Enable for Channel 0 and 1 */
+#define FTM_COMBINE_SYNCEN0              (1 << 5)  /* Bit 5: Synchronization Enable for Channel 0 and 1 */
+#define FTM_COMBINE_FAULTEN0             (1 << 6)  /* Bit 6: Fault Control Enable for Channel 0 and 1 */
+#define FTM_COMBINE_MCOMBINE0            (1 << 7)  /* Bit 7: Modified Combine Mode for Channels 0 and 1 */
+#define FTM_COMBINE_COMBINE1             (1 << 8)  /* Bit 8: Combine Mode for Channels 2 and 3 */
+#define FTM_COMBINE_COMP1                (1 << 9)  /* Bit 9: Channel 3 is Complement of Channel 2 */
+#define FTM_COMBINE_DECAPEN1             (1 << 10) /* Bit 10: Dual Edge Capture Mode Enable for Channel 2 and 3 */
+#define FTM_COMBINE_DECAP1               (1 << 11) /* Bit 11: Dual Edge Capture Mode Capture for Channel 2 and 3 */
+#define FTM_COMBINE_DTEN1                (1 << 12) /* Bit 12: Deadtime Enable for Channel 2 and 3 */
+#define FTM_COMBINE_SYNCEN1              (1 << 13) /* Bit 13: Synchronization Enable for Channel 2 and 3 */
+#define FTM_COMBINE_FAULTEN1             (1 << 14) /* Bit 14: Fault Control Enable for Channel 2 and 3 */
+#define FTM_COMBINE_MCOMBINE1            (1 << 15) /* Bit 15: Modified Combine Mode for Channels 2 and 3 */
+#define FTM_COMBINE_COMBINE2             (1 << 16) /* Bit 16: Combine Mode for Channels 4 and 5 */
+#define FTM_COMBINE_COMP2                (1 << 17) /* Bit 17: Channel 5 is Complement of Channel 4 */
+#define FTM_COMBINE_DECAPEN2             (1 << 18) /* Bit 18: Dual Edge Capture Mode Enable for Channel 4 and 5 */
+#define FTM_COMBINE_DECAP2               (1 << 19) /* Bit 19: Dual Edge Capture Mode Capture for Channel 4 and 5 */
+#define FTM_COMBINE_DTEN2                (1 << 20) /* Bit 20: Deadtime Enable for Channel 4 and 5 */
+#define FTM_COMBINE_SYNCEN2              (1 << 21) /* Bit 21: Synchronization Enable for Channel 4 and 5 */
+#define FTM_COMBINE_FAULTEN2             (1 << 22) /* Bit 22: Fault Control Enable for Channel 4 and 5 */
+#define FTM_COMBINE_MCOMBINE2            (1 << 23) /* Bit 23: Modified Combine Mode for Channels 4 and 5 */
+#define FTM_COMBINE_COMBINE3             (1 << 24) /* Bit 24: Combine Mode for Channels 6 and 7 */
+#define FTM_COMBINE_COMP3                (1 << 25) /* Bit 25: Channel 7 is Complement of Channel 6 */
+#define FTM_COMBINE_DECAPEN3             (1 << 26) /* Bit 26: Dual Edge Capture Mode Enable for Channel 6 and 7 */
+#define FTM_COMBINE_DECAP3               (1 << 27) /* Bit 27: Dual Edge Capture Mode Capture for Channel 6 and 7 */
+#define FTM_COMBINE_DTEN3                (1 << 28) /* Bit 28: Deadtime Enable for Channel 6 and 7 */
+#define FTM_COMBINE_SYNCEN3              (1 << 29) /* Bit 29: Synchronization Enable for Channel 6 and 7 */
+#define FTM_COMBINE_FAULTEN3             (1 << 30) /* Bit 30: Fault Control Enable for Channel 6 and 7 */
+#define FTM_COMBINE_MCOMBINE3            (1 << 31) /* Bit 31: Modified Combine Mode for Channels 6 and 7 */
+
+/* Deadtime Configuration register */
+
+#define FTM_DEADTIME_DTVAL_SHIFT         (0)       /* Bits 0-5: Deadtime Value */
+#define FTM_DEADTIME_DTVAL_MASK          (0x1f << FTM_DEADTIME_DTVAL_SHIFT)
+#define FTM_DEADTIME_DTPS_SHIFT          (6)       /* Bits 6-7: Deadtime Prescaler Value */
+#define FTM_DEADTIME_DTPS_MASK           (0x03 << FTM_DEADTIME_DTPS_SHIFT)
+#  define FTM_DEADTIME_DTPS_DIV1         (1 << FTM_DEADTIME_DTPS_SHIFT) /* Divide the FTM input clock by 1 */
+#  define FTM_DEADTIME_DTPS_DIV4         (2 << FTM_DEADTIME_DTPS_SHIFT) /* Divide the FTM input clock by 4 */
+#  define FTM_DEADTIME_DTPS_DIV16        (3 << FTM_DEADTIME_DTPS_SHIFT) /* Divide the FTM input clock by 16 */
+
+                                                   /* Bits 8-15: Reserved */
+
+#define FTM_DEADTIME_DTVALEX_SHIFT       (16)      /* Bits 16-19: Extended Deadtime Value */
+#define FTM_DEADTIME_DTVALEX_MASK        (0x0f << FTM_DEADTIME_DTVALEX_SHIFT)
+
+                                                   /* Bits 20-31: Reserved */
+
+/* FTM External Trigger register */
+
+#define FTM_EXTTRIG_CH2TRIG              (1 << 0)  /* Bit 0: Channel 2 External Trigger Enable */
+#define FTM_EXTTRIG_CH3TRIG              (1 << 1)  /* Bit 1: Channel 3 External Trigger Enable */
+#define FTM_EXTTRIG_CH4TRIG              (1 << 2)  /* Bit 2: Channel 4 External Trigger Enable */
+#define FTM_EXTTRIG_CH5TRIG              (1 << 3)  /* Bit 3: Channel 5 External Trigger Enable */
+#define FTM_EXTTRIG_CH0TRIG              (1 << 4)  /* Bit 4: Channel 0 External Trigger Enable */
+#define FTM_EXTTRIG_CH1TRIG              (1 << 5)  /* Bit 5: Channel 1 External Trigger Enable */
+#define FTM_EXTTRIG_INITTRIGEN           (1 << 6)  /* Bit 6: Initialization Trigger Enable */
+#define FTM_EXTTRIG_TRIGF                (1 << 7)  /* Bit 7: Channel Trigger Flag */
+#define FTM_EXTTRIG_CH6TRIG              (1 << 8)  /* Bit 8: Channel 6 External Trigger */
+#define FTM_EXTTRIG_CH7TRIG              (1 << 9)  /* Bit 9: Channel 7 External Trigger */
+
+                                                   /* Bits 10-31: Reserved */
+
+/* Channels Polarity register */
+
+#define FTM_POL_POL0                     (1 << 0)  /* Bit 0: Channel 0 Polarity */
+#define FTM_POL_POL1                     (1 << 1)  /* Bit 1: Channel 1 Polarity */
+#define FTM_POL_POL2                     (1 << 2)  /* Bit 2: Channel 2 Polarity */
+#define FTM_POL_POL3                     (1 << 3)  /* Bit 3: Channel 3 Polarity */
+#define FTM_POL_POL4                     (1 << 4)  /* Bit 4: Channel 4 Polarity */
+#define FTM_POL_POL5                     (1 << 5)  /* Bit 5: Channel 5 Polarity */
+#define FTM_POL_POL6                     (1 << 6)  /* Bit 6: Channel 6 Polarity */
+#define FTM_POL_POL7                     (1 << 7)  /* Bit 7: Channel 7 Polarity */
+
+                                                   /* Bits 8-31: Reserved */
+
+/* Fault Mode Status register */
+
+#define FTM_FMS_FAULTF0                  (1 << 0)  /* Bit 0: Fault Detection Flag 0 */
+#define FTM_FMS_FAULTF1                  (1 << 1)  /* Bit 1: Fault Detection Flag 1 */
+#define FTM_FMS_FAULTF2                  (1 << 2)  /* Bit 2: Fault Detection Flag 2 */
+#define FTM_FMS_FAULTF3                  (1 << 3)  /* Bit 3: Fault Detection Flag 3 */
+
+                                                   /* Bit 4: Reserved */
+
+#define FTM_FMS_FAULTIN                  (1 << 5)  /* Bit 5: Fault Inputs */
+#define FTM_FMS_WPEN                     (1 << 6)  /* Bit 6: Write Protection Enable */
+#define FTM_FMS_FAULTF                   (1 << 7)  /* Bit 7: Fault Detection Flag */
+
+                                                   /* Bits 8-31: Reserved */
+
+/* Input Capture Filter Control register */
+
+#define FTM_FILTER_CH0FVAL_SHIFT         (0)       /* Bits 0-3: Channel 0 Input Filter */
+#define FTM_FILTER_CH0FVAL_MASK          (0x0f << FTM_FILTER_CH0FVAL_SHIFT)
+#define FTM_FILTER_CH1FVAL_SHIFT         (4)       /* Bits 4-7: Channel 1 Input Filter */
+#define FTM_FILTER_CH1FVAL_MASK          (0x0f << FTM_FILTER_CH1FVAL_SHIFT)
+#define FTM_FILTER_CH2FVAL_SHIFT         (8)       /* Bits 8-11: Channel 2 Input Filter */
+#define FTM_FILTER_CH2FVAL_MASK          (0x0f << FTM_FILTER_CH2FVAL_SHIFT)
+#define FTM_FILTER_CH3FVAL_SHIFT         (12)      /* Bits 12-15: Channel 3 Input Filter */
+#define FTM_FILTER_CH3FVAL_MASK          (0x0f << FTM_FILTER_CH3FVAL_SHIFT)
+
+                                                   /* Bits 16-31: Reserved */
+
+/* Fault Control register */
+
+#define FTM_FLTCTRL_FAULT0EN             (1 << 0)  /* Bit 0: Fault Input 0 Enable */
+#define FTM_FLTCTRL_FAULT1EN             (1 << 1)  /* Bit 1: Fault Input 1 Enable */
+#define FTM_FLTCTRL_FAULT2EN             (1 << 2)  /* Bit 2: Fault Input 2 Enable */
+#define FTM_FLTCTRL_FAULT3EN             (1 << 3)  /* Bit 3: Fault Input 3 Enable */
+#define FTM_FLTCTRL_FFLTR0EN             (1 << 4)  /* Bit 4: Fault Input 0 Filter Enable */
+#define FTM_FLTCTRL_FFLTR1EN             (1 << 5)  /* Bit 5: Fault Input 1 Filter Enable */
+#define FTM_FLTCTRL_FFLTR2EN             (1 << 6)  /* Bit 6: Fault Input 2 Filter Enable */
+#define FTM_FLTCTRL_FFLTR3EN             (1 << 7)  /* Bit 7: Fault Input 3 Filter Enable */
+#define FTM_FLTCTRL_FFVAL_SHIFT          (8)       /* Bits 8-11: Fault Input Filter */
+#define FTM_FLTCTRL_FFVAL_MASK           (0x0f << FTM_FLTCTRL_FFVAL_SHIFT)
+
+                                                   /* Bits 12-14: Reserved */
+
+#define FTM_FLTCTRL_FSTATE               (1 << 15) /* Bit 15: Fault Output State */
+
+                                                   /* Bits 16-31: Reserved */
+
+/* Quadrature Decoder Control And Status register */
+
+#define FTM_QDCTRL_QUADEN                (1 << 0)  /* Bit 0: Quadrature Decoder Mode Enable */
+#define FTM_QDCTRL_TOFDIR                (1 << 1)  /* Bit 1: Timer Overflow Direction in Quadrature Decoder Mode */
+#define FTM_QDCTRL_QUADIR                (1 << 2)  /* Bit 2: FTM Counter Direction in Quadrature Decoder Mode */
+#define FTM_QDCTRL_QUADMODE              (1 << 3)  /* Bit 3: Quadrature Decoder Mode */
+#define FTM_QDCTRL_PHBPOL                (1 << 4)  /* Bit 4: Phase B Input Polarity */
+#define FTM_QDCTRL_PHAPOL                (1 << 5)  /* Bit 5: Phase A Input Polarity */
+#define FTM_QDCTRL_PHBFLTREN             (1 << 6)  /* Bit 6: Phase B Input Filter Enable */
+#define FTM_QDCTRL_PHAFLTREN             (1 << 7)  /* Bit 7: Phase A Input Filter Enable */
+
+                                                   /* Bits 8-31: Reserved */
+
+/* Configuration register */
+
+#define FTM_CONF_LDFQ_SHIFT              (0)       /* Bits 0-4: Frequency of the Reload Opportunities */
+#define FTM_CONF_LDFQ_MASK               (0x1f << FTM_CONF_LDFQ_SHIFT)
+
+                                                   /* Bit 5: Reserved */
+
+#define FTM_CONF_BDMMODE_SHIFT           (6)       /* Bits 6-7: Debug Mode */
+#define FTM_CONF_BDMMODE_MASK            (0x03 << FTM_CONF_BDMMODE_SHIFT)
+
+                                                   /* Bit 8: Reserved */
+
+#define FTM_CONF_GTBEEN                  (1 << 9)  /* Bit 9:  Global Time Base Enable */
+#define FTM_CONF_GTBEOUT                 (1 << 10) /* Bit 10: Global Time Base Output */
+#define FTM_CONF_ITRIGR                  (1 << 11) /* Bit 11: Initialization trigger on Reload Point */
+
+                                                   /* Bits 12-31: Reserved */
+
+/* FTM Fault Input Polarity register */
+
+#define FTM_FLTPOL_FLT0POL               (1 << 0)  /* Bit 0: Fault Input 0 Polarity */
+#define FTM_FLTPOL_FLT1POL               (1 << 1)  /* Bit 1: Fault Input 1 Polarity */
+#define FTM_FLTPOL_FLT2POL               (1 << 2)  /* Bit 2: Fault Input 2 Polarity */
+#define FTM_FLTPOL_FLT3POL               (1 << 3)  /* Bit 3: Fault Input 3 Polarity */
+
+                                                   /* Bits 4-31: Reserved */
+
+/* Synchronization Configuration register */
+
+#define FTM_SYNCONF_HWTRIGMODE           (1 << 0)  /* Bit 0: Hardware Trigger Mode */
+
+                                                   /* Bit 1: Reserved */
+
+#define FTM_SYNCONF_CNTINC               (1 << 2)  /* Bit 2: CNTIN Register Synchronization */
+
+                                                   /* Bit 3: Reserved */
+
+#define FTM_SYNCONF_INVC                 (1 << 4)  /* Bit 4: INVCTRL Register Synchronization */
+#define FTM_SYNCONF_SWOC                 (1 << 5)  /* Bit 5: SWOCTRL Register Synchronization */
+
+                                                   /* Bit 6:  Reserved */
+
+#define FTM_SYNCONF_SYNCMODE             (1 << 7)  /* Bit 7: Synchronization Mode */
+#define FTM_SYNCONF_SWRSTCNT             (1 << 8)  /* Bit 8: FTM counter synchronization is activated by the software trigger */
+#define FTM_SYNCONF_SWWRBUF              (1 << 9)  /* Bit 9: MOD, HCR, CNTIN, and CV registers synchronization is activated by the software trigger */
+#define FTM_SYNCONF_SWOM                 (1 << 10) /* Bit 10: Output mask synchronization is activated by the software trigger */
+#define FTM_SYNCONF_SWINVC               (1 << 11) /* Bit 11: Inverting control synchronization is activated by the software trigger */
+#define FTM_SYNCONF_SWSOC                (1 << 12) /* Bit 12: Software output control synchronization is activated by the software trigger */
+
+                                                   /* Bits 13-15: Reserved */
+
+#define FTM_SYNCONF_HWRSTCNT             (1 << 16) /* Bit 16: FTM counter synchronization is activated by a hardware trigger */
+#define FTM_SYNCONF_HWWRBUF              (1 << 17) /* Bit 17: MOD, HCR, CNTIN, and CV registers synchronization is activated by a hardware trigger */
+#define FTM_SYNCONF_HWOM                 (1 << 18) /* Bit 18: Output mask synchronization is activated by a hardware trigger */
+#define FTM_SYNCONF_HWINVC               (1 << 19) /* Bit 19: Inverting control synchronization is activated by a hardware trigger */
+#define FTM_SYNCONF_HWSOC                (1 << 20) /* Bit 20: Software output control synchronization is activated by a hardware trigger */
+
+                                                   /* Bits 21-31: Reserved */
+
+/* FTM Inverting Control register */
+
+#define FTM_INVCTRL_INV0EN               (1 << 0)  /* Bit 0: Pair Channels 0 Inverting Enable */
+#define FTM_INVCTRL_INV1EN               (1 << 1)  /* Bit 1: Pair Channels 1 Inverting Enable */
+#define FTM_INVCTRL_INV2EN               (1 << 2)  /* Bit 2: Pair Channels 2 Inverting Enable */
+#define FTM_INVCTRL_INV3EN               (1 << 3)  /* Bit 3: Pair Channels 3 Inverting Enable */
+
+                                                   /* Bits 4-31: Reserved */
+
+/* FTM Software Output Control register */
+
+#define FTM_SWOCTRL_CH0OC                (1 << 0)  /* Bit 0: Channel 0 Software Output Control Enable */
+#define FTM_SWOCTRL_CH1OC                (1 << 1)  /* Bit 1: Channel 1 Software Output Control Enable */
+#define FTM_SWOCTRL_CH2OC                (1 << 2)  /* Bit 2: Channel 2 Software Output Control Enable */
+#define FTM_SWOCTRL_CH3OC                (1 << 3)  /* Bit 3: Channel 3 Software Output Control Enable */
+#define FTM_SWOCTRL_CH4OC                (1 << 4)  /* Bit 4: Channel 4 Software Output Control Enable */
+#define FTM_SWOCTRL_CH5OC                (1 << 5)  /* Bit 5: Channel 5 Software Output Control Enable */
+#define FTM_SWOCTRL_CH6OC                (1 << 6)  /* Bit 6: Channel 6 Software Output Control Enable */
+#define FTM_SWOCTRL_CH7OC                (1 << 7)  /* Bit 7: Channel 7 Software Output Control Enable */
+#define FTM_SWOCTRL_CH0OCV               (1 << 8)  /* Bit 8: Channel 0 Software Output Control Value */
+#define FTM_SWOCTRL_CH1OCV               (1 << 9)  /* Bit 9: Channel 1 Software Output Control Value */
+#define FTM_SWOCTRL_CH2OCV               (1 << 10) /* Bit 10: Channel 2 Software Output Control Value */
+#define FTM_SWOCTRL_CH3OCV               (1 << 11) /* Bit 11: Channel 3 Software Output Control Value */
+#define FTM_SWOCTRL_CH4OCV               (1 << 12) /* Bit 12: Channel 4 Software Output Control Value */
+#define FTM_SWOCTRL_CH5OCV               (1 << 13) /* Bit 13: Channel 5 Software Output Control Value */
+#define FTM_SWOCTRL_CH6OCV               (1 << 14) /* Bit 14: Channel 6 Software Output Control Value */
+#define FTM_SWOCTRL_CH7OCV               (1 << 15) /* Bit 15: Channel 7 Software Output Control Value */
+
+                                                   /* Bits 16-31: Reserved */
+
+/* FTM PWM Load register */
+
+#define FTM_PWMLOAD_CH0SEL               (1 << 0)  /* Bit 0: Channel 0 Select */
+#define FTM_PWMLOAD_CH1SEL               (1 << 1)  /* Bit 1: Channel 1 Select */
+#define FTM_PWMLOAD_CH2SEL               (1 << 2)  /* Bit 2: Channel 2 Select */
+#define FTM_PWMLOAD_CH3SEL               (1 << 3)  /* Bit 3: Channel 3 Select */
+#define FTM_PWMLOAD_CH4SEL               (1 << 4)  /* Bit 4: Channel 4 Select */
+#define FTM_PWMLOAD_CH5SEL               (1 << 5)  /* Bit 5: Channel 5 Select */
+#define FTM_PWMLOAD_CH6SEL               (1 << 6)  /* Bit 6: Channel 6 Select */
+#define FTM_PWMLOAD_CH7SEL               (1 << 7)  /* Bit 7: Channel 7 Select */
+#define FTM_PWMLOAD_HCSEL                (1 << 8)  /* Bit 8: Half Cycle Select */
+#define FTM_PWMLOAD_LDOK                 (1 << 9)  /* Bit 9: Load Enable */
+#define FTM_PWMLOAD_GLEN                 (1 << 10) /* Bit 10: Global Load Enable */
+#define FTM_PWMLOAD_GLDOK                (1 << 11) /* Bit 11: Global Load OK */
+
+                                                   /* Bits 12-31: Reserved */
+
+/* Half Cycle Register */
+
+#define FTM_HCR_HCVAL_SHIFT              (0)       /* Bits 0-15: Half Cycle Value */
+#define FTM_HCR_HCVAL_MASK               (0xff << FTM_HCR_HCVAL_SHIFT)
+
+                                                   /* Bits 16-31: Reserved */
+
+/* Pair 0 Deadtime Configuration register */
+
+#define FTM_PAIR0DEADTIME_DTVAL_SHIFT    (0)       /* Bits 0-5: Deadtime Value */
+#define FTM_PAIR0DEADTIME_DTVAL_MASK     (0x1f << FTM_PAIR0DEADTIME_DTVAL_SHIFT)
+#define FTM_PAIR0DEADTIME_DTPS_SHIFT     (6)       /* Bits 6-7: Deadtime Prescaler Value */
+#define FTM_PAIR0DEADTIME_DTPS_MASK      (0x03 << FTM_PAIR0DEADTIME_DTPS_SHIFT)
+#  define FTM_PAIR0DEADTIME_DTPS_DIV1    (1 << FTM_PAIR0DEADTIME_DTPS_SHIFT) /* Divide the FTM input clock by 1 */
+#  define FTM_PAIR0DEADTIME_DTPS_DIV4    (2 << FTM_PAIR0DEADTIME_DTPS_SHIFT) /* Divide the FTM input clock by 4 */
+#  define FTM_PAIR0DEADTIME_DTPS_DIV16   (3 << FTM_PAIR0DEADTIME_DTPS_SHIFT) /* Divide the FTM input clock by 16 */
+
+                                                   /* Bits 8-15: Reserved */
+
+#define FTM_PAIR0DEADTIME_DTVALEX_SHIFT  (16)      /* Bits 16-19: Extended Deadtime Value */
+#define FTM_PAIR0DEADTIME_DTVALEX_MASK   (0x0f << FTM_PAIR0DEADTIME_DTVALEX_SHIFT)
+
+                                                   /* Bits 20-31: Reserved */
+
+/* Pair 1 Deadtime Configuration register */
+
+#define FTM_PAIR1DEADTIME_DTVAL_SHIFT    (0)       /* Bits 0-5: Deadtime Value */
+#define FTM_PAIR1DEADTIME_DTVAL_MASK     (0x1f << FTM_PAIR1DEADTIME_DTVAL_SHIFT)
+#define FTM_PAIR1DEADTIME_DTPS_SHIFT     (6)       /* Bits 6-7: Deadtime Prescaler Value */
+#define FTM_PAIR1DEADTIME_DTPS_MASK      (0x03 << FTM_PAIR1DEADTIME_DTPS_SHIFT)
+#  define FTM_PAIR1DEADTIME_DTPS_DIV1    (1 << FTM_PAIR1DEADTIME_DTPS_SHIFT) /* Divide the FTM input clock by 1 */
+#  define FTM_PAIR1DEADTIME_DTPS_DIV4    (2 << FTM_PAIR1DEADTIME_DTPS_SHIFT) /* Divide the FTM input clock by 4 */
+#  define FTM_PAIR1DEADTIME_DTPS_DIV16   (3 << FTM_PAIR1DEADTIME_DTPS_SHIFT) /* Divide the FTM input clock by 16 */
+
+                                                   /* Bits 8-15: Reserved */
+
+#define FTM_PAIR1DEADTIME_DTVALEX_SHIFT  (16)      /* Bits 16-19: Extended Deadtime Value */
+#define FTM_PAIR1DEADTIME_DTVALEX_MASK   (0x0f << FTM_PAIR1DEADTIME_DTVALEX_SHIFT)
+
+                                                   /* Bits 20-31: Reserved */
+
+/* Pair 2 Deadtime Configuration register */
+
+#define FTM_PAIR2DEADTIME_DTVAL_SHIFT    (0)       /* Bits 0-5: Deadtime Value */
+#define FTM_PAIR2DEADTIME_DTVAL_MASK     (0x1f << FTM_PAIR2DEADTIME_DTVAL_SHIFT)
+#define FTM_PAIR2DEADTIME_DTPS_SHIFT     (6)       /* Bits 6-7: Deadtime Prescaler Value */
+#define FTM_PAIR2DEADTIME_DTPS_MASK      (0x03 << FTM_PAIR2DEADTIME_DTPS_SHIFT)
+#  define FTM_PAIR2DEADTIME_DTPS_DIV1    (1 << FTM_PAIR2DEADTIME_DTPS_SHIFT) /* Divide the FTM input clock by 1 */
+#  define FTM_PAIR2DEADTIME_DTPS_DIV4    (2 << FTM_PAIR2DEADTIME_DTPS_SHIFT) /* Divide the FTM input clock by 4 */
+#  define FTM_PAIR2DEADTIME_DTPS_DIV16   (3 << FTM_PAIR2DEADTIME_DTPS_SHIFT) /* Divide the FTM input clock by 16 */
+
+                                                   /* Bits 8-15: Reserved */
+
+#define FTM_PAIR2DEADTIME_DTVALEX_SHIFT  (16)      /* Bits 16-19: Extended Deadtime Value */
+#define FTM_PAIR2DEADTIME_DTVALEX_MASK   (0x0f << FTM_PAIR2DEADTIME_DTVALEX_SHIFT)
+
+                                                   /* Bits 20-31: Reserved */
+
+/* Pair 3 Deadtime Configuration register */
+
+#define FTM_PAIR3DEADTIME_DTVAL_SHIFT    (0)       /* Bits 0-5: Deadtime Value */
+#define FTM_PAIR3DEADTIME_DTVAL_MASK     (0x1f << FTM_PAIR3DEADTIME_DTVAL_SHIFT)
+#define FTM_PAIR3DEADTIME_DTPS_SHIFT     (6)       /* Bits 6-7: Deadtime Prescaler Value */
+#define FTM_PAIR3DEADTIME_DTPS_MASK      (0x03 << FTM_PAIR3DEADTIME_DTPS_SHIFT)
+#  define FTM_PAIR3DEADTIME_DTPS_DIV1    (1 << FTM_PAIR3DEADTIME_DTPS_SHIFT) /* Divide the FTM input clock by 1 */
+#  define FTM_PAIR3DEADTIME_DTPS_DIV4    (2 << FTM_PAIR3DEADTIME_DTPS_SHIFT) /* Divide the FTM input clock by 4 */
+#  define FTM_PAIR3DEADTIME_DTPS_DIV16   (3 << FTM_PAIR3DEADTIME_DTPS_SHIFT) /* Divide the FTM input clock by 16 */
+
+                                                   /* Bits 8-15: Reserved */
+
+#define FTM_PAIR3DEADTIME_DTVALEX_SHIFT  (16)      /* Bits 16-19: Extended Deadtime Value */
+#define FTM_PAIR3DEADTIME_DTVALEX_MASK   (0x0f << FTM_PAIR3DEADTIME_DTVALEX_SHIFT)
+
+                                                   /* Bits 20-31: Reserved */
+
+/* Mirror of Modulo Value register */
+
+                                                   /* Bits 0-10: Reserved */
+
+#define FTM_MOD_MIRROR_FRACMOD_SHIFT     (11)      /* Bits 11-15: Modulo Fractional Value */
+#define FTM_MOD_MIRROR_FRACMOD_MASK      (0x1f << FTM_MOD_MIRROR_FRACMOD_SHIFT)
+#define FTM_MOD_MIRROR_MOD_SHIFT         (16)      /* Bits 16-31: Mirror of the Modulo Integer Value */
+#define FTM_MOD_MIRROR_MOD_MASK          (0xff << FTM_MOD_MIRROR_MOD_SHIFT)
+
+/* Mirror of Channel 0 Match Value register */
+
+                                                   /* Bits 0-10: Reserved */
+
+#define FTM_C0V_MIRROR_FRACVAL_SHIFT     (11)      /* Bits 11-15: Channel 0 Match Fractional Value */
+#define FTM_C0V_MIRROR_FRACVAL_MASK      (0x1f << FTM_C0V_MIRROR_FRACVAL)
+#define FTM_C0V_MIRROR_VAL_SHIFT         (16)      /* Bits 16-31: Mirror of the Channel 0 Match Integer Value */
+#define FTM_C0V_MIRROR_VAL_MASK          (0xff << FTM_C0V_MIRROR_VAL_SHIFT)
+
+/* Mirror of Channel 1 Match Value register */
+
+                                                   /* Bits 0-10: Reserved */
+
+#define FTM_C1V_MIRROR_FRACVAL_SHIFT     (11)      /* Bits 11-15: Channel 1 Match Fractional Value */
+#define FTM_C1V_MIRROR_FRACVAL_MASK      (0x1f << FTM_C1V_MIRROR_FRACVAL)
+#define FTM_C1V_MIRROR_VAL_SHIFT         (16)      /* Bits 16-31: Mirror of the Channel 1 Match Integer Value */
+#define FTM_C1V_MIRROR_VAL_MASK          (0xff << FTM_C1V_MIRROR_VAL_SHIFT)
+
+/* Mirror of Channel 2 Match Value register */
+
+                                                   /* Bits 0-10: Reserved */
+
+#define FTM_C2V_MIRROR_FRACVAL_SHIFT     (11)      /* Bits 11-15: Channel 2 Match Fractional Value */
+#define FTM_C2V_MIRROR_FRACVAL_MASK      (0x1f << FTM_C2V_MIRROR_FRACVAL)
+#define FTM_C2V_MIRROR_VAL_SHIFT         (16)      /* Bits 16-31: Mirror of the Channel 2 Match Integer Value */
+#define FTM_C2V_MIRROR_VAL_MASK          (0xff << FTM_C2V_MIRROR_VAL_SHIFT)
+
+/* Mirror of Channel 3 Match Value register */
+
+                                                   /* Bits 0-10: Reserved */
+
+#define FTM_C3V_MIRROR_FRACVAL_SHIFT     (11)      /* Bits 11-15: Channel 3 Match Fractional Value */
+#define FTM_C3V_MIRROR_FRACVAL_MASK      (0x1f << FTM_C3V_MIRROR_FRACVAL)
+#define FTM_C3V_MIRROR_VAL_SHIFT         (16)      /* Bits 16-31: Mirror of the Channel 3 Match Integer Value */
+#define FTM_C3V_MIRROR_VAL_MASK          (0xff << FTM_C3V_MIRROR_VAL_SHIFT)
+
+/* Mirror of Channel 4 Match Value register */
+
+                                                   /* Bits 0-10: Reserved */
+
+#define FTM_C4V_MIRROR_FRACVAL_SHIFT     (11)      /* Bits 11-15: Channel 4 Match Fractional Value */
+#define FTM_C4V_MIRROR_FRACVAL_MASK      (0x1f << FTM_C4V_MIRROR_FRACVAL)
+#define FTM_C4V_MIRROR_VAL_SHIFT         (16)      /* Bits 16-31: Mirror of the Channel 4 Match Integer Value */
+#define FTM_C4V_MIRROR_VAL_MASK          (0xff << FTM_C4V_MIRROR_VAL_SHIFT)
+
+/* Mirror of Channel 5 Match Value register */
+
+                                                   /* Bits 0-10: Reserved */
+
+#define FTM_C5V_MIRROR_FRACVAL_SHIFT     (11)      /* Bits 11-15: Channel 5 Match Fractional Value */
+#define FTM_C5V_MIRROR_FRACVAL_MASK      (0x1f << FTM_C5V_MIRROR_FRACVAL)
+#define FTM_C5V_MIRROR_VAL_SHIFT         (16)      /* Bits 16-31: Mirror of the Channel 5 Match Integer Value */
+#define FTM_C5V_MIRROR_VAL_MASK          (0xff << FTM_C5V_MIRROR_VAL_SHIFT)
+
+/* Mirror of Channel 6 Match Value register */
+
+                                                   /* Bits 0-10: Reserved */
+
+#define FTM_C6V_MIRROR_FRACVAL_SHIFT     (11)      /* Bits 11-15: Channel 6 Match Fractional Value */
+#define FTM_C6V_MIRROR_FRACVAL_MASK      (0x1f << FTM_C6V_MIRROR_FRACVAL)
+#define FTM_C6V_MIRROR_VAL_SHIFT         (16)      /* Bits 16-31: Mirror of the Channel 6 Match Integer Value */
+#define FTM_C6V_MIRROR_VAL_MASK          (0xff << FTM_C6V_MIRROR_VAL_SHIFT)
+
+/* Mirror of Channel 7 Match Value register */
+
+                                                   /* Bits 0-10: Reserved */
+
+#define FTM_C7V_MIRROR_FRACVAL_SHIFT     (11)      /* Bits 11-15: Channel 7 Match Fractional Value */
+#define FTM_C7V_MIRROR_FRACVAL_MASK      (0x1f << FTM_C7V_MIRROR_FRACVAL)
+#define FTM_C7V_MIRROR_VAL_SHIFT         (16)      /* Bits 16-31: Mirror of the Channel 7 Match Integer Value */
+#define FTM_C7V_MIRROR_VAL_MASK          (0xff << FTM_C7V_MIRROR_VAL_SHIFT)
 
 #endif /* __ARCH_ARM_SRC_S32K1XX_HARDWARE_S32K1XX_FTM_H */
diff --git a/arch/arm/src/s32k1xx/hardware/s32k1xx_memorymap.h b/arch/arm/src/s32k1xx/hardware/s32k1xx_memorymap.h
index 1e1b9191d7..b2fd683e30 100644
--- a/arch/arm/src/s32k1xx/hardware/s32k1xx_memorymap.h
+++ b/arch/arm/src/s32k1xx/hardware/s32k1xx_memorymap.h
@@ -60,7 +60,7 @@
 #define S32K1XX_DMAMUX_BASE      0x40021000  /* DMA Channel Multiplexer  */
 #define S32K1XX_FLEXCAN0_BASE    0x40024000  /* FlexCAN 0 */
 #define S32K1XX_FLEXCAN1_BASE    0x40025000  /* FlexCAN 1 */
-#define S32K1XX_FLEXTIMER_BASE   0x40026000  /* FlexTimer */
+#define S32K1XX_FTM3_BASE        0x40026000  /* FlexTimer 3 */
 #define S32K1XX_ADC1_BASE        0x40027000  /* Analog-to-digital converter 1 */
 #define S32K1XX_FLEXCAN2_BASE    0x4002b000  /* FlexCAN 2 */
 #define S32K1XX_LPSPI0_BASE      0x4002c000  /* Low Power SPI 0 */
diff --git a/arch/arm/src/s32k1xx/hardware/s32k1xx_pcc.h b/arch/arm/src/s32k1xx/hardware/s32k1xx_pcc.h
index 173267d72d..e535080e1e 100644
--- a/arch/arm/src/s32k1xx/hardware/s32k1xx_pcc.h
+++ b/arch/arm/src/s32k1xx/hardware/s32k1xx_pcc.h
@@ -55,7 +55,7 @@
 #define S32K1XX_PCC_FLEXCAN1_OFFSET  0x0094  /* PCC FlexCAN1 Register */
 #define S32K1XX_PCC_FTM3_OFFSET      0x0098  /* PCC FTM3 Register */
 #define S32K1XX_PCC_ADC1_OFFSET      0x009c  /* PCC ADC1 Register */
-#define S32K1XX_PCC_FLEXCAN_OFFSET   0x00ac  /* PCC FlexCAN2 Register */
+#define S32K1XX_PCC_FLEXCAN2_OFFSET  0x00ac  /* PCC FlexCAN2 Register */
 #define S32K1XX_PCC_LPSPI0_OFFSET    0x00b0  /* PCC LPSPI0 Register */
 #define S32K1XX_PCC_LPSPI1_OFFSET    0x00b4  /* PCC LPSPI1 Register */
 #define S32K1XX_PCC_LPSPI2_OFFSET    0x00b8  /* PCC LPSPI2 Register */
@@ -101,7 +101,7 @@
 #define S32K1XX_PCC_FLEXCAN1         (S32K1XX_PCC_BASE + S32K1XX_PCC_FLEXCAN1_OFFSET)
 #define S32K1XX_PCC_FTM3             (S32K1XX_PCC_BASE + S32K1XX_PCC_FTM3_OFFSET)
 #define S32K1XX_PCC_ADC1             (S32K1XX_PCC_BASE + S32K1XX_PCC_ADC1_OFFSET)
-#define S32K1XX_PCC_FLEXCAN          (S32K1XX_PCC_BASE + S32K1XX_PCC_FLEXCAN_OFFSET)
+#define S32K1XX_PCC_FLEXCAN2         (S32K1XX_PCC_BASE + S32K1XX_PCC_FLEXCAN2_OFFSET)
 #define S32K1XX_PCC_LPSPI0           (S32K1XX_PCC_BASE + S32K1XX_PCC_LPSPI0_OFFSET)
 #define S32K1XX_PCC_LPSPI1           (S32K1XX_PCC_BASE + S32K1XX_PCC_LPSPI1_OFFSET)
 #define S32K1XX_PCC_LPSPI2           (S32K1XX_PCC_BASE + S32K1XX_PCC_LPSPI2_OFFSET)
diff --git a/arch/arm/src/s32k1xx/s32k1xx_eeeprom.c b/arch/arm/src/s32k1xx/s32k1xx_eeeprom.c
index 6eeb93d7b0..c6d45b65be 100644
--- a/arch/arm/src/s32k1xx/s32k1xx_eeeprom.c
+++ b/arch/arm/src/s32k1xx/s32k1xx_eeeprom.c
@@ -46,7 +46,7 @@
 #include <assert.h>
 #include <errno.h>
 
-#include "up_arch.h"
+#include "arm_arch.h"
 
 #include "hardware/s32k1xx_ftfc.h"
 #include "hardware/s32k1xx_sim.h"
@@ -54,7 +54,7 @@
 #include "s32k1xx_config.h"
 #include "s32k1xx_eeeprom.h"
 
-#include "up_internal.h"
+#include "arm_internal.h"
 
 #include <arch/board/board.h> /* Include last:  has dependencies */
 
diff --git a/arch/arm/src/s32k1xx/s32k1xx_eeeprom.h b/arch/arm/src/s32k1xx/s32k1xx_eeeprom.h
index 5f2e0e6a01..5907950cfd 100644
--- a/arch/arm/src/s32k1xx/s32k1xx_eeeprom.h
+++ b/arch/arm/src/s32k1xx/s32k1xx_eeeprom.h
@@ -47,7 +47,7 @@
 #include <stdint.h>
 #include <stdbool.h>
 
-#include "up_internal.h"
+#include "arm_internal.h"
 #include "s32k1xx_config.h"
 
 /******************************************************************************
diff --git a/arch/arm/src/s32k1xx/s32k1xx_enet.h b/arch/arm/src/s32k1xx/s32k1xx_enet.h
index ef89913af2..fe7cbeae54 100644
--- a/arch/arm/src/s32k1xx/s32k1xx_enet.h
+++ b/arch/arm/src/s32k1xx/s32k1xx_enet.h
@@ -55,7 +55,7 @@
 #define EMAC_INTF 0
 
 /************************************************************************************
- * Public Functions
+ * Public Function Prototypes
  ************************************************************************************/
 
 #ifndef __ASSEMBLY__
@@ -69,6 +69,8 @@ extern "C"
 #define EXTERN extern
 #endif
 
+#if !defined(CONFIG_NETDEV_LATEINIT)
+
 /************************************************************************************
  * Function: arm_netinitialize
  *
@@ -91,6 +93,29 @@ extern "C"
 
 void arm_netinitialize(void);
 
+#else
+
+/************************************************************************************
+ * Function: s32k1xx_netinitialize
+ *
+ * Description:
+ *   Initialize the Ethernet controller and driver
+ *
+ * Input Parameters:
+ *   intf - In the case where there are multiple EMACs, this value
+ *          identifies which EMAC is to be initialized.
+ *
+ * Returned Value:
+ *   OK on success; Negated errno on failure.
+ *
+ * Assumptions:
+ *
+ ************************************************************************************/
+
+int s32k1xx_netinitialize(int intf);
+
+#endif
+
 /************************************************************************************
  * Function: s32k1xx_phy_boardinitialize
  *
diff --git a/arch/arm/src/s32k1xx/s32k1xx_flexcan.c b/arch/arm/src/s32k1xx/s32k1xx_flexcan.c
index a49480b3b0..abc4c22d50 100644
--- a/arch/arm/src/s32k1xx/s32k1xx_flexcan.c
+++ b/arch/arm/src/s32k1xx/s32k1xx_flexcan.c
@@ -1698,14 +1698,14 @@ static void s32k1xx_reset(struct s32k1xx_driver_s *priv)
  ****************************************************************************/
 
 /****************************************************************************
- * Function: s32k1xx_netinitialize
+ * Function: s32k1xx_caninitialize
  *
  * Description:
- *   Initialize the Ethernet controller and driver
+ *   Initialize the CAN controller and driver
  *
  * Input Parameters:
- *   intf - In the case where there are multiple EMACs, this value
- *          identifies which EMAC is to be initialized.
+ *   intf - In the case where there are multiple CAN devices, this value
+ *          identifies which CAN device is to be initialized.
  *
  * Returned Value:
  *   OK on success; Negated errno on failure.
@@ -1714,7 +1714,7 @@ static void s32k1xx_reset(struct s32k1xx_driver_s *priv)
  *
  ****************************************************************************/
 
-int s32k1xx_netinitialize(int intf)
+int s32k1xx_caninitialize(int intf)
 {
   struct s32k1xx_driver_s *priv;
   int ret;
@@ -1894,10 +1894,10 @@ int s32k1xx_netinitialize(int intf)
  * Name: arm_netinitialize
  *
  * Description:
- *   Initialize the first network interface.  If there are more than one
- *   interface in the chip, then board-specific logic will have to provide
- *   this function to determine which, if any, Ethernet controllers should
- *   be initialized.
+ *   Initialize the enabled CAN device interfaces.  If there are more
+ *   different network devices in the chip, then board-specific logic will
+ *   have to provide this function to determine which, if any, network
+ *   devices should be initialized.
  *
  ****************************************************************************/
 
@@ -1905,15 +1905,15 @@ int s32k1xx_netinitialize(int intf)
 void arm_netinitialize(void)
 {
 #ifdef CONFIG_S32K1XX_FLEXCAN0
-  s32k1xx_netinitialize(0);
+  s32k1xx_caninitialize(0);
 #endif
 
 #ifdef CONFIG_S32K1XX_FLEXCAN1
-  s32k1xx_netinitialize(1);
+  s32k1xx_caninitialize(1);
 #endif
 
 #ifdef CONFIG_S32K1XX_FLEXCAN2
-  s32k1xx_netinitialize(2);
+  s32k1xx_caninitialize(2);
 #endif
 }
 #endif
diff --git a/arch/arm/src/s32k1xx/s32k1xx_flexcan.h b/arch/arm/src/s32k1xx/s32k1xx_flexcan.h
index 3b193321ac..cd763fc8bc 100644
--- a/arch/arm/src/s32k1xx/s32k1xx_flexcan.h
+++ b/arch/arm/src/s32k1xx/s32k1xx_flexcan.h
@@ -65,14 +65,16 @@ extern "C"
 #define EXTERN extern
 #endif
 
+#if !defined(CONFIG_NETDEV_LATEINIT)
+
 /************************************************************************************
  * Function: arm_netinitialize
  *
  * Description:
- *   Initialize the first network interface.  If there are more than one
- *   interface in the chip, then board-specific logic will have to provide
- *   this function to determine which, if any, Ethernet controllers should
- *   be initialized.  Also prototyped in up_internal.h.
+ *   Initialize the enabled CAN device interfaces.  If there are more
+ *   different network devices in the chip, then board-specific logic will
+ *   have to provide this function to determine which, if any, network
+ *   devices should be initialized.
  *
  * Input Parameters:
  *   None
@@ -87,24 +89,29 @@ extern "C"
 
 void arm_netinitialize(void);
 
+#else
+
 /************************************************************************************
- * Function: s32k1xx_phy_boardinitialize
+ * Function: s32k1xx_caninitialize
  *
  * Description:
- *   Some boards require specialized initialization of the PHY before it can be
- *   used.  This may include such things as configuring GPIOs, resetting the PHY,
- *   etc.  If CONFIG_S32K1XX_FLEXCAN_PHYINIT is defined in the configuration then the
- *   board specific logic must provide s32k1xx_phyinitialize();  The i.MX RT Ethernet
- *   driver will call this function one time before it first uses the PHY.
+ *   Initialize the CAN controller and driver
  *
  * Input Parameters:
- *   intf - Always zero for now.
+ *   intf - In the case where there are multiple CAN devices, this value
+ *          identifies which CAN device is to be initialized.
  *
  * Returned Value:
  *   OK on success; Negated errno on failure.
  *
+ * Assumptions:
+ *
  ************************************************************************************/
 
+int s32k1xx_caninitialize(int intf);
+
+#endif
+
 #undef EXTERN
 #if defined(__cplusplus)
 }
diff --git a/arch/arm/src/s32k1xx/s32k1xx_lpspi.c b/arch/arm/src/s32k1xx/s32k1xx_lpspi.c
index b0cb406a93..ead9320222 100644
--- a/arch/arm/src/s32k1xx/s32k1xx_lpspi.c
+++ b/arch/arm/src/s32k1xx/s32k1xx_lpspi.c
@@ -151,12 +151,12 @@ static inline void s32k1xx_lpspi_putreg32(FAR struct s32k1xx_lpspidev_s *priv,
               uint8_t offset, uint32_t value);
 static inline uint32_t s32k1xx_lpspi_readword(FAR struct s32k1xx_lpspidev_s *priv);
 static inline void s32k1xx_lpspi_writeword(FAR struct s32k1xx_lpspidev_s *priv,
-              uint16_t byte);
-static inline bool s32k1xx_lpspi_9to16bitmode(FAR struct s32k1xx_lpspidev_s *priv);
+              uint32_t byte);
+static inline uint16_t s32k1xx_lpspi_9to16bitmode(FAR struct s32k1xx_lpspidev_s *priv);
 static uint32_t s32k1xx_lpspi_pckfreq(uintptr_t base);
-static inline void s32k1xx_lpspi_set_delays(FAR struct s32k1xx_lpspidev_s
+static inline void s32k1xx_lpspi_master_set_delays(FAR struct s32k1xx_lpspidev_s
               *priv, uint32_t delay_ns, enum s32k1xx_delay_e type);
-static inline void s32k1xx_lpspi_set_delay_scaler(FAR struct
+static inline void s32k1xx_lpspi_master_set_delay_scaler(FAR struct
               s32k1xx_lpspidev_s *priv, uint32_t scaler, enum s32k1xx_delay_e type);
 
 /* SPI methods */
@@ -457,7 +457,7 @@ static inline uint32_t s32k1xx_lpspi_readword(FAR struct s32k1xx_lpspidev_s *pri
  ************************************************************************************/
 
 static inline void s32k1xx_lpspi_writeword(FAR struct s32k1xx_lpspidev_s *priv,
-                                           uint16_t word)
+                                           uint32_t word)
 {
   /* Wait until the transmit buffer is empty */
 
@@ -470,6 +470,36 @@ static inline void s32k1xx_lpspi_writeword(FAR struct s32k1xx_lpspidev_s *priv,
   s32k1xx_lpspi_putreg32(priv, S32K1XX_LPSPI_TDR_OFFSET, word);
 }
 
+/************************************************************************************
+ * Name: s32k1xx_lpspi_writeDword
+ *
+ * Description:
+ *   Write two words to SPI
+ *
+ * Input Parameters:
+ *   priv - Device-specific state data
+ *   word0, word1 - words to send
+ *
+ * Returned Value:
+ *   None
+ *
+ ************************************************************************************/
+
+static inline void s32k1xx_lpspi_writeDword(FAR struct s32k1xx_lpspidev_s *priv,
+                                           uint32_t word0, uint32_t word1)
+{
+  /* Wait until the transmit buffer is empty */
+
+  while ((s32k1xx_lpspi_getreg32(priv, S32K1XX_LPSPI_SR_OFFSET) & LPSPI_SR_TDF) == 0)
+    {
+    }
+
+  /* Then send the words, use the FIFO */
+
+  s32k1xx_lpspi_putreg32(priv, S32K1XX_LPSPI_TDR_OFFSET, word0);
+  s32k1xx_lpspi_putreg32(priv, S32K1XX_LPSPI_TDR_OFFSET, word1);
+}
+
 /************************************************************************************
  * Name: s32k1xx_lpspi_readbyte
  *
@@ -531,29 +561,22 @@ static inline void s32k1xx_lpspi_writebyte(FAR struct s32k1xx_lpspidev_s *priv,
  *
  * Description:
  *   Check if the SPI is operating in more then 8 bit mode
+ *   On the S32K the frame size can grow to 4096 bit/frame
  *
  * Input Parameters:
  *   priv     - Device-specific state data
  *
  * Returned Value:
- *   true: >8 bit mode-bit mode, false: <= 8-bit mode
+ *   value: frame size
  *
  ************************************************************************************/
 
-static inline bool s32k1xx_lpspi_9to16bitmode(FAR struct s32k1xx_lpspidev_s *priv)
+static inline uint16_t s32k1xx_lpspi_9to16bitmode(FAR struct s32k1xx_lpspidev_s *priv)
 {
-  bool ret;
-
-  if (((s32k1xx_lpspi_getreg32(priv, S32K1XX_LPSPI_TCR_OFFSET) &
-        LPSPI_TCR_FRAMESZ_MASK) + 1) < 9)
-    {
-      ret = false;
-    }
-  else
-    {
-      ret = true;
-    }
+  uint16_t ret;
 
+  ret = ((s32k1xx_lpspi_getreg32(priv, S32K1XX_LPSPI_TCR_OFFSET) &
+        LPSPI_TCR_FRAMESZ_MASK) + 1);
   return ret;
 }
 
@@ -640,7 +663,7 @@ static uint32_t s32k1xx_lpspi_pckfreq(uintptr_t base)
 }
 
 /************************************************************************************
- * Name: s32k1xx_lpspi_set_delays
+ * Name: s32k1xx_lpspi_master_set_delays
  *
  * Description:
  *   SET LPSPI Delay times
@@ -655,10 +678,9 @@ static uint32_t s32k1xx_lpspi_pckfreq(uintptr_t base)
  *
  ************************************************************************************/
 
-static inline void s32k1xx_lpspi_set_delay_scaler(FAR struct
-                                                  s32k1xx_lpspidev_s *priv,
-                                                  uint32_t scaler,
-                                                  enum s32k1xx_delay_e type)
+static inline void s32k1xx_lpspi_master_set_delay_scaler(FAR struct s32k1xx_lpspidev_s *priv,
+                                                         uint32_t scaler,
+                                                         enum s32k1xx_delay_e type)
 {
   switch (type)
     {
@@ -686,7 +708,7 @@ static inline void s32k1xx_lpspi_set_delay_scaler(FAR struct
 }
 
 /************************************************************************************
- * Name: s32k1xx_lpspi_set_delays
+ * Name: s32k1xx_lpspi_master_set_delays
  *
  * Description:
  *   SET LPSPI Delay times
@@ -701,7 +723,7 @@ static inline void s32k1xx_lpspi_set_delay_scaler(FAR struct
  *
  ************************************************************************************/
 
-static inline void s32k1xx_lpspi_set_delays(FAR struct s32k1xx_lpspidev_s *priv,
+static inline void s32k1xx_lpspi_master_set_delays(FAR struct s32k1xx_lpspidev_s *priv,
                                                    uint32_t delay_ns,
                                                    enum s32k1xx_delay_e type)
 {
@@ -786,7 +808,7 @@ static inline void s32k1xx_lpspi_set_delays(FAR struct s32k1xx_lpspidev_s *priv,
 
   if (initial_delay_ns >= delay_ns)
     {
-      s32k1xx_lpspi_set_delay_scaler(priv, 0, type);
+      s32k1xx_lpspi_master_set_delay_scaler(priv, 0, type);
     }
   else
     {
@@ -823,7 +845,7 @@ static inline void s32k1xx_lpspi_set_delays(FAR struct s32k1xx_lpspidev_s *priv,
             }
         }
 
-      s32k1xx_lpspi_set_delay_scaler(priv, best_scaler, type);
+      s32k1xx_lpspi_master_set_delay_scaler(priv, best_scaler, type);
     }
 }
 
@@ -852,7 +874,8 @@ static int s32k1xx_lpspi_lock(FAR struct spi_dev_s *dev, bool lock)
 {
   FAR struct s32k1xx_lpspidev_s *priv = (FAR struct s32k1xx_lpspidev_s *)dev;
   int ret;
-
+// TODO; Needs to be switched of for debugging
+#if 0
   if (lock)
     {
       ret = nxsem_wait_uninterruptible(&priv->exclsem);
@@ -863,6 +886,9 @@ static int s32k1xx_lpspi_lock(FAR struct spi_dev_s *dev, bool lock)
     }
 
   return ret;
+#else
+  return 1;
+#endif
 }
 
 /************************************************************************************
@@ -960,11 +986,11 @@ static uint32_t s32k1xx_lpspi_setfrequency(FAR struct spi_dev_s *dev,
       priv->frequency = frequency;
       priv->actual = best_frequency;
 
-      s32k1xx_lpspi_set_delays(priv, 1000000000 / best_frequency,
+      s32k1xx_lpspi_master_set_delays(priv, 1000000000 / best_frequency,
                                     LPSPI_PCS_TO_SCK);
-      s32k1xx_lpspi_set_delays(priv, 1000000000 / best_frequency,
+      s32k1xx_lpspi_master_set_delays(priv, 1000000000 / best_frequency,
                                     LPSPI_LAST_SCK_TO_PCS);
-      s32k1xx_lpspi_set_delays(priv, 1000000000 / best_frequency,
+      s32k1xx_lpspi_master_set_delays(priv, 1000000000 / best_frequency,
                                     LPSPI_BETWEEN_TRANSFER);
 
       /* Re-enable LPSPI if it was enabled previously */
@@ -1220,6 +1246,57 @@ static uint32_t s32k1xx_lpspi_send(FAR struct spi_dev_s *dev, uint32_t wd)
   return ret;
 }
 
+/************************************************************************************
+ * Name: s32k1xx_lpspi_send2
+ *
+ * Description:
+ *   Exchange two words on SPI
+ *
+ * Input Parameters:
+ *   dev - Device-specific state data
+ *   wd0, wd1  - The word to send.  the size of the data is determined by the
+ *         number of bits selected for the SPI interface.
+ *
+ * Returned Value:
+ *   response
+ *
+ ************************************************************************************/
+
+static uint32_t s32k1xx_lpspi_send2(FAR struct spi_dev_s *dev, uint32_t wd0, uint32_t wd1, uint32_t *rw1)
+{
+  FAR struct s32k1xx_lpspidev_s *priv = (FAR struct s32k1xx_lpspidev_s *)dev;
+  uint32_t regval;
+  uint32_t ret;
+
+  DEBUGASSERT(priv && priv->spibase);
+
+#if 1
+  /* check if the receive buffer is empty, if not clear it */
+  while ((s32k1xx_lpspi_getreg32(priv, S32K1XX_LPSPI_SR_OFFSET) & LPSPI_SR_RDF)) {
+    s32k1xx_lpspi_getreg32(priv, S32K1XX_LPSPI_RDR_OFFSET);
+  }
+#endif
+
+  s32k1xx_lpspi_writeDword(priv, wd0, wd1);
+
+  while ((s32k1xx_lpspi_getreg32(priv, S32K1XX_LPSPI_SR_OFFSET) & LPSPI_SR_RDF) !=
+         LPSPI_SR_RDF);
+
+  ret  = s32k1xx_lpspi_readword(priv);
+  *rw1 = s32k1xx_lpspi_readword(priv);
+
+  /* Check and clear any error flags (Reading from the SR clears the error
+   * flags).
+   */
+
+  regval = s32k1xx_lpspi_getreg32(priv, S32K1XX_LPSPI_SR_OFFSET);
+
+  spiinfo("Sent: %02x %08x  Return: %04x Status: %02x\n", wd1, wd0, ret, regval);
+
+  UNUSED(regval);
+  return ret;
+}
+
 /************************************************************************************
  * Name: s32k1xx_lpspi_exchange (no DMA).  aka s32k1xx_lpspi_exchange_nodma
  *
@@ -1254,42 +1331,85 @@ static void s32k1xx_lpspi_exchange_nodma(FAR struct spi_dev_s *dev,
 {
   FAR struct s32k1xx_lpspidev_s *priv = (FAR struct s32k1xx_lpspidev_s *)dev;
   DEBUGASSERT(priv && priv->spibase);
+  uint16_t frameSize;
 
   spiinfo("txbuffer=%p rxbuffer=%p nwords=%d\n", txbuffer, rxbuffer, nwords);
 
   /* 8- or 16-bit mode? */
-
-  if (s32k1xx_lpspi_9to16bitmode(priv))
+  frameSize = s32k1xx_lpspi_9to16bitmode(priv);
+  if (frameSize > 8)
     {
-      /* 16-bit mode */
+      /* 16-bit, 32-bit or 40-bit mode */
+      /* take care of big endian mode of hardware !! */
 
-      const uint16_t *src = (const uint16_t *)txbuffer;
-      uint16_t *dest = (uint16_t *) rxbuffer;
-      uint16_t word;
+      const uint8_t *src = (const uint8_t *)txbuffer;
+      uint8_t *dest = (uint8_t *) rxbuffer;
+      uint32_t word, word1, rword1;
+      bool     dwords = false;
 
-      while (nwords-- > 0)
-        {
+      while (nwords-- > 0) {
           /* Get the next word to write.  Is there a source buffer? */
 
-          if (src)
-            {
-              word = *src++;
-            }
-          else
-            {
-              word = 0xffff;
-            }
+          if (src) {
+			// read the required number of bytes
+			switch (frameSize) {
+			  case 16:
+				   word = (src[0] << 8) + src[1];
+				   src += 2;
+				   break;
+			  case 32:
+				   word = (src[0] << 24) + (src[1] << 16) + (src[2] << 8) + src[3];
+				   src += 4;
+				   break;
+			  case 40:
+				   word = (src[0] << 24) + (src[1] << 16) + (src[2] << 8) + src[3];
+				   word1 = src[4];
+				   src += 5;
+				   dwords = true;
+			  default: // expect 40 bit TODO
+					  break;
+			}
+          } else {
+              word = 0xffffffff;
+          }
 
           /* Exchange one word */
-
-          word = (uint16_t) s32k1xx_lpspi_send(dev, (uint32_t) word);
+          if (dwords) {
+              word = s32k1xx_lpspi_send2(dev, word, word1, &rword1);
+          } else {
+            word = s32k1xx_lpspi_send(dev, word);
+          }
 
           /* Is there a buffer to receive the return value? */
 
-          if (dest)
-            {
-              *dest++ = word;
+          if (dest) {
+			switch (frameSize) {
+			  case 16:
+				   dest[0] = (word >> 8) & 0xff;
+				   dest[1] =  word       & 0xff;
+				   dest += 2;
+				   break;
+			  case 32:
+				   dest[0] = (word >> 24) & 0xff;
+				   dest[1] = (word >> 16) & 0xff;
+				   dest[2] = (word >>  8) & 0xff;
+				   dest[3] =  word        & 0xff;
+				   dest += 4;
+				   break;
+			  case 40:
+				   dest[0] = (word >> 24) & 0xff;
+				   dest[1] = (word >> 16) & 0xff;
+				   dest[2] = (word >>  8) & 0xff;
+				   dest[3] =  word        & 0xff;
+				   dest[4] =  rword1      & 0xff;
+				   dest += 5;
+				   break;
+
+			  default: // expect 40 bit TODO
+
+					  break;
             }
+	      }
         }
     }
   else
diff --git a/arch/arm/src/s32k1xx/s32k1xx_pin.c b/arch/arm/src/s32k1xx/s32k1xx_pin.c
index 2e66bf137e..b098a104d9 100644
--- a/arch/arm/src/s32k1xx/s32k1xx_pin.c
+++ b/arch/arm/src/s32k1xx/s32k1xx_pin.c
@@ -161,6 +161,7 @@ int s32k1xx_pinconfig(uint32_t cfgset)
            * as an input
            */
 
+          base   = S32K1XX_GPIO_BASE(port);
           regval = getreg32(base + S32K1XX_GPIO_PIDR_OFFSET);
           if ((cfgset & PIN_DISABLE_INPUT) != 0)
             {
diff --git a/arch/arm/src/s32k1xx/s32k1xx_pingpio.c b/arch/arm/src/s32k1xx/s32k1xx_pingpio.c
index 5661da57b6..780a0d926d 100644
--- a/arch/arm/src/s32k1xx/s32k1xx_pingpio.c
+++ b/arch/arm/src/s32k1xx/s32k1xx_pingpio.c
@@ -111,7 +111,6 @@ bool s32k1xx_gpioread(uint32_t pinset)
   bool         ret = false;
 
   DEBUGASSERT((pinset & _PIN_MODE_MASK) == _PIN_MODE_GPIO);
-  DEBUGASSERT((pinset & _PIN_IO_MASK) == _PIN_INPUT);
 
   /* Get the port number and pin number */
 
diff --git a/arch/arm/src/s32k1xx/s32k1xx_progmem.h b/arch/arm/src/s32k1xx/s32k1xx_progmem.h
index 9b97d7798e..e413ec8368 100644
--- a/arch/arm/src/s32k1xx/s32k1xx_progmem.h
+++ b/arch/arm/src/s32k1xx/s32k1xx_progmem.h
@@ -47,7 +47,7 @@
 #include <stdint.h>
 #include <stdbool.h>
 
-#include "up_internal.h"
+#include "arm_internal.h"
 #include "s32k1xx_config.h"
 
 /******************************************************************************
diff --git a/arch/arm/src/s32k1xx/s32k1xx_pwm.c b/arch/arm/src/s32k1xx/s32k1xx_pwm.c
new file mode 100644
index 0000000000..f680686540
--- /dev/null
+++ b/arch/arm/src/s32k1xx/s32k1xx_pwm.c
@@ -0,0 +1,836 @@
+/*****************************************************************************
+ * arch/arm/src/s32k1xx/s32k1xx_pwm.c
+ *
+ *   Copyright (C) 2013, 2016, 2017 Gregory Nutt. All rights reserved.
+ *   Authors: Gregory Nutt <gnutt@nuttx.org>
+ *            Alan Carvalho de Assis <acassis@gmail.com>
+ *            Ken Fazzone <kfazz01@gmail.com>
+ *            David Sidrane <david_s5@nscdg.com>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ *****************************************************************************/
+
+/*****************************************************************************
+ * Included Files
+ *****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include <stdint.h>
+#include <stdio.h>
+#include <assert.h>
+#include <errno.h>
+#include <debug.h>
+
+#include <nuttx/irq.h>
+#include <nuttx/arch.h>
+#include <nuttx/timers/pwm.h>
+#include <arch/board/board.h>
+
+#include "arm_internal.h"
+#include "arm_arch.h"
+
+#include "chip.h"
+
+#include "s32k1xx_clockconfig.h"
+#include "s32k1xx_pin.h"
+#include "s32k1xx_pwm.h"
+#include "hardware/s32k1xx_gpio.h"
+#include "hardware/s32k1xx_ftm.h"
+#include "hardware/s32k1xx_sim.h"
+
+/* This module then only compiles if there is at least one enabled timer
+ * intended for use with the PWM upper half driver.
+ */
+
+#if defined(CONFIG_S32K1XX_FTM0_PWM) || defined(CONFIG_S32K1XX_FTM1_PWM) || \
+    defined(CONFIG_S32K1XX_FTM2_PWM) || defined(CONFIG_S32K1XX_FTM3_PWM) || \
+    defined(CONFIG_S32K1XX_FTM4_PWM) || defined(CONFIG_S32K1XX_FTM5_PWM) || \
+    defined(CONFIG_S32K1XX_FTM6_PWM) || defined(CONFIG_S32K1XX_FTM7_PWM)
+
+/*****************************************************************************
+ * Pre-processor Definitions
+ *****************************************************************************/
+
+/* PWM/Timer Definitions *****************************************************/
+
+/* Debug *********************************************************************/
+
+#ifdef CONFIG_DEBUG_PWM_INFO
+#  define pwm_dumpgpio(p,m) s32k1xx_pindump(p,m)
+#else
+#  define pwm_dumpgpio(p,m)
+#endif
+
+/****************************************************************************
+ * Private Types
+ ****************************************************************************/
+
+/* This structure represents the state of one PWM timer */
+
+struct s32k1xx_pwmtimer_s
+{
+  FAR const struct pwm_ops_s *ops;     /* PWM operations */
+  uint8_t                     tpmid;   /* Timer/PWM Module ID {0,..,7} */
+  uint8_t                     channel; /* Timer/PWM Module channel: {0,...,7} */
+  uint32_t                    base;    /* The base address of the timer */
+  uint32_t                    pincfg;  /* Output pin configuration */
+  uint32_t                    pclk;    /* The frequency of the peripheral clock */
+};
+
+/*****************************************************************************
+ * Static Function Prototypes
+ *****************************************************************************/
+
+/* Register access */
+
+static uint32_t pwm_getreg(struct s32k1xx_pwmtimer_s *priv, int offset);
+static void pwm_putreg(struct s32k1xx_pwmtimer_s *priv, int offset,
+                       uint32_t value);
+
+#ifdef CONFIG_DEBUG_PWM_INFO
+static void pwm_dumpregs(struct s32k1xx_pwmtimer_s *priv,
+                         FAR const char *msg);
+#else
+#  define pwm_dumpregs(priv,msg)
+#endif
+
+/* Timer management */
+
+static int pwm_timer(FAR struct s32k1xx_pwmtimer_s *priv,
+                     FAR const struct pwm_info_s *info);
+
+/* PWM driver methods */
+
+static int pwm_setup(FAR struct pwm_lowerhalf_s *dev);
+static int pwm_shutdown(FAR struct pwm_lowerhalf_s *dev);
+
+static int pwm_start(FAR struct pwm_lowerhalf_s *dev,
+                     FAR const struct pwm_info_s *info);
+
+static int pwm_stop(FAR struct pwm_lowerhalf_s *dev);
+static int pwm_ioctl(FAR struct pwm_lowerhalf_s *dev, int cmd,
+                     unsigned long arg);
+
+/*****************************************************************************
+ * Private Data
+ *****************************************************************************/
+
+/* This is the list of lower half PWM driver methods used by the upper half
+ * driver.
+ */
+
+static const struct pwm_ops_s g_pwmops =
+{
+  .setup    = pwm_setup,
+  .shutdown = pwm_shutdown,
+  .start    = pwm_start,
+  .stop     = pwm_stop,
+  .ioctl    = pwm_ioctl,
+};
+
+#ifdef CONFIG_S32K1XX_FTM0_PWM
+static struct s32k1xx_pwmtimer_s g_pwm0dev =
+{
+  .ops        = &g_pwmops,
+  .tpmid      = 0,
+  .channel    = CONFIG_S32K1XX_FTM0_CHANNEL,
+  .base       = S32K1XX_FTM0_BASE,
+  .pincfg     = PWM_FTM0_PINCFG,
+};
+#endif
+
+#ifdef CONFIG_S32K1XX_FTM1_PWM
+static struct s32k1xx_pwmtimer_s g_pwm1dev =
+{
+  .ops        = &g_pwmops,
+  .tpmid      = 1,
+  .channel    = CONFIG_S32K1XX_FTM1_CHANNEL,
+  .base       = S32K1XX_FTM1_BASE,
+  .pincfg     = PWM_FTM1_PINCFG,
+};
+#endif
+
+#ifdef CONFIG_S32K1XX_FTM2_PWM
+static struct s32k1xx_pwmtimer_s g_pwm2dev =
+{
+  .ops        = &g_pwmops,
+  .tpmid      = 2,
+  .channel    = CONFIG_S32K1XX_FTM2_CHANNEL,
+  .base       = S32K1XX_FTM2_BASE,
+  .pincfg     = PWM_FTM2_PINCFG,
+};
+#endif
+
+#ifdef CONFIG_S32K1XX_FTM3_PWM
+static struct s32k1xx_pwmtimer_s g_pwm3dev =
+{
+  .ops        = &g_pwmops,
+  .tpmid      = 3,
+  .channel    = CONFIG_S32K1XX_FTM3_CHANNEL,
+  .base       = S32K1XX_FTM3_BASE,
+  .pincfg     = PWM_FTM3_PINCFG,
+};
+#endif
+
+#ifdef CONFIG_S32K1XX_FTM4_PWM
+static struct s32k1xx_pwmtimer_s g_pwm4dev =
+{
+  .ops        = &g_pwmops,
+  .tpmid      = 4,
+  .channel    = CONFIG_S32K1XX_FTM4_CHANNEL,
+  .base       = S32K1XX_FTM4_BASE,
+  .pincfg     = PWM_FTM4_PINCFG,
+};
+#endif
+
+#ifdef CONFIG_S32K1XX_FTM5_PWM
+static struct s32k1xx_pwmtimer_s g_pwm5dev =
+{
+  .ops        = &g_pwmops,
+  .tpmid      = 5,
+  .channel    = CONFIG_S32K1XX_FTM5_CHANNEL,
+  .base       = S32K1XX_FTM5_BASE,
+  .pincfg     = PWM_FTM5_PINCFG,
+};
+#endif
+
+#ifdef CONFIG_S32K1XX_FTM6_PWM
+static struct s32k1xx_pwmtimer_s g_pwm6dev =
+{
+  .ops        = &g_pwmops,
+  .tpmid      = 6,
+  .channel    = CONFIG_S32K1XX_FTM6_CHANNEL,
+  .base       = S32K1XX_FTM6_BASE,
+  .pincfg     = PWM_FTM6_PINCFG,
+};
+#endif
+
+#ifdef CONFIG_S32K1XX_FTM7_PWM
+static struct s32k1xx_pwmtimer_s g_pwm7dev =
+{
+  .ops        = &g_pwmops,
+  .tpmid      = 7,
+  .channel    = CONFIG_S32K1XX_FTM7_CHANNEL,
+  .base       = S32K1XX_FTM7_BASE,
+  .pincfg     = PWM_FTM7_PINCFG,
+};
+#endif
+
+/*****************************************************************************
+ * Private Functions
+ *****************************************************************************/
+
+/*****************************************************************************
+ * Name: pwm_getreg
+ *
+ * Description:
+ *   Read the value of an PWM timer register.
+ *
+ * Input Parameters:
+ *   priv - A reference to the PWM block status
+ *   offset - The offset to the register to read
+ *
+ * Returned Value:
+ *   The current contents of the specified register
+ *
+ *****************************************************************************/
+
+static uint32_t pwm_getreg(struct s32k1xx_pwmtimer_s *priv, int offset)
+{
+  return getreg32(priv->base + offset);
+}
+
+/*****************************************************************************
+ * Name: pwm_putreg
+ *
+ * Description:
+ *   Read the value of an PWM timer register.
+ *
+ * Input Parameters:
+ *   priv - A reference to the PWM block status
+ *   offset - The offset to the register to read
+ *
+ * Returned Value:
+ *   None
+ *
+ *****************************************************************************/
+
+static void pwm_putreg(struct s32k1xx_pwmtimer_s *priv, int offset,
+                       uint32_t value)
+{
+  putreg32(value, priv->base + offset);
+}
+
+/*****************************************************************************
+ * Name: pwm_dumpregs
+ *
+ * Description:
+ *   Dump all timer registers.
+ *
+ * Input Parameters:
+ *   priv - A reference to the PWM block status
+ *
+ * Returned Value:
+ *   None
+ *
+ *****************************************************************************/
+
+#ifdef CONFIG_DEBUG_PWM_INFO
+static void pwm_dumpregs(struct s32k1xx_pwmtimer_s *priv, FAR const char *msg)
+{
+  pwminfo("%s:\n", msg);
+  pwminfo("  FTM%d_SC:     %04x   FTM%d_CNT:  %04x     FTM%d_MOD:  %04x\n",
+          priv->tpmid, pwm_getreg(priv, S32K1XX_FTM_SC_OFFSET),
+          priv->tpmid, pwm_getreg(priv, S32K1XX_FTM_CNT_OFFSET),
+          priv->tpmid, pwm_getreg(priv, S32K1XX_FTM_MOD_OFFSET));
+  pwminfo("  FTM%d_STATUS: %04x   FTM%d_CONF: %04x\n",
+          priv->tpmid, pwm_getreg(priv, S32K1XX_FTM_STATUS_OFFSET),
+          priv->tpmid, pwm_getreg(priv, S32K1XX_FTM_CONF_OFFSET));
+  pwminfo("   FTM%d_C0SC:  %04x   FTM%d_C0V:  %04x\n",
+          priv->tpmid, pwm_getreg(priv, S32K1XX_FTM_C0SC_OFFSET),
+          priv->tpmid, pwm_getreg(priv, S32K1XX_FTM_C0V_OFFSET));
+  pwminfo("   FTM%d_C1SC:  %04x   FTM%d_C1V:  %04x\n",
+          priv->tpmid, pwm_getreg(priv, S32K1XX_FTM_C1SC_OFFSET),
+          priv->tpmid, pwm_getreg(priv, S32K1XX_FTM_C1V_OFFSET));
+  pwminfo("   FTM%d_C2SC:  %04x   FTM%d_C2V:  %04x\n",
+          priv->tpmid, pwm_getreg(priv, S32K1XX_FTM_C2SC_OFFSET),
+          priv->tpmid, pwm_getreg(priv, S32K1XX_FTM_C2V_OFFSET));
+  pwminfo("   FTM%d_C3SC:  %04x   FTM%d_C3V:  %04x\n",
+          priv->tpmid, pwm_getreg(priv, S32K1XX_FTM_C3SC_OFFSET),
+          priv->tpmid, pwm_getreg(priv, S32K1XX_FTM_C3V_OFFSET));
+  pwminfo("   FTM%d_C4SC:  %04x   FTM%d_C4V:  %04x\n",
+          priv->tpmid, pwm_getreg(priv, S32K1XX_FTM_C4SC_OFFSET),
+          priv->tpmid, pwm_getreg(priv, S32K1XX_FTM_C4V_OFFSET));
+  pwminfo("   FTM%d_C5SC:  %04x   FTM%d_C5V:  %04x\n",
+          priv->tpmid, pwm_getreg(priv, S32K1XX_FTM_C5SC_OFFSET),
+          priv->tpmid, pwm_getreg(priv, S32K1XX_FTM_C5V_OFFSET));
+  pwminfo("   FTM%d_C6SC:  %04x   FTM%d_C6V:  %04x\n",
+          priv->tpmid, pwm_getreg(priv, S32K1XX_FTM_C6SC_OFFSET),
+          priv->tpmid, pwm_getreg(priv, S32K1XX_FTM_C6V_OFFSET));
+  pwminfo("   FTM%d_C7SC:  %04x   FTM%d_C7V:  %04x\n",
+          priv->tpmid, pwm_getreg(priv, S32K1XX_FTM_C7SC_OFFSET),
+          priv->tpmid, pwm_getreg(priv, S32K1XX_FTM_C7V_OFFSET));
+}
+#endif
+
+/*****************************************************************************
+ * Name: pwm_timer
+ *
+ * Description:
+ *   (Re-)initialize the timer resources and start the pulsed output
+ *
+ * Input Parameters:
+ *   priv - A reference to the lower half PWM driver state structure
+ *   info - A reference to the characteristics of the pulsed output
+ *
+ * Returned Value:
+ *   Zero on success; a negated errno value on failure
+ *
+ *****************************************************************************/
+
+static int pwm_timer(FAR struct s32k1xx_pwmtimer_s *priv,
+                     FAR const struct pwm_info_s *info)
+{
+  /* Calculated values */
+
+  uint32_t prescaler;
+  uint32_t tpmclk;
+  uint32_t modulo;
+  uint32_t regval;
+  uint32_t cv;
+  uint8_t i;
+
+  static const uint8_t presc_values[8] = {1, 2, 4, 8, 16, 32, 64, 128};
+
+  /* Register contents */
+
+  DEBUGASSERT(priv != NULL && info != NULL);
+
+  pwminfo("FTM%d channel: %d frequency: %d duty: %08x\n",
+          priv->tpmid, priv->channel, info->frequency, info->duty);
+
+  DEBUGASSERT(info->frequency > 0 && info->duty > 0 &&
+              info->duty < uitoub16(100));
+
+  /* Calculate optimal values for the timer prescaler and for the timer modulo
+   * register.  If' frequency' is the desired frequency, then
+   *
+   *   modulo = tpmclk / frequency
+   *   tpmclk = pclk / presc
+   *
+   * Or,
+   *
+   *   modulo = pclk / presc / frequency
+   *
+   * There are many solutions to do this, but the best solution will be the
+   * one that has the largest modulo value and the smallest prescaler value.
+   * That is the solution that should give us the most accuracy in the timer
+   * control.  Subject to:
+   *
+   *   1 <= presc  <= 128 (need to be 1, 2, 4, 8, 16, 32, 64, 128)
+   *   1 <= modulo <= 65535
+   *
+   * So presc = pclk / 65535 / frequency would be optimal.
+   *
+   * Example:
+   *
+   *  pclk      = 24 MHz
+   *  frequency = 100 Hz
+   *
+   *  prescaler = 24,000,000 / 65,535 / 100
+   *            = 3.6 (or 4 -- taking the ceiling always)
+   *  timclk    = 24,000,000 / 4
+   *            = 6,000,000
+   *  modulo    = 6,000,000 / 100
+   *            = 60,000
+   */
+
+  prescaler = (priv->pclk / info->frequency + 65534) / 65535;
+
+  for (i = 0; i < 7; i++)
+    {
+      if (prescaler <= presc_values[i])
+        {
+           break;
+        }
+    }
+
+  prescaler = i;
+
+  tpmclk = priv->pclk / presc_values[prescaler];
+
+  modulo = tpmclk / info->frequency;
+  if (modulo < 1)
+    {
+      modulo = 1;
+    }
+  else if (modulo > 65535)
+    {
+      modulo = 65535;
+    }
+
+  /* Duty cycle:
+   *
+   * duty cycle = cv / modulo (fractional value)
+   */
+
+  cv = b16toi(info->duty * modulo + b16HALF);
+
+  pwminfo("FTM%d PCLK: %d frequency: %d FTMCLK: %d prescaler: %d modulo: %d c0v: %d\n",
+          priv->tpmid, priv->pclk, info->frequency, tpmclk,
+          presc_values[prescaler], modulo, cv);
+
+  /* Disable FTM and reset CNT before writing MOD and PS */
+
+  pwm_putreg(priv, S32K1XX_FTM_SC_OFFSET, FTM_SC_CLKS_DIS);
+  pwm_putreg(priv, S32K1XX_FTM_CNT_OFFSET, 0);
+
+  /* Set the modulo value */
+
+  pwm_putreg(priv, S32K1XX_FTM_MOD_OFFSET, (uint16_t)modulo);
+
+  /* Set the duty cycle for channel specific */
+
+  switch (priv->channel)
+    {
+      case 0:  /* PWM Mode configuration: Channel 0 */
+        {
+          pwm_putreg(priv, S32K1XX_FTM_C0SC_OFFSET, FTM_CNSC_MSB | FTM_CNSC_ELSB);
+          pwm_putreg(priv, S32K1XX_FTM_C0V_OFFSET, (uint16_t) cv);
+        }
+        break;
+
+      case 1:  /* PWM Mode configuration: Channel 1 */
+        {
+          pwm_putreg(priv, S32K1XX_FTM_C1SC_OFFSET, FTM_CNSC_MSB | FTM_CNSC_ELSB);
+          pwm_putreg(priv, S32K1XX_FTM_C1V_OFFSET, (uint16_t) cv);
+        }
+        break;
+
+      case 2:  /* PWM Mode configuration: Channel 2 */
+        {
+          pwm_putreg(priv, S32K1XX_FTM_C2SC_OFFSET, FTM_CNSC_MSB | FTM_CNSC_ELSB);
+          pwm_putreg(priv, S32K1XX_FTM_C2V_OFFSET, (uint16_t) cv);
+        }
+        break;
+
+      case 3:  /* PWM Mode configuration: Channel 3 */
+        {
+          pwm_putreg(priv, S32K1XX_FTM_C3SC_OFFSET, FTM_CNSC_MSB | FTM_CNSC_ELSB);
+          pwm_putreg(priv, S32K1XX_FTM_C3V_OFFSET, (uint16_t) cv);
+        }
+        break;
+
+      case 4:  /* PWM Mode configuration: Channel 4 */
+        {
+          pwm_putreg(priv, S32K1XX_FTM_C4SC_OFFSET, FTM_CNSC_MSB | FTM_CNSC_ELSB);
+          pwm_putreg(priv, S32K1XX_FTM_C4V_OFFSET, (uint16_t) cv);
+        }
+        break;
+
+      case 5:  /* PWM Mode configuration: Channel 5 */
+        {
+          pwm_putreg(priv, S32K1XX_FTM_C5SC_OFFSET, FTM_CNSC_MSB | FTM_CNSC_ELSB);
+          pwm_putreg(priv, S32K1XX_FTM_C5V_OFFSET, (uint16_t) cv);
+        }
+        break;
+
+      case 6:  /* PWM Mode configuration: Channel 6 */
+        {
+          pwm_putreg(priv, S32K1XX_FTM_C6SC_OFFSET, FTM_CNSC_MSB | FTM_CNSC_ELSB);
+          pwm_putreg(priv, S32K1XX_FTM_C6V_OFFSET, (uint16_t) cv);
+        }
+        break;
+      case 7:  /* PWM Mode configuration: Channel 7 */
+        {
+          pwm_putreg(priv, S32K1XX_FTM_C7SC_OFFSET, FTM_CNSC_MSB | FTM_CNSC_ELSB);
+          pwm_putreg(priv, S32K1XX_FTM_C7V_OFFSET, (uint16_t) cv);
+        }
+        break;
+
+      default:
+        pwmerr("ERROR: No such channel: %d\n", priv->channel);
+        return -EINVAL;
+    }
+
+  /* Set prescaler and enable clock */
+
+  regval = pwm_getreg(priv, S32K1XX_FTM_SC_OFFSET);
+  regval &= ~(FTM_SC_PS_MASK);
+  regval &= ~(FTM_SC_CLKS_MASK);
+  regval |= prescaler | FTM_SC_CLKS_FTM;
+  regval |= FTM_SC_PWMEN(priv->channel);
+  pwm_putreg(priv, S32K1XX_FTM_SC_OFFSET, regval);
+
+  pwm_dumpregs(priv, "After starting");
+  return OK;
+}
+
+/****************************************************************************
+ * Name: pwm_setup
+ *
+ * Description:
+ *   This method is called when the driver is opened.  The lower half driver
+ *   should configure and initialize the device so that it is ready for use.
+ *   It should not, however, output pulses until the start method is called.
+ *
+ * Input Parameters:
+ *   dev - A reference to the lower half PWM driver state structure
+ *
+ * Returned Value:
+ *   Zero on success; a negated errno value on failure
+ *
+ * Assumptions:
+ *   AHB1 or 2 clocking for the GPIOs and timer has already been configured
+ *   by the RCC logic at power up.
+ *
+ ****************************************************************************/
+
+static int pwm_setup(FAR struct pwm_lowerhalf_s *dev)
+{
+  FAR struct s32k1xx_pwmtimer_s *priv = (FAR struct s32k1xx_pwmtimer_s *)dev;
+
+  /* Note: The appropriate clock should for the right FTM device should
+   * already be enabled in the board-specific s32k1xx_periphclocks.c file. */
+
+  pwminfo("FTM%d pincfg: %08x\n", priv->tpmid, priv->pincfg);
+  pwm_dumpregs(priv, "Initially");
+
+  /* Configure the PWM output pin, but do not start the timer yet */
+
+  s32k1xx_pinconfig(priv->pincfg);
+  pwm_dumpgpio(priv->pincfg, "PWM setup");
+  return OK;
+}
+
+/****************************************************************************
+ * Name: pwm_shutdown
+ *
+ * Description:
+ *   This method is called when the driver is closed.  The lower half driver
+ *   stop pulsed output, free any resources, disable the timer hardware, and
+ *   put the system into the lowest possible power usage state
+ *
+ * Input Parameters:
+ *   dev - A reference to the lower half PWM driver state structure
+ *
+ * Returned Value:
+ *   Zero on success; a negated errno value on failure
+ *
+ ****************************************************************************/
+
+static int pwm_shutdown(FAR struct pwm_lowerhalf_s *dev)
+{
+  FAR struct s32k1xx_pwmtimer_s *priv = (FAR struct s32k1xx_pwmtimer_s *)dev;
+  uint32_t pincfg;
+
+  pwminfo("FTM%d pincfg: %08x\n", priv->tpmid, priv->pincfg);
+
+  /* Make sure that the output has been stopped */
+
+  pwm_stop(dev);
+
+  /* Then put the GPIO pin back to the default state */
+
+  pincfg  = (priv->pincfg & ~(_PIN_MODE_MASK));
+  pincfg |= GPIO_INPUT;
+  s32k1xx_pinconfig(pincfg);
+  return OK;
+}
+
+/****************************************************************************
+ * Name: pwm_start
+ *
+ * Description:
+ *   (Re-)initialize the timer resources and start the pulsed output
+ *
+ * Input Parameters:
+ *   dev - A reference to the lower half PWM driver state structure
+ *   info - A reference to the characteristics of the pulsed output
+ *
+ * Returned Value:
+ *   Zero on success; a negated errno value on failure
+ *
+ ****************************************************************************/
+
+static int pwm_start(FAR struct pwm_lowerhalf_s *dev,
+                     FAR const struct pwm_info_s *info)
+{
+  FAR struct s32k1xx_pwmtimer_s *priv = (FAR struct s32k1xx_pwmtimer_s *)dev;
+  return pwm_timer(priv, info);
+}
+
+/****************************************************************************
+ * Name: pwm_stop
+ *
+ * Description:
+ *   Stop the pulsed output and reset the timer resources
+ *
+ * Input Parameters:
+ *   dev - A reference to the lower half PWM driver state structure
+ *
+ * Returned Value:
+ *   Zero on success; a negated errno value on failure
+ *
+ * Assumptions:
+ *   This function is called to stop the pulsed output at anytime.  This
+ *   method is also called from the timer interrupt handler when a repetition
+ *   count expires... automatically stopping the timer.
+ *
+ ****************************************************************************/
+
+static int pwm_stop(FAR struct pwm_lowerhalf_s *dev)
+{
+  FAR struct s32k1xx_pwmtimer_s *priv = (FAR struct s32k1xx_pwmtimer_s *)dev;
+  irqstate_t flags;
+
+  pwminfo("FTM%d\n", priv->tpmid);
+
+  /* Disable interrupts momentary to stop any ongoing timer processing and
+   * to prevent any concurrent access to the reset register.
+   */
+
+  flags = enter_critical_section();
+
+  /* Disable further interrupts and stop the timer */
+
+  pwm_putreg(priv, S32K1XX_FTM_SC_OFFSET, FTM_SC_CLKS_DIS);
+  pwm_putreg(priv, S32K1XX_FTM_CNT_OFFSET, 0);
+
+  /* Determine which timer channel to clear */
+
+  switch (priv->channel)
+    {
+      case 0:
+        pwm_putreg(priv, S32K1XX_FTM_C0V_OFFSET, 0);
+        break;
+
+      case 1:
+        pwm_putreg(priv, S32K1XX_FTM_C1V_OFFSET, 0);
+        break;
+
+      case 2:
+        pwm_putreg(priv, S32K1XX_FTM_C2V_OFFSET, 0);
+        break;
+
+      case 3:
+        pwm_putreg(priv, S32K1XX_FTM_C3V_OFFSET, 0);
+        break;
+
+      case 4:
+        pwm_putreg(priv, S32K1XX_FTM_C4V_OFFSET, 0);
+        break;
+
+      case 5:
+        pwm_putreg(priv, S32K1XX_FTM_C5V_OFFSET, 0);
+        break;
+
+      case 6:
+        pwm_putreg(priv, S32K1XX_FTM_C6V_OFFSET, 0);
+        break;
+
+      case 7:
+        pwm_putreg(priv, S32K1XX_FTM_C7V_OFFSET, 0);
+        break;
+
+      default:
+        pwmerr("ERROR: No such channel: %d\n", priv->channel);
+        return -EINVAL;
+    }
+
+  leave_critical_section(flags);
+
+  pwm_dumpregs(priv, "After stop");
+  return OK;
+}
+
+/****************************************************************************
+ * Name: pwm_ioctl
+ *
+ * Description:
+ *   Lower-half logic may support platform-specific ioctl commands
+ *
+ * Input Parameters:
+ *   dev - A reference to the lower half PWM driver state structure
+ *   cmd - The ioctl command
+ *   arg - The argument accompanying the ioctl command
+ *
+ * Returned Value:
+ *   Zero on success; a negated errno value on failure
+ *
+ ****************************************************************************/
+
+static int pwm_ioctl(FAR struct pwm_lowerhalf_s *dev, int cmd, unsigned long arg)
+{
+#ifdef CONFIG_DEBUG_PWM_INFO
+  FAR struct s32k1xx_pwmtimer_s *priv = (FAR struct s32k1xx_pwmtimer_s *)dev;
+
+  /* There are no platform-specific ioctl commands */
+
+  pwminfo("FTM%d\n", priv->tpmid);
+#endif
+  return -ENOTTY;
+}
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: s32k1xx_pwminitialize
+ *
+ * Description:
+ *   Initialize one timer for use with the upper_level PWM driver.
+ *
+ * Input Parameters:
+ *   timer - A number identifying the timer use.
+ *
+ * Returned Value:
+ *   On success, a pointer to the S32K1XX lower half PWM driver is returned.
+ *   NULL is returned on any failure.
+ *
+ ****************************************************************************/
+
+FAR struct pwm_lowerhalf_s *s32k1xx_pwminitialize(int timer)
+{
+  FAR struct s32k1xx_pwmtimer_s *lower;
+  int ret;
+  uint32_t sysclk;
+
+  sysclk = s32k1xx_get_coreclk();
+  ret = (sysclk == 0) ? -ENODEV : OK;
+
+  pwminfo("FTM%d\n", timer);
+
+  switch (timer)
+    {
+#ifdef CONFIG_S32K1XX_FTM0_PWM
+      case 0:
+        g_pwm0dev.pclk = sysclk;
+        lower = &g_pwm0dev;
+        break;
+#endif
+#ifdef CONFIG_S32K1XX_FTM1_PWM
+      case 1:
+        g_pwm1dev.pclk = sysclk;
+        lower = &g_pwm1dev;
+        break;
+#endif
+#ifdef CONFIG_S32K1XX_FTM2_PWM
+      case 2:
+        g_pwm2dev.pclk = sysclk;
+        lower = &g_pwm2dev;
+        break;
+#endif
+#ifdef CONFIG_S32K1XX_FTM3_PWM
+      case 3:
+        g_pwm3dev.pclk = sysclk;
+        lower = &g_pwm3dev;
+        break;
+#endif
+#ifdef CONFIG_S32K1XX_FTM4_PWM
+      case 4:
+        g_pwm4dev.pclk = sysclk;
+        lower = &g_pwm4dev;
+        break;
+#endif
+#ifdef CONFIG_S32K1XX_FTM5_PWM
+      case 5:
+        g_pwm5dev.pclk = sysclk;
+        lower = &g_pwm5dev;
+        break;
+#endif
+#ifdef CONFIG_S32K1XX_FTM6_PWM
+      case 6:
+        g_pwm6dev.pclk = sysclk;
+        lower = &g_pwm6dev;
+        break;
+#endif
+#ifdef CONFIG_S32K1XX_FTM7_PWM
+      case 7:
+        g_pwm7dev.pclk = sysclk;
+        lower = &g_pwm7dev;
+        break;
+#endif
+      default:
+        pwmerr("ERROR: No such timer configured\n");
+        return NULL;
+    }
+
+    if (ret != OK)
+      {
+        pwmerr("ERROR: FTM%d peripheral clock not available\n", timer);
+        return NULL;
+      }
+
+  return (FAR struct pwm_lowerhalf_s *)lower;
+}
+
+#endif /* CONFIG_S32K1XX_FTMn_PWM, n = 0,...,7 */
diff --git a/arch/arm/src/s32k1xx/s32k1xx_pwm.h b/arch/arm/src/s32k1xx/s32k1xx_pwm.h
new file mode 100644
index 0000000000..746c67fefb
--- /dev/null
+++ b/arch/arm/src/s32k1xx/s32k1xx_pwm.h
@@ -0,0 +1,346 @@
+/*****************************************************************************
+ * arch/arm/src/s32k1xx/s32k1xx_pwm.h
+ *
+ *   Copyright (C) 2013, 2016, 2017 Gregory Nutt. All rights reserved.
+ *   Authors: Gregory Nutt <gnutt@nuttx.org>
+ *            Alan Carvalho de Assis <acassis@gmail.com>
+ *            Ken Fazzone <kfazz01@gmail.com>
+ *            David Sidrane <david_s5@nscdg.com>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ *****************************************************************************/
+
+#ifndef __ARCH_ARM_SRC_S32K1XX_S32K1XX_PWM_H
+#define __ARCH_ARM_SRC_S32K1XX_S32K1XX_PWM_H
+
+/*****************************************************************************
+ * Included Files
+ *****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Pre-processor Definitions
+ *****************************************************************************/
+
+/* Configuration *************************************************************/
+
+/* Timer devices may be used for different purposes.  One special purpose is
+ * to generate modulated outputs for such things as motor control.  If
+ * CONFIG_S32K1XX_FTMn is defined then the CONFIG_S32K1XX_FTMn_PWM must also
+ * be defined to indicate that timer "n" is intended to be used for pulsed
+ * output signal generation.
+ */
+
+#ifndef CONFIG_S32K1XX_FTM0
+#  undef CONFIG_S32K1XX_FTM0_PWM
+#endif
+#ifndef CONFIG_S32K1XX_FTM1
+#  undef CONFIG_S32K1XX_FTM1_PWM
+#endif
+#ifndef CONFIG_S32K1XX_FTM2
+#  undef CONFIG_S32K1XX_FTM2_PWM
+#endif
+#ifndef CONFIG_S32K1XX_FTM3
+#  undef CONFIG_S32K1XX_FTM3_PWM
+#endif
+#ifndef CONFIG_S32K1XX_FTM4
+#  undef CONFIG_S32K1XX_FTM4_PWM
+#endif
+#ifndef CONFIG_S32K1XX_FTM5
+#  undef CONFIG_S32K1XX_FTM5_PWM
+#endif
+#ifndef CONFIG_S32K1XX_FTM6
+#  undef CONFIG_S32K1XX_FTM6_PWM
+#endif
+#ifndef CONFIG_S32K1XX_FTM7
+#  undef CONFIG_S32K1XX_FTM7_PWM
+#endif
+
+/* Check if PWM support for any channel is enabled. */
+
+#if defined(CONFIG_S32K1XX_FTM0_PWM) || defined(CONFIG_S32K1XX_FTM1_PWM) || \
+    defined(CONFIG_S32K1XX_FTM2_PWM) || defined(CONFIG_S32K1XX_FTM3_PWM) || \
+    defined(CONFIG_S32K1XX_FTM4_PWM) || defined(CONFIG_S32K1XX_FTM5_PWM) || \
+    defined(CONFIG_S32K1XX_FTM6_PWM) || defined(CONFIG_S32K1XX_FTM7_PWM)
+
+#include <arch/board/board.h>
+#include "hardware/s32k1xx_pinmux.h"
+
+/* For each timer that is enabled for PWM usage, we need the following additional
+ * configuration settings:
+ *
+ * CONFIG_S32K1XX_FTMx_CHANNEL - Specifies the timer output channel {0,..,7}
+ * PWM_FTMx_PINCFG - One of the values defined in s32k1*_pinmux.h.  In the case
+ *   where there are multiple pin selections, the correct setting must be provided
+ *   in the arch/board/board.h file.
+ */
+
+#ifdef CONFIG_S32K1XX_FTM0_PWM
+#  if !defined(CONFIG_S32K1XX_FTM0_CHANNEL)
+#    error "CONFIG_S32K1XX_FTM0_CHANNEL must be provided"
+#  elif CONFIG_S32K1XX_FTM0_CHANNEL == 0
+#    define PWM_FTM0_PINCFG GPIO_FTM0_CH0OUT
+#  elif CONFIG_S32K1XX_FTM0_CHANNEL == 1
+#    define PWM_FTM0_PINCFG GPIO_FTM0_CH1OUT
+#  elif CONFIG_S32K1XX_FTM0_CHANNEL == 2
+#    define PWM_FTM0_PINCFG GPIO_FTM0_CH2OUT
+#  elif CONFIG_S32K1XX_FTM0_CHANNEL == 3
+#    define PWM_FTM0_PINCFG GPIO_FTM0_CH3OUT
+#  elif CONFIG_S32K1XX_FTM0_CHANNEL == 4
+#    define PWM_FTM0_PINCFG GPIO_FTM0_CH4OUT
+#  elif CONFIG_S32K1XX_FTM0_CHANNEL == 5
+#    define PWM_FTM0_PINCFG GPIO_FTM0_CH5OUT
+#  elif CONFIG_S32K1XX_FTM0_CHANNEL == 6
+#    define PWM_FTM0_PINCFG GPIO_FTM0_CH6OUT
+#  elif CONFIG_S32K1XX_FTM0_CHANNEL == 7
+#    define PWM_FTM0_PINCFG GPIO_FTM0_CH7OUT
+#  else
+#    error "Unsupported value of CONFIG_S32K1XX_FTM0_CHANNEL"
+#  endif
+#endif
+
+#ifdef CONFIG_S32K1XX_FTM1_PWM
+#  if !defined(CONFIG_S32K1XX_FTM1_CHANNEL)
+#    error "CONFIG_S32K1XX_FTM1_CHANNEL must be provided"
+#  elif CONFIG_S32K1XX_FTM1_CHANNEL == 0
+#    define PWM_FTM1_PINCFG GPIO_FTM1_CH0OUT
+#  elif CONFIG_S32K1XX_FTM1_CHANNEL == 1
+#    define PWM_FTM1_PINCFG GPIO_FTM1_CH1OUT
+#  elif CONFIG_S32K1XX_FTM1_CHANNEL == 2
+#    define PWM_FTM1_PINCFG GPIO_FTM1_CH2OUT
+#  elif CONFIG_S32K1XX_FTM1_CHANNEL == 3
+#    define PWM_FTM1_PINCFG GPIO_FTM1_CH3OUT
+#  elif CONFIG_S32K1XX_FTM1_CHANNEL == 4
+#    define PWM_FTM1_PINCFG GPIO_FTM1_CH4OUT
+#  elif CONFIG_S32K1XX_FTM1_CHANNEL == 5
+#    define PWM_FTM1_PINCFG GPIO_FTM1_CH5OUT
+#  elif CONFIG_S32K1XX_FTM1_CHANNEL == 6
+#    define PWM_FTM1_PINCFG GPIO_FTM1_CH6OUT
+#  elif CONFIG_S32K1XX_FTM1_CHANNEL == 7
+#    define PWM_FTM1_PINCFG GPIO_FTM1_CH7OUT
+#  else
+#    error "Unsupported value of CONFIG_S32K1XX_FTM1_CHANNEL"
+#  endif
+#endif
+
+#ifdef CONFIG_S32K1XX_FTM2_PWM
+#  if !defined(CONFIG_S32K1XX_FTM2_CHANNEL)
+#    error "CONFIG_S32K1XX_FTM2_CHANNEL must be provided"
+#  elif CONFIG_S32K1XX_FTM2_CHANNEL == 0
+#    define PWM_FTM2_PINCFG GPIO_FTM2_CH0OUT
+#  elif CONFIG_S32K1XX_FTM2_CHANNEL == 1
+#    define PWM_FTM2_PINCFG GPIO_FTM2_CH1OUT
+#  elif CONFIG_S32K1XX_FTM2_CHANNEL == 2
+#    define PWM_FTM2_PINCFG GPIO_FTM2_CH2OUT
+#  elif CONFIG_S32K1XX_FTM2_CHANNEL == 3
+#    define PWM_FTM2_PINCFG GPIO_FTM2_CH3OUT
+#  elif CONFIG_S32K1XX_FTM2_CHANNEL == 4
+#    define PWM_FTM2_PINCFG GPIO_FTM2_CH4OUT
+#  elif CONFIG_S32K1XX_FTM2_CHANNEL == 5
+#    define PWM_FTM2_PINCFG GPIO_FTM2_CH5OUT
+#  elif CONFIG_S32K1XX_FTM2_CHANNEL == 6
+#    define PWM_FTM2_PINCFG GPIO_FTM2_CH6OUT
+#  elif CONFIG_S32K1XX_FTM2_CHANNEL == 7
+#    define PWM_FTM2_PINCFG GPIO_FTM2_CH7OUT
+#  else
+#    error "Unsupported value of CONFIG_S32K1XX_FTM2_CHANNEL"
+#  endif
+#endif
+
+#ifdef CONFIG_S32K1XX_FTM3_PWM
+#  if !defined(CONFIG_S32K1XX_FTM3_CHANNEL)
+#    error "CONFIG_S32K1XX_FTM3_CHANNEL must be provided"
+#  elif CONFIG_S32K1XX_FTM3_CHANNEL == 0
+#    define PWM_FTM3_PINCFG GPIO_FTM3_CH0OUT
+#  elif CONFIG_S32K1XX_FTM3_CHANNEL == 1
+#    define PWM_FTM3_PINCFG GPIO_FTM3_CH1OUT
+#  elif CONFIG_S32K1XX_FTM3_CHANNEL == 2
+#    define PWM_FTM3_PINCFG GPIO_FTM3_CH2OUT
+#  elif CONFIG_S32K1XX_FTM3_CHANNEL == 3
+#    define PWM_FTM3_PINCFG GPIO_FTM3_CH3OUT
+#  elif CONFIG_S32K1XX_FTM3_CHANNEL == 4
+#    define PWM_FTM3_PINCFG GPIO_FTM3_CH4OUT
+#  elif CONFIG_S32K1XX_FTM3_CHANNEL == 5
+#    define PWM_FTM3_PINCFG GPIO_FTM3_CH5OUT
+#  elif CONFIG_S32K1XX_FTM3_CHANNEL == 6
+#    define PWM_FTM3_PINCFG GPIO_FTM3_CH6OUT
+#  elif CONFIG_S32K1XX_FTM3_CHANNEL == 7
+#    define PWM_FTM3_PINCFG GPIO_FTM3_CH7OUT
+#  else
+#    error "Unsupported value of CONFIG_S32K1XX_FTM3_CHANNEL"
+#  endif
+#endif
+
+#ifdef CONFIG_S32K1XX_FTM4_PWM
+#  if !defined(CONFIG_S32K1XX_FTM4_CHANNEL)
+#    error "CONFIG_S32K1XX_FTM4_CHANNEL must be provided"
+#  elif CONFIG_S32K1XX_FTM4_CHANNEL == 0
+#    define PWM_FTM4_PINCFG GPIO_FTM4_CH0OUT
+#  elif CONFIG_S32K1XX_FTM4_CHANNEL == 1
+#    define PWM_FTM4_PINCFG GPIO_FTM4_CH1OUT
+#  elif CONFIG_S32K1XX_FTM4_CHANNEL == 2
+#    define PWM_FTM4_PINCFG GPIO_FTM4_CH2OUT
+#  elif CONFIG_S32K1XX_FTM4_CHANNEL == 3
+#    define PWM_FTM4_PINCFG GPIO_FTM4_CH3OUT
+#  elif CONFIG_S32K1XX_FTM4_CHANNEL == 4
+#    define PWM_FTM4_PINCFG GPIO_FTM4_CH4OUT
+#  elif CONFIG_S32K1XX_FTM4_CHANNEL == 5
+#    define PWM_FTM4_PINCFG GPIO_FTM4_CH5OUT
+#  elif CONFIG_S32K1XX_FTM4_CHANNEL == 6
+#    define PWM_FTM4_PINCFG GPIO_FTM4_CH6OUT
+#  elif CONFIG_S32K1XX_FTM4_CHANNEL == 7
+#    define PWM_FTM4_PINCFG GPIO_FTM4_CH7OUT
+#  else
+#    error "Unsupported value of CONFIG_S32K1XX_FTM4_CHANNEL"
+#  endif
+#endif
+
+#ifdef CONFIG_S32K1XX_FTM5_PWM
+#  if !defined(CONFIG_S32K1XX_FTM5_CHANNEL)
+#    error "CONFIG_S32K1XX_FTM5_CHANNEL must be provided"
+#  elif CONFIG_S32K1XX_FTM5_CHANNEL == 0
+#    define PWM_FTM5_PINCFG GPIO_FTM5_CH0OUT
+#  elif CONFIG_S32K1XX_FTM5_CHANNEL == 1
+#    define PWM_FTM5_PINCFG GPIO_FTM5_CH1OUT
+#  elif CONFIG_S32K1XX_FTM5_CHANNEL == 2
+#    define PWM_FTM5_PINCFG GPIO_FTM5_CH2OUT
+#  elif CONFIG_S32K1XX_FTM5_CHANNEL == 3
+#    define PWM_FTM5_PINCFG GPIO_FTM5_CH3OUT
+#  elif CONFIG_S32K1XX_FTM5_CHANNEL == 4
+#    define PWM_FTM5_PINCFG GPIO_FTM5_CH4OUT
+#  elif CONFIG_S32K1XX_FTM5_CHANNEL == 5
+#    define PWM_FTM5_PINCFG GPIO_FTM5_CH5OUT
+#  elif CONFIG_S32K1XX_FTM5_CHANNEL == 6
+#    define PWM_FTM5_PINCFG GPIO_FTM5_CH6OUT
+#  elif CONFIG_S32K1XX_FTM5_CHANNEL == 7
+#    define PWM_FTM5_PINCFG GPIO_FTM5_CH7OUT
+#  else
+#    error "Unsupported value of CONFIG_S32K1XX_FTM5_CHANNEL"
+#  endif
+#endif
+
+#ifdef CONFIG_S32K1XX_FTM6_PWM
+#  if !defined(CONFIG_S32K1XX_FTM6_CHANNEL)
+#    error "CONFIG_S32K1XX_FTM6_CHANNEL must be provided"
+#  elif CONFIG_S32K1XX_FTM6_CHANNEL == 0
+#    define PWM_FTM6_PINCFG GPIO_FTM6_CH0OUT
+#  elif CONFIG_S32K1XX_FTM6_CHANNEL == 1
+#    define PWM_FTM6_PINCFG GPIO_FTM6_CH1OUT
+#  elif CONFIG_S32K1XX_FTM6_CHANNEL == 2
+#    define PWM_FTM6_PINCFG GPIO_FTM6_CH2OUT
+#  elif CONFIG_S32K1XX_FTM6_CHANNEL == 3
+#    define PWM_FTM6_PINCFG GPIO_FTM6_CH3OUT
+#  elif CONFIG_S32K1XX_FTM6_CHANNEL == 4
+#    define PWM_FTM6_PINCFG GPIO_FTM6_CH4OUT
+#  elif CONFIG_S32K1XX_FTM6_CHANNEL == 5
+#    define PWM_FTM6_PINCFG GPIO_FTM6_CH5OUT
+#  elif CONFIG_S32K1XX_FTM6_CHANNEL == 6
+#    define PWM_FTM6_PINCFG GPIO_FTM6_CH6OUT
+#  elif CONFIG_S32K1XX_FTM6_CHANNEL == 7
+#    define PWM_FTM6_PINCFG GPIO_FTM6_CH7OUT
+#  else
+#    error "Unsupported value of CONFIG_S32K1XX_FTM6_CHANNEL"
+#  endif
+#endif
+
+#ifdef CONFIG_S32K1XX_FTM7_PWM
+#  if !defined(CONFIG_S32K1XX_FTM7_CHANNEL)
+#    error "CONFIG_S32K1XX_FTM7_CHANNEL must be provided"
+#  elif CONFIG_S32K1XX_FTM7_CHANNEL == 0
+#    define PWM_FTM7_PINCFG GPIO_FTM7_CH0OUT
+#  elif CONFIG_S32K1XX_FTM7_CHANNEL == 1
+#    define PWM_FTM7_PINCFG GPIO_FTM7_CH1OUT
+#  elif CONFIG_S32K1XX_FTM7_CHANNEL == 2
+#    define PWM_FTM7_PINCFG GPIO_FTM7_CH2OUT
+#  elif CONFIG_S32K1XX_FTM7_CHANNEL == 3
+#    define PWM_FTM7_PINCFG GPIO_FTM7_CH3OUT
+#  elif CONFIG_S32K1XX_FTM7_CHANNEL == 4
+#    define PWM_FTM7_PINCFG GPIO_FTM7_CH4OUT
+#  elif CONFIG_S32K1XX_FTM7_CHANNEL == 5
+#    define PWM_FTM7_PINCFG GPIO_FTM7_CH5OUT
+#  elif CONFIG_S32K1XX_FTM7_CHANNEL == 6
+#    define PWM_FTM7_PINCFG GPIO_FTM7_CH6OUT
+#  elif CONFIG_S32K1XX_FTM7_CHANNEL == 7
+#    define PWM_FTM7_PINCFG GPIO_FTM7_CH7OUT
+#  else
+#    error "Unsupported value of CONFIG_S32K1XX_FTM7_CHANNEL"
+#  endif
+#endif
+
+/*****************************************************************************
+ * Public Types
+ *****************************************************************************/
+
+/*****************************************************************************
+ * Public Data
+ *****************************************************************************/
+
+#ifndef __ASSEMBLY__
+
+#undef EXTERN
+#if defined(__cplusplus)
+#define EXTERN extern "C"
+extern "C"
+{
+#else
+#define EXTERN extern
+#endif
+
+/*****************************************************************************
+ * Public Function Prototypes
+ *****************************************************************************/
+
+/*****************************************************************************
+ * Name: s32k1xx_pwminitialize
+ *
+ * Description:
+ *   Initialize one timer for use with the upper_level PWM driver.
+ *
+ * Input Parameters:
+ *   timer - A number identifying the timer use.
+ *
+ * Returned Value:
+ *   On success, a pointer to the S32K1XX lower half PWM driver is returned.
+ *   NULL is returned on any failure.
+ *
+ ************************************************************************************/
+
+FAR struct pwm_lowerhalf_s *s32k1xx_pwminitialize(int timer);
+
+#undef EXTERN
+#if defined(__cplusplus)
+}
+#endif
+
+#endif /* __ASSEMBLY__ */
+#endif /* CONFIG_S32K1XX_FTMx_PWM */
+#endif /* __ARCH_ARM_SRC_S32K1XX_S32K1XX_PWM_H */
diff --git a/arch/arm/src/s32k1xx/s32k1xx_start.c b/arch/arm/src/s32k1xx/s32k1xx_start.c
index 3ad3620279..85c352d664 100644
--- a/arch/arm/src/s32k1xx/s32k1xx_start.c
+++ b/arch/arm/src/s32k1xx/s32k1xx_start.c
@@ -69,6 +69,10 @@
 #include "s32k1xx_progmem.h"
 #endif
 
+#ifdef CONFIG_S32K1XX_EEEPROM
+#include "s32k1xx_eeeprom.h"
+#endif
+
 /****************************************************************************
  * Pre-processor Definitions
  ****************************************************************************/
diff --git a/boards/Kconfig b/boards/Kconfig
index 69d80745ee..e02128b1f5 100644
--- a/boards/Kconfig
+++ b/boards/Kconfig
@@ -1279,6 +1279,14 @@ config ARCH_BOARD_S32K144EVB
 		This options selects support for NuttX on the NXP S32K144EVB board
 		featuring the S32K144 Cortex-M4F.
 
+config ARCH_BOARD_RDDRONE_BMS772
+	bool "NXP RDDRONE-BMS772"
+	depends on ARCH_CHIP_S32K144
+	select ARCH_HAVE_LEDS
+	---help---
+		This options selects support for NuttX on the NXP RDDRONE-BMS772 board
+		featuring the S32K144 Cortex-M4F.
+
 config ARCH_BOARD_RDDRONE_UAVCAN144
 	bool "NXP RDDRONE-UAVCAN144"
 	depends on ARCH_CHIP_S32K144
@@ -2229,6 +2237,7 @@ config ARCH_BOARD
 	default "rddrone-uavcan146"        if ARCH_BOARD_RDDRONE_UAVCAN146
 	default "s32k146evb"               if ARCH_BOARD_S32K146EVB
 	default "s32k148evb"               if ARCH_BOARD_S32K148EVB
+	default "rddrone-bms772"           if ARCH_BOARD_RDDRONE_BMS772
 	default "sabre-6quad"              if ARCH_BOARD_SABRE_6QUAD
 	default "sama5d2-xult"             if ARCH_BOARD_SAMA5D2_XULT
 	default "sama5d3x-ek"              if ARCH_BOARD_SAMA5D3X_EK
@@ -2368,6 +2377,9 @@ endif
 if ARCH_BOARD_S32K144EVB
 source "boards/arm/s32k1xx/s32k144evb/Kconfig"
 endif
+if ARCH_BOARD_RDDRONE_BMS772
+source "boards/arm/s32k1xx/rddrone-bms772/Kconfig"
+endif
 if ARCH_BOARD_RDDRONE_UAVCAN144
 source "boards/arm/s32k1xx/rddrone-uavcan144/Kconfig"
 endif
diff --git a/boards/arm/s32k1xx/rddrone-bms772/Kconfig b/boards/arm/s32k1xx/rddrone-bms772/Kconfig
new file mode 100644
index 0000000000..4eef827d41
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/Kconfig
@@ -0,0 +1,8 @@
+#
+# For a description of the syntax of this configuration file,
+# see the file kconfig-language.txt in the NuttX tools repository.
+#
+
+if ARCH_BOARD_RDDRONE_BMS772
+
+endif # ARCH_BOARD_RDDRONE_BMS772
diff --git a/boards/arm/s32k1xx/rddrone-bms772/README.txt b/boards/arm/s32k1xx/rddrone-bms772/README.txt
new file mode 100644
index 0000000000..8e0a75f186
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/README.txt
@@ -0,0 +1,15 @@
+README
+======
+
+This directory holds the port to the NXP RDDRONE-BMS772 board with S32K144 MCU.
+
+Contents
+========
+
+  o Status
+
+Status
+======
+
+  2020-02-11:  Configuration created (copy-paste from S32K146EVB).
+    Tested: -
\ No newline at end of file
diff --git a/boards/arm/s32k1xx/rddrone-bms772/configs/bms/.gitignore b/boards/arm/s32k1xx/rddrone-bms772/configs/bms/.gitignore
new file mode 100644
index 0000000000..aff67cd1fb
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/configs/bms/.gitignore
@@ -0,0 +1,2 @@
+old/
+/old
\ No newline at end of file
diff --git a/boards/arm/s32k1xx/rddrone-bms772/configs/bms/defconfig b/boards/arm/s32k1xx/rddrone-bms772/configs/bms/defconfig
new file mode 100644
index 0000000000..46ca45a77a
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/configs/bms/defconfig
@@ -0,0 +1,105 @@
+#
+# This file is autogenerated: PLEASE DO NOT EDIT IT.
+#
+# You can use "make menuconfig" to make any modifications to the installed .config file.
+# You can then do "make savedefconfig" to generate a new defconfig file that includes your
+# modifications.
+#
+# CONFIG_ARCH_LEDS is not set
+# CONFIG_NET_ETHERNET is not set
+# CONFIG_NET_IPv4 is not set
+# CONFIG_NSH_ARGCAT is not set
+# CONFIG_NSH_CMDOPT_HEXDUMP is not set
+# CONFIG_NSH_CMDPARMS is not set
+CONFIG_ARCH="arm"
+CONFIG_ARCH_BOARD="rddrone-bms772"
+CONFIG_ARCH_BOARD_RDDRONE_BMS772=y
+CONFIG_ARCH_CHIP="s32k1xx"
+CONFIG_ARCH_CHIP_S32K144=y
+CONFIG_ARCH_CHIP_S32K14X=y
+CONFIG_ARCH_CHIP_S32K1XX=y
+CONFIG_ARCH_STACKDUMP=y
+CONFIG_ARMV7M_LIBM=y
+CONFIG_ARMV7M_MEMCPY=y
+CONFIG_BINFMT_DISABLE=y
+CONFIG_BOARD_LOOPSPERMSEC=3997
+CONFIG_BUILTIN=y
+CONFIG_CANUTILS_LIBCANARDV1=y
+CONFIG_CLOCK_MONOTONIC=y
+CONFIG_DEBUG_SYMBOLS=y
+CONFIG_DEV_GPIO=y
+CONFIG_DEV_GPIO_NSIGNALS=5
+CONFIG_EXAMPLES_HELLO=y
+CONFIG_FS_PROCFS=y
+CONFIG_FS_ROMFS=y
+CONFIG_I2C=y
+CONFIG_I2C_DRIVER=y
+CONFIG_LIBC_FLOATINGPOINT=y
+CONFIG_LIBM=y
+CONFIG_LPUART0_RXBUFSIZE=64
+CONFIG_LPUART0_TXBUFSIZE=64
+CONFIG_LPUART1_RXBUFSIZE=64
+CONFIG_LPUART1_SERIAL_CONSOLE=y
+CONFIG_LPUART1_TXBUFSIZE=64
+CONFIG_MAX_TASKS=16
+CONFIG_MAX_WDOGPARMS=2
+CONFIG_NET=y
+CONFIG_NETDEV_CAN_BITRATE_IOCTL=y
+CONFIG_NETDEV_IFINDEX=y
+CONFIG_NET_CAN=y
+CONFIG_NET_CAN_NOTIFIER=y
+CONFIG_NET_CAN_RAW_TX_DEADLINE=y
+CONFIG_NET_CAN_SOCK_OPTS=y
+CONFIG_NET_TIMESTAMP=y
+CONFIG_NFILE_DESCRIPTORS=20
+CONFIG_NSH_ARCHINIT=y
+CONFIG_NSH_ARCHROMFS=y
+CONFIG_NSH_BUILTIN_APPS=y
+CONFIG_NSH_DISABLE_DATE=y
+CONFIG_NSH_FILEIOSIZE=512
+CONFIG_NSH_READLINE=y
+CONFIG_NSH_ROMFSETC=y
+CONFIG_NXP_BMS=y
+CONFIG_PATH_MAX=128
+CONFIG_PREALLOC_MQ_MSGS=4
+CONFIG_PREALLOC_TIMERS=4
+CONFIG_PREALLOC_WDOGS=16
+CONFIG_RAM_SIZE=61440
+CONFIG_RAM_START=0x1fff8000
+CONFIG_RAW_BINARY=y
+CONFIG_RR_INTERVAL=200
+CONFIG_RTC=y
+CONFIG_RTC_FREQUENCY=32768
+CONFIG_RTC_HIRES=y
+CONFIG_S32K1XX_EEEPROM=y
+CONFIG_S32K1XX_FLEXCAN0=y
+CONFIG_S32K1XX_GPIOIRQ=y
+CONFIG_S32K1XX_LPI2C0=y
+CONFIG_S32K1XX_LPSPI0=y
+CONFIG_S32K1XX_LPSPI1=y
+CONFIG_S32K1XX_LPUART0=y
+CONFIG_S32K1XX_LPUART1=y
+CONFIG_S32K1XX_PORTAINTS=y
+CONFIG_S32K1XX_PORTBINTS=y
+CONFIG_S32K1XX_PORTCINTS=y
+CONFIG_S32K1XX_PORTDINTS=y
+CONFIG_S32K1XX_PORTEINTS=y
+CONFIG_S32K1XX_RTC=y
+CONFIG_SCHED_CPULOAD=y
+CONFIG_SCHED_LPWORK=y
+CONFIG_SCHED_LPWORKSTACKSIZE=1536
+CONFIG_SCHED_WAITPID=y
+CONFIG_SDCLONE_DISABLE=y
+CONFIG_SIG_DEFAULT=y
+CONFIG_SPI_DRIVER=y
+CONFIG_STACK_COLORATION=y
+CONFIG_START_DAY=18
+CONFIG_START_MONTH=8
+CONFIG_START_YEAR=2019
+CONFIG_STDIO_DISABLE_BUFFERING=y
+CONFIG_SYMTAB_ORDEREDBYNAME=y
+CONFIG_SYSLOG_CONSOLE=y
+CONFIG_SYSTEM_NSH=y
+CONFIG_USERLED=y
+CONFIG_USERLED_LOWER=y
+CONFIG_USER_ENTRYPOINT="nsh_main"
diff --git a/boards/arm/s32k1xx/rddrone-bms772/configs/bmsdebug/.gitignore b/boards/arm/s32k1xx/rddrone-bms772/configs/bmsdebug/.gitignore
new file mode 100644
index 0000000000..aff67cd1fb
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/configs/bmsdebug/.gitignore
@@ -0,0 +1,2 @@
+old/
+/old
\ No newline at end of file
diff --git a/boards/arm/s32k1xx/rddrone-bms772/configs/bmsdebug/defconfig b/boards/arm/s32k1xx/rddrone-bms772/configs/bmsdebug/defconfig
new file mode 100644
index 0000000000..73f9e45d84
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/configs/bmsdebug/defconfig
@@ -0,0 +1,107 @@
+#
+# This file is autogenerated: PLEASE DO NOT EDIT IT.
+#
+# You can use "make menuconfig" to make any modifications to the installed .config file.
+# You can then do "make savedefconfig" to generate a new defconfig file that includes your
+# modifications.
+#
+# CONFIG_ARCH_LEDS is not set
+# CONFIG_NET_ETHERNET is not set
+# CONFIG_NET_IPv4 is not set
+# CONFIG_NSH_ARGCAT is not set
+# CONFIG_NSH_CMDOPT_HEXDUMP is not set
+# CONFIG_NSH_CMDPARMS is not set
+CONFIG_ARCH="arm"
+CONFIG_ARCH_BOARD="rddrone-bms772"
+CONFIG_ARCH_BOARD_RDDRONE_BMS772=y
+CONFIG_ARCH_CHIP="s32k1xx"
+CONFIG_ARCH_CHIP_S32K144=y
+CONFIG_ARCH_CHIP_S32K14X=y
+CONFIG_ARCH_CHIP_S32K1XX=y
+CONFIG_ARCH_STACKDUMP=y
+CONFIG_ARMV7M_LIBM=y
+CONFIG_ARMV7M_MEMCPY=y
+CONFIG_BINFMT_DISABLE=y
+CONFIG_BOARD_LOOPSPERMSEC=3997
+CONFIG_BUILTIN=y
+CONFIG_CANUTILS_LIBCANARDV1=y
+CONFIG_CLOCK_MONOTONIC=y
+CONFIG_DEBUG_ERROR=y
+CONFIG_DEBUG_FEATURES=y
+CONFIG_DEBUG_SYMBOLS=y
+CONFIG_DEV_GPIO=y
+CONFIG_DEV_GPIO_NSIGNALS=5
+CONFIG_EXAMPLES_HELLO=y
+CONFIG_FS_PROCFS=y
+CONFIG_FS_ROMFS=y
+CONFIG_I2C=y
+CONFIG_I2C_DRIVER=y
+CONFIG_LIBC_FLOATINGPOINT=y
+CONFIG_LIBM=y
+CONFIG_LPUART0_RXBUFSIZE=64
+CONFIG_LPUART0_TXBUFSIZE=64
+CONFIG_LPUART1_RXBUFSIZE=64
+CONFIG_LPUART1_SERIAL_CONSOLE=y
+CONFIG_LPUART1_TXBUFSIZE=64
+CONFIG_MAX_TASKS=16
+CONFIG_MAX_WDOGPARMS=2
+CONFIG_NET=y
+CONFIG_NETDEV_CAN_BITRATE_IOCTL=y
+CONFIG_NETDEV_IFINDEX=y
+CONFIG_NET_CAN=y
+CONFIG_NET_CAN_NOTIFIER=y
+CONFIG_NET_CAN_RAW_TX_DEADLINE=y
+CONFIG_NET_CAN_SOCK_OPTS=y
+CONFIG_NET_TIMESTAMP=y
+CONFIG_NFILE_DESCRIPTORS=20
+CONFIG_NSH_ARCHINIT=y
+CONFIG_NSH_ARCHROMFS=y
+CONFIG_NSH_BUILTIN_APPS=y
+CONFIG_NSH_DISABLE_DATE=y
+CONFIG_NSH_FILEIOSIZE=512
+CONFIG_NSH_READLINE=y
+CONFIG_NSH_ROMFSETC=y
+CONFIG_NXP_BMS=y
+CONFIG_PATH_MAX=128
+CONFIG_PREALLOC_MQ_MSGS=4
+CONFIG_PREALLOC_TIMERS=4
+CONFIG_PREALLOC_WDOGS=16
+CONFIG_RAM_SIZE=61440
+CONFIG_RAM_START=0x1fff8000
+CONFIG_RAW_BINARY=y
+CONFIG_RR_INTERVAL=200
+CONFIG_RTC=y
+CONFIG_RTC_FREQUENCY=32768
+CONFIG_RTC_HIRES=y
+CONFIG_S32K1XX_EEEPROM=y
+CONFIG_S32K1XX_FLEXCAN0=y
+CONFIG_S32K1XX_GPIOIRQ=y
+CONFIG_S32K1XX_LPI2C0=y
+CONFIG_S32K1XX_LPSPI0=y
+CONFIG_S32K1XX_LPSPI1=y
+CONFIG_S32K1XX_LPUART0=y
+CONFIG_S32K1XX_LPUART1=y
+CONFIG_S32K1XX_PORTAINTS=y
+CONFIG_S32K1XX_PORTBINTS=y
+CONFIG_S32K1XX_PORTCINTS=y
+CONFIG_S32K1XX_PORTDINTS=y
+CONFIG_S32K1XX_PORTEINTS=y
+CONFIG_S32K1XX_RTC=y
+CONFIG_SCHED_CPULOAD=y
+CONFIG_SCHED_LPWORK=y
+CONFIG_SCHED_LPWORKSTACKSIZE=1536
+CONFIG_SCHED_WAITPID=y
+CONFIG_SDCLONE_DISABLE=y
+CONFIG_SIG_DEFAULT=y
+CONFIG_SPI_DRIVER=y
+CONFIG_STACK_COLORATION=y
+CONFIG_START_DAY=18
+CONFIG_START_MONTH=8
+CONFIG_START_YEAR=2019
+CONFIG_STDIO_DISABLE_BUFFERING=y
+CONFIG_SYMTAB_ORDEREDBYNAME=y
+CONFIG_SYSLOG_CONSOLE=y
+CONFIG_SYSTEM_NSH=y
+CONFIG_USERLED=y
+CONFIG_USERLED_LOWER=y
+CONFIG_USER_ENTRYPOINT="nsh_main"
diff --git a/boards/arm/s32k1xx/rddrone-bms772/configs/nsh/defconfig b/boards/arm/s32k1xx/rddrone-bms772/configs/nsh/defconfig
new file mode 100644
index 0000000000..d09b448a68
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/configs/nsh/defconfig
@@ -0,0 +1,72 @@
+#
+# This file is autogenerated: PLEASE DO NOT EDIT IT.
+#
+# You can use "make menuconfig" to make any modifications to the installed .config file.
+# You can then do "make savedefconfig" to generate a new defconfig file that includes your
+# modifications.
+#
+# CONFIG_ARCH_FPU is not set
+# CONFIG_NSH_ARGCAT is not set
+# CONFIG_NSH_CMDOPT_HEXDUMP is not set
+# CONFIG_NSH_CMDPARMS is not set
+CONFIG_ARCH="arm"
+CONFIG_ARCH_BOARD="rddrone-bms772"
+CONFIG_ARCH_BOARD_RDDRONE_BMS772=y
+CONFIG_ARCH_CHIP="s32k1xx"
+CONFIG_ARCH_CHIP_S32K144=y
+CONFIG_ARCH_CHIP_S32K14X=y
+CONFIG_ARCH_CHIP_S32K1XX=y
+CONFIG_ARCH_STACKDUMP=y
+CONFIG_BOARD_LOOPSPERMSEC=3997
+CONFIG_BUILTIN=y
+CONFIG_EXAMPLES_HELLO=y
+CONFIG_FS_PROCFS=y
+CONFIG_HAVE_CXX=y
+CONFIG_HAVE_CXXINITIALIZE=y
+CONFIG_I2C=y
+CONFIG_I2CTOOL_DEFFREQ=100000
+CONFIG_I2CTOOL_MAXADDR=0x7f
+CONFIG_I2CTOOL_MAXBUS=0
+CONFIG_I2CTOOL_MINADDR=0x00
+CONFIG_INTELHEX_BINARY=y
+CONFIG_LPUART0_RXBUFSIZE=64
+CONFIG_LPUART0_TXBUFSIZE=64
+CONFIG_LPUART1_RXBUFSIZE=64
+CONFIG_LPUART1_SERIAL_CONSOLE=y
+CONFIG_LPUART1_TXBUFSIZE=64
+CONFIG_MAX_TASKS=16
+CONFIG_MAX_WDOGPARMS=2
+CONFIG_MOTOROLA_SREC=y
+CONFIG_NFILE_DESCRIPTORS=8
+CONFIG_NFILE_STREAMS=8
+CONFIG_NSH_ARCHINIT=y
+CONFIG_NSH_BUILTIN_APPS=y
+CONFIG_NSH_FILEIOSIZE=512
+CONFIG_NSH_READLINE=y
+CONFIG_PREALLOC_MQ_MSGS=4
+CONFIG_PREALLOC_TIMERS=4
+CONFIG_PREALLOC_WDOGS=16
+CONFIG_RAM_SIZE=61440
+CONFIG_RAM_START=0x1fff8000
+CONFIG_RAW_BINARY=y
+CONFIG_RR_INTERVAL=200
+CONFIG_S32K1XX_LPI2C0=y
+CONFIG_S32K1XX_LPSPI0=y
+CONFIG_S32K1XX_LPSPI1=y
+CONFIG_S32K1XX_LPUART0=y
+CONFIG_S32K1XX_LPUART1=y
+CONFIG_SCHED_WAITPID=y
+CONFIG_SDCLONE_DISABLE=y
+CONFIG_SPITOOL_DEFFREQ=400000
+CONFIG_SPITOOL_MAXBUS=0
+CONFIG_SPITOOL_PROGNAME="spi"
+CONFIG_START_DAY=18
+CONFIG_START_MONTH=8
+CONFIG_START_YEAR=2019
+CONFIG_STDIO_DISABLE_BUFFERING=y
+CONFIG_SYMTAB_ORDEREDBYNAME=y
+CONFIG_SYSTEM_I2CTOOL=y
+CONFIG_SYSTEM_NSH=y
+CONFIG_SYSTEM_NSH_CXXINITIALIZE=y
+CONFIG_SYSTEM_SPITOOL=y
+CONFIG_USER_ENTRYPOINT="nsh_main"
\ No newline at end of file
diff --git a/boards/arm/s32k1xx/rddrone-bms772/configs/nshdebug/defconfig b/boards/arm/s32k1xx/rddrone-bms772/configs/nshdebug/defconfig
new file mode 100644
index 0000000000..ab2ec7a278
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/configs/nshdebug/defconfig
@@ -0,0 +1,74 @@
+#
+# This file is autogenerated: PLEASE DO NOT EDIT IT.
+#
+# You can use "make menuconfig" to make any modifications to the installed .config file.
+# You can then do "make savedefconfig" to generate a new defconfig file that includes your
+# modifications.
+#
+# CONFIG_ARCH_FPU is not set
+# CONFIG_NSH_ARGCAT is not set
+# CONFIG_NSH_CMDOPT_HEXDUMP is not set
+# CONFIG_NSH_CMDPARMS is not set
+CONFIG_ARCH="arm"
+CONFIG_ARCH_BOARD="rddrone-bms772"
+CONFIG_ARCH_BOARD_RDDRONE_BMS772=y
+CONFIG_ARCH_CHIP="s32k1xx"
+CONFIG_ARCH_CHIP_S32K144=y
+CONFIG_ARCH_CHIP_S32K14X=y
+CONFIG_ARCH_CHIP_S32K1XX=y
+CONFIG_ARCH_STACKDUMP=y
+CONFIG_BOARD_LOOPSPERMSEC=3997
+CONFIG_BUILTIN=y
+CONFIG_DEBUG_FEATURES=y
+CONFIG_DEBUG_SYMBOLS=y
+CONFIG_EXAMPLES_HELLO=y
+CONFIG_FS_PROCFS=y
+CONFIG_HAVE_CXX=y
+CONFIG_HAVE_CXXINITIALIZE=y
+CONFIG_I2C=y
+CONFIG_I2CTOOL_DEFFREQ=100000
+CONFIG_I2CTOOL_MAXADDR=0x7f
+CONFIG_I2CTOOL_MAXBUS=0
+CONFIG_I2CTOOL_MINADDR=0x00
+CONFIG_INTELHEX_BINARY=y
+CONFIG_LPUART0_RXBUFSIZE=64
+CONFIG_LPUART0_TXBUFSIZE=64
+CONFIG_LPUART1_RXBUFSIZE=64
+CONFIG_LPUART1_SERIAL_CONSOLE=y
+CONFIG_LPUART1_TXBUFSIZE=64
+CONFIG_MAX_TASKS=16
+CONFIG_MAX_WDOGPARMS=2
+CONFIG_MOTOROLA_SREC=y
+CONFIG_NFILE_DESCRIPTORS=8
+CONFIG_NFILE_STREAMS=8
+CONFIG_NSH_ARCHINIT=y
+CONFIG_NSH_BUILTIN_APPS=y
+CONFIG_NSH_FILEIOSIZE=512
+CONFIG_NSH_READLINE=y
+CONFIG_PREALLOC_MQ_MSGS=4
+CONFIG_PREALLOC_TIMERS=4
+CONFIG_PREALLOC_WDOGS=16
+CONFIG_RAM_SIZE=61440
+CONFIG_RAM_START=0x1fff8000
+CONFIG_RAW_BINARY=y
+CONFIG_RR_INTERVAL=200
+CONFIG_S32K1XX_LPI2C0=y
+CONFIG_S32K1XX_LPSPI0=y
+CONFIG_S32K1XX_LPSPI1=y
+CONFIG_S32K1XX_LPUART0=y
+CONFIG_S32K1XX_LPUART1=y
+CONFIG_SCHED_WAITPID=y
+CONFIG_SDCLONE_DISABLE=y
+CONFIG_SPITOOL_DEFFREQ=400000
+CONFIG_SPITOOL_MAXBUS=0
+CONFIG_SPITOOL_PROGNAME="spi"
+CONFIG_START_DAY=18
+CONFIG_START_MONTH=8
+CONFIG_START_YEAR=2019
+CONFIG_STDIO_DISABLE_BUFFERING=y
+CONFIG_SYMTAB_ORDEREDBYNAME=y
+CONFIG_SYSTEM_I2CTOOL=y
+CONFIG_SYSTEM_NSH=y
+CONFIG_SYSTEM_NSH_CXXINITIALIZE=y
+CONFIG_SYSTEM_SPITOOL=y
+CONFIG_USER_ENTRYPOINT="nsh_main"
\ No newline at end of file
diff --git a/boards/arm/s32k1xx/rddrone-bms772/configs/nshsv/defconfig b/boards/arm/s32k1xx/rddrone-bms772/configs/nshsv/defconfig
new file mode 100644
index 0000000000..0341ee9878
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/configs/nshsv/defconfig
@@ -0,0 +1,1540 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Nuttx/x86_64 Configuration
+#
+
+#
+# Build Setup
+#
+# CONFIG_EXPERIMENTAL is not set
+# CONFIG_DEFAULT_SMALL is not set
+CONFIG_DEFAULT_TASK_STACKSIZE=2048
+CONFIG_HOST_LINUX=y
+# CONFIG_HOST_MACOS is not set
+# CONFIG_HOST_WINDOWS is not set
+# CONFIG_HOST_OTHER is not set
+
+#
+# Build Configuration
+#
+CONFIG_APPS_DIR="../apps"
+CONFIG_BUILD_FLAT=y
+# CONFIG_BUILD_2PASS is not set
+
+#
+# Binary Output Formats
+#
+# CONFIG_INTELHEX_BINARY is not set
+# CONFIG_MOTOROLA_SREC is not set
+CONFIG_RAW_BINARY=y
+# CONFIG_UBOOT_UIMAGE is not set
+# CONFIG_DFU_BINARY is not set
+
+#
+# Customize Header Files
+#
+# CONFIG_ARCH_HAVE_STDINT_H is not set
+# CONFIG_ARCH_HAVE_STDBOOL_H is not set
+# CONFIG_ARCH_HAVE_MATH_H is not set
+CONFIG_ARCH_FLOAT_H=y
+CONFIG_ARCH_HAVE_STDARG_H=y
+# CONFIG_ARCH_STDARG_H is not set
+CONFIG_ARCH_HAVE_SETJMP=y
+# CONFIG_ARCH_SETJMP_H is not set
+# CONFIG_ARCH_DEBUG_H is not set
+
+#
+# Debug Options
+#
+CONFIG_DEBUG_ALERT=y
+CONFIG_DEBUG_FEATURES=y
+
+#
+# Debug SYSLOG Output Controls
+#
+# CONFIG_DEBUG_ERROR is not set
+# CONFIG_DEBUG_ASSERTIONS is not set
+
+#
+# Subsystem Debug Options
+#
+# CONFIG_DEBUG_FS is not set
+# CONFIG_DEBUG_GRAPHICS is not set
+# CONFIG_DEBUG_LIB is not set
+# CONFIG_DEBUG_MM is not set
+# CONFIG_DEBUG_NET is not set
+# CONFIG_DEBUG_POWER is not set
+# CONFIG_DEBUG_SCHED is not set
+
+#
+# OS Function Debug Options
+#
+# CONFIG_DEBUG_IRQ is not set
+
+#
+# Driver Debug Options
+#
+# CONFIG_DEBUG_LEDS is not set
+# CONFIG_DEBUG_GPIO is not set
+# CONFIG_DEBUG_I2C is not set
+# CONFIG_DEBUG_RTC is not set
+# CONFIG_DEBUG_SPI is not set
+# CONFIG_DEBUG_TIMER is not set
+CONFIG_ARCH_HAVE_STACKCHECK=y
+CONFIG_STACK_COLORATION=y
+# CONFIG_ARCH_HAVE_HEAPCHECK is not set
+CONFIG_DEBUG_SYMBOLS=y
+CONFIG_ARCH_HAVE_CUSTOMOPT=y
+CONFIG_DEBUG_NOOPT=y
+# CONFIG_DEBUG_CUSTOMOPT is not set
+# CONFIG_DEBUG_FULLOPT is not set
+
+#
+# System Type
+#
+CONFIG_ARCH_ARM=y
+# CONFIG_ARCH_AVR is not set
+# CONFIG_ARCH_HC is not set
+# CONFIG_ARCH_MIPS is not set
+# CONFIG_ARCH_MISOC is not set
+# CONFIG_ARCH_RENESAS is not set
+# CONFIG_ARCH_RISCV is not set
+# CONFIG_ARCH_SIM is not set
+# CONFIG_ARCH_X86 is not set
+# CONFIG_ARCH_X86_64 is not set
+# CONFIG_ARCH_XTENSA is not set
+# CONFIG_ARCH_Z16 is not set
+# CONFIG_ARCH_Z80 is not set
+# CONFIG_ARCH_OR1K is not set
+CONFIG_ARCH="arm"
+
+#
+# ARM Options
+#
+# CONFIG_ARCH_CHIP_A1X is not set
+# CONFIG_ARCH_CHIP_AM335X is not set
+# CONFIG_ARCH_CHIP_C5471 is not set
+# CONFIG_ARCH_CHIP_DM320 is not set
+# CONFIG_ARCH_CHIP_EFM32 is not set
+# CONFIG_ARCH_CHIP_IMX1 is not set
+# CONFIG_ARCH_CHIP_IMX6 is not set
+# CONFIG_ARCH_CHIP_IMXRT is not set
+# CONFIG_ARCH_CHIP_KINETIS is not set
+# CONFIG_ARCH_CHIP_KL is not set
+# CONFIG_ARCH_CHIP_LC823450 is not set
+# CONFIG_ARCH_CHIP_LM is not set
+# CONFIG_ARCH_CHIP_LPC17XX_40XX is not set
+# CONFIG_ARCH_CHIP_LPC214X is not set
+# CONFIG_ARCH_CHIP_LPC2378 is not set
+# CONFIG_ARCH_CHIP_LPC31XX is not set
+# CONFIG_ARCH_CHIP_LPC43XX is not set
+# CONFIG_ARCH_CHIP_LPC54XX is not set
+# CONFIG_ARCH_CHIP_MAX326XX is not set
+# CONFIG_ARCH_CHIP_MOXART is not set
+# CONFIG_ARCH_CHIP_NRF52 is not set
+# CONFIG_ARCH_CHIP_NUC1XX is not set
+CONFIG_ARCH_CHIP_S32K1XX=y
+# CONFIG_ARCH_CHIP_SAMA5 is not set
+# CONFIG_ARCH_CHIP_SAMD2X is not set
+# CONFIG_ARCH_CHIP_SAML2X is not set
+# CONFIG_ARCH_CHIP_SAMD5X is not set
+# CONFIG_ARCH_CHIP_SAME5X is not set
+# CONFIG_ARCH_CHIP_SAM34 is not set
+# CONFIG_ARCH_CHIP_SAMV7 is not set
+# CONFIG_ARCH_CHIP_STM32 is not set
+# CONFIG_ARCH_CHIP_STM32F0 is not set
+# CONFIG_ARCH_CHIP_STM32L0 is not set
+# CONFIG_ARCH_CHIP_STM32G0 is not set
+# CONFIG_ARCH_CHIP_STM32F7 is not set
+# CONFIG_ARCH_CHIP_STM32H7 is not set
+# CONFIG_ARCH_CHIP_STM32L4 is not set
+# CONFIG_ARCH_CHIP_STR71X is not set
+# CONFIG_ARCH_CHIP_TMS570 is not set
+# CONFIG_ARCH_CHIP_TIVA is not set
+# CONFIG_ARCH_CHIP_XMC4 is not set
+# CONFIG_ARCH_CHIP_CXD56XX is not set
+# CONFIG_ARCH_ARM7TDMI is not set
+# CONFIG_ARCH_ARM920T is not set
+# CONFIG_ARCH_ARM926EJS is not set
+# CONFIG_ARCH_ARM1136J is not set
+# CONFIG_ARCH_ARM1156T2 is not set
+# CONFIG_ARCH_ARM1176JZ is not set
+# CONFIG_ARCH_CORTEXM0 is not set
+CONFIG_ARCH_ARMV7M=y
+# CONFIG_ARCH_CORTEXM3 is not set
+CONFIG_ARCH_CORTEXM4=y
+# CONFIG_ARCH_CORTEXM7 is not set
+# CONFIG_ARCH_ARMV7A is not set
+# CONFIG_ARCH_CORTEXA5 is not set
+# CONFIG_ARCH_CORTEXA7 is not set
+# CONFIG_ARCH_CORTEXA8 is not set
+# CONFIG_ARCH_CORTEXA9 is not set
+# CONFIG_ARCH_ARMV7R is not set
+# CONFIG_ARCH_CORTEXR4 is not set
+# CONFIG_ARCH_CORTEXR5 is not set
+# CONFIG_ARCH_CORTEXR7 is not set
+# CONFIG_ARCH_ARMV8M is not set
+# CONFIG_ARCH_CORTEXM23 is not set
+# CONFIG_ARCH_CORTEXM33 is not set
+# CONFIG_ARCH_CORTEXM35P is not set
+CONFIG_ARCH_FAMILY="armv7-m"
+CONFIG_ARCH_CHIP="s32k1xx"
+# CONFIG_ARCH_HAVE_TRUSTZONE is not set
+CONFIG_ARM_HAVE_MPU_UNIFIED=y
+# CONFIG_ARM_MPU is not set
+CONFIG_ARCH_HAVE_HARDFAULT_DEBUG=y
+# CONFIG_DEBUG_HARDFAULT_ALERT is not set
+CONFIG_ARCH_HAVE_MEMFAULT_DEBUG=y
+# CONFIG_ARM_SEMIHOSTING_SYSLOG is not set
+
+#
+# ARMV7M Configuration Options
+#
+# CONFIG_ARMV7M_HAVE_ICACHE is not set
+# CONFIG_ARMV7M_HAVE_DCACHE is not set
+# CONFIG_ARMV7M_LAZYFPU is not set
+# CONFIG_ARMV7M_USEBASEPRI is not set
+# CONFIG_ARMV7M_HAVE_ITCM is not set
+# CONFIG_ARMV7M_HAVE_DTCM is not set
+# CONFIG_ARMV7M_TOOLCHAIN_IARL is not set
+# CONFIG_ARMV7M_TOOLCHAIN_BUILDROOT is not set
+CONFIG_ARMV7M_TOOLCHAIN_GNU_EABIL=y
+# CONFIG_ARMV7M_TOOLCHAIN_CLANGL is not set
+# CONFIG_ARMV7M_HAVE_STACKCHECK is not set
+# CONFIG_ARMV7M_ITMSYSLOG is not set
+CONFIG_FLEXCAN0_ARBI_BITRATE=1000000
+CONFIG_FLEXCAN0_ARBI_SAMPLEP=80
+CONFIG_FLEXCAN0_DATA_BITRATE=4000000
+CONFIG_FLEXCAN0_DATA_SAMPLEP=90
+# CONFIG_ARCH_CHIP_S32K116 is not set
+# CONFIG_ARCH_CHIP_S32K118 is not set
+# CONFIG_ARCH_CHIP_S32K142 is not set
+CONFIG_ARCH_CHIP_S32K144=y
+# CONFIG_ARCH_CHIP_S32K146 is not set
+# CONFIG_ARCH_CHIP_S32K148 is not set
+CONFIG_ARCH_CHIP_S32K14X=y
+# CONFIG_S32K1XX_HAVE_ENET is not set
+CONFIG_S32K1XX_HAVE_EWM=y
+# CONFIG_S32K1XX_HAVE_FIRC_CMU is not set
+CONFIG_S32K1XX_HAVE_FTM2=y
+CONFIG_S32K1XX_HAVE_FTM3=y
+# CONFIG_S32K1XX_HAVE_FTM4 is not set
+# CONFIG_S32K1XX_HAVE_FTM5 is not set
+# CONFIG_S32K1XX_HAVE_FTM6 is not set
+# CONFIG_S32K1XX_HAVE_FTM7 is not set
+CONFIG_S32K1XX_HAVE_HSRUN=y
+CONFIG_S32K1XX_HAVE_LMEM=y
+# CONFIG_S32K1XX_HAVE_LPI2C1 is not set
+CONFIG_S32K1XX_HAVE_LPSPI1=y
+CONFIG_S32K1XX_HAVE_LPSPI2=y
+CONFIG_S32K1XX_HAVE_FLEXCAN1=y
+CONFIG_S32K1XX_HAVE_FLEXCAN2=y
+# CONFIG_S32K1XX_HAVE_QSPI is not set
+# CONFIG_S32K1XX_HAVE_SAI is not set
+CONFIG_S32K1XX_HAVE_SPLL=y
+# CONFIG_S32K1XX_FTM is not set
+CONFIG_S32K1XX_LPUART=y
+CONFIG_S32K1XX_LPI2C=y
+CONFIG_S32K1XX_LPSPI=y
+CONFIG_S32K1XX_FLEXCAN=y
+
+#
+# S32K1XX Peripheral Selection
+#
+# CONFIG_S32K1XX_EDMA is not set
+CONFIG_S32K1XX_FLEXCAN0=y
+# CONFIG_S32K1XX_FLEXCAN1 is not set
+# CONFIG_S32K1XX_FLEXCAN2 is not set
+# CONFIG_S32K1XX_FTM0 is not set
+# CONFIG_S32K1XX_FTM1 is not set
+# CONFIG_S32K1XX_FTM2 is not set
+# CONFIG_S32K1XX_FTM3 is not set
+CONFIG_S32K1XX_LPI2C0=y
+CONFIG_S32K1XX_LPSPI0=y
+CONFIG_S32K1XX_LPSPI1=y
+# CONFIG_S32K1XX_LPSPI2 is not set
+CONFIG_S32K1XX_LPUART0=y
+CONFIG_S32K1XX_LPUART1=y
+# CONFIG_S32K1XX_LPUART2 is not set
+CONFIG_S32K1XX_RTC=y
+# CONFIG_S32K1XX_PROGMEM is not set
+CONFIG_S32K1XX_EEEPROM=y
+CONFIG_S32K1XX_WDT_DISABLE=y
+
+#
+# S32K1xx GPIO Interrupt Configuration
+#
+CONFIG_S32K1XX_GPIOIRQ=y
+CONFIG_S32K1XX_PORTAINTS=y
+CONFIG_S32K1XX_PORTBINTS=y
+CONFIG_S32K1XX_PORTCINTS=y
+CONFIG_S32K1XX_PORTDINTS=y
+CONFIG_S32K1XX_PORTEINTS=y
+
+#
+# S32K1xx FLASH Configuration
+#
+
+#
+# CAREFUL: Bad selections may lock up your board
+#
+CONFIG_S32K1XX_FLASHCFG_BACKDOOR1=0xffffffff
+CONFIG_S32K1XX_FLASHCFG_BACKDOOR2=0xffffffff
+CONFIG_S32K1XX_FLASHCFG_FPROT=0xffffffff
+CONFIG_S32K1XX_FLASHCFG_FSEC=0xfe
+CONFIG_S32K1XX_FLASHCFG_FOPT=0x7f
+CONFIG_S32K1XX_FLASHCFG_FEPROT=0xff
+CONFIG_S32K1XX_FLASHCFG_FDPROT=0xff
+
+#
+# LPI2C0 Configuration
+#
+CONFIG_LPI2C0_BUSYIDLE=0
+CONFIG_LPI2C0_FILTSCL=0
+CONFIG_LPI2C0_FILTSDA=0
+
+#
+# FLEXCAN0 Configuration
+#
+CONFIG_ARCH_BOARD="rddrone-bms772"
+# CONFIG_ARCH_TOOLCHAIN_IAR is not set
+CONFIG_ARCH_TOOLCHAIN_GNU=y
+# CONFIG_ARCH_GNU_NO_WEAKFUNCTIONS is not set
+# CONFIG_ARCH_SIZET_LONG is not set
+
+#
+# Architecture Options
+#
+# CONFIG_ARCH_NOINTC is not set
+# CONFIG_ARCH_VECNOTIRQ is not set
+CONFIG_ARCH_HAVE_IRQTRIGGER=y
+# CONFIG_ARCH_DMA is not set
+CONFIG_ARCH_HAVE_IRQPRIO=y
+# CONFIG_ARCH_ICACHE is not set
+# CONFIG_ARCH_DCACHE is not set
+# CONFIG_ARCH_L2CACHE is not set
+# CONFIG_ARCH_HAVE_ADDRENV is not set
+# CONFIG_ARCH_NEED_ADDRENV_MAPPING is not set
+# CONFIG_ARCH_HAVE_MODULE_TEXT is not set
+# CONFIG_ARCH_HAVE_MULTICPU is not set
+CONFIG_ARCH_HAVE_VFORK=y
+CONFIG_ARCH_HAVE_FPU=y
+# CONFIG_ARCH_HAVE_DPFPU is not set
+CONFIG_ARCH_HAVE_LAZYFPU=y
+# CONFIG_ARCH_HAVE_MMU is not set
+CONFIG_ARCH_HAVE_MPU=y
+# CONFIG_ARCH_NAND_HWECC is not set
+# CONFIG_ARCH_HAVE_EXTCLK is not set
+# CONFIG_ARCH_HAVE_POWEROFF is not set
+# CONFIG_ARCH_HAVE_PROGMEM is not set
+CONFIG_ARCH_HAVE_RESET=y
+CONFIG_ARCH_HAVE_TESTSET=y
+CONFIG_ARCH_HAVE_FETCHADD=y
+# CONFIG_ARCH_HAVE_RTC_SUBSECONDS is not set
+# CONFIG_ARCH_GLOBAL_IRQDISABLE is not set
+# CONFIG_ARCH_HAVE_SYSCALL_HOOKS is not set
+CONFIG_ARCH_FPU=y
+# CONFIG_ARCH_USE_MPU is not set
+# CONFIG_ARCH_IRQPRIO is not set
+CONFIG_ARCH_STACKDUMP=y
+# CONFIG_ENDIAN_BIG is not set
+# CONFIG_ARCH_IDLE_CUSTOM is not set
+# CONFIG_ARCH_HAVE_RAMFUNCS is not set
+CONFIG_ARCH_HAVE_RAMVECTORS=y
+# CONFIG_ARCH_RAMVECTORS is not set
+# CONFIG_ARCH_MINIMAL_VECTORTABLE is not set
+
+#
+# Board Settings
+#
+CONFIG_BOARD_LOOPSPERMSEC=3997
+
+#
+# Interrupt options
+#
+CONFIG_ARCH_HAVE_INTERRUPTSTACK=y
+CONFIG_ARCH_INTERRUPTSTACK=0
+CONFIG_ARCH_HAVE_HIPRI_INTERRUPT=y
+# CONFIG_ARCH_HIPRI_INTERRUPT is not set
+
+#
+# Boot options
+#
+# CONFIG_BOOT_RUNFROMEXTSRAM is not set
+CONFIG_BOOT_RUNFROMFLASH=y
+# CONFIG_BOOT_RUNFROMISRAM is not set
+# CONFIG_BOOT_RUNFROMSDRAM is not set
+# CONFIG_BOOT_COPYTORAM is not set
+
+#
+# Boot Memory Configuration
+#
+CONFIG_RAM_START=0x1fff8000
+CONFIG_RAM_SIZE=61440
+# CONFIG_ARCH_HAVE_SDRAM is not set
+
+#
+# Board Selection
+#
+# CONFIG_ARCH_BOARD_S32K144EVB is not set
+CONFIG_ARCH_BOARD_RDDRONE_BMS772=y
+# CONFIG_ARCH_BOARD_RDDRONE_UAVCAN144 is not set
+# CONFIG_ARCH_BOARD_RDDRONE_UWB144 is not set
+# CONFIG_ARCH_BOARD_CUSTOM is not set
+
+#
+# Common Board Options
+#
+CONFIG_ARCH_HAVE_LEDS=y
+# CONFIG_ARCH_LEDS is not set
+
+#
+# Board-Specific Options
+#
+# CONFIG_BOARD_CRASHDUMP is not set
+CONFIG_LIB_BOARDCTL=y
+# CONFIG_BOARDCTL_FINALINIT is not set
+# CONFIG_BOARDCTL_RESET is not set
+# CONFIG_BOARDCTL_UNIQUEID is not set
+CONFIG_BOARDCTL_MKRD=y
+CONFIG_BOARDCTL_ROMDISK=y
+# CONFIG_BOARDCTL_APP_SYMTAB is not set
+# CONFIG_BOARDCTL_TESTSET is not set
+# CONFIG_BOARDCTL_IOCTL is not set
+
+#
+# RTOS Features
+#
+CONFIG_DISABLE_OS_API=y
+# CONFIG_DISABLE_POSIX_TIMERS is not set
+# CONFIG_DISABLE_PTHREAD is not set
+# CONFIG_DISABLE_MQUEUE is not set
+# CONFIG_DISABLE_ENVIRON is not set
+
+#
+# Clocks and Timers
+#
+CONFIG_USEC_PER_TICK=10000
+# CONFIG_SYSTEMTICK_HOOK is not set
+# CONFIG_SYSTEM_TIME64 is not set
+CONFIG_CLOCK_MONOTONIC=y
+# CONFIG_ARCH_HAVE_TIMEKEEPING is not set
+# CONFIG_JULIAN_TIME is not set
+CONFIG_START_YEAR=2019
+CONFIG_START_MONTH=8
+CONFIG_START_DAY=18
+CONFIG_MAX_WDOGPARMS=2
+CONFIG_PREALLOC_WDOGS=16
+CONFIG_WDOG_INTRESERVE=4
+CONFIG_PREALLOC_TIMERS=4
+
+#
+# Tasks and Scheduling
+#
+# CONFIG_SPINLOCK is not set
+# CONFIG_IRQCHAIN is not set
+# CONFIG_IRQCOUNT is not set
+# CONFIG_INIT_NONE is not set
+CONFIG_INIT_ENTRYPOINT=y
+CONFIG_USER_ENTRYPOINT="nsh_main"
+CONFIG_USERMAIN_PRIORITY=100
+CONFIG_RR_INTERVAL=200
+# CONFIG_SCHED_SPORADIC is not set
+CONFIG_TASK_NAME_SIZE=31
+CONFIG_MAX_TASKS=16
+# CONFIG_SCHED_HAVE_PARENT is not set
+CONFIG_SCHED_WAITPID=y
+# CONFIG_SCHED_USER_IDENTITY is not set
+
+#
+# Pthread Options
+#
+# CONFIG_PTHREAD_MUTEX_TYPES is not set
+CONFIG_PTHREAD_MUTEX_ROBUST=y
+# CONFIG_PTHREAD_MUTEX_UNSAFE is not set
+# CONFIG_PTHREAD_MUTEX_BOTH is not set
+# CONFIG_PTHREAD_CLEANUP is not set
+# CONFIG_CANCELLATION_POINTS is not set
+
+#
+# Performance Monitoring
+#
+# CONFIG_SCHED_SUSPENDSCHEDULER is not set
+# CONFIG_SCHED_RESUMESCHEDULER is not set
+# CONFIG_SCHED_IRQMONITOR is not set
+# CONFIG_SCHED_CRITMONITOR is not set
+CONFIG_SCHED_CPULOAD=y
+# CONFIG_SCHED_CPULOAD_EXTCLK is not set
+CONFIG_SCHED_CPULOAD_TIMECONSTANT=2
+# CONFIG_SCHED_INSTRUMENTATION is not set
+
+#
+# Files and I/O
+#
+CONFIG_DEV_CONSOLE=y
+# CONFIG_FDCLONE_DISABLE is not set
+# CONFIG_FDCLONE_STDIO is not set
+CONFIG_SDCLONE_DISABLE=y
+CONFIG_NFILE_DESCRIPTORS=20
+CONFIG_NFILE_STREAMS=16
+CONFIG_NAME_MAX=32
+CONFIG_PATH_MAX=128
+CONFIG_PRIORITY_INHERITANCE=y
+CONFIG_SEM_PREALLOCHOLDERS=16
+CONFIG_SEM_NNESTPRIO=16
+
+#
+# RTOS hooks
+#
+# CONFIG_BOARD_EARLY_INITIALIZE is not set
+# CONFIG_BOARD_LATE_INITIALIZE is not set
+# CONFIG_SCHED_STARTHOOK is not set
+# CONFIG_SCHED_ATEXIT is not set
+# CONFIG_SCHED_ONEXIT is not set
+
+#
+# Signal Configuration
+#
+# CONFIG_SIG_EVTHREAD is not set
+CONFIG_SIG_DEFAULT=y
+
+#
+# Per-signal Default Actions
+#
+# CONFIG_SIG_SIGUSR1_ACTION is not set
+# CONFIG_SIG_SIGUSR2_ACTION is not set
+# CONFIG_SIG_SIGALRM_ACTION is not set
+CONFIG_SIG_SIGSTOP_ACTION=y
+CONFIG_SIG_SIGKILL_ACTION=y
+CONFIG_SIG_SIGPIPE_ACTION=y
+
+#
+# Signal Numbers
+#
+
+#
+# Standard Signal Numbers
+#
+CONFIG_SIG_SIGUSR1=1
+CONFIG_SIG_SIGUSR2=2
+CONFIG_SIG_SIGALRM=3
+CONFIG_SIG_STOP=6
+CONFIG_SIG_STP=7
+CONFIG_SIG_CONT=8
+CONFIG_SIG_KILL=9
+CONFIG_SIG_INT=10
+CONFIG_SIG_PIPE=11
+
+#
+# Non-standard Signal Numbers
+#
+CONFIG_SIG_SIGCONDTIMEDOUT=16
+CONFIG_SIG_SIGWORK=17
+
+#
+# POSIX Message Queue Options
+#
+CONFIG_PREALLOC_MQ_MSGS=4
+CONFIG_MQ_MAXMSGSIZE=32
+# CONFIG_MODULE is not set
+
+#
+# Work queue support
+#
+CONFIG_SCHED_WORKQUEUE=y
+CONFIG_WQUEUE_NOTIFIER=y
+# CONFIG_SCHED_HPWORK is not set
+CONFIG_SCHED_LPWORK=y
+CONFIG_SCHED_LPNTHREADS=1
+CONFIG_SCHED_LPWORKPRIORITY=100
+CONFIG_SCHED_LPWORKPRIOMAX=176
+CONFIG_SCHED_LPWORKSTACKSIZE=1024
+
+#
+# Stack and heap information
+#
+CONFIG_IDLETHREAD_STACKSIZE=1024
+CONFIG_USERMAIN_STACKSIZE=2048
+CONFIG_PTHREAD_STACK_MIN=256
+CONFIG_PTHREAD_STACK_DEFAULT=1024
+# CONFIG_LIB_SYSCALL is not set
+CONFIG_SYSTEMVIEW_ENABLE=y
+CONFIG_SYSTEMVIEW_APP_NAME="NuttX_BMS"
+CONFIG_SYSTEMVIEW_DEVICE_NAME="S32K144"
+CONFIG_SYSTEMVIEW_CPU_FREQ=80000000
+CONFIG_SYSTEMVIEW_TIMESTAMP_FREQ=80000000
+CONFIG_SYSTEMVIEW_RES_ID_BASE=0x00000000
+CONFIG_SYSTEMVIEW_RES_ID_SHIFT=0
+# CONFIG_SYSTEMVIEW_START_ON_INIT is not set
+CONFIG_SYSTEMVIEW_SYSDESC_0="I#11=SVC,I#15=SysTick"
+CONFIG_SYSTEMVIEW_SYSDESC_1=""
+CONFIG_SYSTEMVIEW_SYSDESC_2=""
+CONFIG_SYSTEMVIEW_RECORD_API=y
+CONFIG_SYSTEMVIEW_RECORD_ISR=y
+CONFIG_SYSTEMVIEW_BUFFER_SIZE=0
+CONFIG_SYSTEMVIEW_RTT_CHANNEL=0
+CONFIG_SYSTEMVIEW_USE_STATIC_BUFFER=y
+# CONFIG_SYSTEMVIEW_POST_MORTEM_MODE is not set
+CONFIG_SYSTEMVIEW_MAX_NOF_TASKS=16
+
+#
+# Device Drivers
+#
+# CONFIG_DEV_SIMPLE_ADDRENV is not set
+CONFIG_DEV_NULL=y
+# CONFIG_DEV_ZERO is not set
+CONFIG_DRVR_MKRD=y
+
+#
+# Buffering
+#
+# CONFIG_DRVR_WRITEBUFFER is not set
+# CONFIG_DRVR_READAHEAD is not set
+# CONFIG_DEV_URANDOM is not set
+# CONFIG_DEV_LOOP is not set
+# CONFIG_ARCH_HAVE_CAN_ERRORS is not set
+# CONFIG_CAN is not set
+# CONFIG_ARCH_HAVE_I2CRESET is not set
+CONFIG_I2C=y
+# CONFIG_I2C_SLAVE is not set
+# CONFIG_I2C_POLLED is not set
+# CONFIG_I2C_TRACE is not set
+CONFIG_I2C_DRIVER=y
+
+#
+# I2C Multiplexer Support
+#
+# CONFIG_I2CMULTIPLEXER_PCA9540BDP is not set
+# CONFIG_ARCH_HAVE_SPI_CRCGENERATION is not set
+# CONFIG_ARCH_HAVE_SPI_CS_CONTROL is not set
+# CONFIG_ARCH_HAVE_SPI_BITORDER is not set
+CONFIG_SPI=y
+# CONFIG_SPI_SLAVE is not set
+CONFIG_SPI_EXCHANGE=y
+# CONFIG_SPI_CMDDATA is not set
+# CONFIG_SPI_CALLBACK is not set
+# CONFIG_SPI_HWFEATURES is not set
+# CONFIG_SPI_CS_DELAY_CONTROL is not set
+# CONFIG_SPI_TRIGGER is not set
+CONFIG_SPI_DRIVER=y
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_I2S is not set
+
+#
+# Timer Driver Support
+#
+# CONFIG_ARCH_HAVE_PWM_PULSECOUNT is not set
+# CONFIG_ARCH_HAVE_PWM_MULTICHAN is not set
+# CONFIG_PWM is not set
+# CONFIG_TIMER is not set
+# CONFIG_ONESHOT is not set
+CONFIG_RTC=y
+# CONFIG_RTC_DATETIME is not set
+CONFIG_RTC_HIRES=y
+CONFIG_RTC_FREQUENCY=32768
+# CONFIG_RTC_ALARM is not set
+# CONFIG_RTC_DRIVER is not set
+# CONFIG_RTC_EXTERNAL is not set
+# CONFIG_WATCHDOG is not set
+# CONFIG_TIMERS_CS2100CP is not set
+# CONFIG_ANALOG is not set
+# CONFIG_DRIVERS_AUDIO is not set
+# CONFIG_DRIVERS_VIDEO is not set
+# CONFIG_BCH is not set
+# CONFIG_INPUT is not set
+
+#
+# IO Expander/GPIO Support
+#
+# CONFIG_IOEXPANDER is not set
+CONFIG_DEV_GPIO=y
+CONFIG_DEV_GPIO_NSIGNALS=5
+
+#
+# LCD Driver Support
+#
+# CONFIG_LCD is not set
+
+#
+# Character/Segment LCD Devices
+#
+# CONFIG_SLCD is not set
+
+#
+# Other LCD-related Devices
+#
+# CONFIG_LCD_OTHER is not set
+
+#
+# LED Support
+#
+CONFIG_USERLED=y
+CONFIG_USERLED_LOWER=y
+# CONFIG_LEDS_APA102 is not set
+# CONFIG_LEDS_MAX7219 is not set
+# CONFIG_RGBLED is not set
+# CONFIG_PCA9635PW is not set
+# CONFIG_NCP5623C is not set
+# CONFIG_ARCH_HAVE_SDIO is not set
+# CONFIG_ARCH_HAVE_SDIOWAIT_WRCOMPLETE is not set
+# CONFIG_ARCH_HAVE_SDIO_PREFLIGHT is not set
+# CONFIG_ARCH_HAVE_SDIO_DELAYED_INVLDT is not set
+# CONFIG_MMCSD is not set
+# CONFIG_MODEM is not set
+# CONFIG_MTD is not set
+# CONFIG_EEPROM is not set
+# CONFIG_NETDEVICES is not set
+# CONFIG_PIPES is not set
+# CONFIG_PM is not set
+# CONFIG_DRIVERS_POWERLED is not set
+# CONFIG_DRIVERS_SMPS is not set
+# CONFIG_DRIVERS_MOTOR is not set
+# CONFIG_POWER is not set
+# CONFIG_SENSORS is not set
+CONFIG_ARCH_HAVE_SERIAL_TERMIOS=y
+CONFIG_SERIAL=y
+# CONFIG_SERIAL_REMOVABLE is not set
+CONFIG_SERIAL_CONSOLE=y
+# CONFIG_16550_UART is not set
+# CONFIG_OTHER_UART_SERIALDRIVER is not set
+CONFIG_MCU_SERIAL=y
+CONFIG_STANDARD_SERIAL=y
+CONFIG_SERIAL_NPOLLWAITERS=2
+# CONFIG_SERIAL_IFLOWCONTROL is not set
+# CONFIG_SERIAL_RS485CONTROL is not set
+# CONFIG_SERIAL_OFLOWCONTROL is not set
+# CONFIG_SERIAL_TXDMA is not set
+# CONFIG_SERIAL_RXDMA is not set
+# CONFIG_SERIAL_TIOCSERGSTRUCT is not set
+# CONFIG_SERIAL_TERMIOS is not set
+# CONFIG_LPUART0_SERIAL_CONSOLE is not set
+CONFIG_LPUART1_SERIAL_CONSOLE=y
+# CONFIG_OTHER_SERIAL_CONSOLE is not set
+# CONFIG_NO_SERIAL_CONSOLE is not set
+# CONFIG_UART_SERIALDRIVER is not set
+# CONFIG_UART0_SERIALDRIVER is not set
+# CONFIG_UART1_SERIALDRIVER is not set
+# CONFIG_UART2_SERIALDRIVER is not set
+# CONFIG_UART3_SERIALDRIVER is not set
+# CONFIG_UART4_SERIALDRIVER is not set
+# CONFIG_UART5_SERIALDRIVER is not set
+# CONFIG_UART6_SERIALDRIVER is not set
+# CONFIG_UART7_SERIALDRIVER is not set
+# CONFIG_UART8_SERIALDRIVER is not set
+# CONFIG_LPUART_SERIALDRIVER is not set
+CONFIG_LPUART0_SERIALDRIVER=y
+CONFIG_LPUART1_SERIALDRIVER=y
+# CONFIG_LPUART2_SERIALDRIVER is not set
+# CONFIG_LPUART3_SERIALDRIVER is not set
+# CONFIG_LPUART4_SERIALDRIVER is not set
+# CONFIG_LPUART5_SERIALDRIVER is not set
+# CONFIG_LPUART6_SERIALDRIVER is not set
+# CONFIG_LPUART7_SERIALDRIVER is not set
+# CONFIG_LPUART8_SERIALDRIVER is not set
+
+#
+# LPUART0 Configuration
+#
+CONFIG_LPUART0_RXBUFSIZE=64
+CONFIG_LPUART0_TXBUFSIZE=64
+CONFIG_LPUART0_BAUD=115200
+CONFIG_LPUART0_BITS=8
+CONFIG_LPUART0_PARITY=0
+CONFIG_LPUART0_2STOP=0
+CONFIG_LPUART0_NOIFLOWCONTROL=y
+# CONFIG_LPUART0_RS485RTSCONTROL is not set
+# CONFIG_LPUART0_IFLOWCONTROL is not set
+# CONFIG_LPUART0_OFLOWCONTROL is not set
+# CONFIG_LPUART0_RXDMA is not set
+# CONFIG_LPUART0_TXDMA is not set
+
+#
+# LPUART1 Configuration
+#
+CONFIG_LPUART1_RXBUFSIZE=64
+CONFIG_LPUART1_TXBUFSIZE=64
+CONFIG_LPUART1_BAUD=115200
+CONFIG_LPUART1_BITS=8
+CONFIG_LPUART1_PARITY=0
+CONFIG_LPUART1_2STOP=0
+CONFIG_LPUART1_NOIFLOWCONTROL=y
+# CONFIG_LPUART1_RS485RTSCONTROL is not set
+# CONFIG_LPUART1_IFLOWCONTROL is not set
+# CONFIG_LPUART1_OFLOWCONTROL is not set
+# CONFIG_LPUART1_RXDMA is not set
+# CONFIG_LPUART1_TXDMA is not set
+# CONFIG_USART0_SERIALDRIVER is not set
+# CONFIG_USART1_SERIALDRIVER is not set
+# CONFIG_USART2_SERIALDRIVER is not set
+# CONFIG_USART3_SERIALDRIVER is not set
+# CONFIG_USART4_SERIALDRIVER is not set
+# CONFIG_USART5_SERIALDRIVER is not set
+# CONFIG_USART6_SERIALDRIVER is not set
+# CONFIG_USART7_SERIALDRIVER is not set
+# CONFIG_USART8_SERIALDRIVER is not set
+# CONFIG_USART9_SERIALDRIVER is not set
+# CONFIG_SCI0_SERIALDRIVER is not set
+# CONFIG_SCI1_SERIALDRIVER is not set
+# CONFIG_SCI2_SERIALDRIVER is not set
+# CONFIG_SCI3_SERIALDRIVER is not set
+# CONFIG_SCI4_SERIALDRIVER is not set
+# CONFIG_SCI5_SERIALDRIVER is not set
+# CONFIG_SCI6_SERIALDRIVER is not set
+# CONFIG_SCI7_SERIALDRIVER is not set
+# CONFIG_SCI8_SERIALDRIVER is not set
+# CONFIG_SCI9_SERIALDRIVER is not set
+# CONFIG_SCI10_SERIALDRIVER is not set
+# CONFIG_SCI11_SERIALDRIVER is not set
+# CONFIG_SCI12_SERIALDRIVER is not set
+# CONFIG_PSEUDOTERM is not set
+# CONFIG_USBDEV is not set
+# CONFIG_USBHOST_HAVE_ASYNCH is not set
+# CONFIG_USBHOST is not set
+# CONFIG_USBMISC is not set
+# CONFIG_HAVE_USBTRACE is not set
+# CONFIG_DRIVERS_WIRELESS is not set
+# CONFIG_DRIVERS_CONTACTLESS is not set
+# CONFIG_1WIRE is not set
+
+#
+# System Logging
+#
+# CONFIG_ARCH_SYSLOG is not set
+CONFIG_SYSLOG_WRITE=y
+# CONFIG_RAMLOG is not set
+# CONFIG_SYSLOG_BUFFER is not set
+# CONFIG_SYSLOG_INTBUFFER is not set
+# CONFIG_SYSLOG_TIMESTAMP is not set
+# CONFIG_SYSLOG_PREFIX is not set
+# CONFIG_SYSLOG_CHAR is not set
+CONFIG_SYSLOG_CONSOLE=y
+# CONFIG_SYSLOG_DEFAULT is not set
+# CONFIG_SYSLOG_FILE is not set
+# CONFIG_SYSLOG_CHARDEV is not set
+# CONFIG_DRIVERS_RF is not set
+
+#
+# Networking Support
+#
+CONFIG_ARCH_HAVE_NET=y
+# CONFIG_ARCH_HAVE_PHY is not set
+# CONFIG_ARCH_PHY_INTERRUPT is not set
+# CONFIG_ARCH_HAVE_NETDEV_STATISTICS is not set
+# CONFIG_NET_WRITE_BUFFERS is not set
+CONFIG_NET_READAHEAD=y
+# CONFIG_NET_MCASTGROUP is not set
+CONFIG_NET=y
+# CONFIG_NET_PROMISCUOUS is not set
+
+#
+# Driver buffer configuration
+#
+CONFIG_NET_GUARDSIZE=2
+
+#
+# Link layer support
+#
+# CONFIG_NET_ETHERNET is not set
+# CONFIG_NET_LOOPBACK is not set
+# CONFIG_NET_SLIP is not set
+# CONFIG_NET_TUN is not set
+# CONFIG_NET_USRSOCK is not set
+# CONFIG_NETDEV_LATEINIT is not set
+
+#
+# Network Device Operations
+#
+CONFIG_NETDEV_IOCTL=y
+# CONFIG_NETDEV_PHY_IOCTL is not set
+CONFIG_NETDEV_CAN_BITRATE_IOCTL=y
+CONFIG_NETDEV_IFINDEX=y
+# CONFIG_NETDOWN_NOTIFIER is not set
+
+#
+# Internet Protocol Selection
+#
+# CONFIG_NET_IPv4 is not set
+# CONFIG_NET_IPv6 is not set
+# CONFIG_NET_IPFORWARD is not set
+
+#
+# Socket Support
+#
+CONFIG_NSOCKET_DESCRIPTORS=8
+CONFIG_NET_NACTIVESOCKETS=16
+CONFIG_NET_SOCKOPTS=y
+# CONFIG_NET_TCPPROTO_OPTIONS is not set
+# CONFIG_NET_UDPPROTO_OPTIONS is not set
+CONFIG_NET_CANPROTO_OPTIONS=y
+CONFIG_NET_TIMESTAMP=y
+CONFIG_NET_CMSG=y
+
+#
+# Raw Socket Support
+#
+
+#
+# Unix Domain Socket Support
+#
+# CONFIG_NET_LOCAL is not set
+
+#
+# SocketCAN Support
+#
+CONFIG_NET_CAN=y
+CONFIG_NET_CAN_HAVE_TX_DEADLINE=y
+CONFIG_NET_CAN_HAVE_CANFD=y
+CONFIG_CAN_CONNS=4
+CONFIG_NET_CAN_CANFD=y
+CONFIG_NET_CAN_SOCK_OPTS=y
+CONFIG_NET_CAN_RAW_TX_DEADLINE=y
+CONFIG_NET_CAN_RAW_DEFAULT_TX_DEADLINE=0
+CONFIG_NET_CAN_RAW_FILTER_MAX=32
+CONFIG_NET_CAN_NOTIFIER=y
+
+#
+# Netlink Socket Support
+#
+# CONFIG_NET_NETLINK is not set
+
+#
+# TCP/IP Networking
+#
+# CONFIG_NET_TCP is not set
+# CONFIG_NET_TCP_NO_STACK is not set
+
+#
+# UDP Networking
+#
+# CONFIG_NET_UDP is not set
+# CONFIG_NET_UDP_NO_STACK is not set
+
+#
+# Bluetooth socket support
+#
+
+#
+# IEEE 802.15.4 socket support
+#
+
+#
+# ARP Configuration
+#
+
+#
+# User-space networking stack API
+#
+# CONFIG_NET_ARCH_INCR32 is not set
+# CONFIG_NET_ARCH_CHKSUM is not set
+# CONFIG_NET_STATISTICS is not set
+# CONFIG_NET_HAVE_STAR is not set
+
+#
+# Network Topologies
+#
+
+#
+# Routing Table Configuration
+#
+
+#
+# Crypto API
+#
+# CONFIG_CRYPTO is not set
+
+#
+# File Systems
+#
+
+#
+# File system configuration
+#
+# CONFIG_DISABLE_MOUNTPOINT is not set
+# CONFIG_FS_AUTOMOUNTER is not set
+# CONFIG_DISABLE_PSEUDOFS_OPERATIONS is not set
+# CONFIG_PSEUDOFS_SOFTLINKS is not set
+# CONFIG_FS_AIO is not set
+# CONFIG_FS_NAMED_SEMAPHORES is not set
+CONFIG_FS_MQUEUE_MPATH="/var/mqueue"
+# CONFIG_FS_RAMMAP is not set
+
+#
+# Partition Table
+#
+# CONFIG_PTABLE_PARTITION is not set
+# CONFIG_FS_FAT is not set
+# CONFIG_NFS is not set
+# CONFIG_FS_NXFFS is not set
+CONFIG_FS_ROMFS=y
+# CONFIG_FS_CROMFS is not set
+# CONFIG_FS_TMPFS is not set
+# CONFIG_FS_SMARTFS is not set
+# CONFIG_FS_BINFS is not set
+CONFIG_FS_PROCFS=y
+# CONFIG_FS_PROCFS_REGISTER is not set
+
+#
+# Exclude individual procfs entries
+#
+# CONFIG_FS_PROCFS_EXCLUDE_PROCESS is not set
+CONFIG_FS_PROCFS_EXCLUDE_ENVIRON=y
+# CONFIG_FS_PROCFS_EXCLUDE_BLOCKS is not set
+# CONFIG_FS_PROCFS_EXCLUDE_MOUNT is not set
+# CONFIG_FS_PROCFS_EXCLUDE_USAGE is not set
+# CONFIG_FS_PROCFS_EXCLUDE_UPTIME is not set
+# CONFIG_FS_PROCFS_EXCLUDE_VERSION is not set
+# CONFIG_FS_PROCFS_EXCLUDE_CPULOAD is not set
+# CONFIG_FS_PROCFS_EXCLUDE_MEMINFO is not set
+# CONFIG_FS_PROCFS_EXCLUDE_IOBINFO is not set
+# CONFIG_FS_PROCFS_EXCLUDE_MOUNTS is not set
+# CONFIG_FS_PROCFS_EXCLUDE_NET is not set
+# CONFIG_FS_SPIFFS is not set
+# CONFIG_FS_LITTLEFS is not set
+# CONFIG_FS_UNIONFS is not set
+# CONFIG_FS_HOSTFS is not set
+
+#
+# Graphics Support
+#
+# CONFIG_NX is not set
+# CONFIG_NXFONTS is not set
+
+#
+# Font Cache Pixel Depths
+#
+# CONFIG_NXFONTS_DISABLE_1BPP is not set
+# CONFIG_NXFONTS_DISABLE_2BPP is not set
+# CONFIG_NXFONTS_DISABLE_4BPP is not set
+# CONFIG_NXFONTS_DISABLE_8BPP is not set
+# CONFIG_NXFONTS_DISABLE_16BPP is not set
+# CONFIG_NXFONTS_DISABLE_24BPP is not set
+# CONFIG_NXFONTS_DISABLE_32BPP is not set
+CONFIG_NXFONTS_PACKEDMSFIRST=y
+# CONFIG_NXGLIB is not set
+
+#
+# Memory Management
+#
+# CONFIG_MM_SMALL is not set
+CONFIG_MM_REGIONS=1
+# CONFIG_ARCH_HAVE_HEAP2 is not set
+# CONFIG_GRAN is not set
+# CONFIG_MM_FILL_ALLOCATIONS is not set
+
+#
+# Common I/O Buffer Support
+#
+CONFIG_MM_IOB=y
+CONFIG_IOB_NBUFFERS=24
+CONFIG_IOB_BUFSIZE=196
+CONFIG_IOB_NCHAINS=24
+CONFIG_IOB_THROTTLE=0
+# CONFIG_IOB_NOTIFIER is not set
+# CONFIG_IOB_DEBUG is not set
+
+#
+# Audio Support
+#
+# CONFIG_AUDIO is not set
+
+#
+# Video Support
+#
+
+#
+# Video subsystem
+#
+# CONFIG_VIDEO is not set
+
+#
+# Wireless Support
+#
+# CONFIG_WIRELESS is not set
+
+#
+# Binary Loader
+#
+CONFIG_BINFMT_DISABLE=y
+CONFIG_SYMTAB_ORDEREDBYNAME=y
+
+#
+# Library Routines
+#
+
+#
+# Standard C Library Options
+#
+
+#
+# Standard C I/O
+#
+CONFIG_STDIO_DISABLE_BUFFERING=y
+CONFIG_NUNGET_CHARS=2
+# CONFIG_LIBC_PRINT_LEGACY is not set
+CONFIG_LIBC_FLOATINGPOINT=y
+CONFIG_LIBC_LONG_LONG=y
+# CONFIG_LIBC_NUMBERED_ARGS is not set
+# CONFIG_LIBC_SCANSET is not set
+# CONFIG_EOL_IS_CR is not set
+# CONFIG_EOL_IS_LF is not set
+# CONFIG_EOL_IS_BOTH_CRLF is not set
+CONFIG_EOL_IS_EITHER_CRLF=y
+CONFIG_LIBM=y
+
+#
+# Architecture-Specific Support
+#
+CONFIG_ARCH_LOWPUTC=y
+# CONFIG_ARCH_ROMGETC is not set
+CONFIG_LIBC_ARCH_MEMCPY=y
+# CONFIG_LIBC_ARCH_MEMCMP is not set
+# CONFIG_LIBC_ARCH_MEMMOVE is not set
+# CONFIG_LIBC_ARCH_MEMSET is not set
+# CONFIG_LIBC_ARCH_STRCHR is not set
+# CONFIG_LIBC_ARCH_STRCMP is not set
+# CONFIG_LIBC_ARCH_STRCPY is not set
+# CONFIG_LIBC_ARCH_STRNCPY is not set
+# CONFIG_LIBC_ARCH_STRLEN is not set
+# CONFIG_LIBC_ARCH_STRNLEN is not set
+# CONFIG_LIBC_ARCH_ELF is not set
+CONFIG_ARMV7M_MEMCPY=y
+CONFIG_ARMV7M_LIBM=y
+CONFIG_MACHINE_OPTS_ARMV7M=y
+CONFIG_LIBM_ARCH_FABSF=y
+CONFIG_LIBM_ARCH_SQRTF=y
+
+#
+# stdlib Options
+#
+CONFIG_LIB_RAND_ORDER=1
+CONFIG_LIB_HOMEDIR="/"
+CONFIG_LIBC_TMPDIR="/tmp"
+CONFIG_LIBC_MAX_TMPFILE=32
+
+#
+# Program Execution Options
+#
+CONFIG_POSIX_SPAWN_PROXY_STACKSIZE=1024
+CONFIG_TASK_SPAWN_DEFAULT_STACKSIZE=2048
+CONFIG_LIB_HOSTNAME=""
+
+#
+# errno Decode Support
+#
+# CONFIG_LIBC_STRERROR is not set
+# CONFIG_LIBC_PERROR_STDOUT is not set
+
+#
+# memcpy/memset Options
+#
+# CONFIG_MEMSET_OPTSPEED is not set
+
+#
+# pthread support
+#
+# CONFIG_LIBC_DLFCN is not set
+# CONFIG_LIBC_MODLIB is not set
+# CONFIG_LIBC_GROUP_FILE is not set
+# CONFIG_LIBC_PASSWD_FILE is not set
+# CONFIG_LIBC_WCHAR is not set
+# CONFIG_LIBC_LOCALE is not set
+# CONFIG_LIBC_LZF is not set
+
+#
+# Time/Time Zone Support
+#
+# CONFIG_LIBC_LOCALTIME is not set
+
+#
+# Thread Local Storage (TLS)
+#
+# CONFIG_TLS_ALIGNED is not set
+CONFIG_TLS_NELEM=4
+
+#
+# Network-Related Options
+#
+# CONFIG_LIBC_IPv4_ADDRCONV is not set
+# CONFIG_LIBC_IPv6_ADDRCONV is not set
+CONFIG_LIBC_NETDB=y
+
+#
+# NETDB Support
+#
+# CONFIG_LIBC_GAISTRERROR is not set
+CONFIG_NETDB_BUFSIZE=128
+CONFIG_NETDB_MAX_IPADDR=1
+# CONFIG_NETDB_HOSTFILE is not set
+CONFIG_LIB_SENDFILE_BUFSIZE=512
+
+#
+# Non-standard Library Support
+#
+# CONFIG_LIB_CRC64_FAST is not set
+# CONFIG_LIB_KBDCODEC is not set
+# CONFIG_LIB_SLCDCODEC is not set
+# CONFIG_LIB_ENVPATH is not set
+# CONFIG_LIB_HEX2BIN is not set
+CONFIG_BUILTIN=y
+
+#
+# Basic CXX Support
+#
+# CONFIG_C99_BOOL8 is not set
+# CONFIG_HAVE_CXX is not set
+# CONFIG_LIBDSP is not set
+
+#
+# Open Asymmetric Multi Processing
+#
+# CONFIG_OPENAMP is not set
+
+#
+# Application Configuration
+#
+
+#
+# CAN Utilities
+#
+# CONFIG_CANUTILS_CANDUMP is not set
+# CONFIG_CANUTILS_CANSEND is not set
+CONFIG_CANUTILS_LIBCANARDV1=y
+CONFIG_LIBCANARDV1_URL="https://github.com/UAVCAN/libcanard/archive"
+CONFIG_LIBCANARDV1_VERSION="e776368355a890543035cdae356710ade5d7baea"
+# CONFIG_CANUTILS_SLCAN is not set
+
+#
+# Examples
+#
+# CONFIG_EXAMPLES_ABNTCODI is not set
+# CONFIG_EXAMPLES_ADXL372_TEST is not set
+# CONFIG_EXAMPLES_APA102 is not set
+# CONFIG_EXAMPLES_AUDIO_SOUND is not set
+# CONFIG_EXAMPLES_BATTERY is not set
+# CONFIG_EXAMPLES_SIXAXIS is not set
+# CONFIG_EXAMPLES_CALIB_UDELAY is not set
+# CONFIG_EXAMPLES_LIBCANARDV1 is not set
+# CONFIG_EXAMPLES_CCTYPE is not set
+# CONFIG_EXAMPLES_CHARGER is not set
+# CONFIG_EXAMPLES_CHAT is not set
+# CONFIG_EXAMPLES_CHRONO is not set
+# CONFIG_EXAMPLES_CONFIGDATA is not set
+# CONFIG_EXAMPLES_DHCPD is not set
+# CONFIG_EXAMPLES_DHTXX is not set
+# CONFIG_EXAMPLES_DSPTEST is not set
+# CONFIG_EXAMPLES_FTPC is not set
+# CONFIG_EXAMPLES_FTPD is not set
+# CONFIG_EXAMPLES_GPIO is not set
+# CONFIG_EXAMPLES_GPS is not set
+CONFIG_EXAMPLES_HELLO=y
+CONFIG_EXAMPLES_HELLO_PROGNAME="hello"
+CONFIG_EXAMPLES_HELLO_PRIORITY=100
+CONFIG_EXAMPLES_HELLO_STACKSIZE=2048
+# CONFIG_EXAMPLES_HIDKBD is not set
+# CONFIG_EXAMPLES_IGMP is not set
+# CONFIG_EXAMPLES_INA219 is not set
+# CONFIG_EXAMPLES_INA226 is not set
+# CONFIG_EXAMPLES_LEDS is not set
+# CONFIG_EXAMPLES_LSM330SPI_TEST is not set
+# CONFIG_EXAMPLES_LVGLDEMO is not set
+# CONFIG_EXAMPLES_MAX31855 is not set
+# CONFIG_EXAMPLES_MEDIA is not set
+# CONFIG_EXAMPLES_MLX90614 is not set
+# CONFIG_EXAMPLES_MODBUS is not set
+# CONFIG_EXAMPLES_MODBUSMASTER is not set
+# CONFIG_EXAMPLES_MOUNT is not set
+# CONFIG_EXAMPLES_NULL is not set
+# CONFIG_EXAMPLES_NXDEMO is not set
+# CONFIG_EXAMPLES_OBD2 is not set
+# CONFIG_EXAMPLES_PCA9635 is not set
+# CONFIG_EXAMPLES_PDCURSES is not set
+# CONFIG_EXAMPLES_POSIXSPAWN is not set
+# CONFIG_EXAMPLES_POWERLED is not set
+# CONFIG_EXAMPLES_POWERMONITOR is not set
+# CONFIG_EXAMPLES_PPPD is not set
+# CONFIG_EXAMPLES_RFID_READUID is not set
+# CONFIG_EXAMPLES_RGBLED is not set
+# CONFIG_EXAMPLES_ROMFS is not set
+# CONFIG_EXAMPLES_SERIALBLASTER is not set
+# CONFIG_EXAMPLES_SERIALRX is not set
+# CONFIG_EXAMPLES_SERLOOP is not set
+# CONFIG_EXAMPLES_SLCD is not set
+# CONFIG_EXAMPLES_SMPS is not set
+# CONFIG_EXAMPLES_STAT is not set
+# CONFIG_EXAMPLES_TCPECHO is not set
+# CONFIG_EXAMPLES_THTTPD is not set
+# CONFIG_EXAMPLES_TIFF is not set
+# CONFIG_EXAMPLES_TOUCHSCREEN is not set
+# CONFIG_EXAMPLES_UID is not set
+# CONFIG_EXAMPLES_UNIONFS is not set
+# CONFIG_EXAMPLES_USBSERIAL is not set
+# CONFIG_EXAMPLES_USERFS is not set
+# CONFIG_EXAMPLES_WATCHDOG is not set
+# CONFIG_EXAMPLES_WEBSERVER is not set
+# CONFIG_EXAMPLES_XBC_TEST is not set
+
+#
+# File System Utilities
+#
+# CONFIG_FSUTILS_INIFILE is not set
+# CONFIG_FSUTILS_INIH is not set
+# CONFIG_FSUTILS_PASSWD is not set
+
+#
+# GPS Utilities
+#
+# CONFIG_GPSUTILS_MINMEA_LIB is not set
+
+#
+# Graphics Support
+#
+# CONFIG_GRAPHICS_FT80X is not set
+# CONFIG_GRAPHICS_LVGL is not set
+
+#
+# NxWidgets
+#
+
+#
+# NxWM
+#
+# CONFIG_GRAPHICS_PDCURSES is not set
+# CONFIG_TIFF is not set
+
+#
+# Industrial Applications
+#
+# CONFIG_INDUSTRY_ABNT_CODI_LIB is not set
+
+#
+# Interpreters
+#
+# CONFIG_INTERPRETERS_BAS is not set
+# CONFIG_INTERPRETERS_FICL is not set
+# CONFIG_INTERPRETERS_MINIBASIC is not set
+
+#
+# FreeModBus
+#
+# CONFIG_MODBUS is not set
+
+#
+# Network Utilities
+#
+# CONFIG_NETUTILS_CHAT is not set
+# CONFIG_NETUTILS_CJSON is not set
+# CONFIG_NETUTILS_CODECS is not set
+# CONFIG_NETUTILS_ESP8266 is not set
+# CONFIG_NETUTILS_FTPC is not set
+CONFIG_NETUTILS_NETINIT=y
+# CONFIG_NETINIT_NETLOCAL is not set
+# CONFIG_NETINIT_THREAD is not set
+# CONFIG_NETINIT_DEBUG is not set
+
+#
+# IP Address Configuration
+#
+# CONFIG_NETINIT_NOMAC is not set
+CONFIG_NETUTILS_NETLIB=y
+# CONFIG_NETUTILS_NETLIB_GENERICURLPARSER is not set
+
+#
+# NSH Library
+#
+CONFIG_NSH_LIBRARY=y
+# CONFIG_NSH_MOTD is not set
+
+#
+# Command Line Configuration
+#
+CONFIG_NSH_PROMPT_STRING="nsh> "
+CONFIG_NSH_READLINE=y
+# CONFIG_NSH_CLE is not set
+CONFIG_NSH_LINELEN=80
+# CONFIG_NSH_DISABLE_SEMICOLON is not set
+# CONFIG_NSH_QUOTE is not set
+# CONFIG_NSH_CMDPARMS is not set
+CONFIG_NSH_MAXARGUMENTS=7
+# CONFIG_NSH_ARGCAT is not set
+CONFIG_NSH_NESTDEPTH=3
+# CONFIG_NSH_DISABLEBG is not set
+CONFIG_NSH_BUILTIN_APPS=y
+
+#
+# Disable Individual commands
+#
+# CONFIG_NSH_DISABLE_BASENAME is not set
+# CONFIG_NSH_DISABLE_CAT is not set
+# CONFIG_NSH_DISABLE_CD is not set
+# CONFIG_NSH_DISABLE_CP is not set
+# CONFIG_NSH_DISABLE_CMP is not set
+CONFIG_NSH_DISABLE_DATE=y
+# CONFIG_NSH_DISABLE_DD is not set
+# CONFIG_NSH_DISABLE_DF is not set
+# CONFIG_NSH_DISABLE_DIRNAME is not set
+# CONFIG_NSH_DISABLE_ECHO is not set
+# CONFIG_NSH_DISABLE_ENV is not set
+# CONFIG_NSH_DISABLE_EXEC is not set
+# CONFIG_NSH_DISABLE_EXIT is not set
+# CONFIG_NSH_DISABLE_EXPORT is not set
+# CONFIG_NSH_DISABLE_FREE is not set
+# CONFIG_NSH_DISABLE_GET is not set
+# CONFIG_NSH_DISABLE_HELP is not set
+# CONFIG_NSH_DISABLE_HEXDUMP is not set
+# CONFIG_NSH_DISABLE_IFCONFIG is not set
+# CONFIG_NSH_DISABLE_IFUPDOWN is not set
+# CONFIG_NSH_DISABLE_KILL is not set
+# CONFIG_NSH_DISABLE_LOSETUP is not set
+CONFIG_NSH_DISABLE_LOSMART=y
+# CONFIG_NSH_DISABLE_LS is not set
+# CONFIG_NSH_DISABLE_MB is not set
+# CONFIG_NSH_DISABLE_MKDIR is not set
+# CONFIG_NSH_DISABLE_MKRD is not set
+# CONFIG_NSH_DISABLE_MH is not set
+# CONFIG_NSH_DISABLE_MOUNT is not set
+# CONFIG_NSH_DISABLE_MV is not set
+# CONFIG_NSH_DISABLE_MW is not set
+CONFIG_NSH_DISABLE_PRINTF=y
+# CONFIG_NSH_DISABLE_PS is not set
+# CONFIG_NSH_DISABLE_PSSTACKUSAGE is not set
+# CONFIG_NSH_DISABLE_PUT is not set
+# CONFIG_NSH_DISABLE_PWD is not set
+# CONFIG_NSH_DISABLE_RM is not set
+# CONFIG_NSH_DISABLE_RMDIR is not set
+# CONFIG_NSH_DISABLE_SET is not set
+# CONFIG_NSH_DISABLE_SH is not set
+# CONFIG_NSH_DISABLE_SLEEP is not set
+# CONFIG_NSH_DISABLE_TIME is not set
+# CONFIG_NSH_DISABLE_TEST is not set
+# CONFIG_NSH_DISABLE_TELNETD is not set
+CONFIG_NSH_DISABLE_TRUNCATE=y
+# CONFIG_NSH_DISABLE_UMOUNT is not set
+# CONFIG_NSH_DISABLE_UNAME is not set
+# CONFIG_NSH_DISABLE_UNSET is not set
+# CONFIG_NSH_DISABLE_USLEEP is not set
+# CONFIG_NSH_DISABLE_WGET is not set
+# CONFIG_NSH_DISABLE_XD is not set
+CONFIG_NSH_MMCSDMINOR=0
+
+#
+# Configure Command Options
+#
+# CONFIG_NSH_VARS is not set
+# CONFIG_NSH_CMDOPT_DD_STATS is not set
+CONFIG_NSH_CODECS_BUFSIZE=128
+# CONFIG_NSH_CMDOPT_HEXDUMP is not set
+CONFIG_NSH_PROC_MOUNTPOINT="/proc"
+CONFIG_NSH_FILEIOSIZE=512
+
+#
+# Scripting Support
+#
+# CONFIG_NSH_DISABLESCRIPT is not set
+# CONFIG_NSH_DISABLE_ITEF is not set
+# CONFIG_NSH_DISABLE_LOOPS is not set
+CONFIG_NSH_ROMFSETC=y
+# CONFIG_NSH_ROMFSRC is not set
+CONFIG_NSH_ROMFSMOUNTPT="/etc"
+CONFIG_NSH_INITSCRIPT="init.d/rcS"
+CONFIG_NSH_ROMFSDEVNO=0
+CONFIG_NSH_ROMFSSECTSIZE=64
+# CONFIG_NSH_DEFAULTROMFS is not set
+CONFIG_NSH_ARCHROMFS=y
+# CONFIG_NSH_CUSTOMROMFS is not set
+
+#
+# Console Configuration
+#
+CONFIG_NSH_CONSOLE=y
+# CONFIG_NSH_ALTCONDEV is not set
+CONFIG_NSH_ARCHINIT=y
+
+#
+# Networking Configuration
+#
+CONFIG_NSH_NETINIT=y
+# CONFIG_NSH_LOGIN is not set
+# CONFIG_NSH_CONSOLE_LOGIN is not set
+
+#
+# nxp_bms
+#
+CONFIG_NXP_BMS=y
+CONFIG_NXP_BMS_PROGNAME="bms"
+CONFIG_NXP_BMS_PRIORITY=100
+CONFIG_NXP_BMS_STACKSIZE=2048
+# CONFIG_NXP_BMS_HELLO2 is not set
+# CONFIG_NXP_BMS_HELLO is not set
+# CONFIG_NXP_BMS_SPIGPIO is not set
+# CONFIG_NXP_BMS_SPITOOL is not set
+
+#
+# nxp_uwb
+#
+# CONFIG_NXP_UWB_HELLO is not set
+# CONFIG_NXP_UWB_UWB is not set
+
+#
+# Platform-specific Support
+#
+# CONFIG_PLATFORM_CONFIGDATA is not set
+
+#
+# System Libraries and NSH Add-Ons
+#
+# CONFIG_SYSTEM_CLE is not set
+# CONFIG_SYSTEM_CUTERM is not set
+# CONFIG_SYSTEM_EMBEDLOG is not set
+# CONFIG_SYSTEM_HEX2BIN is not set
+# CONFIG_SYSTEM_HEXED is not set
+# CONFIG_SYSTEM_I2CTOOL is not set
+# CONFIG_SYSTEM_NETDB is not set
+CONFIG_SYSTEM_NSH=y
+CONFIG_SYSTEM_NSH_PRIORITY=100
+CONFIG_SYSTEM_NSH_STACKSIZE=2048
+CONFIG_SYSTEM_NSH_PROGNAME="nsh"
+# CONFIG_SYSTEM_POPEN is not set
+# CONFIG_SYSTEM_RAMTEST is not set
+CONFIG_READLINE_HAVE_EXTMATCH=y
+CONFIG_SYSTEM_READLINE=y
+CONFIG_READLINE_ECHO=y
+# CONFIG_READLINE_TABCOMPLETION is not set
+# CONFIG_READLINE_CMD_HISTORY is not set
+# CONFIG_SYSTEM_SETLOGMASK is not set
+# CONFIG_SYSTEM_SPITOOL is not set
+# CONFIG_SYSTEM_STACKMONITOR is not set
+# CONFIG_SYSTEM_SYSTEM is not set
+# CONFIG_SYSTEM_TEE is not set
+# CONFIG_SYSTEM_TERMCURSES is not set
+# CONFIG_SYSTEM_UBLOXMODEM is not set
+# CONFIG_SYSTEM_VI is not set
+# CONFIG_SYSTEM_ZMODEM is not set
+
+#
+# Testing
+#
+# CONFIG_TESTING_FSTEST is not set
+# CONFIG_TESTING_GETPRIME is not set
+# CONFIG_TESTING_MM is not set
+# CONFIG_TESTING_NXFFS is not set
+# CONFIG_TESTING_OSTEST is not set
+# CONFIG_TESTING_SCANFTEST is not set
+# CONFIG_TESTING_SMART is not set
+# CONFIG_TESTING_SMART_TEST is not set
+# CONFIG_TESTING_UNITY is not set
+
+#
+# Wireless Libraries and NSH Add-Ons
+#
+
+#
+# Bluetooth applications
+#
+# CONFIG_BTSAK is not set
+
+#
+# IEEE 802.15.4 applications
+#
+# CONFIG_IEEE802154_I8SAK is not set
+# CONFIG_IEEE802154_LIBMAC is not set
+# CONFIG_IEEE802154_LIBUTILS is not set
diff --git a/boards/arm/s32k1xx/rddrone-bms772/include/board.h b/boards/arm/s32k1xx/rddrone-bms772/include/board.h
new file mode 100644
index 0000000000..02d230a770
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/include/board.h
@@ -0,0 +1,162 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/rddrone-bms772/include/board.h
+ *
+ *   Copyright (C) 2019 Gregory Nutt. All rights reserved.
+ *   Author: Gregory Nutt <gnutt@nuttx.org>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+#ifndef __BOARDS_ARM_RDDRONE_BMS772_INCLUDE_BOARD_H
+#define __BOARDS_ARM_RDDRONE_BMS772_INCLUDE_BOARD_H
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#ifndef __ASSEMBLY__
+#  include <stdint.h>
+#  include <stdbool.h>
+#endif
+
+/****************************************************************************
+ * Pre-processor Definitions
+ ****************************************************************************/
+
+/* Clocking *****************************************************************/
+
+/* The RDDRONE-BMS772 is fitted with a 32 MHz Crystal */
+
+#define BOARD_XTAL_FREQUENCY 32000000
+
+/* The S32K144 will run at 80 MHz */
+
+/* LED definitions **********************************************************/
+
+/* The RDDRONE-BMS772 has one RGB LED:
+ *
+ *   RedLED   PTD16 (FTM0 CH1)
+ *   GreenLED PTB13 (FTM0 CH1)
+ *   BlueLED  PTD15 (FTM0 CH0)
+ *
+ * If CONFIG_ARCH_LEDS is not defined, then the user can control the LEDs in
+ * any way.  The following definitions are used to access individual RGB
+ * components.
+ *
+ * The RGB components could, alternatively be controlled through PWM using
+ * the common RGB LED driver.
+ */
+
+/* LED index values for use with board_userled() */
+
+#define BOARD_LED_R       0
+#define BOARD_LED_G       1
+#define BOARD_LED_B       2
+#define BOARD_NLEDS       3
+
+/* LED bits for use with board_userled_all() */
+
+#define BOARD_LED_R_BIT   (1 << BOARD_LED_R)
+#define BOARD_LED_G_BIT   (1 << BOARD_LED_G)
+#define BOARD_LED_B_BIT   (1 << BOARD_LED_B)
+
+/* If CONFIG_ARCH_LEDs is defined, then NuttX will control the LEDs on board
+ * the RDDRONE-BMS772.  The following definitions describe how NuttX
+ * controls the LEDs:
+ *
+ *   SYMBOL                Meaning                      LED state
+ *                                                      RED   GREEN  BLUE
+ *   -------------------  ----------------------------  -----------------
+ */
+
+#define LED_STARTED       1 /* NuttX has been started    OFF   OFF    OFF */
+#define LED_HEAPALLOCATE  2 /* Heap has been allocated   OFF   OFF    ON  */
+#define LED_IRQSENABLED   0 /* Interrupts enabled        OFF   OFF    ON  */
+#define LED_STACKCREATED  3 /* Idle stack created        OFF   ON     OFF */
+#define LED_INIRQ         0 /* In an interrupt          (no change)       */
+#define LED_SIGNAL        0 /* In a signal handler      (no change)       */
+#define LED_ASSERTION     0 /* An assertion failed      (no change)       */
+#define LED_PANIC         4 /* The system has crashed    FLASH OFF    OFF */
+#undef  LED_IDLE            /* RDDRONE-BMS772 in sleep mode (Not used)    */
+
+/* Button definitions *******************************************************/
+
+/* The rddrone-bms772 supports one button:
+ *
+ *   SW1  PTC14
+ */
+
+#define BUTTON_SW1         0
+
+#define NUM_BUTTONS        1
+
+#define BUTTON_SW1_BIT    (1 << BUTTON_SW1)
+
+/* Alternate function pin selections ****************************************/
+
+/* By default, the serial console will be provided on the OpenSDA VCOM port:
+ *
+ *   OpenSDA UART TX  PTC7 (LPUART1_TX)
+ *   OpenSDA UART RX  PTC6 (LPUART1_RX)
+ */
+
+/* optional UART on connector J21                   */
+#define PIN_LPUART0_RX    PIN_LPUART0_RX_1  /* PTB0 */
+#define PIN_LPUART0_TX    PIN_LPUART0_TX_1  /* PTB1 */
+
+/* NuttX console                                    */
+#define PIN_LPUART1_RX    PIN_LPUART1_RX_1  /* PTC6 */
+#define PIN_LPUART1_TX    PIN_LPUART1_TX_1  /* PTC7 */
+
+/* SPI selections ***********************************************************/
+
+/* SBC connection through SPI 0                     */
+#define PIN_LPSPI0_SCK   PIN_LPSPI0_SCK_2   /* PTB2 */
+#define PIN_LPSPI0_MISO  PIN_LPSPI0_SIN_2   /* PTB3 */
+#define PIN_LPSPI0_MOSI  PIN_LPSPI0_SOUT_3  /* PTB4 */
+#define PIN_LPSPI0_PCS   PIN_LPSPI0_PCS0_2  /* PTB5 */
+
+/* BCC connection through SPI 1                     */
+#define PIN_LPSPI1_SCK   PIN_LPSPI1_SCK_2   /* PTD0 */
+#define PIN_LPSPI1_MISO  PIN_LPSPI1_SIN_2   /* PTD1 */
+#define PIN_LPSPI1_MOSI  PIN_LPSPI1_SOUT_2  /* PTD2 */
+#define PIN_LPSPI1_PCS   PIN_LPSPI1_PCS0_1  /* PTD3 */
+
+/* I2C selections ***********************************************************/
+
+#define PIN_LPI2C0_SCL   PIN_LPI2C0_SCL_2   /* PTA3 */
+#define PIN_LPI2C0_SDA	 PIN_LPI2C0_SDA_2   /* PTA2 */
+
+/* CAN selections ***********************************************************/
+#define PIN_CAN0_TX      PIN_CAN0_TX_3      /* PTE5 */
+#define PIN_CAN0_RX      PIN_CAN0_RX_3      /* PTE4 */
+
+#endif  /* __BOARDS_ARM_RDDRONE_BMS772_INCLUDE_BOARD_H */
diff --git a/boards/arm/s32k1xx/rddrone-bms772/include/nsh_romfsimg.h b/boards/arm/s32k1xx/rddrone-bms772/include/nsh_romfsimg.h
new file mode 100644
index 0000000000..5e3d107769
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/include/nsh_romfsimg.h
@@ -0,0 +1,89 @@
+const unsigned char romfs_img[] = {
+  0x2d, 0x72, 0x6f, 0x6d, 0x31, 0x66, 0x73, 0x2d, 0x00, 0x00, 0x02, 0x70,
+  0xe9, 0x59, 0x88, 0x5d, 0x4e, 0x53, 0x48, 0x49, 0x6e, 0x69, 0x74, 0x56,
+  0x6f, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x49,
+  0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0xd1, 0xff, 0xff, 0x97,
+  0x2e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x20,
+  0x00, 0x00, 0x00, 0x00, 0xd1, 0xd1, 0xff, 0x80, 0x2e, 0x2e, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00,
+  0x68, 0x2d, 0x96, 0x03, 0x69, 0x6e, 0x69, 0x74, 0x2e, 0x64, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3a,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x8b, 0x8d, 0x9c, 0xa9, 0x3b,
+  0x72, 0x63, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x23, 0x20, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65,
+  0x20, 0x72, 0x63, 0x53, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x3b, 0x20, 0x79,
+  0x6f, 0x75, 0x20, 0x6d, 0x75, 0x73, 0x74, 0x20, 0x72, 0x75, 0x6e, 0x20,
+  0x74, 0x6f, 0x6f, 0x6c, 0x73, 0x2f, 0x67, 0x65, 0x6e, 0x72, 0x6f, 0x6d,
+  0x66, 0x73, 0x20, 0x3c, 0x6e, 0x75, 0x74, 0x74, 0x78, 0x20, 0x64, 0x69,
+  0x72, 0x3e, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x77, 0x69, 0x74, 0x68,
+  0x69, 0x6e, 0x20, 0x74, 0x68, 0x69, 0x73, 0x0a, 0x23, 0x20, 0x6c, 0x6f,
+  0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x74, 0x6f, 0x20, 0x63, 0x6f,
+  0x6e, 0x76, 0x65, 0x72, 0x74, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x66,
+  0x69, 0x6c, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x6e, 0x73, 0x68, 0x5f, 0x72,
+  0x6f, 0x6d, 0x66, 0x73, 0x69, 0x6d, 0x67, 0x2e, 0x68, 0x20, 0x66, 0x6f,
+  0x72, 0x20, 0x69, 0x6e, 0x63, 0x6c, 0x75, 0x73, 0x69, 0x6f, 0x6e, 0x20,
+  0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x75, 0x69, 0x6c, 0x64,
+  0x0a, 0x23, 0x20, 0x65, 0x63, 0x68, 0x6f, 0x20, 0x22, 0x54, 0x68, 0x69,
+  0x73, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x74, 0x61,
+  0x72, 0x74, 0x75, 0x70, 0x20, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x22,
+  0x0a, 0x23, 0x20, 0x65, 0x63, 0x68, 0x6f, 0x20, 0x22, 0x43, 0x6f, 0x75,
+  0x6e, 0x74, 0x64, 0x6f, 0x77, 0x6e, 0x22, 0x0a, 0x23, 0x20, 0x73, 0x6c,
+  0x65, 0x65, 0x70, 0x20, 0x31, 0x0a, 0x23, 0x20, 0x65, 0x63, 0x68, 0x6f,
+  0x20, 0x22, 0x33, 0x22, 0x0a, 0x23, 0x20, 0x73, 0x6c, 0x65, 0x65, 0x70,
+  0x20, 0x31, 0x0a, 0x23, 0x20, 0x65, 0x63, 0x68, 0x6f, 0x20, 0x22, 0x32,
+  0x22, 0x0a, 0x23, 0x20, 0x73, 0x6c, 0x65, 0x65, 0x70, 0x20, 0x31, 0x0a,
+  0x23, 0x20, 0x65, 0x63, 0x68, 0x6f, 0x20, 0x22, 0x31, 0x22, 0x0a, 0x23,
+  0x20, 0x73, 0x6c, 0x65, 0x65, 0x70, 0x20, 0x31, 0x0a, 0x20, 0x65, 0x63,
+  0x68, 0x6f, 0x20, 0x22, 0x53, 0x74, 0x61, 0x72, 0x74, 0x69, 0x6e, 0x67,
+  0x20, 0x42, 0x4d, 0x53, 0x22, 0x0a, 0x20, 0x73, 0x6c, 0x65, 0x65, 0x70,
+  0x20, 0x31, 0x0a, 0x22, 0x66, 0x72, 0x65, 0x65, 0x22, 0x0a, 0x65, 0x63,
+  0x68, 0x6f, 0x20, 0x22, 0x53, 0x74, 0x61, 0x72, 0x74, 0x69, 0x6e, 0x67,
+  0x20, 0x63, 0x61, 0x6e, 0x30, 0x22, 0x0a, 0x22, 0x69, 0x66, 0x75, 0x70,
+  0x22, 0x20, 0x22, 0x63, 0x61, 0x6e, 0x30, 0x22, 0x0a, 0x22, 0x62, 0x6d,
+  0x73, 0x22, 0x0a, 0x20, 0x73, 0x6c, 0x65, 0x65, 0x70, 0x20, 0x31, 0x0a,
+  0x20, 0x65, 0x63, 0x68, 0x6f, 0x20, 0x22, 0x53, 0x74, 0x61, 0x72, 0x74,
+  0x65, 0x64, 0x22, 0x0a, 0x20, 0x23, 0x20, 0x73, 0x6c, 0x65, 0x65, 0x70,
+  0x20, 0x31, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x50,
+  0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0xd1, 0xd1, 0xfd, 0x90,
+  0x2e, 0x2e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60,
+  0x00, 0x00, 0x00, 0x00, 0xd1, 0xff, 0xff, 0xa0, 0x2e, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00
+};
+const unsigned int romfs_img_len = 1024;
diff --git a/boards/arm/s32k1xx/rddrone-bms772/include/rcS.template b/boards/arm/s32k1xx/rddrone-bms772/include/rcS.template
new file mode 100644
index 0000000000..749d48a926
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/include/rcS.template
@@ -0,0 +1,20 @@
+# sample rcS file; you must run tools/genromfs <nuttx dir> from within this
+# location to convert this file to nsh_romfsimg.h for inclusion in the build
+# echo "This is the startup script"
+# echo "Countdown"
+# sleep 1
+# echo "3"
+# sleep 1
+# echo "2"
+# sleep 1
+# echo "1"
+# sleep 1
+ echo "Starting BMS"
+ sleep 1
+"free"
+echo "Starting can0"
+"ifup" "can0"
+"bms"
+ sleep 1
+ echo "Started"
+ # sleep 1
diff --git a/boards/arm/s32k1xx/rddrone-bms772/scripts/Make.defs b/boards/arm/s32k1xx/rddrone-bms772/scripts/Make.defs
new file mode 100644
index 0000000000..ef6d67909e
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/scripts/Make.defs
@@ -0,0 +1,108 @@
+############################################################################
+# boards/arm/s32k1xx/rddrone-bms772/scripts/Make.defs
+#
+#   Copyright (C) 2018 Gregory Nutt. All rights reserved.
+#   Author: Gregory Nutt <gnutt@nuttx.org>
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in
+#    the documentation and/or other materials provided with the
+#    distribution.
+# 3. Neither the name NuttX nor the names of its contributors may be
+#    used to endorse or promote products derived from this software
+#    without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+# OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+# AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+############################################################################
+
+include $(TOPDIR)/.config
+include $(TOPDIR)/tools/Config.mk
+include $(TOPDIR)/arch/arm/src/armv7-m/Toolchain.defs
+
+ifeq ($(CONFIG_BOOT_RUNFROMFLASH),y)
+ LDSCRIPT = flash.ld
+else ifeq ($(CONFIG_BOOT_RUNFROMISRAM),y)
+ LDSCRIPT = sram.ld
+endif
+
+$(warning, LDSCRIPT is $(LDSCRIPT))
+CINCPATH := ${shell $(INCDIR) -s "$(CC)" $(TOPDIR)$(DELIM)include}
+CXXINCPATH := ${shell $(INCDIR) -s "$(CC)" $(TOPDIR)$(DELIM)include$(DELIM)cxx}
+
+ARCHINCLUDES += $(CINCPATH)
+ARCHXXINCLUDES += $(CINCPATH) $(CXXINCPATH)
+
+ifeq ($(CONFIG_CYGWIN_WINTOOL),y)
+  ARCHSCRIPT = -T "${shell cygpath -w $(BOARD_DIR)$(DELIM)scripts$(DELIM)$(LDSCRIPT)}"
+else
+  ARCHSCRIPT = -T$(BOARD_DIR)$(DELIM)scripts$(DELIM)$(LDSCRIPT)
+endif
+$(warning, LDSCRIPT is $(LDSCRIPT))
+$(warning, ARCHSCRIPT is $(ARCHSCRIPT))
+
+CC = $(CROSSDEV)gcc
+CXX = $(CROSSDEV)g++
+CPP = $(CROSSDEV)gcc -E
+LD = $(CROSSDEV)ld
+STRIP = $(CROSSDEV)strip --strip-unneeded
+AR = $(ARCROSSDEV)ar rcs
+NM = $(ARCROSSDEV)nm
+OBJCOPY = $(CROSSDEV)objcopy
+OBJDUMP = $(CROSSDEV)objdump
+
+ARCHCCVERSION = ${shell $(CC) -v 2>&1 | sed -n '/^gcc version/p' | sed -e 's/^gcc version \([0-9\.]\)/\1/g' -e 's/[-\ ].*//g' -e '1q'}
+ARCHCCMAJOR = ${shell echo $(ARCHCCVERSION) | cut -d'.' -f1}
+
+ifeq ($(CONFIG_DEBUG_SYMBOLS),y)
+  ARCHOPTIMIZATION = -g
+endif
+
+ifneq ($(CONFIG_DEBUG_NOOPT),y)
+  ARCHOPTIMIZATION += $(MAXOPTIMIZATION) -fno-strict-aliasing -fno-strength-reduce -fomit-frame-pointer
+endif
+
+ARCHCFLAGS = -fno-builtin
+ARCHCXXFLAGS = -fno-builtin -fno-exceptions -fcheck-new -fno-rtti
+ARCHWARNINGS = -Wall -Wstrict-prototypes -Wshadow -Wundef
+ARCHWARNINGSXX = -Wall -Wshadow -Wundef
+ARCHPICFLAGS = -fpic -msingle-pic-base -mpic-register=r10
+
+CFLAGS = $(ARCHCFLAGS) $(ARCHWARNINGS) $(ARCHOPTIMIZATION) $(ARCHCPUFLAGS) $(ARCHINCLUDES) $(ARCHDEFINES) $(EXTRAFLAGS) -pipe
+CPICFLAGS = $(ARCHPICFLAGS) $(CFLAGS)
+CXXFLAGS = $(ARCHCXXFLAGS) $(ARCHWARNINGSXX) $(ARCHOPTIMIZATION) $(ARCHCPUFLAGS) $(ARCHXXINCLUDES) $(ARCHDEFINES) $(EXTRAFLAGS) -pipe
+CXXPICFLAGS = $(ARCHPICFLAGS) $(CXXFLAGS)
+CPPFLAGS = $(ARCHINCLUDES) $(ARCHDEFINES) $(EXTRAFLAGS)
+AFLAGS = $(CFLAGS) -D__ASSEMBLY__
+
+NXFLATLDFLAGS1 = -r -d -warn-common
+NXFLATLDFLAGS2 = $(NXFLATLDFLAGS1) -T$(TOPDIR)/binfmt/libnxflat/gnu-nxflat-pcrel.ld -no-check-sections
+LDNXFLATFLAGS = -e main -s 2048
+
+ifneq ($(CROSSDEV),arm-nuttx-elf-)
+  LDFLAGS += -nostartfiles -nodefaultlibs
+endif
+ifeq ($(CONFIG_DEBUG_SYMBOLS),y)
+  LDFLAGS += -g
+endif
+
+
+HOSTCC = gcc
+HOSTCFLAGS = -Wall -Wstrict-prototypes -Wshadow -Wundef -g -pipe
diff --git a/boards/arm/s32k1xx/rddrone-bms772/scripts/flash.ld b/boards/arm/s32k1xx/rddrone-bms772/scripts/flash.ld
new file mode 100644
index 0000000000..83b003c887
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/scripts/flash.ld
@@ -0,0 +1,152 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/rddrone-bms772/scripts/flash.ld
+ *
+ *   Copyright (C) 2019 Gregory Nutt. All rights reserved.
+ *   Author: Gregory Nutt <gnutt@nuttx.org>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/* The S32K144 has 512Kb of FLASH beginning at address 0x0000:0000 and
+ * 60Kb of SRAM beginning at address 0x1fff:8000 (plus 4Kb of FlexRAM)
+ *
+ * The on-chip RAM is split in two regions: SRAM_L and SRAM_U. The RAM is
+ * implemented such that the SRAM_L and SRAM_U ranges form a contiguous
+ * block in the memory map
+ *
+ *   SRAM_L 1fff8000 - 1fffffff 32Kb
+ *   SRAM_U 20000000 - 20006fff 28Kb
+ */
+
+MEMORY
+{
+  vflash (rx) : ORIGIN = 0x00000000, LENGTH = 1K
+  pflash (rx) : ORIGIN = 0x00000400, LENGTH = 16
+  dflash (rx) : ORIGIN = 0x00000410, LENGTH = 511K-16
+  sram  (rwx) : ORIGIN = 0x1fff8000, LENGTH = 60K
+}
+
+OUTPUT_ARCH(arm)
+EXTERN(_vectors)
+EXTERN(g_flashcfg)
+ENTRY(_stext)
+
+SECTIONS
+{
+  .vectors :
+  {
+    _stext = ABSOLUTE(.);
+    *(.vectors)
+  } > vflash
+
+  .flashcfg :
+  {
+    *(.flashcfg)
+  } > pflash
+
+  .text :
+  {
+    *(.text .text.*)
+    *(.fixup)
+    *(.gnu.warning)
+    *(.rodata .rodata.*)
+    *(.gnu.linkonce.t.*)
+    *(.glue_7)
+    *(.glue_7t)
+    *(.got)
+    *(.gcc_except_table)
+    *(.gnu.linkonce.r.*)
+    _etext = ABSOLUTE(.);
+  } > dflash
+
+  .init_section :
+  {
+    _sinit = ABSOLUTE(.);
+    *(.init_array .init_array.*)
+    _einit = ABSOLUTE(.);
+  } > dflash
+
+  .ARM.extab :
+  {
+    *(.ARM.extab*)
+  } >dflash
+
+  .ARM.exidx :
+  {
+    __exidx_start = ABSOLUTE(.);
+    *(.ARM.exidx*)
+    __exidx_end = ABSOLUTE(.);
+  } >dflash
+
+  .data :
+  {
+    _sdata = ABSOLUTE(.);
+    *(.data .data.*)
+    *(.gnu.linkonce.d.*)
+    CONSTRUCTORS
+    . = ALIGN(4);
+    _edata = ABSOLUTE(.);
+  } > sram AT > dflash
+
+  _eronly = LOADADDR(.data);
+
+  .ramfunc ALIGN(4):
+  {
+    _sramfuncs = ABSOLUTE(.);
+    *(.ramfunc  .ramfunc.*)
+    _eramfuncs = ABSOLUTE(.);
+  } > sram AT > dflash
+
+  _framfuncs = LOADADDR(.ramfunc);
+
+  .bss :
+  {
+    _sbss = ABSOLUTE(.);
+    *(.bss .bss.*)
+    *(.gnu.linkonce.b.*)
+    *(COMMON)
+    . = ALIGN(4);
+    _ebss = ABSOLUTE(.);
+  } > sram
+
+  /* Stabs debugging sections. */
+
+  .stab 0 : { *(.stab) }
+  .stabstr 0 : { *(.stabstr) }
+  .stab.excl 0 : { *(.stab.excl) }
+  .stab.exclstr 0 : { *(.stab.exclstr) }
+  .stab.index 0 : { *(.stab.index) }
+  .stab.indexstr 0 : { *(.stab.indexstr) }
+  .comment 0 : { *(.comment) }
+  .debug_abbrev 0 : { *(.debug_abbrev) }
+  .debug_info 0 : { *(.debug_info) }
+  .debug_line 0 : { *(.debug_line) }
+  .debug_pubnames 0 : { *(.debug_pubnames) }
+  .debug_aranges 0 : { *(.debug_aranges) }
+}
diff --git a/boards/arm/s32k1xx/rddrone-bms772/scripts/s32k144.cfg b/boards/arm/s32k1xx/rddrone-bms772/scripts/s32k144.cfg
new file mode 100644
index 0000000000..7d30a9f05f
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/scripts/s32k144.cfg
@@ -0,0 +1,58 @@
+#
+# NXP S32K144 - 1x ARM Cortex-M4 @ up to 112 MHz
+#
+
+adapter_khz 4000
+transport select swd
+
+if { [info exists CHIPNAME] } {
+	set _CHIPNAME $CHIPNAME
+} else {
+	set _CHIPNAME s32k144
+}
+
+#
+# M4 JTAG mode TAP
+#
+if { [info exists M4_JTAG_TAPID] } {
+	set _M4_JTAG_TAPID $M4_JTAG_TAPID
+} else {
+	set _M4_JTAG_TAPID 0x4ba00477
+}
+
+#
+# M4 SWD mode TAP
+#
+if { [info exists M4_SWD_TAPID] } {
+	set _M4_SWD_TAPID $M4_SWD_TAPID
+} else {
+	set _M4_SWD_TAPID 0x2ba01477
+}
+
+source [find target/swj-dp.tcl]
+
+if { [using_jtag] } {
+	set _M4_TAPID $_M4_JTAG_TAPID
+} else {
+	set _M4_TAPID $_M4_SWD_TAPID
+}
+
+swj_newdap $_CHIPNAME m4 -irlen 4 -ircapture 0x1 -irmask 0xf \
+				-expected-id $_M4_TAPID
+
+target create $_CHIPNAME.m4 cortex_m -chain-position $_CHIPNAME.m4
+
+# S32K144 has 32+28 KB contiguous SRAM
+if { [info exists WORKAREASIZE] } {
+	set _WORKAREASIZE $WORKAREASIZE
+} else {
+	set _WORKAREASIZE 0xF000
+}
+$_CHIPNAME.m4 configure -work-area-phys 0x1FFF8000 \
+                        -work-area-size $_WORKAREASIZE -work-area-backup 0
+
+$_CHIPNAME.m4 configure -rtos nuttx
+
+if { ![using_hla] } {
+	cortex_m reset_config vectreset
+}
diff --git a/boards/arm/s32k1xx/rddrone-bms772/scripts/sram.ld b/boards/arm/s32k1xx/rddrone-bms772/scripts/sram.ld
new file mode 100644
index 0000000000..0c6b5867e0
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/scripts/sram.ld
@@ -0,0 +1,129 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/rddrone-bms772/scripts/sram.ld
+ *
+ *   Copyright (C) 2019 Gregory Nutt. All rights reserved.
+ *   Author: Gregory Nutt <gnutt@nuttx.org>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/* The S32K144 has 512Kb of FLASH beginning at address 0x0000:0000 and
+ * 60Kb of SRAM beginning at address 0x1fff:8000 (plus 4Kb of FlexRAM)
+ *
+ * The on-chip RAM is split in two regions: SRAM_L and SRAM_U. The RAM is
+ * implemented such that the SRAM_L and SRAM_U ranges form a contiguous
+ * block in the memory map
+ *
+ *   SRAM_L 1fff8000 - 1fffffff 32Kb
+ *   SRAM_U 20000000 - 20006fff 28Kb
+ */
+
+MEMORY
+{
+  flash (rx)  : ORIGIN = 0x00000000, LENGTH = 512K
+  sram  (rwx) : ORIGIN = 0x1fff8000, LENGTH = 60K
+}
+
+OUTPUT_ARCH(arm)
+EXTERN(_vectors)
+ENTRY(_stext)
+
+SECTIONS
+{
+  .text :
+  {
+    _stext = ABSOLUTE(.);
+    *(.vectors)
+    *(.text .text.*)
+    *(.fixup)
+    *(.gnu.warning)
+    *(.rodata .rodata.*)
+    *(.gnu.linkonce.t.*)
+    *(.glue_7)
+    *(.glue_7t)
+    *(.got)
+    *(.gcc_except_table)
+    *(.gnu.linkonce.r.*)
+    _etext = ABSOLUTE(.);
+  } > sram
+
+  .init_section :
+  {
+    _sinit = ABSOLUTE(.);
+    *(.init_array .init_array.*)
+    _einit = ABSOLUTE(.);
+  } > sram
+
+  .ARM.extab :
+  {
+    *(.ARM.extab*)
+  } >sram
+
+  .ARM.exidx :
+  {
+    __exidx_start = ABSOLUTE(.);
+    *(.ARM.exidx*)
+    __exidx_end = ABSOLUTE(.);
+  } >sram
+
+  .data :
+  {
+    _sdata = ABSOLUTE(.);
+    *(.data .data.*)
+    *(.gnu.linkonce.d.*)
+    CONSTRUCTORS
+    . = ALIGN(4);
+    _edata = ABSOLUTE(.);
+  } > sram
+
+  .bss :
+  {
+    _sbss = ABSOLUTE(.);
+    *(.bss .bss.*)
+    *(.gnu.linkonce.b.*)
+    *(COMMON)
+    . = ALIGN(4);
+    _ebss = ABSOLUTE(.);
+  } > sram
+
+  /* Stabs debugging sections. */
+
+  .stab 0 : { *(.stab) }
+  .stabstr 0 : { *(.stabstr) }
+  .stab.excl 0 : { *(.stab.excl) }
+  .stab.exclstr 0 : { *(.stab.exclstr) }
+  .stab.index 0 : { *(.stab.index) }
+  .stab.indexstr 0 : { *(.stab.indexstr) }
+  .comment 0 : { *(.comment) }
+  .debug_abbrev 0 : { *(.debug_abbrev) }
+  .debug_info 0 : { *(.debug_info) }
+  .debug_line 0 : { *(.debug_line) }
+  .debug_pubnames 0 : { *(.debug_pubnames) }
+  .debug_aranges 0 : { *(.debug_aranges) }
+}
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/.gitignore b/boards/arm/s32k1xx/rddrone-bms772/src/.gitignore
new file mode 100644
index 0000000000..726d936e1e
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/.gitignore
@@ -0,0 +1,2 @@
+/.depend
+/Make.dep
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/Makefile b/boards/arm/s32k1xx/rddrone-bms772/src/Makefile
new file mode 100644
index 0000000000..35331bdf62
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/Makefile
@@ -0,0 +1,67 @@
+############################################################################
+# boards/arm/s32k1xx/rddrone-bms772/src/Makefile
+#
+#   Copyright (C) 2019 Gregory Nutt. All rights reserved.
+#   Author: Gregory Nutt <gnutt@nuttx.org>
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in
+#    the documentation and/or other materials provided with the
+#    distribution.
+# 3. Neither the name NuttX nor the names of its contributors may be
+#    used to endorse or promote products derived from this software
+#    without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+# OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+# AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+############################################################################
+
+include $(TOPDIR)/Make.defs
+
+CSRCS  = s32k1xx_boot.c s32k1xx_bringup.c s32k1xx_clockconfig.c
+CSRCS += s32k1xx_periphclocks.c
+
+ifeq ($(CONFIG_ARCH_LEDS),y)
+CSRCS += s32k1xx_autoleds.c
+else
+CSRCS += s32k1xx_userleds.c
+endif
+
+ifeq ($(CONFIG_ARCH_BUTTONS),y)
+CSRCS += s32k1xx_buttons.c
+endif
+
+ifeq ($(CONFIG_DEV_GPIO),y)
+CSRCS += s32k1xx_gpio.c
+endif
+
+ifeq ($(CONFIG_LIB_BOARDCTL),y)
+CSRCS += s32k1xx_appinit.c
+endif
+
+ifeq ($(CONFIG_PWM),y)
+CSRCS += s32k1xx_pwm.c
+endif
+
+ifeq ($(CONFIG_S32K1XX_LPSPI),y)
+CSRCS += s32k1xx_spi.c
+endif
+
+include $(TOPDIR)/boards/Board.mk
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/rddrone-bms772.h b/boards/arm/s32k1xx/rddrone-bms772/src/rddrone-bms772.h
new file mode 100644
index 0000000000..7ac4c338d3
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/rddrone-bms772.h
@@ -0,0 +1,215 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/rddrone-bms772/src/rddrone-bms772.h
+ *
+ *   Copyright (C) 2019 Gregory Nutt. All rights reserved.
+ *   Author: Gregory Nutt <gnutt@nuttx.org>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+#ifndef __BOARDS_ARM_S32K1XX_RDDRONE_BMS772_SRC_RDDRONE_BMS772_H
+#define __BOARDS_ARM_S32K1XX_RDDRONE_BMS772_SRC_RDDRONE_BMS772_H
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+#include <nuttx/compiler.h>
+
+#include <stdint.h>
+
+#include "hardware/s32k1xx_pinmux.h"
+#include "s32k1xx_periphclocks.h"
+#include "s32k1xx_pin.h"
+
+/****************************************************************************
+ * Pre-processor Definitions
+ ****************************************************************************/
+
+/* Configuration ************************************************************/
+
+/* RDDRONE-BMS772 GPIOs *****************************************************/
+
+/* LEDs.  The RDDRONE-BMS772 has one RGB LED:
+ *
+ *   RedLED   PTD16 (FTM0 CH1)
+ *   GreenLED PTB13 (FTM0 CH1)
+ *   BlueLED  PTD15 (FTM0 CH0)
+ *
+ * An output of '1' illuminates the LED.
+ */
+
+#define GPIO_LED_R     (PIN_PTD16 | GPIO_LOWDRIVE | GPIO_OUTPUT_ZERO)
+#define GPIO_LED_G     (PIN_PTB13 | GPIO_LOWDRIVE | GPIO_OUTPUT_ZERO)
+#define GPIO_LED_B     (PIN_PTD15 | GPIO_LOWDRIVE | GPIO_OUTPUT_ZERO)
+
+/* Buttons.  The rddrone-bms772 supports one button:
+ *
+ *   SW1  PTC14
+ */
+
+//#define GPIO_SW1       (PIN_PTC14 | PIN_INT_BOTH)    
+//#define GPIO_SW3       (PIN_PTC13 | PIN_INT_BOTH)
+
+/* GPIO pins to be registered to the GPIO driver: */
+
+/*WARNING IF THIS CHANGES CHANGE gpio.h 
+			and the define of GPIO_x
+			and the array in s32k1xx_gpio.c */
+#define NUM_OF_GPIO_IN  0//5 /* Amount of GPIO input pins */
+#define NUM_OF_GPIO_OUT 7//5//5 /* Amount of GPIO output pins */
+#ifdef CONFIG_S32K1XX_GPIOIRQ
+#define NUM_OF_GPIO_INT 7//4 /* Amount of GPIO interrupt pins */
+#else
+#define NUM_OF_GPIO_INT 0 /* Amount of GPIO interrupt pins */
+#endif
+
+/*WARNING IF THIS CHANGES CHANGE gpio.h 
+			and the NUM_OF_GPIO_x
+			and the array in s32k1xx_gpio.c */
+//#define GPIO_IN0 	(PIN_PTA13 | GPIO_INPUT) // NFC_ED
+// #define GPIO_IN1 	(PIN_PTC14 | GPIO_INPUT) // SBC Wake
+// #define GPIO_IN2 	(PIN_PTC8  | GPIO_INPUT) // GATE_RS
+// #define GPIO_IN3 	(PIN_PTA11 | GPIO_INPUT) // SBC_LIMP
+//#define GPIO_IN0 	(PIN_PTC9  | GPIO_INPUT) // BCC_FAULT
+
+// #define GPIO_OUT1 	(PIN_PTC1  | GPIO_OUTPUT) // GATE_CTRL_CP
+// #define GPIO_OUT2 	(PIN_PTC2  | GPIO_OUTPUT) // GATE_CTRL_D
+// #define GPIO_OUT3 	(PIN_PTD5  | GPIO_OUTPUT) // BCC_RESET
+// #define GPIO_OUT4 	(PIN_PTA12 | GPIO_OUTPUT) // NFC_HPD
+// #define GPIO_OUT5 	(PIN_PTC15 | GPIO_OUTPUT) // AUTH_WAKE
+#define GPIO_OUT0 	(PIN_PTC1  | GPIO_OUTPUT) // GATE_CTRL_CP
+#define GPIO_OUT1 	(PIN_PTC2  | GPIO_OUTPUT) // GATE_CTRL_D
+#define GPIO_OUT2 	(PIN_PTD5  | GPIO_OUTPUT) // BCC_RESET
+#define GPIO_OUT3 	(PIN_PTA12 | GPIO_OUTPUT) // NFC_HPD
+#define GPIO_OUT4 	(PIN_PTC15 | GPIO_OUTPUT) // AUTH_WAKE
+#define GPIO_OUT5 	(PIN_PTE8  | GPIO_OUTPUT) // EXT_OUT1 To ext header
+//#define GPIO_OUT6 	(PIN_PTE9  | GPIO_OUTPUT) // EXT_OUT2 To ext header
+#define GPIO_OUT6 	(PIN_PTD3  | GPIO_OUTPUT) // BCC_CS
+
+#define GPIO_INT7 	(PIN_PTC3  | GPIO_INPUT | PIN_INT_BOTH) // OVERCURRENT
+#define GPIO_INT8 	(PIN_PTC14 | GPIO_INPUT | PIN_INT_BOTH) // SBC Wake 
+#define GPIO_INT9 	(PIN_PTC8  | GPIO_INPUT | PIN_INT_BOTH) // GATE_RS
+#define GPIO_INT10 	(PIN_PTA11 | GPIO_INPUT | PIN_INT_BOTH) // SBC_LIMP
+#define GPIO_INT11 	(PIN_PTC9  | GPIO_INPUT | PIN_INT_BOTH) // BCC_FAULT
+#define GPIO_INT12 	(PIN_PTA13 | GPIO_INPUT | PIN_INT_BOTH) // NFC_ED
+#define GPIO_INT13	(PIN_PTA5  | GPIO_INPUT | PIN_INT_BOTH) // RST_N
+
+
+//#define GPIO_INTn (PIN_PTC9 | GPIO_INPUT | PIN_INT_RISING)	// BCC_FAULT
+
+
+// #define NUM_OF_GPIO_IN  1//1 /* Amount of GPIO input pins */
+// #define NUM_OF_GPIO_OUT 2 /* Amount of GPIO output pins */
+// #define NUM_OF_GPIO_INT 1 //1 /* Amount of GPIO interrupt pins */
+
+// // these need to be added in the array in s32k1xx_gpio.c: in the g_gpioinputs, g_gpiooutputs or g_gpiointinputs
+// #define GPIO_IN1  (PIN_PTC8  | GPIO_INPUT) 	// GATE_RS
+
+// #define GPIO_OUT1 (PIN_PTC1  | GPIO_OUTPUT) // GATE_CTRL_CP
+// #define GPIO_OUT2 (PIN_PTC2  | GPIO_OUTPUT) // GATE_CTRL_D
+
+// // for interrupt use PIN_INT_BOTH, PIN_INT_RISING, PIN_INT_FALLING or another define from s32k1xx_pinirq.c
+// #define GPIO_INT1 (PIN_PTC3  | GPIO_INPUT | PIN_INT_BOTH) // OVERCURRENT
+// #define GPIO_OUT2 (PIN_PTC2  | GPIO_OUTPUT)
+// #define GPIO_OUT3 (PIN_PTC2  | GPIO_OUTPUT)
+// #define GPIO_OUT4 (PIN_PTC2  | GPIO_OUTPUT)
+// #define GPIO_OUT5 (PIN_PTC2  | GPIO_OUTPUT)
+// #define GPIO_OUT6 (PIN_PTC2  | GPIO_OUTPUT)
+
+//#define GPIO_INT2 (PIN_PTA12 | GPIO_INPUT | PIN_INT_RISING)
+
+/* SPI chip selects */
+
+/* Count of peripheral clock user configurations */
+
+#define NUM_OF_PERIPHERAL_CLOCKS_0 12
+
+/****************************************************************************
+ * Public Types
+ ****************************************************************************/
+
+/****************************************************************************
+ * Public Data
+ ****************************************************************************/
+
+#ifndef __ASSEMBLY__
+
+/* User peripheral configuration structure 0 */
+
+extern const struct peripheral_clock_config_s g_peripheral_clockconfig0[];
+
+/****************************************************************************
+ * Public Function Prototypes
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: s32k1xx_bringup
+ *
+ * Description:
+ *   Perform architecture-specific initialization
+ *
+ *   CONFIG_BOARD_LATE_INITIALIZE=y :
+ *     Called from board_late_initialize().
+ *
+ *   CONFIG_BOARD_LATE_INITIALIZE=y && CONFIG_LIB_BOARDCTL=y :
+ *     Called from the NSH library
+ *
+ ****************************************************************************/
+
+int s32k1xx_bringup(void);
+
+#ifdef CONFIG_DEV_GPIO
+/****************************************************************************
+ * Name: s32k1xx_gpio_initialize
+ *
+ * Description:
+ *   Initialize GPIO drivers for use with /apps/examples/gpio
+ *
+ ****************************************************************************/
+
+int s32k1xx_gpio_initialize(void);
+#endif
+
+/****************************************************************************
+ * Name: s32k1xx_spidev_initialize
+ *
+ * Description:
+ *   Called to configure SPI chip select GPIO pins for the RDDRONE-BMS772
+ *   board.
+ *
+ ****************************************************************************/
+
+#ifdef CONFIG_S32K1XX_LPSPI
+void s32k1xx_spidev_initialize(void);
+#endif
+
+#endif /* __ASSEMBLY__ */
+#endif /* __BOARDS_ARM_S32K1XX_RDDRONE_BMS772_SRC_RDDRONE_BMS772_H */
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_appinit.c b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_appinit.c
new file mode 100644
index 0000000000..145c8dd558
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_appinit.c
@@ -0,0 +1,94 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_appinit.c
+ *
+ *   Copyright (C) 2019 Gregory Nutt. All rights reserved.
+ *   Author: Gregory Nutt <gnutt@nuttx.org>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include <nuttx/board.h>
+
+#include "rddrone-bms772.h"
+
+/****************************************************************************
+ * Pre-processor Definitions
+ ****************************************************************************/
+
+#ifndef OK
+#  define OK 0
+#endif
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: board_app_initialize
+ *
+ * Description:
+ *   Perform application specific initialization.  This function is never
+ *   called directly from application code, but only indirectly via the
+ *   (non-standard) boardctl() interface using the command BOARDIOC_INIT.
+ *
+ * Input Parameters:
+ *   arg - The boardctl() argument is passed to the board_app_initialize()
+ *         implementation without modification.  The argument has no
+ *         meaning to NuttX; the meaning of the argument is a contract
+ *         between the board-specific initialization logic and the
+ *         matching application logic.  The value could be such things as a
+ *         mode enumeration value, a set of DIP switch switch settings, a
+ *         pointer to configuration data read from a file or serial FLASH,
+ *         or whatever you would like to do with it.  Every implementation
+ *         should accept zero/NULL as a default configuration.
+ *
+ * Returned Value:
+ *   Zero (OK) is returned on success; a negated errno value is returned on
+ *   any failure to indicate the nature of the failure.
+ *
+ ****************************************************************************/
+
+int board_app_initialize(uintptr_t arg)
+{
+#ifdef CONFIG_BOARD_LATE_INITIALIZE
+  /* Board initialization already performed by board_late_initialize() */
+
+  return OK;
+#else
+  /* Perform board-specific initialization */
+
+  return s32k1xx_bringup();
+#endif
+}
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_autoleds.c b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_autoleds.c
new file mode 100644
index 0000000000..3cda4ef8bd
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_autoleds.c
@@ -0,0 +1,165 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_autoleds.c
+ *
+ *   Copyright (C) 2019 Gregory Nutt. All rights reserved.
+ *   Author: Gregory Nutt <gnutt@nuttx.org>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/* The RDDRONE-BMS772 has one RGB LED:
+ *
+ *   RedLED   PTD16 (FTM0 CH1)
+ *   GreenLED PTB13 (FTM0 CH1)
+ *   BlueLED  PTD15 (FTM0 CH0)
+ *
+ * An output of '1' illuminates the LED.
+ *
+ * If CONFIG_ARCH_LEDs is defined, then NuttX will control the LED on board
+ * the Freedom K66F.  The following definitions describe how NuttX controls
+ * the LEDs:
+ *
+ *   SYMBOL                Meaning                 LED state
+ *                                                 RED   GREEN  BLUE
+ *   -------------------  -----------------------  -----------------
+ *   LED_STARTED          NuttX has been started    OFF  OFF  OFF
+ *   LED_HEAPALLOCATE     Heap has been allocated   OFF  OFF  ON
+ *   LED_IRQSENABLED      Interrupts enabled        OFF  OFF  ON
+ *   LED_STACKCREATED     Idle stack created        OFF  ON   OFF
+ *   LED_INIRQ            In an interrupt          (no change)
+ *   LED_SIGNAL           In a signal handler      (no change)
+ *   LED_ASSERTION        An assertion failed      (no change)
+ *   LED_PANIC            The system has crashed    FLASH OFF OFF
+ *   LED_IDLE             K66 is in sleep mode     (Optional, not used)
+ */
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include <stdint.h>
+#include <stdbool.h>
+#include <debug.h>
+
+#include <nuttx/board.h>
+#include <arch/board/board.h>
+
+#include "arm_arch.h"
+#include "arm_internal.h"
+
+#include "s32k1xx_pin.h"
+#include "rddrone-bms772.h"
+
+#include <arch/board/board.h>
+
+#ifdef CONFIG_ARCH_LEDS
+
+/****************************************************************************
+ * Pre-processor Definitions
+ ****************************************************************************/
+
+/* Summary of all possible settings */
+
+#define LED_NOCHANGE      0 /* LED_IRQSENABLED, LED_INIRQ, LED_SIGNAL, LED_ASSERTION */
+#define LED_OFF_OFF_OFF   1 /* LED_STARTED */
+#define LED_OFF_OFF_ON    2 /* LED_HEAPALLOCATE */
+#define LED_OFF_ON_OFF    3 /* LED_STACKCREATED */
+#define LED_ON_OFF_OFF    4 /* LED_PANIC */
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: board_autoled_initialize
+ ****************************************************************************/
+
+void board_autoled_initialize(void)
+{
+  /* Configure LED GPIOs for output */
+
+  s32k1xx_pinconfig(GPIO_LED_R);
+  s32k1xx_pinconfig(GPIO_LED_G);
+  s32k1xx_pinconfig(GPIO_LED_B);
+}
+
+/****************************************************************************
+ * Name: board_autoled_on
+ ****************************************************************************/
+
+void board_autoled_on(int led)
+{
+  if (led != LED_NOCHANGE)
+    {
+      bool redon   = false;
+      bool greenon = false;
+      bool blueon  = false;
+
+      switch (led)
+        {
+          default:
+          case LED_OFF_OFF_OFF:
+            break;
+
+          case LED_OFF_OFF_ON:
+            blueon = true;
+            break;
+
+          case LED_OFF_ON_OFF:
+            greenon = true;
+            break;
+
+          case LED_ON_OFF_OFF:
+            redon = true;
+            break;
+        }
+
+      s32k1xx_gpiowrite(GPIO_LED_R, redon);
+      s32k1xx_gpiowrite(GPIO_LED_G, greenon);
+      s32k1xx_gpiowrite(GPIO_LED_B, blueon);
+    }
+}
+
+/****************************************************************************
+ * Name: board_autoled_off
+ ****************************************************************************/
+
+void board_autoled_off(int led)
+{
+  if (led == LED_ON_OFF_OFF)
+    {
+      s32k1xx_gpiowrite(GPIO_LED_R, true);
+      s32k1xx_gpiowrite(GPIO_LED_G, false);
+      s32k1xx_gpiowrite(GPIO_LED_B, false);
+    }
+}
+
+#endif /* CONFIG_ARCH_LEDS */
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_boot.c b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_boot.c
new file mode 100644
index 0000000000..01fb4945bd
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_boot.c
@@ -0,0 +1,93 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_boot.c
+ *
+ *   Copyright (C) 2019 Gregory Nutt. All rights reserved.
+ *   Author: Gregory Nutt <gnutt@nuttx.org>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include <debug.h>
+
+#include <nuttx/board.h>
+
+#include "rddrone-bms772.h"
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: s32k1xx_board_initialize
+ *
+ * Description:
+ *   All S32K1XX architectures must provide the following entry point.  This
+ *   entry point is called early in the initialization -- after all memory
+ *   has been configured and mapped but before any devices have been
+ *   initialized.
+ *
+ ****************************************************************************/
+
+void s32k1xx_board_initialize(void)
+{
+#ifdef CONFIG_ARCH_LEDS
+  /* Configure on-board LEDs if LED support has been selected. */
+
+  board_autoled_initialize();
+#endif
+}
+
+/****************************************************************************
+ * Name: board_late_initialize
+ *
+ * Description:
+ *   If CONFIG_BOARD_LATE_INITIALIZE is selected, then an additional
+ *   initialization call will be performed in the boot-up sequence to a
+ *   function called board_late_initialize().  board_late_initialize() will
+ *   be called immediately after up_initialize() is called and just before
+ *   the initial application is started.  This additional initialization
+ *   phase may be used, for example, to initialize board-specific device
+ *   drivers.
+ *
+ ****************************************************************************/
+
+#ifdef CONFIG_BOARD_LATE_INITIALIZE
+void board_late_initialize(void)
+{
+  /* Perform board-specific initialization */
+
+  s32k1xx_bringup();
+}
+#endif
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_bringup.c b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_bringup.c
new file mode 100644
index 0000000000..04ed807709
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_bringup.c
@@ -0,0 +1,181 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_bringup.c
+ *
+ *   Copyright (C) 2019 Gregory Nutt. All rights reserved.
+ *   Author: Gregory Nutt <gnutt@nuttx.org>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include <sys/types.h>
+#include <sys/mount.h>
+#include <syslog.h>
+
+#ifdef CONFIG_BUTTONS
+#  include <nuttx/input/buttons.h>
+#endif
+
+#ifdef CONFIG_USERLED
+#  include <nuttx/leds/userled.h>
+#endif
+
+#ifdef CONFIG_I2C_DRIVER
+#  include "s32k1xx_pin.h"
+#  include <nuttx/i2c/i2c_master.h>
+#  include "s32k1xx_lpi2c.h"
+#endif
+
+#ifdef CONFIG_S32K1XX_EEEPROM
+#  include "s32k1xx_eeeprom.h"
+#endif
+
+#include "rddrone-bms772.h"
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: s32k1xx_bringup
+ *
+ * Description:
+ *   Perform architecture-specific initialization
+ *
+ *   CONFIG_BOARD_LATE_INITIALIZE=y :
+ *     Called from board_late_initialize().
+ *
+ *   CONFIG_BOARD_LATE_INITIALIZE=n && CONFIG_LIB_BOARDCTL=y :
+ *     Called from the NSH library
+ *
+ ****************************************************************************/
+
+int s32k1xx_bringup(void)
+{
+  int ret = OK;
+
+#ifdef CONFIG_BUTTONS
+  /* Register the BUTTON driver */
+
+  ret = btn_lower_initialize("/dev/buttons");
+  if (ret < 0)
+    {
+      syslog(LOG_ERR, "ERROR: btn_lower_initialize() failed: %d\n", ret);
+    }
+#endif
+
+#ifdef CONFIG_USERLED
+  /* Register the LED driver */
+
+  ret = userled_lower_initialize("/dev/userleds");
+  if (ret < 0)
+    {
+      syslog(LOG_ERR, "ERROR: userled_lower_initialize() failed: %d\n", ret);
+    }
+#endif
+
+#ifdef CONFIG_FS_PROCFS
+  /* Mount the procfs file system */
+
+  ret = mount(NULL, "/proc", "procfs", 0, NULL);
+  if (ret < 0)
+    {
+      syslog(LOG_ERR, "ERROR: Failed to mount procfs at /proc: %d\n", ret);
+    }
+#endif
+
+#ifdef CONFIG_DEV_GPIO
+  ret = s32k1xx_gpio_initialize();
+  if (ret < 0)
+    {
+      syslog(LOG_ERR, "ERROR: Failed to initialize GPIO driver: %d\n", ret);
+    }
+#endif
+
+#ifdef CONFIG_PWM
+  /* Initialize PWM and register the PWM device. */
+
+  ret = s32k1xx_pwm_setup();
+  if (ret < 0)
+    {
+      syslog(LOG_ERR, "ERROR: s32k1xx_pwm_setup() failed: %d\n", ret);
+    }
+#endif
+
+#ifdef CONFIG_S32K1XX_LPSPI
+  /* Configure SPI chip selects if 1) SPI is not disabled, and 2) the weak
+   * function s32k1xx_spidev_initialize() has been brought into the link.
+   */
+
+  s32k1xx_spidev_initialize();
+#endif
+
+#if defined(CONFIG_S32K1XX_LPI2C0) && defined(CONFIG_I2C_DRIVER)
+  FAR struct i2c_master_s *i2c;
+
+  i2c = s32k1xx_i2cbus_initialize(0);
+  if (i2c == NULL)
+    {
+      serr("ERROR: Failed to get I2C%d interface\n", bus);
+    }
+  else
+    {
+      ret = i2c_register(i2c, 0);
+      if (ret < 0)
+        {
+          serr("ERROR: Failed to register I2C%d driver: %d\n", bus, ret);
+          s32k1xx_i2cbus_uninitialize(i2c);
+        }
+    }
+#endif
+
+#ifdef CONFIG_S32K1XX_PROGMEM
+  FAR struct mtd_dev_s *mtd;
+  int minor = 0;
+
+  mtd = progmem_initialize();
+  if (!mtd)
+    {
+      syslog(LOG_ERR, "ERROR: progmem_initialize failed\n");
+    }
+#endif
+
+#ifdef CONFIG_S32K1XX_EEEPROM
+      /* Register EEEPROM block device */
+
+      s32k1xx_eeeprom_register(0, 4096);
+#endif
+
+  return ret;
+}
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_buttons.c b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_buttons.c
new file mode 100644
index 0000000000..e8c464ed63
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_buttons.c
@@ -0,0 +1,164 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_buttons.c
+ *
+ *   Copyright (C) 2019 Gregory Nutt. All rights reserved.
+ *   Author: Gregory Nutt <gnutt@nuttx.org>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/* The rddrone-bms772 supports one button:
+ *
+ *   SW1 PTC14
+ */
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include <stdint.h>
+#include <errno.h>
+
+#include <nuttx/arch.h>
+#include <nuttx/board.h>
+
+#include "s32k1xx_pin.h"
+#include "rddrone-bms772.h"
+
+#include <arch/board/board.h>
+
+#ifdef CONFIG_ARCH_BUTTONS
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: board_button_initialize
+ *
+ * Description:
+ *   board_button_initialize() must be called to initialize button resources.
+ *   After that, board_buttons() may be called to collect the current state
+ *   of all buttons or board_button_irq() may be called to register button
+ *   interrupt handlers.
+ *
+ ****************************************************************************/
+
+uint32_t board_button_initialize(void)
+{
+  /* Configure the GPIO pins as interrupting inputs. */
+
+  s32k1xx_pinconfig(GPIO_SW1);
+  return NUM_BUTTONS;
+}
+
+/****************************************************************************
+ * Name: board_buttons
+ ****************************************************************************/
+
+uint32_t board_buttons(void)
+{
+  uint32_t ret = 0;
+
+  if (s32k1xx_gpioread(GPIO_SW1))
+    {
+      ret |= BUTTON_SW1_BIT;
+    }
+
+  // if (s32k1xx_gpioread(GPIO_SW3))
+  //   {
+  //     ret |= BUTTON_SW3_BIT;
+  //   }
+
+  return ret;
+}
+
+/****************************************************************************
+ * Button support.
+ *
+ * Description:
+ *   board_button_initialize() must be called to initialize button resources.
+ *   After that, board_buttons() may be called to collect the current state
+ *   of all buttons or board_button_irq() may be called to register button
+ *   interrupt handlers.
+ *
+ *   After board_button_initialize() has been called, board_buttons() may be
+ *   called to collect the state of all buttons.  board_buttons() returns a
+ *   32-bit bit set with each bit associated with a button.  See the
+ *   BUTTON_*_BIT definitions in board.h for the meaning of each bit.
+ *
+ *   board_button_irq() may be called to register an interrupt handler that
+ *   will be called when a button is depressed or released.  The ID value is
+ *   a button enumeration value that uniquely identifies a button resource.
+ *   See the BUTTON_* definitions in board.h for the meaning of enumeration
+ *   value.
+ *
+ ****************************************************************************/
+
+#ifdef CONFIG_ARCH_IRQBUTTONS
+int board_button_irq(int id, xcpt_t irqhandler, FAR void *arg)
+{
+  uint32_t pinset;
+  int ret;
+
+  /* Map the button id to the GPIO bit set. */
+
+  if (id == BUTTON_SW1)
+    {
+      pinset = GPIO_SW1;
+    }
+  // else if (id == BUTTON_SW3)
+  //   {
+  //     pinset = GPIO_SW3;
+  //   }
+  else
+    {
+      return -EINVAL;
+    }
+
+  /* The button has already been configured as an interrupting input (by
+   * board_button_initialize() above).
+   *
+   * Attach the new button handler.
+   */
+
+  ret = s32k1xx_pinirqattach(pinset, irqhandler, NULL);
+  if (ret >= 0)
+    {
+      /* Then make sure that interrupts are enabled on the pin */
+
+      s32k1xx_pinirqenable(pinset);
+    }
+
+  return ret;
+}
+#endif
+#endif /* CONFIG_ARCH_BUTTONS */
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_clockconfig.c b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_clockconfig.c
new file mode 100644
index 0000000000..e62cecbc7f
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_clockconfig.c
@@ -0,0 +1,217 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_clockconfig.c
+ *
+ *   Copyright (C) 2019 Gregory Nutt. All rights reserved.
+ *   Author: Gregory Nutt <gnutt@nuttx.org>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Most of the settings within this file derives from NXP sample code for
+ * the S32K1XX MCUs.  That sample code has this licensing information:
+ *
+ *   Copyright (c) 2013 - 2015, Freescale Semiconductor, Inc.
+ *   Copyright 2016-2018 NXP
+ *   All rights reserved.
+ *
+ * THIS SOFTWARE IS PROVIDED BY NXP "AS IS" AND ANY EXPRESSED OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL NXP OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include <stdint.h>
+#include <stdbool.h>
+
+#include "s32k1xx_clockconfig.h"
+#include "s32k1xx_start.h"
+#include "rddrone-bms772.h"
+
+/****************************************************************************
+ * Public Data
+ ****************************************************************************/
+
+/* Each S32K1XX board must provide the following initialized structure.
+ * This is needed to establish the initial board clocking.
+ */
+
+const struct clock_configuration_s g_initial_clkconfig =
+{
+  .scg =
+  {
+    .sirc          =
+    {
+      .range       = SCG_SIRC_RANGE_HIGH,      /* RANGE - High range (8 MHz) */
+      .div1        = SCG_ASYNC_CLOCK_DIV_BY_1, /* SIRCDIV1 */
+      .div2        = SCG_ASYNC_CLOCK_DIV_BY_1, /* SIRCDIV2 */
+      .initialize  = true,  /* Initialize */
+      .stopmode    = false, /* SIRCSTEN */
+      .lowpower    = true,  /* SIRCLPEN */
+      .locked      = false, /* LK */
+    },
+    .firc          =
+    {
+      .range       = SCG_FIRC_RANGE_48M,       /* RANGE */
+      .div1        = SCG_ASYNC_CLOCK_DIV_BY_1, /* FIRCDIV1 */
+      .div2        = SCG_ASYNC_CLOCK_DIV_BY_1, /* FIRCDIV2 */
+      .initialize  = true,  /* Initialize */
+      .regulator   = true,  /* FIRCREGOFF */
+      .locked      = false, /* LK */
+    },
+    .sosc          =
+    {
+      .mode        = SCG_SOSC_MONITOR_DISABLE, /* SOSCCM */
+      .gain        = SCG_SOSC_GAIN_LOW,        /* HGO */
+      .range       = SCG_SOSC_RANGE_HIGH,      /* RANGE */
+      .extref      = SCG_SOSC_REF_OSC,         /* EREFS */
+      .div1        = SCG_ASYNC_CLOCK_DIV_BY_1, /* SOSCDIV1 */
+      .div2        = SCG_ASYNC_CLOCK_DIV_BY_1, /* SOSCDIV2 */
+      .initialize  = true,  /* Initialize */
+      .locked      = false, /* LK */
+    },
+    .spll          =
+    {
+      .mode        = SCG_SPLL_MONITOR_DISABLE, /* SPLLCM */
+      .div1        = SCG_ASYNC_CLOCK_DIV_BY_1, /* SPLLDIV1 */
+      .div2        = SCG_ASYNC_CLOCK_DIV_BY_1, /* SPLLDIV2 */
+      .prediv      = 4,     /* PREDIV */
+      .mult        = 40,    /* MULT */
+      .src         = 0,     /* SOURCE */
+      .initialize  = true,  /* Initialize */
+      .locked      = false, /* LK */
+    },
+    .rtc           =
+    {
+      .initialize  = true, /* Initialize */
+      .clkin       = 0,    /* RTC_CLKIN */
+    },
+    .clockout      =
+    {
+      .source      = SCG_CLOCKOUT_SRC_FIRC, /* SCG CLKOUTSEL */
+      .initialize  = true, /* Initialize */
+    },
+    .clockmode     =
+    {
+      .rccr        = /* RCCR - Run Clock Control Register */
+      {
+        .src       = SCG_SYSTEM_CLOCK_SRC_SYS_PLL, /* SCS */
+        .divslow   = 3, /* DIVSLOW, range 1..16 */
+        .divbus    = 2, /* DIVBUS, range 1..16 */
+        .divcore   = 2, /* DIVCORE, range 1..16 */
+      },
+      .vccr        = /* VCCR - VLPR Clock Control Register */
+      {
+        .src       = SCG_SYSTEM_CLOCK_SRC_SIRC, /* SCS */
+        .divslow   = 4, /* DIVSLOW, range 1..16 */
+        .divbus    = 1, /* DIVBUS, range 1..16 */
+        .divcore   = 2, /* DIVCORE, range 1..16 */
+      },
+      .hccr        =
+      {
+        .src       = SCG_SYSTEM_CLOCK_SRC_SYS_PLL, /* SCS */
+        .divslow   = 3, /* DIVSLOW, range 1..16 */
+        .divbus    = 2, /* DIVBUS, range 1..16 */
+        .divcore   = 2, /* DIVCORE, range 1..16 */
+      },
+      .initialize  = true, /* Initialize */
+    },
+  },
+  .sim             =
+  {
+    .clockout      = /* Clock Out configuration. */
+    {
+      .source      = SIM_CLKOUT_SEL_SYSTEM_SCG_CLKOUT, /* CLKOUTSEL */
+      .divider     = 1,     /* CLKOUTDIV, range 1..8 */
+      .initialize  = true,  /* Initialize */
+      .enable      = false, /* CLKOUTEN */
+    },
+    .lpoclk        = /* Low Power Clock configuration. */
+    {
+      .rtc_source  = SIM_RTCCLK_SEL_LPO_32K, /* RTCCLKSEL */
+      .lpo_source  = SIM_LPO_CLK_SEL_LPO_128K,    /* LPOCLKSEL */
+      .initialize  = true, /* Initialize */
+      .lpo32k      = true, /* LPO32KCLKEN */
+      .lpo1k       = true, /* LPO1KCLKEN */
+    },
+    .tclk          = /* TCLK CLOCK configuration. */
+    {
+      .tclkfreq[0] = 0,    /* TCLK0 */
+      .tclkfreq[1] = 0,    /* TCLK1 */
+      .tclkfreq[2] = 0,    /* TCLK2 */
+      .initialize  = true, /* Initialize */
+    },
+    .platgate      = /* Platform Gate Clock configuration. */
+    {
+      .initialize  = true, /* Initialize */
+      .mscm        = true, /* CGCMSCM */
+      .mpu         = true, /* CGCMPU */
+      .dma         = true, /* CGCDMA */
+      .erm         = true, /* CGCERM */
+      .eim         = true, /* CGCEIM */
+    },
+    .traceclk      = /* Debug trace Clock Configuration. */
+    {
+      .source      = CLOCK_TRACE_SRC_CORE_CLK, /* TRACECLK_SEL */
+      .divider     = 1,     /* TRACEDIV, range 1..8 */
+      .initialize  = true,  /* Initialize */
+      .enable      = true,  /* TRACEDIVEN */
+      .fraction    = false, /* TRACEFRAC */
+    },
+  },
+  .pcc             =
+  {
+    .count         = NUM_OF_PERIPHERAL_CLOCKS_0, /* Number peripheral clock configurations */
+    .pclks         = g_peripheral_clockconfig0,  /* Peripheral clock configurations */
+  },
+  .pmc             =
+  {
+    .lpoclk        = /* Low Power Clock configuration. */
+    {
+      .trim        = 0,    /* Trimming value for LPO */
+      .initialize  = true, /* Initialize */
+      .enable      = true, /* Enable/disable LPO */
+    },
+  },
+};
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_gpio.c b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_gpio.c
new file mode 100644
index 0000000000..9c3d45df23
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_gpio.c
@@ -0,0 +1,399 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_gpio.c
+ *
+ *   Copyright (C) 2017-2018 Gregory Nutt. All rights reserved.
+ *   Copyright (C) 2017 Alan Carvalho de Assis. All rights reserved.
+ *   Author:  Alan Carvalho de Assis <acassis@gmail.com>
+ *
+ * Based on: boards/imxrt1050-evk/src/imxrt_gpio.c
+ *
+ *   Author:  Pavlina Koleva <pavlinaikoleva19@gmail.com>
+ *   Modified by: Ivan Ucherdzhiev <ivanucherdjiev@gmail.com>
+ *
+ * Also based on: boards/arm/stm32/stm32f103-minimum/src/stm32_gpio.c
+ *
+ *   Author:  Alan Carvalho de Assis <acassis@gmail.com>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include <stdbool.h>
+#include <assert.h>
+#include <debug.h>
+
+#include <nuttx/clock.h>
+#include <nuttx/wdog.h>
+#include <nuttx/ioexpander/gpio.h>
+
+#include <arch/board/board.h>
+
+#include "chip.h"
+
+#include <s32k1xx_pin.h>
+#include "rddrone-bms772.h"
+
+#if defined(CONFIG_DEV_GPIO) && !defined(CONFIG_GPIO_LOWER_HALF)
+
+/****************************************************************************
+ * Private Types
+ ****************************************************************************/
+
+struct s32k1xx_gpio_dev_s
+{
+  struct gpio_dev_s gpio;
+  uint8_t id;
+};
+
+struct s32k1xx_gpint_dev_s
+{
+  struct s32k1xx_gpio_dev_s s32k1xx_gpio;
+  pin_interrupt_t callback;
+};
+
+/****************************************************************************
+ * Private Function Prototypes
+ ****************************************************************************/
+#if NUM_OF_GPIO_IN > 0 
+static int gpin_read(FAR struct gpio_dev_s *dev, FAR bool *value);
+#endif
+
+#if NUM_OF_GPIO_OUT > 0 
+static int gpout_read(FAR struct gpio_dev_s *dev, FAR bool *value);
+static int gpout_write(FAR struct gpio_dev_s *dev, bool value);
+#endif
+
+#if NUM_OF_GPIO_INT > 0 
+static int gpint_read(FAR struct gpio_dev_s *dev, FAR bool *value);
+static int gpint_attach(FAR struct gpio_dev_s *dev,
+                        pin_interrupt_t callback);
+static int gpint_enable(FAR struct gpio_dev_s *dev, bool enable);
+#endif
+
+/****************************************************************************
+ * Private Data
+ ****************************************************************************/
+#if NUM_OF_GPIO_IN > 0 
+static const struct gpio_operations_s gpin_ops =
+{
+  .go_read   = gpin_read,
+  .go_write  = NULL,
+  .go_attach = NULL,
+  .go_enable = NULL,
+};
+#endif
+
+#if NUM_OF_GPIO_OUT > 0 
+static const struct gpio_operations_s gpout_ops =
+{
+  .go_read   = gpout_read,
+  .go_write  = gpout_write,
+  .go_attach = NULL,
+  .go_enable = NULL,
+};
+#endif
+
+#if NUM_OF_GPIO_INT > 0 
+static const struct gpio_operations_s gpint_ops =
+{
+  .go_read   = gpint_read,
+  .go_write  = NULL,
+  .go_attach = gpint_attach,
+  .go_enable = gpint_enable,
+};
+#endif
+
+#if NUM_OF_GPIO_IN > 0 
+static struct s32k1xx_gpio_dev_s g_gpin[NUM_OF_GPIO_IN];
+
+/*WARNING IF THIS CHANGES CHANGE gpio.h 
+          and the define of GPIO_x in rddrone-bms772.h
+          and the NUM_OF_GPIO_x in rddrone-bms772.h
+*/
+/* This array maps the GPIO pins used as INPUT */
+static const uint32_t g_gpioinputs[NUM_OF_GPIO_IN] =
+{
+  //GPIO_IN0//, GPIO_IN1//, GPIO_IN2, GPIO_IN3, GPIO_IN4
+};
+#endif
+
+#if NUM_OF_GPIO_OUT > 0 
+static struct s32k1xx_gpio_dev_s g_gpout[NUM_OF_GPIO_OUT];
+
+/*WARNING IF THIS CHANGES CHANGE gpio.h 
+          and the define of GPIO_x in rddrone-bms772.h
+          and the NUM_OF_GPIO_x in rddrone-bms772.h
+*/
+/* This array maps the GPIO pins used as OUTPUT */
+static const uint32_t g_gpiooutputs[NUM_OF_GPIO_OUT] =
+{
+  GPIO_OUT0, GPIO_OUT1, GPIO_OUT2, GPIO_OUT3, GPIO_OUT4, GPIO_OUT5, GPIO_OUT6//, GPIO_OUT7, GPIO_OUT8, GPIO_OUT9
+};
+#endif
+
+#if NUM_OF_GPIO_INT > 0 
+static struct s32k1xx_gpint_dev_s g_gpint[NUM_OF_GPIO_INT];
+
+/*WARNING IF THIS CHANGES CHANGE gpio.h  
+          and the define of GPIO_x in rddrone-bms772.h
+          and the NUM_OF_GPIO_x in rddrone-bms772.h
+*/
+/* This array maps the GPIO pins used as OUTPUT */
+static const uint32_t g_gpiointinputs[NUM_OF_GPIO_INT] =
+{
+ // GPIO_INT2//GPIO_INT10
+  //GPIO_INT5, GPIO_INT6,
+   GPIO_INT7, GPIO_INT8, GPIO_INT9, GPIO_INT10, GPIO_INT11 ,GPIO_INT12, GPIO_INT13, 
+};
+#endif
+
+// #if NUM_OF_GPIO_IN > 0
+// static const uint32_t g_gpioinputs[NUM_OF_GPIO_IN] =
+// {
+//   GPIO_IN1,
+// };
+// static struct s32k1xx_gpio_dev_s g_gpin[NUM_OF_GPIO_IN];
+// #endif
+
+// /* This array maps the GPIO pins used as OUTPUT */
+// #if NUM_OF_GPIO_OUT > 0
+// static const uint32_t g_gpiooutputs[NUM_OF_GPIO_OUT] =
+// {
+//   GPIO_OUT1, GPIO_OUT2
+// };
+// static struct s32k1xx_gpio_dev_s g_gpout[NUM_OF_GPIO_OUT];
+// #endif
+
+// /* This array maps the GPIO pins used as interrupt pins */
+// #if NUM_OF_GPIO_INT > 0
+// static const uint32_t g_gpiointinputs[NUM_OF_GPIO_INT] =
+// {
+//   GPIO_INT1,
+// };
+// static struct s32k1xx_gpint_dev_s g_gpint[NUM_OF_GPIO_INT];
+// #endif
+
+/****************************************************************************
+ * Private Functions
+ ****************************************************************************/
+#if NUM_OF_GPIO_INT > 0 
+static int s32k1xx_gpio_interrupt(int irq, void *context, void *arg)
+{
+  FAR struct s32k1xx_gpint_dev_s *s32k1xx_gpint =
+    (FAR struct s32k1xx_gpint_dev_s *)arg;
+
+  DEBUGASSERT(s32k1xx_gpint != NULL && s32k1xx_gpint->callback != NULL);
+  gpioinfo("Interrupt! callback=%p\n", s32k1xx_gpint->callback);
+
+  s32k1xx_gpint->callback(&s32k1xx_gpint->s32k1xx_gpio.gpio,
+                           s32k1xx_gpint->s32k1xx_gpio.id);
+  return OK;
+}
+#endif
+
+#if NUM_OF_GPIO_IN > 0 
+static int gpin_read(FAR struct gpio_dev_s *dev, FAR bool *value)
+{
+  FAR struct s32k1xx_gpio_dev_s *s32k1xx_gpio =
+    (FAR struct s32k1xx_gpio_dev_s *)dev;
+
+  DEBUGASSERT(s32k1xx_gpio != NULL && value != NULL);
+  DEBUGASSERT(s32k1xx_gpio->id < NUM_OF_GPIO_IN);
+  gpioinfo("Reading...\n");
+
+  *value = s32k1xx_gpioread(g_gpioinputs[s32k1xx_gpio->id]);
+  return OK;
+}
+#endif
+
+#if NUM_OF_GPIO_OUT > 0 
+static int gpout_read(FAR struct gpio_dev_s *dev, FAR bool *value)
+{
+  FAR struct s32k1xx_gpio_dev_s *s32k1xx_gpio =
+    (FAR struct s32k1xx_gpio_dev_s *)dev;
+
+  DEBUGASSERT(s32k1xx_gpio != NULL && value != NULL);
+  DEBUGASSERT(s32k1xx_gpio->id < NUM_OF_GPIO_OUT);
+  gpioinfo("Reading...\n");
+
+  *value = s32k1xx_gpioread(g_gpiooutputs[s32k1xx_gpio->id]);
+  return OK;
+}
+
+static int gpout_write(FAR struct gpio_dev_s *dev, bool value)
+{
+  FAR struct s32k1xx_gpio_dev_s *s32k1xx_gpio =
+    (FAR struct s32k1xx_gpio_dev_s *)dev;
+
+  DEBUGASSERT(s32k1xx_gpio != NULL);
+  DEBUGASSERT(s32k1xx_gpio->id < NUM_OF_GPIO_OUT);
+  gpioinfo("Writing %d\n", (int)value);
+
+  s32k1xx_gpiowrite(g_gpiooutputs[s32k1xx_gpio->id], value);
+  return OK;
+}
+
+#endif
+
+#if NUM_OF_GPIO_INT > 0 
+static int gpint_read(FAR struct gpio_dev_s *dev, FAR bool *value)
+{
+  FAR struct s32k1xx_gpint_dev_s *s32k1xx_gpint =
+    (FAR struct s32k1xx_gpint_dev_s *)dev;
+
+  DEBUGASSERT(s32k1xx_gpint != NULL && value != NULL);
+  DEBUGASSERT(s32k1xx_gpint->s32k1xx_gpio.id < NUM_OF_GPIO_INT);
+  gpioinfo("Reading int pin...\n");
+
+  *value = s32k1xx_gpioread(g_gpiointinputs[s32k1xx_gpint->s32k1xx_gpio.id]);
+  return OK;
+}
+
+static int gpint_attach(FAR struct gpio_dev_s *dev, pin_interrupt_t callback)
+{
+  FAR struct s32k1xx_gpint_dev_s *s32k1xx_gpint =
+    (FAR struct s32k1xx_gpint_dev_s *)dev;
+
+  gpioinfo("Attaching the callback\n");
+  s32k1xx_pinirqattach(g_gpiointinputs[s32k1xx_gpint->s32k1xx_gpio.id],
+                       s32k1xx_gpio_interrupt,
+                       &g_gpint[s32k1xx_gpint->s32k1xx_gpio.id]);
+
+  gpioinfo("Attach %p\n", callback);
+  s32k1xx_gpint->callback = callback;
+  return OK;
+}
+
+static int gpint_enable(FAR struct gpio_dev_s *dev, bool enable)
+{
+  FAR struct s32k1xx_gpint_dev_s *s32k1xx_gpint =
+    (FAR struct s32k1xx_gpint_dev_s *)dev;
+
+  if (enable)
+    {
+      if (s32k1xx_gpint->callback != NULL)
+        {
+          gpioinfo("Enabling the interrupt\n");
+          s32k1xx_pinirqenable(
+            g_gpiointinputs[s32k1xx_gpint->s32k1xx_gpio.id]);
+        }
+    }
+  else
+    {
+      gpioinfo("Disable the interrupt\n");
+      s32k1xx_pinirqdisable(g_gpiointinputs[s32k1xx_gpint->s32k1xx_gpio.id]);
+    }
+
+  return OK;
+}
+#endif
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: s32k1xx_gpio_initialize
+ *
+ * Description:
+ *   Initialize GPIO drivers for use with /apps/examples/gpio
+ *
+ ****************************************************************************/
+
+int s32k1xx_gpio_initialize(void)
+{
+  int i;
+  int pincount = 0;
+
+#if NUM_OF_GPIO_IN > 0
+  for (i = 0; i < NUM_OF_GPIO_IN; i++)
+    {
+      /* Setup and register the GPIO pin */
+
+      g_gpin[i].gpio.gp_pintype = GPIO_INPUT_PIN;
+      g_gpin[i].gpio.gp_ops     = &gpin_ops;
+      g_gpin[i].id              = i;
+
+      gpio_pin_register(&g_gpin[i].gpio, pincount);
+
+      /* Configure the pin that will be used as input */
+
+      s32k1xx_pinconfig(g_gpioinputs[i]);
+
+      pincount++;
+    }
+#endif
+
+#if NUM_OF_GPIO_OUT > 0
+  for (i = 0; i < NUM_OF_GPIO_OUT; i++)
+    {
+      /* Setup and register the GPIO pin */
+
+      g_gpout[i].gpio.gp_pintype = GPIO_OUTPUT_PIN;
+      g_gpout[i].gpio.gp_ops     = &gpout_ops;
+      g_gpout[i].id              = i;
+
+      gpio_pin_register(&g_gpout[i].gpio, pincount);
+
+      /* Configure the pin that will be used as output */
+
+      s32k1xx_gpiowrite(g_gpiooutputs[i], 0);
+      s32k1xx_pinconfig(g_gpiooutputs[i]);
+
+      pincount++;
+    }
+#endif
+
+#if NUM_OF_GPIO_INT > 0
+  for (i = 0; i < NUM_OF_GPIO_INT; i++)
+    {
+      /* Setup and register the GPIO pin */
+
+      g_gpint[i].s32k1xx_gpio.gpio.gp_pintype = GPIO_INTERRUPT_PIN;
+      g_gpint[i].s32k1xx_gpio.gpio.gp_ops     = &gpint_ops;
+      g_gpint[i].s32k1xx_gpio.id              = i;
+
+      gpio_pin_register(&g_gpint[i].s32k1xx_gpio.gpio, pincount);
+
+      /* Configure the pin that will be used as interrupt input */
+
+      s32k1xx_pinconfig(g_gpiointinputs[i]);
+
+      pincount++;
+    }
+#endif
+
+  return 0;
+}
+#endif /* CONFIG_DEV_GPIO && !CONFIG_GPIO_LOWER_HALF */
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_periphclocks.c b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_periphclocks.c
new file mode 100644
index 0000000000..e393208ed3
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_periphclocks.c
@@ -0,0 +1,159 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_periphclks.c
+ *
+ *   Copyright (C) 2019 Gregory Nutt. All rights reserved.
+ *   Author: Gregory Nutt <gnutt@nuttx.org>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *  notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *  notice, this list of conditions and the following disclaimer in
+ *  the documentation and/or other materials provided with the
+ *  distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *  used to endorse or promote products derived from this software
+ *  without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Most of the settings within this file derives from NXP sample code for
+ * the S32K1XX MCUs.  That sample code has this licensing information:
+ *
+ *   Copyright (c) 2013 - 2015, Freescale Semiconductor, Inc.
+ *   Copyright 2016-2018 NXP
+ *   All rights reserved.
+ *
+ * THIS SOFTWARE IS PROVIDED BY NXP "AS IS" AND ANY EXPRESSED OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL NXP OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include "s32k1xx_periphclocks.h"
+#include "rddrone-bms772.h"
+
+/****************************************************************************
+ * Public Data
+ ****************************************************************************/
+
+/* Each S32K1XX board must provide the following initialized structure.
+ * This is needed to establish the initial peripheral clocking.
+ */
+
+const struct peripheral_clock_config_s g_peripheral_clockconfig0[] =
+{
+  {
+    .clkname = FLEXCAN0_CLK,
+#ifdef CONFIG_S32K1XX_FLEXCAN0
+    .clkgate = true,
+#else
+    .clkgate = false,
+#endif
+  },
+  {
+    .clkname = LPI2C0_CLK,
+#ifdef CONFIG_S32K1XX_LPI2C0
+    .clkgate = true,
+#else
+    .clkgate = false,
+#endif
+    .clksrc  = CLK_SRC_SIRC_DIV2,
+  },
+  {
+    .clkname = LPSPI0_CLK,
+#ifdef CONFIG_S32K1XX_LPSPI0
+    .clkgate = true,
+#else
+    .clkgate = false,
+#endif
+    .clksrc  = CLK_SRC_SIRC_DIV2,
+  },
+  {
+    .clkname = LPSPI1_CLK,
+#ifdef CONFIG_S32K1XX_LPSPI1
+    .clkgate = true,
+#else
+    .clkgate = false,
+#endif
+    .clksrc  = CLK_SRC_SIRC_DIV2,
+  },
+  {
+    .clkname = LPUART0_CLK,
+#ifdef CONFIG_S32K1XX_LPUART0
+    .clkgate = true,
+#else
+    .clkgate = false,
+#endif
+    .clksrc  = CLK_SRC_SIRC_DIV2,
+  },
+  {
+    .clkname = LPUART1_CLK,
+#ifdef CONFIG_S32K1XX_LPUART1
+    .clkgate = true,
+#else
+    .clkgate = false,
+#endif
+    .clksrc  = CLK_SRC_SIRC_DIV2,
+  },
+  {
+    .clkname = PORTA_CLK,
+    .clkgate = true,
+  },
+  {
+    .clkname = PORTB_CLK,
+    .clkgate = true,
+  },
+  {
+    .clkname = PORTC_CLK,
+    .clkgate = true,
+  },
+  {
+    .clkname = PORTD_CLK,
+    .clkgate = true,
+  },
+  {
+    .clkname = PORTE_CLK,
+    .clkgate = true,
+  },
+  {
+    .clkname = RTC0_CLK,
+#ifdef CONFIG_S32K1XX_RTC
+    .clkgate = true,
+#else
+    .clkgate = false,
+#endif
+  },
+};
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_spi.c b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_spi.c
new file mode 100644
index 0000000000..cc327371b1
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_spi.c
@@ -0,0 +1,166 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_spi.c
+ *
+ *   Copyright (C) 2018 Gregory Nutt. All rights reserved.
+ *   Author: Ivan Ucherdzhiev <ivanucherdjiev@gmail.com>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include <stdint.h>
+#include <stdbool.h>
+#include <errno.h>
+#include <debug.h>
+
+#include <nuttx/spi/spi.h>
+#include <nuttx/spi/spi_transfer.h>
+#include <arch/board/board.h>
+
+#include "arm_arch.h"
+
+#include "s32k1xx_config.h"
+#include "s32k1xx_lpspi.h"
+#include "s32k1xx_pin.h"
+#include "rddrone-bms772.h"
+
+#if defined(CONFIG_S32K1XX_LPSPI0) || defined(CONFIG_S32K1XX_LPSPI1)
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: s32k1xx_spidev_initialize
+ *
+ * Description:
+ *   Called to configure SPI chip select GPIO pins for the RDDRONE-BMS772
+ *   board.
+ *
+ ****************************************************************************/
+
+void weak_function s32k1xx_spidev_initialize(void)
+{
+#ifdef CONFIG_S32K1XX_LPSPI0
+  s32k1xx_pinconfig(PIN_LPSPI0_PCS);
+
+#ifdef CONFIG_SPI_DRIVER
+  struct spi_dev_s *g_lpspi0;
+  g_lpspi0 = s32k1xx_lpspibus_initialize(0);
+
+  if (!g_lpspi0)
+    {
+      spierr("ERROR: [boot] FAILED to initialize LPSPI0\n");
+    }
+
+  spi_register(g_lpspi0, 0);
+#endif
+#endif
+
+#ifdef CONFIG_S32K1XX_LPSPI1
+  s32k1xx_pinconfig(PIN_LPSPI1_PCS);
+
+#ifdef CONFIG_SPI_DRIVER
+  struct spi_dev_s *g_lpspi1;
+  g_lpspi1 = s32k1xx_lpspibus_initialize(1);
+
+  if (!g_lpspi1)
+    {
+      spierr("ERROR: [boot] FAILED to initialize LPSPI1\n");
+    }
+
+  spi_register(g_lpspi1, 1);
+#endif
+#endif
+}
+
+/****************************************************************************
+ * Name:  s32k1xx_lpspi0/1select and s32k1xx_lpspi0/1status
+ *
+ * Description:
+ *   The external functions, s32k1xx_lpspi0/1select and
+ *   s32k1xx_lpspi0/1status must be provided by board-specific logic.
+ *   They are implementations of the select and status methods of the SPI
+ *   interface defined by struct spi_ops_s (see include/nuttx/spi/spi.h).
+ *   All other methods (including s32k1xx_lpspibus_initialize()) are provided
+ *   by common logic.  To use this common SPI logic on your board:
+ *
+ *   1. Provide logic in s32k1xx_boardinitialize() to configure SPI chip
+ *      select pins.
+ *   2. Provide s32k1xx_lpspi0/1select() and s32k1xx_lpspi0/1status()
+ *      functions in your board-specific logic.  These functions will perform
+ *      chip selection and status operations using GPIOs in the way your
+ *      board is configured.
+ *   3. Add a calls to s32k1xx_lpspibus_initialize() in your low level
+ *      application initialization logic
+ *   4. The handle returned by s32k1xx_lpspibus_initialize() may then be used
+ *      to bind the SPI driver to higher level logic (e.g., calling
+ *      mmcsd_spislotinitialize(), for example, will bind the SPI driver to
+ *      the SPI MMC/SD driver).
+ *
+ ****************************************************************************/
+
+#ifdef CONFIG_S32K1XX_LPSPI0
+void s32k1xx_lpspi0select(FAR struct spi_dev_s *dev, uint32_t devid,
+                        bool selected)
+{
+  spiinfo("devid: %d CS: %s\n", (int)devid,
+          selected ? "assert" : "de-assert");
+
+  s32k1xx_gpiowrite(PIN_LPSPI0_PCS, !selected);
+}
+
+uint8_t s32k1xx_lpspi0status(FAR struct spi_dev_s *dev, uint32_t devid)
+{
+  return 0;
+}
+#endif
+
+#ifdef CONFIG_S32K1XX_LPSPI1
+void s32k1xx_lpspi1select(FAR struct spi_dev_s *dev,
+                        uint32_t devid, bool selected)
+{
+  spiinfo("devid: %d CS: %s\n", (int)devid,
+          selected ? "assert" : "de-assert");
+
+  s32k1xx_gpiowrite(PIN_LPSPI1_PCS, !selected);
+}
+
+uint8_t s32k1xx_lpspi1status(FAR struct spi_dev_s *dev, uint32_t devid)
+{
+  return 0;
+}
+#endif
+
+#endif /* CONFIG_S32K1XX_LPSPI0 || CONFIG_S32K1XX_LPSPI01 */
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_userleds.c b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_userleds.c
new file mode 100644
index 0000000000..10a0b8047c
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_userleds.c
@@ -0,0 +1,117 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_userleds.c
+ *
+ *   Copyright (C) 2019 Gregory Nutt. All rights reserved.
+ *   Author: Gregory Nutt <gnutt@nuttx.org>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name NuttX nor the names of its contributors may be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include <stdint.h>
+#include <stdbool.h>
+#include <debug.h>
+
+#include <nuttx/board.h>
+
+#include "arm_arch.h"
+#include "arm_internal.h"
+
+#include "s32k1xx_pin.h"
+#include "rddrone-bms772.h"
+
+#include <arch/board/board.h>
+
+#ifndef CONFIG_ARCH_LEDS
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: board_userled_initialize
+ ****************************************************************************/
+
+uint32_t board_userled_initialize(void)
+{
+  /* Configure LED GPIOs for output */
+
+  s32k1xx_pinconfig(GPIO_LED_R);
+  s32k1xx_pinconfig(GPIO_LED_G);
+  s32k1xx_pinconfig(GPIO_LED_B);
+  return BOARD_NLEDS;
+}
+
+/****************************************************************************
+ * Name: board_userled
+ ****************************************************************************/
+
+void board_userled(int led, bool ledon)
+{
+  uint32_t ledcfg;
+
+  if (led == BOARD_LED_R)
+    {
+      ledcfg = GPIO_LED_R;
+    }
+  else if (led == BOARD_LED_G)
+    {
+      ledcfg = GPIO_LED_G;
+    }
+  else if (led == BOARD_LED_B)
+    {
+      ledcfg = GPIO_LED_B;
+    }
+  else
+    {
+      return;
+    }
+
+  s32k1xx_gpiowrite(ledcfg, !ledon); /* High illuminates */
+}
+
+/****************************************************************************
+ * Name: board_userled_all
+ ****************************************************************************/
+
+void board_userled_all(uint32_t ledset)
+{
+  /* Low illuminates */
+
+  s32k1xx_gpiowrite(GPIO_LED_R, (ledset & BOARD_LED_R_BIT) == 0);
+  s32k1xx_gpiowrite(GPIO_LED_G, (ledset & BOARD_LED_G_BIT) == 0);
+  s32k1xx_gpiowrite(GPIO_LED_B, (ledset & BOARD_LED_B_BIT) == 0);
+}
+
+#endif /* !CONFIG_ARCH_LEDS */
diff --git a/sched/Makefile b/sched/Makefile
index 4d15730497..6aaa0bb7b7 100644
--- a/sched/Makefile
+++ b/sched/Makefile
@@ -32,6 +32,7 @@ include pthread/Make.defs
 include sched/Make.defs
 include semaphore/Make.defs
 include signal/Make.defs
+include systemview/Make.defs
 include task/Make.defs
 include timer/Make.defs
 include wdog/Make.defs
diff --git a/sched/init/nx_start.c b/sched/init/nx_start.c
index d4dff07f2e..effca60b61 100644
--- a/sched/init/nx_start.c
+++ b/sched/init/nx_start.c
@@ -76,6 +76,8 @@
 #include "group/group.h"
 #include "init/init.h"
 
+#include "systemview/SEGGER_SYSVIEW_NuttX.h"
+
 /****************************************************************************
  * Pre-processor Definitions
  ****************************************************************************/
@@ -803,6 +805,8 @@ void nx_start(void)
 
 #endif /* CONFIG_SMP */
 
+  TRACE_INIT();
+
   /* Bring Up the System ****************************************************/
 
   /* The OS is fully initialized and we are beginning multi-tasking */
diff --git a/sched/irq/irq_dispatch.c b/sched/irq/irq_dispatch.c
index 49be385613..03ae04ca62 100644
--- a/sched/irq/irq_dispatch.c
+++ b/sched/irq/irq_dispatch.c
@@ -49,6 +49,9 @@
 #include "clock/clock.h"
 #include "sched/sched.h"
 
+
+#include "systemview/SEGGER_SYSVIEW_NuttX.h"
+
 /****************************************************************************
  * Pre-processor Definitions
  ****************************************************************************/
@@ -139,6 +142,9 @@ void irq_dispatch(int irq, FAR void *context)
   FAR void *arg = NULL;
   unsigned int ndx = irq;
 
+
+  TRACE_ISR_ENTER();
+
 #if NR_IRQS > 0
   if ((unsigned)irq < NR_IRQS)
     {
@@ -183,6 +189,13 @@ void irq_dispatch(int irq, FAR void *context)
   CALL_VECTOR(ndx, vector, irq, context, arg);
   UNUSED(ndx);
 
+  if (g_running_tasks[this_cpu()] != this_task()) {
+    TRACE_ISR_EXIT_TO_SCHEDULER();
+    TRACE_TASK_START(this_task()->pid);
+  } else {
+    TRACE_ISR_EXIT();
+  }
+
 #ifdef CONFIG_SCHED_INSTRUMENTATION_IRQHANDLER
   /* Notify that we are leaving from the interrupt handler */
 
diff --git a/sched/pthread/pthread_create.c b/sched/pthread/pthread_create.c
index daef024476..6dfbd360df 100644
--- a/sched/pthread/pthread_create.c
+++ b/sched/pthread/pthread_create.c
@@ -45,6 +45,8 @@
 #include "clock/clock.h"
 #include "pthread/pthread.h"
 
+#include "systemview/SEGGER_SYSVIEW_NuttX.h"
+
 /****************************************************************************
  * Public Data
  ****************************************************************************/
@@ -235,6 +237,8 @@ int pthread_create(FAR pthread_t *thread, FAR const pthread_attr_t *attr,
   int ret;
   bool group_joined = false;
 
+  TRACE_API_PTHREAD_CREATE(thread, attr, start_routine, arg);
+
   /* If attributes were not supplied, use the default attributes */
 
   if (!attr)
@@ -587,6 +591,10 @@ int pthread_create(FAR pthread_t *thread, FAR const pthread_attr_t *attr,
       goto errout_with_join;
     }
 
+  TRACE_TASK_CREATED(pid, ptcb->cmn.name, ptcb->cmn.base_priority, ptcb->cmn.adj_stack_ptr, ptcb->cmn.adj_stack_size);
+
+  TRACE_API_PTHREAD_CREATE_RETURN(ret);
+
   return ret;
 
 errout_with_join:
@@ -603,5 +611,8 @@ errout_with_tcb:
     }
 
   nxsched_release_tcb((FAR struct tcb_s *)ptcb, TCB_FLAG_TTYPE_PTHREAD);
+
+  TRACE_API_PTHREAD_CREATE_RETURN(errcode);
+
   return errcode;
 }
diff --git a/sched/pthread/pthread_exit.c b/sched/pthread/pthread_exit.c
index b77f2c8a5c..55955dea20 100644
--- a/sched/pthread/pthread_exit.c
+++ b/sched/pthread/pthread_exit.c
@@ -55,6 +55,8 @@
 #include "task/task.h"
 #include "pthread/pthread.h"
 
+#include "systemview/SEGGER_SYSVIEW_NuttX.h"
+
 /****************************************************************************
  * Public Functions
  ****************************************************************************/
@@ -136,6 +138,8 @@ void pthread_exit(FAR void *exit_value)
 
   nxtask_exithook(tcb, EXIT_SUCCESS, false);
 
+  TRACE_TASK_TERMINATE(tcb->pid);
+
   /* Then just exit, retaining all file descriptors and without
    * calling atexit() functions.
    */
diff --git a/sched/sched/sched_addblocked.c b/sched/sched/sched_addblocked.c
index 6b6d8559c7..b3ed65d6c2 100644
--- a/sched/sched/sched_addblocked.c
+++ b/sched/sched/sched_addblocked.c
@@ -44,6 +44,8 @@
 
 #include "sched/sched.h"
 
+#include "systemview/SEGGER_SYSVIEW_NuttX.h"
+
 /****************************************************************************
  * Public Functions
  ****************************************************************************/
@@ -83,6 +85,8 @@ void nxsched_add_blocked(FAR struct tcb_s *btcb, tstate_t task_state)
   irqstate_t lock = nxsched_lock_tasklist();
 #endif
 
+  TRACE_TASK_BLOCK(btcb->pid, task_state);
+
   /* Add the TCB to the blocked task list associated with this state. */
 
   tasklist = TLIST_BLOCKED(task_state);
diff --git a/sched/sched/sched_addreadytorun.c b/sched/sched/sched_addreadytorun.c
index acb5ecac08..8cccc02a80 100644
--- a/sched/sched/sched_addreadytorun.c
+++ b/sched/sched/sched_addreadytorun.c
@@ -47,6 +47,8 @@
 #include "irq/irq.h"
 #include "sched/sched.h"
 
+#include "systemview/SEGGER_SYSVIEW_NuttX.h"
+
 /****************************************************************************
  * Public Functions
  ****************************************************************************/
@@ -85,6 +87,8 @@ bool nxsched_add_readytorun(FAR struct tcb_s *btcb)
   FAR struct tcb_s *rtcb = this_task();
   bool ret;
 
+  TRACE_TASK_READY(btcb->pid);
+
   /* Check if pre-emption is disabled for the current running task and if
    * the new ready-to-run task would cause the current running task to be
    * pre-empted.  NOTE that IRQs disabled implies that pre-emption is
diff --git a/sched/sched/sched_resumescheduler.c b/sched/sched/sched_resumescheduler.c
index fc9fe26568..e377ec1696 100644
--- a/sched/sched/sched_resumescheduler.c
+++ b/sched/sched/sched_resumescheduler.c
@@ -48,6 +48,8 @@
 #include "irq/irq.h"
 #include "sched/sched.h"
 
+#include "systemview/SEGGER_SYSVIEW_NuttX.h"
+
 #if CONFIG_RR_INTERVAL > 0 || defined(CONFIG_SCHED_RESUMESCHEDULER)
 
 /****************************************************************************
diff --git a/sched/systemview/Global.h b/sched/systemview/Global.h
new file mode 100644
index 0000000000..6e978bc92b
--- /dev/null
+++ b/sched/systemview/Global.h
@@ -0,0 +1,113 @@
+/*********************************************************************
+*                    SEGGER Microcontroller GmbH                     *
+*                        The Embedded Experts                        *
+**********************************************************************
+*                                                                    *
+*            (c) 1995 - 2019 SEGGER Microcontroller GmbH             *
+*                                                                    *
+*       www.segger.com     Support: support@segger.com               *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SEGGER SystemView * Real-time application analysis           *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+* All rights reserved.                                               *
+*                                                                    *
+* SEGGER strongly recommends to not make any changes                 *
+* to or modify the source code of this software in order to stay     *
+* compatible with the SystemView and RTT protocol, and J-Link.       *
+*                                                                    *
+* Redistribution and use in source and binary forms, with or         *
+* without modification, are permitted provided that the following    *
+* condition is met:                                                  *
+*                                                                    *
+* o Redistributions of source code must retain the above copyright   *
+*   notice, this condition and the following disclaimer.             *
+*                                                                    *
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
+* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
+* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
+* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
+* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
+* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
+* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
+* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
+* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
+* DAMAGE.                                                            *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SystemView version: V3.12                                    *
+*                                                                    *
+**********************************************************************
+----------------------------------------------------------------------
+File    : Global.h
+Purpose : Global types
+          In case your application already has a Global.h, you should
+          merge the files. In order to use Segger code, the types
+          U8, U16, U32, I8, I16, I32 need to be defined in Global.h;
+          additional definitions do not hurt.
+Revision: $Rev: 12501 $
+---------------------------END-OF-HEADER------------------------------
+*/
+
+#ifndef GLOBAL_H            // Guard against multiple inclusion
+#define GLOBAL_H
+
+#define U8    unsigned char
+#define I8    signed char
+#define U16   unsigned short
+#define I16   signed short
+#ifdef __x86_64__
+#define U32   unsigned
+#define I32   int
+#else
+#define U32   unsigned long
+#define I32   signed long
+#endif
+
+//
+// CC_NO_LONG_SUPPORT can be defined to compile test
+// without long support for compilers that do not
+// support C99 and its long type.
+//
+#ifdef CC_NO_LONG_SUPPORT
+  #define PTR_ADDR  U32
+#else  // Supports long type.
+#if defined(_WIN32) && !defined(__clang__) && !defined(__MINGW32__)
+  //
+  // Microsoft VC6 compiler related
+  //
+  #define U64   unsigned __int64
+  #define U128  unsigned __int128
+  #define I64   __int64
+  #define I128  __int128
+  #if _MSC_VER <= 1200
+    #define U64_C(x) x##UI64
+  #else
+    #define U64_C(x) x##ULL
+  #endif
+#else
+  //
+  // C99 compliant compiler
+  //
+  #define U64   unsigned long long
+  #define I64   signed long long
+  #define U64_C(x) x##ULL
+#endif
+
+#if (defined(_WIN64) || defined(__LP64__))  // 64-bit symbols used by Visual Studio and GCC, maybe others as well.
+  #define PTR_ADDR  U64
+#else
+  #define PTR_ADDR  U32
+#endif
+#endif  // Supports long type.
+
+#endif                      // Avoid multiple inclusion
+
+/*************************** End of file ****************************/
diff --git a/sched/systemview/Kconfig b/sched/systemview/Kconfig
new file mode 100644
index 0000000000..7d22459232
--- /dev/null
+++ b/sched/systemview/Kconfig
@@ -0,0 +1,66 @@
+#
+# For a description of the syntax of this configuration file,
+# see the file kconfig-language.txt in the NuttX tools repository.
+#
+
+menuconfig SYSTEMVIEW_ENABLE
+	bool "Enable SystemView Instrumentation"
+	default n
+    ---help---
+        Enable instrumentation of the scheduler using SEGGER SystemView.
+
+if SYSTEMVIEW_ENABLE
+config SYSTEMVIEW_APP_NAME
+    string "Application Name"
+    default "NuttX start project"
+config SYSTEMVIEW_DEVICE_NAME
+    string "Device Name"
+    default "Cortex-M3/M4/M7"
+config SYSTEMVIEW_CPU_FREQ
+    int "CPU Frequency [Hz]"
+    default 168000000
+config SYSTEMVIEW_TIMESTAMP_FREQ
+    int "Timestamp Frequency [Hz]"
+    default 168000000
+config SYSTEMVIEW_RES_ID_BASE
+    hex "Resource ID Base"
+    default 0x00000000
+config SYSTEMVIEW_RES_ID_SHIFT
+    int "Resource ID Shift"
+    default 0
+config SYSTEMVIEW_START_ON_INIT
+    bool "Start Recording on Init"
+    default n
+config SYSTEMVIEW_SYSDESC_0
+    string "System Description 0"
+    default "I#11=SVC,I#15=SysTick"
+config SYSTEMVIEW_SYSDESC_1
+    string "System Description 1"
+config SYSTEMVIEW_SYSDESC_2
+    string "System Description 2"
+config SYSTEMVIEW_RECORD_API
+    bool "Record APIs"
+    default y
+config SYSTEMVIEW_RECORD_ISR
+    bool "Record Interrupts"
+    default y
+config SYSTEMVIEW_BUFFER_SIZE
+    int "SystemView Buffer Size"
+    default 8192
+config SYSTEMVIEW_RTT_CHANNEL
+    int "SystemView RTT Channel"
+    default 1
+config SYSTEMVIEW_USE_STATIC_BUFFER
+    bool "Use static event buffer"
+    default y
+config SYSTEMVIEW_POST_MORTEM_MODE
+    bool "Enable Post-Mortem Mode"
+    default n
+config SYSTEMVIEW_MAX_NOF_TASKS
+    int "Maximum Number of Tasks"
+    default 16
+    ---help---
+        Maximum number of Tasks to be recorded by Systemview.
+        If more tasks are created, their information is not added to the list, i.e. not recorded.
+        
+endif # SYSTEMVIEW_ENABLE
diff --git a/sched/systemview/Make.defs b/sched/systemview/Make.defs
new file mode 100644
index 0000000000..2ab5602b29
--- /dev/null
+++ b/sched/systemview/Make.defs
@@ -0,0 +1,47 @@
+############################################################################
+# sched/systemview/Make.defs
+#
+#   Copyright (C) 2014, 2018 Gregory Nutt. All rights reserved.
+#   Author: Gregory Nutt <gnutt@nuttx.org>
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in
+#    the documentation and/or other materials provided with the
+#    distribution.
+# 3. Neither the name NuttX nor the names of its contributors may be
+#    used to endorse or promote products derived from this software
+#    without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+# OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+# AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+############################################################################
+
+ifeq ($(CONFIG_SYSTEMVIEW_ENABLE),y)
+
+ASRCS += SEGGER_RTT_ASM_ARMv7M.S
+
+CSRCS += SEGGER_RTT.c SEGGER_RTT_printf.c SEGGER_SYSVIEW.c SEGGER_SYSVIEW_Config_NuttX.c SEGGER_SYSVIEW_NuttX.c
+
+endif
+
+# Include systemview build support
+
+DEPPATH += --dep-path systemview
+VPATH += :systemview
diff --git a/sched/systemview/Makefile b/sched/systemview/Makefile
new file mode 100644
index 0000000000..95cb4439a4
--- /dev/null
+++ b/sched/systemview/Makefile
@@ -0,0 +1,76 @@
+############################################################################
+# systemview/Makefile
+##
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in
+#    the documentation and/or other materials provided with the
+#    distribution.
+# 3. Neither the name NuttX nor the names of its contributors may be
+#    used to endorse or promote products derived from this software
+#    without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+# OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+# AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+############################################################################
+
+-include $(TOPDIR)/Make.defs
+
+ASRCS = SEGGER_RTT_ASM_ARMv7M.S
+AOBJS = $(ASRCS:.S=$(OBJEXT))
+
+CSRCS = SEGGER_RTT.c SEGGER_RTT_printf.c SEGGER_SYSVIEW.c SEGGER_SYSVIEW_Config_NuttX.c SEGGER_SYSVIEW_NuttX.c
+
+DEPPATH = --dep-path .
+VPATH = .
+
+COBJS = $(CSRCS:.c=$(OBJEXT))
+
+SRCS = $(ASRCS) $(CSRCS)
+OBJS = $(AOBJS) $(COBJS)
+
+BIN = libsystemview$(LIBEXT)
+
+all: $(BIN)
+.PHONY: depend clean distclean
+
+$(AOBJS): %$(OBJEXT): %.S
+	$(call ASSEMBLE, $<, $@)
+
+$(COBJS): %$(OBJEXT): %.c
+	$(call COMPILE, $<, $@)
+
+$(BIN):	$(OBJS)
+	$(call ARCHIVE, $@, $(OBJS))
+
+.depend: Makefile $(SRCS)
+	$(Q) $(MKDEP) $(DEPPATH) "$(CC)" -- $(CFLAGS) -- $(SRCS) >Make.dep
+	$(Q) touch $@
+
+depend: .depend
+
+clean:
+	$(call DELFILE, $(BIN))
+	$(call CLEAN)
+
+distclean: clean
+	$(call DELFILE, Make.dep)
+	$(call DELFILE, .depend)
+
+-include Make.dep
diff --git a/sched/systemview/SEGGER.h b/sched/systemview/SEGGER.h
new file mode 100644
index 0000000000..a2b43065fd
--- /dev/null
+++ b/sched/systemview/SEGGER.h
@@ -0,0 +1,248 @@
+/*********************************************************************
+*                    SEGGER Microcontroller GmbH                     *
+*                        The Embedded Experts                        *
+**********************************************************************
+*                                                                    *
+*            (c) 1995 - 2019 SEGGER Microcontroller GmbH             *
+*                                                                    *
+*       www.segger.com     Support: support@segger.com               *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SEGGER SystemView * Real-time application analysis           *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+* All rights reserved.                                               *
+*                                                                    *
+* SEGGER strongly recommends to not make any changes                 *
+* to or modify the source code of this software in order to stay     *
+* compatible with the SystemView and RTT protocol, and J-Link.       *
+*                                                                    *
+* Redistribution and use in source and binary forms, with or         *
+* without modification, are permitted provided that the following    *
+* condition is met:                                                  *
+*                                                                    *
+* o Redistributions of source code must retain the above copyright   *
+*   notice, this condition and the following disclaimer.             *
+*                                                                    *
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
+* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
+* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
+* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
+* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
+* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
+* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
+* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
+* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
+* DAMAGE.                                                            *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SystemView version: V3.12                                    *
+*                                                                    *
+**********************************************************************
+----------------------------------------------------------------------
+File    : SEGGER.h
+Purpose : Global types etc & general purpose utility functions
+Revision: $Rev: 18102 $
+---------------------------END-OF-HEADER------------------------------
+*/
+
+#ifndef SEGGER_H            // Guard against multiple inclusion
+#define SEGGER_H
+
+#include <stdarg.h>         // For va_list.
+#include "Global.h"         // Type definitions: U8, U16, U32, I8, I16, I32
+
+#if defined(__cplusplus)
+extern "C" {     /* Make sure we have C-declarations in C++ programs */
+#endif
+
+/*********************************************************************
+*
+*       Keywords/specifiers
+*
+**********************************************************************
+*/
+
+#ifndef INLINE
+  #if (defined(__ICCARM__) || defined(__RX) || defined(__ICCRX__))
+    //
+    // Other known compilers.
+    //
+    #define INLINE  inline
+  #else
+    #if (defined(_WIN32) && !defined(__clang__))
+      //
+      // Microsoft VC6 and newer.
+      // Force inlining without cost checking.
+      //
+      #define INLINE  __forceinline
+    #elif defined(__GNUC__) || defined(__clang__)
+      //
+      // Force inlining with GCC + clang
+      //
+      #define INLINE inline __attribute__((always_inline))
+    #elif (defined(__CC_ARM))
+      //
+      // Force inlining with ARMCC (Keil)
+      //
+      #define INLINE  __inline
+    #else
+      //
+      // Unknown compilers.
+      //
+      #define INLINE
+    #endif
+  #endif
+#endif
+
+/*********************************************************************
+*
+*       Function-like macros
+*
+**********************************************************************
+*/
+
+#define SEGGER_COUNTOF(a)          (sizeof((a))/sizeof((a)[0]))
+#define SEGGER_MIN(a,b)            (((a) < (b)) ? (a) : (b))
+#define SEGGER_MAX(a,b)            (((a) > (b)) ? (a) : (b))
+
+#ifndef   SEGGER_USE_PARA                   // Some compiler complain about unused parameters.
+  #define SEGGER_USE_PARA(Para) (void)Para  // This works for most compilers.
+#endif
+
+#define SEGGER_ADDR2PTR(Type, Addr)  (/*lint -e(923) -e(9078)*/((Type*)((PTR_ADDR)(Addr))))    // Allow cast from address to pointer.
+#define SEGGER_PTR2ADDR(p)           (/*lint -e(923) -e(9078)*/((PTR_ADDR)(p)))                // Allow cast from pointer to address.
+#define SEGGER_PTR2PTR(Type, p)      (/*lint -e(740) -e(826) -e(9079) -e(9087)*/((Type*)(p)))  // Allow cast from one pointer type to another (ignore different size).
+#define SEGGER_PTR_DISTANCE(p0, p1)  (SEGGER_PTR2ADDR(p0) - SEGGER_PTR2ADDR(p1))
+
+/*********************************************************************
+*
+*       Defines
+*
+**********************************************************************
+*/
+
+#define SEGGER_PRINTF_FLAG_ADJLEFT    (1 << 0)
+#define SEGGER_PRINTF_FLAG_SIGNFORCE  (1 << 1)
+#define SEGGER_PRINTF_FLAG_SIGNSPACE  (1 << 2)
+#define SEGGER_PRINTF_FLAG_PRECEED    (1 << 3)
+#define SEGGER_PRINTF_FLAG_ZEROPAD    (1 << 4)
+#define SEGGER_PRINTF_FLAG_NEGATIVE   (1 << 5)
+
+/*********************************************************************
+*
+*       Types
+*
+**********************************************************************
+*/
+
+typedef struct {
+  char* pBuffer;
+  int   BufferSize;
+  int   Cnt;
+} SEGGER_BUFFER_DESC;
+
+typedef struct {
+  unsigned int CacheLineSize;                             // 0: No Cache. Most Systems such as ARM9 use a 32 bytes cache line size.
+  void (*pfDMB)       (void);                             // Optional DMB function for Data Memory Barrier to make sure all memory operations are completed.
+  void (*pfClean)     (void *p, unsigned long NumBytes);  // Optional clean function for cached memory.
+  void (*pfInvalidate)(void *p, unsigned long NumBytes);  // Optional invalidate function for cached memory.
+} SEGGER_CACHE_CONFIG;
+
+typedef struct SEGGER_SNPRINTF_CONTEXT_struct SEGGER_SNPRINTF_CONTEXT;
+
+struct SEGGER_SNPRINTF_CONTEXT_struct {
+  void*               pContext;                       // Application specific context.
+  SEGGER_BUFFER_DESC* pBufferDesc;                    // Buffer descriptor to use for output.
+  void (*pfFlush)(SEGGER_SNPRINTF_CONTEXT* pContext); // Callback executed once the buffer is full. Callback decides if the buffer gets cleared to store more or not.
+};
+
+typedef struct {
+  void (*pfStoreChar)       (SEGGER_BUFFER_DESC* pBufferDesc, SEGGER_SNPRINTF_CONTEXT* pContext, char c);
+  int  (*pfPrintUnsigned)   (SEGGER_BUFFER_DESC* pBufferDesc, SEGGER_SNPRINTF_CONTEXT* pContext, U32 v, unsigned Base, char Flags, int Width, int Precision);
+  int  (*pfPrintInt)        (SEGGER_BUFFER_DESC* pBufferDesc, SEGGER_SNPRINTF_CONTEXT* pContext, I32 v, unsigned Base, char Flags, int Width, int Precision);
+} SEGGER_PRINTF_API;
+
+typedef void (*SEGGER_pFormatter)(SEGGER_BUFFER_DESC* pBufferDesc, SEGGER_SNPRINTF_CONTEXT* pContext, const SEGGER_PRINTF_API* pApi, va_list* pParamList, char Lead, int Width, int Precision);
+
+typedef struct SEGGER_PRINTF_FORMATTER {
+  struct SEGGER_PRINTF_FORMATTER* pNext;              // Pointer to next formatter.
+  SEGGER_pFormatter               pfFormatter;        // Formatter function.
+  char                            Specifier;          // Format specifier.
+} SEGGER_PRINTF_FORMATTER;
+
+typedef struct {
+  U32 (*pfGetHPTimestamp)(void);          // Mandatory, pfGetHPTimestamp
+  int (*pfGetUID)        (U8 abUID[16]);  // Optional,  pfGetUID
+} SEGGER_BSP_API;
+
+/*********************************************************************
+*
+*       Utility functions
+*
+**********************************************************************
+*/
+
+//
+// Memory operations.
+//
+void SEGGER_ARM_memcpy(void* pDest, const void* pSrc, int NumBytes);
+void SEGGER_memcpy    (void* pDest, const void* pSrc, unsigned NumBytes);
+void SEGGER_memxor    (void* pDest, const void* pSrc, unsigned NumBytes);
+
+//
+// String functions.
+//
+int      SEGGER_atoi       (const char* s);
+int      SEGGER_isalnum    (int c);
+int      SEGGER_isalpha    (int c);
+unsigned SEGGER_strlen     (const char* s);
+int      SEGGER_tolower    (int c);
+int      SEGGER_strcasecmp (const char* sText1, const char* sText2);
+int      SEGGER_strncasecmp(const char *sText1, const char *sText2, unsigned Count);
+
+//
+// Buffer/printf related.
+//
+void SEGGER_StoreChar    (SEGGER_BUFFER_DESC* pBufferDesc, char c);
+void SEGGER_PrintUnsigned(SEGGER_BUFFER_DESC* pBufferDesc, U32 v, unsigned Base, int Precision);
+void SEGGER_PrintInt     (SEGGER_BUFFER_DESC* pBufferDesc, I32 v, unsigned Base, int Precision);
+int  SEGGER_snprintf     (char* pBuffer, int BufferSize, const char* sFormat, ...);
+int  SEGGER_vsnprintf    (char* pBuffer, int BufferSize, const char* sFormat, va_list ParamList);
+int  SEGGER_vsnprintfEx  (SEGGER_SNPRINTF_CONTEXT* pContext, const char* sFormat, va_list ParamList);
+
+int  SEGGER_PRINTF_AddFormatter       (SEGGER_PRINTF_FORMATTER* pFormatter, SEGGER_pFormatter pfFormatter, char c);
+void SEGGER_PRINTF_AddDoubleFormatter (void);
+void SEGGER_PRINTF_AddIPFormatter     (void);
+void SEGGER_PRINTF_AddBLUEFormatter   (void);
+void SEGGER_PRINTF_AddCONNECTFormatter(void);
+void SEGGER_PRINTF_AddSSLFormatter    (void);
+void SEGGER_PRINTF_AddSSHFormatter    (void);
+void SEGGER_PRINTF_AddHTMLFormatter   (void);
+
+//
+// BSP abstraction API.
+//
+int  SEGGER_BSP_GetUID  (U8 abUID[16]);
+int  SEGGER_BSP_GetUID32(U32* pUID);
+void SEGGER_BSP_SetAPI  (const SEGGER_BSP_API* pAPI);
+void SEGGER_BSP_SeedUID (void);
+
+//
+// Other API.
+//
+void SEGGER_VERSION_GetString(char acText[8], unsigned Version);
+
+#if defined(__cplusplus)
+}                /* Make sure we have C-declarations in C++ programs */
+#endif
+
+#endif                      // Avoid multiple inclusion
+
+/*************************** End of file ****************************/
diff --git a/sched/systemview/SEGGER_RTT.c b/sched/systemview/SEGGER_RTT.c
new file mode 100644
index 0000000000..b5a6eafc44
--- /dev/null
+++ b/sched/systemview/SEGGER_RTT.c
@@ -0,0 +1,2009 @@
+/*********************************************************************
+*                    SEGGER Microcontroller GmbH                     *
+*                        The Embedded Experts                        *
+**********************************************************************
+*                                                                    *
+*            (c) 1995 - 2019 SEGGER Microcontroller GmbH             *
+*                                                                    *
+*       www.segger.com     Support: support@segger.com               *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SEGGER SystemView * Real-time application analysis           *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+* All rights reserved.                                               *
+*                                                                    *
+* SEGGER strongly recommends to not make any changes                 *
+* to or modify the source code of this software in order to stay     *
+* compatible with the SystemView and RTT protocol, and J-Link.       *
+*                                                                    *
+* Redistribution and use in source and binary forms, with or         *
+* without modification, are permitted provided that the following    *
+* condition is met:                                                  *
+*                                                                    *
+* o Redistributions of source code must retain the above copyright   *
+*   notice, this condition and the following disclaimer.             *
+*                                                                    *
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
+* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
+* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
+* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
+* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
+* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
+* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
+* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
+* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
+* DAMAGE.                                                            *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SystemView version: V3.12                                    *
+*                                                                    *
+**********************************************************************
+---------------------------END-OF-HEADER------------------------------
+File    : SEGGER_RTT.c
+Purpose : Implementation of SEGGER real-time transfer (RTT) which
+          allows real-time communication on targets which support
+          debugger memory accesses while the CPU is running.
+Revision: $Rev: 17697 $
+
+Additional information:
+          Type "int" is assumed to be 32-bits in size
+          H->T    Host to target communication
+          T->H    Target to host communication
+
+          RTT channel 0 is always present and reserved for Terminal usage.
+          Name is fixed to "Terminal"
+
+          Effective buffer size: SizeOfBuffer - 1
+
+          WrOff == RdOff:       Buffer is empty
+          WrOff == (RdOff - 1): Buffer is full
+          WrOff >  RdOff:       Free space includes wrap-around
+          WrOff <  RdOff:       Used space includes wrap-around
+          (WrOff == (SizeOfBuffer - 1)) && (RdOff == 0):  
+                                Buffer full and wrap-around after next byte
+
+
+----------------------------------------------------------------------
+*/
+
+#include "SEGGER_RTT.h"
+
+#include <string.h>                 // for memcpy
+
+/*********************************************************************
+*
+*       Configuration, default values
+*
+**********************************************************************
+*/
+
+#ifndef   BUFFER_SIZE_UP
+  #define BUFFER_SIZE_UP                                  1024  // Size of the buffer for terminal output of target, up to host
+#endif
+
+#ifndef   BUFFER_SIZE_DOWN
+  #define BUFFER_SIZE_DOWN                                16    // Size of the buffer for terminal input to target from host (Usually keyboard input)
+#endif
+
+#ifndef   SEGGER_RTT_MAX_NUM_UP_BUFFERS
+  #define SEGGER_RTT_MAX_NUM_UP_BUFFERS                    2    // Number of up-buffers (T->H) available on this target
+#endif
+
+#ifndef   SEGGER_RTT_MAX_NUM_DOWN_BUFFERS
+  #define SEGGER_RTT_MAX_NUM_DOWN_BUFFERS                  2    // Number of down-buffers (H->T) available on this target
+#endif
+
+#ifndef SEGGER_RTT_BUFFER_SECTION
+  #if defined(SEGGER_RTT_SECTION)
+    #define SEGGER_RTT_BUFFER_SECTION SEGGER_RTT_SECTION
+  #endif
+#endif
+
+#ifndef   SEGGER_RTT_ALIGNMENT
+  #define SEGGER_RTT_ALIGNMENT                            0
+#endif
+
+#ifndef   SEGGER_RTT_BUFFER_ALIGNMENT
+  #define SEGGER_RTT_BUFFER_ALIGNMENT                     0
+#endif
+
+#ifndef   SEGGER_RTT_MODE_DEFAULT
+  #define SEGGER_RTT_MODE_DEFAULT                         SEGGER_RTT_MODE_NO_BLOCK_SKIP
+#endif
+
+#ifndef   SEGGER_RTT_LOCK
+  #define SEGGER_RTT_LOCK()
+#endif
+
+#ifndef   SEGGER_RTT_UNLOCK
+  #define SEGGER_RTT_UNLOCK()
+#endif
+
+#ifndef   STRLEN
+  #define STRLEN(a)                                       strlen((a))
+#endif
+
+#ifndef   STRCPY
+  #define STRCPY(pDest, pSrc, NumBytes)                   strcpy((pDest), (pSrc))
+#endif
+
+#ifndef   SEGGER_RTT_MEMCPY_USE_BYTELOOP
+  #define SEGGER_RTT_MEMCPY_USE_BYTELOOP                  0
+#endif
+
+#ifndef   SEGGER_RTT_MEMCPY
+  #ifdef  MEMCPY
+    #define SEGGER_RTT_MEMCPY(pDest, pSrc, NumBytes)      MEMCPY((pDest), (pSrc), (NumBytes))
+  #else
+    #define SEGGER_RTT_MEMCPY(pDest, pSrc, NumBytes)      memcpy((pDest), (pSrc), (NumBytes))
+  #endif
+#endif
+
+#ifndef   MIN
+  #define MIN(a, b)         (((a) < (b)) ? (a) : (b))
+#endif
+
+#ifndef   MAX
+  #define MAX(a, b)         (((a) > (b)) ? (a) : (b))
+#endif
+//
+// For some environments, NULL may not be defined until certain headers are included
+//
+#ifndef NULL
+  #define NULL 0
+#endif
+
+/*********************************************************************
+*
+*       Defines, fixed
+*
+**********************************************************************
+*/
+#if (defined __ICCARM__) || (defined __ICCRX__)
+  #define RTT_PRAGMA(P) _Pragma(#P)
+#endif
+
+#if SEGGER_RTT_ALIGNMENT || SEGGER_RTT_BUFFER_ALIGNMENT
+  #if (defined __GNUC__)
+    #define SEGGER_RTT_ALIGN(Var, Alignment) Var __attribute__ ((aligned (Alignment)))
+  #elif (defined __ICCARM__) || (defined __ICCRX__)
+    #define PRAGMA(A) _Pragma(#A)
+#define SEGGER_RTT_ALIGN(Var, Alignment) RTT_PRAGMA(data_alignment=Alignment) \
+                                  Var
+  #elif (defined __CC_ARM)
+    #define SEGGER_RTT_ALIGN(Var, Alignment) Var __attribute__ ((aligned (Alignment)))
+  #else
+    #error "Alignment not supported for this compiler."
+  #endif
+#else
+  #define SEGGER_RTT_ALIGN(Var, Alignment) Var
+#endif
+
+#if defined(SEGGER_RTT_SECTION) || defined (SEGGER_RTT_BUFFER_SECTION)
+  #if (defined __GNUC__)
+    #define SEGGER_RTT_PUT_SECTION(Var, Section) __attribute__ ((section (Section))) Var
+  #elif (defined __ICCARM__) || (defined __ICCRX__)
+#define SEGGER_RTT_PUT_SECTION(Var, Section) RTT_PRAGMA(location=Section) \
+                                        Var
+  #elif (defined __CC_ARM)
+    #define SEGGER_RTT_PUT_SECTION(Var, Section) __attribute__ ((section (Section), zero_init))  Var
+  #else
+    #error "Section placement not supported for this compiler."
+  #endif
+#else
+  #define SEGGER_RTT_PUT_SECTION(Var, Section) Var
+#endif
+
+
+#if SEGGER_RTT_ALIGNMENT
+  #define SEGGER_RTT_CB_ALIGN(Var)  SEGGER_RTT_ALIGN(Var, SEGGER_RTT_ALIGNMENT)
+#else
+  #define SEGGER_RTT_CB_ALIGN(Var)  Var
+#endif
+
+#if SEGGER_RTT_BUFFER_ALIGNMENT
+  #define SEGGER_RTT_BUFFER_ALIGN(Var)  SEGGER_RTT_ALIGN(Var, SEGGER_RTT_BUFFER_ALIGNMENT)
+#else
+  #define SEGGER_RTT_BUFFER_ALIGN(Var)  Var
+#endif
+
+
+#if defined(SEGGER_RTT_SECTION)
+  #define SEGGER_RTT_PUT_CB_SECTION(Var) SEGGER_RTT_PUT_SECTION(Var, SEGGER_RTT_SECTION)
+#else
+  #define SEGGER_RTT_PUT_CB_SECTION(Var) Var
+#endif
+
+#if defined(SEGGER_RTT_BUFFER_SECTION)
+  #define SEGGER_RTT_PUT_BUFFER_SECTION(Var) SEGGER_RTT_PUT_SECTION(Var, SEGGER_RTT_BUFFER_SECTION)
+#else
+  #define SEGGER_RTT_PUT_BUFFER_SECTION(Var) Var
+#endif
+
+/*********************************************************************
+*
+*       Static const data
+*
+**********************************************************************
+*/
+
+static unsigned char _aTerminalId[16] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
+
+/*********************************************************************
+*
+*       Static data
+*
+**********************************************************************
+*/
+//
+// RTT Control Block and allocate buffers for channel 0
+//
+SEGGER_RTT_PUT_CB_SECTION(SEGGER_RTT_CB_ALIGN(SEGGER_RTT_CB _SEGGER_RTT));
+
+SEGGER_RTT_PUT_BUFFER_SECTION(SEGGER_RTT_BUFFER_ALIGN(static char _acUpBuffer  [BUFFER_SIZE_UP]));
+SEGGER_RTT_PUT_BUFFER_SECTION(SEGGER_RTT_BUFFER_ALIGN(static char _acDownBuffer[BUFFER_SIZE_DOWN]));
+
+static unsigned char _ActiveTerminal;
+
+/*********************************************************************
+*
+*       Static functions
+*
+**********************************************************************
+*/
+
+/*********************************************************************
+*
+*       _DoInit()
+*
+*  Function description
+*    Initializes the control block an buffers.
+*    May only be called via INIT() to avoid overriding settings.
+*
+*/
+#define INIT()  do {                                            \
+                  if (_SEGGER_RTT.acID[0] == '\0') { _DoInit(); }  \
+                } while (0)
+static void _DoInit(void) {
+  SEGGER_RTT_CB* p;
+  //
+  // Initialize control block
+  //
+  p = &_SEGGER_RTT;
+  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
+  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
+  //
+  // Initialize up buffer 0
+  //
+  p->aUp[0].sName         = "Terminal";
+  p->aUp[0].pBuffer       = _acUpBuffer;
+  p->aUp[0].SizeOfBuffer  = sizeof(_acUpBuffer);
+  p->aUp[0].RdOff         = 0u;
+  p->aUp[0].WrOff         = 0u;
+  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
+  //
+  // Initialize down buffer 0
+  //
+  p->aDown[0].sName         = "Terminal";
+  p->aDown[0].pBuffer       = _acDownBuffer;
+  p->aDown[0].SizeOfBuffer  = sizeof(_acDownBuffer);
+  p->aDown[0].RdOff         = 0u;
+  p->aDown[0].WrOff         = 0u;
+  p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
+  //
+  // Finish initialization of the control block.
+  // Copy Id string in three steps to make sure "SEGGER RTT" is not found
+  // in initializer memory (usually flash) by J-Link
+  //
+  STRCPY(&p->acID[7], "RTT", 9);
+  STRCPY(&p->acID[0], "SEGGER", 7);
+  p->acID[6] = ' ';
+}
+
+/*********************************************************************
+*
+*       _WriteBlocking()
+*
+*  Function description
+*    Stores a specified number of characters in SEGGER RTT ring buffer
+*    and updates the associated write pointer which is periodically
+*    read by the host.
+*    The caller is responsible for managing the write chunk sizes as
+*    _WriteBlocking() will block until all data has been posted successfully.
+*
+*  Parameters
+*    pRing        Ring buffer to post to.
+*    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
+*    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
+*
+*  Return value
+*    >= 0 - Number of bytes written into buffer.
+*/
+static unsigned _WriteBlocking(SEGGER_RTT_BUFFER_UP* pRing, const char* pBuffer, unsigned NumBytes) {
+  unsigned NumBytesToWrite;
+  unsigned NumBytesWritten;
+  unsigned RdOff;
+  unsigned WrOff;
+#if SEGGER_RTT_MEMCPY_USE_BYTELOOP
+  char*    pDst;
+#endif
+  //
+  // Write data to buffer and handle wrap-around if necessary
+  //
+  NumBytesWritten = 0u;
+  WrOff = pRing->WrOff;
+  do {
+    RdOff = pRing->RdOff;                         // May be changed by host (debug probe) in the meantime
+    if (RdOff > WrOff) {
+      NumBytesToWrite = RdOff - WrOff - 1u;
+    } else {
+      NumBytesToWrite = pRing->SizeOfBuffer - (WrOff - RdOff + 1u);
+    }
+    NumBytesToWrite = MIN(NumBytesToWrite, (pRing->SizeOfBuffer - WrOff));      // Number of bytes that can be written until buffer wrap-around
+    NumBytesToWrite = MIN(NumBytesToWrite, NumBytes);
+#if SEGGER_RTT_MEMCPY_USE_BYTELOOP
+    pDst = pRing->pBuffer + WrOff;
+    NumBytesWritten += NumBytesToWrite;
+    NumBytes        -= NumBytesToWrite;
+    WrOff           += NumBytesToWrite;
+    while (NumBytesToWrite--) {
+      *pDst++ = *pBuffer++;
+    };
+#else
+    SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pBuffer, NumBytesToWrite);
+    NumBytesWritten += NumBytesToWrite;
+    pBuffer         += NumBytesToWrite;
+    NumBytes        -= NumBytesToWrite;
+    WrOff           += NumBytesToWrite;
+#endif
+    if (WrOff == pRing->SizeOfBuffer) {
+      WrOff = 0u;
+    }
+    pRing->WrOff = WrOff;
+  } while (NumBytes);
+  //
+  return NumBytesWritten;
+}
+
+/*********************************************************************
+*
+*       _WriteNoCheck()
+*
+*  Function description
+*    Stores a specified number of characters in SEGGER RTT ring buffer
+*    and updates the associated write pointer which is periodically
+*    read by the host.
+*    It is callers responsibility to make sure data actually fits in buffer.
+*
+*  Parameters
+*    pRing        Ring buffer to post to.
+*    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
+*    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
+*
+*  Notes
+*    (1) If there might not be enough space in the "Up"-buffer, call _WriteBlocking
+*/
+static void _WriteNoCheck(SEGGER_RTT_BUFFER_UP* pRing, const char* pData, unsigned NumBytes) {
+  unsigned NumBytesAtOnce;
+  unsigned WrOff;
+  unsigned Rem;
+#if SEGGER_RTT_MEMCPY_USE_BYTELOOP
+  char*    pDst;
+#endif
+
+  WrOff = pRing->WrOff;
+  Rem = pRing->SizeOfBuffer - WrOff;
+  if (Rem > NumBytes) {
+    //
+    // All data fits before wrap around
+    //
+#if SEGGER_RTT_MEMCPY_USE_BYTELOOP
+    pDst = pRing->pBuffer + WrOff;
+    WrOff += NumBytes;
+    while (NumBytes--) {
+      *pDst++ = *pData++;
+    };
+    pRing->WrOff = WrOff;
+#else
+    SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pData, NumBytes);
+    pRing->WrOff = WrOff + NumBytes;
+#endif
+  } else {
+    //
+    // We reach the end of the buffer, so need to wrap around
+    //
+#if SEGGER_RTT_MEMCPY_USE_BYTELOOP
+    pDst = pRing->pBuffer + WrOff;
+    NumBytesAtOnce = Rem;
+    while (NumBytesAtOnce--) {
+      *pDst++ = *pData++;
+    };
+    pDst = pRing->pBuffer;
+    NumBytesAtOnce = NumBytes - Rem;
+    while (NumBytesAtOnce--) {
+      *pDst++ = *pData++;
+    };
+    pRing->WrOff = NumBytes - Rem;
+#else
+    NumBytesAtOnce = Rem;
+    SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pData, NumBytesAtOnce);
+    NumBytesAtOnce = NumBytes - Rem;
+    SEGGER_RTT_MEMCPY(pRing->pBuffer, pData + Rem, NumBytesAtOnce);
+    pRing->WrOff = NumBytesAtOnce;
+#endif
+  }
+}
+
+/*********************************************************************
+*
+*       _PostTerminalSwitch()
+*
+*  Function description
+*    Switch terminal to the given terminal ID.  It is the caller's
+*    responsibility to ensure the terminal ID is correct and there is
+*    enough space in the buffer for this to complete successfully.
+*
+*  Parameters
+*    pRing        Ring buffer to post to.
+*    TerminalId   Terminal ID to switch to.
+*/
+static void _PostTerminalSwitch(SEGGER_RTT_BUFFER_UP* pRing, unsigned char TerminalId) {
+  unsigned char ac[2];
+
+  ac[0] = 0xFFu;
+  ac[1] = _aTerminalId[TerminalId];  // Caller made already sure that TerminalId does not exceed our terminal limit
+  _WriteBlocking(pRing, (const char*)ac, 2u);
+}
+
+/*********************************************************************
+*
+*       _GetAvailWriteSpace()
+*
+*  Function description
+*    Returns the number of bytes that can be written to the ring
+*    buffer without blocking.
+*
+*  Parameters
+*    pRing        Ring buffer to check.
+*
+*  Return value
+*    Number of bytes that are free in the buffer.
+*/
+static unsigned _GetAvailWriteSpace(SEGGER_RTT_BUFFER_UP* pRing) {
+  unsigned RdOff;
+  unsigned WrOff;
+  unsigned r;
+  //
+  // Avoid warnings regarding volatile access order.  It's not a problem
+  // in this case, but dampen compiler enthusiasm.
+  //
+  RdOff = pRing->RdOff;
+  WrOff = pRing->WrOff;
+  if (RdOff <= WrOff) {
+    r = pRing->SizeOfBuffer - 1u - WrOff + RdOff;
+  } else {
+    r = RdOff - WrOff - 1u;
+  }
+  return r;
+}
+
+/*********************************************************************
+*
+*       Public code
+*
+**********************************************************************
+*/
+/*********************************************************************
+*
+*       SEGGER_RTT_ReadUpBufferNoLock()
+*
+*  Function description
+*    Reads characters from SEGGER real-time-terminal control block
+*    which have been previously stored by the application.
+*    Do not lock against interrupts and multiple access.
+*    Used to do the same operation that J-Link does, to transfer 
+*    RTT data via other channels, such as TCP/IP or UART.
+*
+*  Parameters
+*    BufferIndex  Index of Up-buffer to be used.
+*    pBuffer      Pointer to buffer provided by target application, to copy characters from RTT-up-buffer to.
+*    BufferSize   Size of the target application buffer.
+*
+*  Return value
+*    Number of bytes that have been read.
+*
+*  Additional information
+*    This function must not be called when J-Link might also do RTT.
+*/
+unsigned SEGGER_RTT_ReadUpBufferNoLock(unsigned BufferIndex, void* pData, unsigned BufferSize) {
+  unsigned                NumBytesRem;
+  unsigned                NumBytesRead;
+  unsigned                RdOff;
+  unsigned                WrOff;
+  unsigned char*          pBuffer;
+  SEGGER_RTT_BUFFER_UP*   pRing;
+#if SEGGER_RTT_MEMCPY_USE_BYTELOOP
+  const char*             pSrc;
+#endif
+  //
+  INIT();
+  pRing = &_SEGGER_RTT.aUp[BufferIndex];
+  pBuffer = (unsigned char*)pData;
+  RdOff = pRing->RdOff;
+  WrOff = pRing->WrOff;
+  NumBytesRead = 0u;
+  //
+  // Read from current read position to wrap-around of buffer, first
+  //
+  if (RdOff > WrOff) {
+    NumBytesRem = pRing->SizeOfBuffer - RdOff;
+    NumBytesRem = MIN(NumBytesRem, BufferSize);
+#if SEGGER_RTT_MEMCPY_USE_BYTELOOP
+    pSrc = pRing->pBuffer + RdOff;
+    NumBytesRead += NumBytesRem;
+    BufferSize   -= NumBytesRem;
+    RdOff        += NumBytesRem;
+    while (NumBytesRem--) {
+      *pBuffer++ = *pSrc++;
+    };
+#else
+    SEGGER_RTT_MEMCPY(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
+    NumBytesRead += NumBytesRem;
+    pBuffer      += NumBytesRem;
+    BufferSize   -= NumBytesRem;
+    RdOff        += NumBytesRem;
+#endif
+    //
+    // Handle wrap-around of buffer
+    //
+    if (RdOff == pRing->SizeOfBuffer) {
+      RdOff = 0u;
+    }
+  }
+  //
+  // Read remaining items of buffer
+  //
+  NumBytesRem = WrOff - RdOff;
+  NumBytesRem = MIN(NumBytesRem, BufferSize);
+  if (NumBytesRem > 0u) {
+#if SEGGER_RTT_MEMCPY_USE_BYTELOOP
+    pSrc = pRing->pBuffer + RdOff;
+    NumBytesRead += NumBytesRem;
+    BufferSize   -= NumBytesRem;
+    RdOff        += NumBytesRem;
+    while (NumBytesRem--) {
+      *pBuffer++ = *pSrc++;
+    };
+#else
+    SEGGER_RTT_MEMCPY(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
+    NumBytesRead += NumBytesRem;
+    pBuffer      += NumBytesRem;
+    BufferSize   -= NumBytesRem;
+    RdOff        += NumBytesRem;
+#endif
+  }
+  //
+  // Update read offset of buffer
+  //
+  if (NumBytesRead) {
+    pRing->RdOff = RdOff;
+  }
+  //
+  return NumBytesRead;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_ReadNoLock()
+*
+*  Function description
+*    Reads characters from SEGGER real-time-terminal control block
+*    which have been previously stored by the host.
+*    Do not lock against interrupts and multiple access.
+*
+*  Parameters
+*    BufferIndex  Index of Down-buffer to be used (e.g. 0 for "Terminal").
+*    pBuffer      Pointer to buffer provided by target application, to copy characters from RTT-down-buffer to.
+*    BufferSize   Size of the target application buffer.
+*
+*  Return value
+*    Number of bytes that have been read.
+*/
+unsigned SEGGER_RTT_ReadNoLock(unsigned BufferIndex, void* pData, unsigned BufferSize) {
+  unsigned                NumBytesRem;
+  unsigned                NumBytesRead;
+  unsigned                RdOff;
+  unsigned                WrOff;
+  unsigned char*          pBuffer;
+  SEGGER_RTT_BUFFER_DOWN* pRing;
+#if SEGGER_RTT_MEMCPY_USE_BYTELOOP
+  const char*             pSrc;
+#endif
+  //
+  INIT();
+  pRing = &_SEGGER_RTT.aDown[BufferIndex];
+  pBuffer = (unsigned char*)pData;
+  RdOff = pRing->RdOff;
+  WrOff = pRing->WrOff;
+  NumBytesRead = 0u;
+  //
+  // Read from current read position to wrap-around of buffer, first
+  //
+  if (RdOff > WrOff) {
+    NumBytesRem = pRing->SizeOfBuffer - RdOff;
+    NumBytesRem = MIN(NumBytesRem, BufferSize);
+#if SEGGER_RTT_MEMCPY_USE_BYTELOOP
+    pSrc = pRing->pBuffer + RdOff;
+    NumBytesRead += NumBytesRem;
+    BufferSize   -= NumBytesRem;
+    RdOff        += NumBytesRem;
+    while (NumBytesRem--) {
+      *pBuffer++ = *pSrc++;
+    };
+#else
+    SEGGER_RTT_MEMCPY(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
+    NumBytesRead += NumBytesRem;
+    pBuffer      += NumBytesRem;
+    BufferSize   -= NumBytesRem;
+    RdOff        += NumBytesRem;
+#endif
+    //
+    // Handle wrap-around of buffer
+    //
+    if (RdOff == pRing->SizeOfBuffer) {
+      RdOff = 0u;
+    }
+  }
+  //
+  // Read remaining items of buffer
+  //
+  NumBytesRem = WrOff - RdOff;
+  NumBytesRem = MIN(NumBytesRem, BufferSize);
+  if (NumBytesRem > 0u) {
+#if SEGGER_RTT_MEMCPY_USE_BYTELOOP
+    pSrc = pRing->pBuffer + RdOff;
+    NumBytesRead += NumBytesRem;
+    BufferSize   -= NumBytesRem;
+    RdOff        += NumBytesRem;
+    while (NumBytesRem--) {
+      *pBuffer++ = *pSrc++;
+    };
+#else
+    SEGGER_RTT_MEMCPY(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
+    NumBytesRead += NumBytesRem;
+    pBuffer      += NumBytesRem;
+    BufferSize   -= NumBytesRem;
+    RdOff        += NumBytesRem;
+#endif
+  }
+  if (NumBytesRead) {
+    pRing->RdOff = RdOff;
+  }
+  //
+  return NumBytesRead;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_ReadUpBuffer
+*
+*  Function description
+*    Reads characters from SEGGER real-time-terminal control block
+*    which have been previously stored by the application.
+*    Used to do the same operation that J-Link does, to transfer 
+*    RTT data via other channels, such as TCP/IP or UART.
+*
+*  Parameters
+*    BufferIndex  Index of Up-buffer to be used.
+*    pBuffer      Pointer to buffer provided by target application, to copy characters from RTT-up-buffer to.
+*    BufferSize   Size of the target application buffer.
+*
+*  Return value
+*    Number of bytes that have been read.
+*
+*  Additional information
+*    This function must not be called when J-Link might also do RTT.
+*    This function locks against all other RTT operations. I.e. during
+*    the read operation, writing is also locked.
+*    If only one consumer reads from the up buffer, 
+*    call sEGGER_RTT_ReadUpBufferNoLock() instead.
+*/
+unsigned SEGGER_RTT_ReadUpBuffer(unsigned BufferIndex, void* pBuffer, unsigned BufferSize) {
+  unsigned NumBytesRead;
+  //
+  SEGGER_RTT_LOCK();
+  //
+  // Call the non-locking read function
+  //
+  NumBytesRead = SEGGER_RTT_ReadUpBufferNoLock(BufferIndex, pBuffer, BufferSize);
+  //
+  // Finish up.
+  //
+  SEGGER_RTT_UNLOCK();
+  //
+  return NumBytesRead;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_Read
+*
+*  Function description
+*    Reads characters from SEGGER real-time-terminal control block
+*    which have been previously stored by the host.
+*
+*  Parameters
+*    BufferIndex  Index of Down-buffer to be used (e.g. 0 for "Terminal").
+*    pBuffer      Pointer to buffer provided by target application, to copy characters from RTT-down-buffer to.
+*    BufferSize   Size of the target application buffer.
+*
+*  Return value
+*    Number of bytes that have been read.
+*/
+unsigned SEGGER_RTT_Read(unsigned BufferIndex, void* pBuffer, unsigned BufferSize) {
+  unsigned NumBytesRead;
+  //
+  SEGGER_RTT_LOCK();
+  //
+  // Call the non-locking read function
+  //
+  NumBytesRead = SEGGER_RTT_ReadNoLock(BufferIndex, pBuffer, BufferSize);
+  //
+  // Finish up.
+  //
+  SEGGER_RTT_UNLOCK();
+  //
+  return NumBytesRead;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_WriteWithOverwriteNoLock
+*
+*  Function description
+*    Stores a specified number of characters in SEGGER RTT
+*    control block.
+*    SEGGER_RTT_WriteWithOverwriteNoLock does not lock the application 
+*    and overwrites data if the data does not fit into the buffer.
+*
+*  Parameters
+*    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
+*    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
+*    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
+*
+*  Notes
+*    (1) If there is not enough space in the "Up"-buffer, data is overwritten.
+*    (2) For performance reasons this function does not call Init()
+*        and may only be called after RTT has been initialized.
+*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
+*    (3) Do not use SEGGER_RTT_WriteWithOverwriteNoLock if a J-Link 
+*        connection reads RTT data.
+*/
+void SEGGER_RTT_WriteWithOverwriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
+  const char*           pData;
+  SEGGER_RTT_BUFFER_UP* pRing;
+  unsigned              Avail;
+#if SEGGER_RTT_MEMCPY_USE_BYTELOOP
+  char*                 pDst;
+#endif
+
+  pData = (const char *)pBuffer;
+  //
+  // Get "to-host" ring buffer and copy some elements into local variables.
+  //
+  pRing = &_SEGGER_RTT.aUp[BufferIndex];
+  //
+  // Check if we will overwrite data and need to adjust the RdOff.
+  //
+  if (pRing->WrOff == pRing->RdOff) {
+    Avail = pRing->SizeOfBuffer - 1u;
+  } else if ( pRing->WrOff < pRing->RdOff) {
+    Avail = pRing->RdOff - pRing->WrOff - 1u;
+  } else {
+    Avail = pRing->RdOff - pRing->WrOff - 1u + pRing->SizeOfBuffer;
+  }
+  if (NumBytes > Avail) {
+    pRing->RdOff += (NumBytes - Avail);
+    while (pRing->RdOff >= pRing->SizeOfBuffer) {
+      pRing->RdOff -= pRing->SizeOfBuffer;
+    }
+  }
+  //
+  // Write all data, no need to check the RdOff, but possibly handle multiple wrap-arounds
+  //
+  Avail = pRing->SizeOfBuffer - pRing->WrOff;
+  do {
+    if (Avail > NumBytes) {
+      //
+      // Last round
+      //
+#if SEGGER_RTT_MEMCPY_USE_BYTELOOP
+      pDst = pRing->pBuffer + pRing->WrOff;
+      Avail = NumBytes;
+      while (NumBytes--) {
+        *pDst++ = *pData++;
+      };
+      pRing->WrOff += Avail;
+#else
+      SEGGER_RTT_MEMCPY(pRing->pBuffer + pRing->WrOff, pData, NumBytes);
+      pRing->WrOff += NumBytes;
+#endif
+      break;
+    } else {
+      //
+      //  Wrap-around necessary, write until wrap-around and reset WrOff
+      //
+#if SEGGER_RTT_MEMCPY_USE_BYTELOOP
+      pDst = pRing->pBuffer + pRing->WrOff;
+      NumBytes -= Avail;
+      while (Avail--) {
+        *pDst++ = *pData++;
+      };
+      pRing->WrOff = 0;
+#else
+      SEGGER_RTT_MEMCPY(pRing->pBuffer + pRing->WrOff, pData, Avail);
+      pData += Avail;
+      pRing->WrOff = 0;
+      NumBytes -= Avail;
+#endif
+      Avail = (pRing->SizeOfBuffer - 1);
+    }
+  } while (NumBytes);
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_WriteSkipNoLock
+*
+*  Function description
+*    Stores a specified number of characters in SEGGER RTT
+*    control block which is then read by the host.
+*    SEGGER_RTT_WriteSkipNoLock does not lock the application and
+*    skips all data, if the data does not fit into the buffer.
+*
+*  Parameters
+*    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
+*    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
+*    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
+*                 MUST be > 0!!!
+*                 This is done for performance reasons, so no initial check has do be done.
+*
+*  Return value
+*    1: Data has been copied
+*    0: No space, data has not been copied
+*
+*  Notes
+*    (1) If there is not enough space in the "Up"-buffer, all data is dropped.
+*    (2) For performance reasons this function does not call Init()
+*        and may only be called after RTT has been initialized.
+*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
+*/
+#if (RTT_USE_ASM == 0)
+unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
+  const char*           pData;
+  SEGGER_RTT_BUFFER_UP* pRing;
+  unsigned              Avail;
+  unsigned              RdOff;
+  unsigned              WrOff;
+  unsigned              Rem;
+  //
+  // Cases:
+  //   1) RdOff <= WrOff => Space until wrap-around is sufficient
+  //   2) RdOff <= WrOff => Space after wrap-around needed (copy in 2 chunks)
+  //   3) RdOff <  WrOff => No space in buf
+  //   4) RdOff >  WrOff => Space is sufficient
+  //   5) RdOff >  WrOff => No space in buf
+  //
+  // 1) is the most common case for large buffers and assuming that J-Link reads the data fast enough
+  //
+  pData = (const char *)pBuffer;
+  pRing = &_SEGGER_RTT.aUp[BufferIndex];
+  RdOff = pRing->RdOff;
+  WrOff = pRing->WrOff;
+  if (RdOff <= WrOff) {                                 // Case 1), 2) or 3)
+    Avail = pRing->SizeOfBuffer - WrOff - 1u;           // Space until wrap-around (assume 1 byte not usable for case that RdOff == 0)
+    if (Avail >= NumBytes) {                            // Case 1)?
+CopyStraight:
+      memcpy(pRing->pBuffer + WrOff, pData, NumBytes);
+      pRing->WrOff = WrOff + NumBytes;
+      return 1;
+    }
+    Avail += RdOff;                                     // Space incl. wrap-around
+    if (Avail >= NumBytes) {                            // Case 2? => If not, we have case 3) (does not fit)
+      Rem = pRing->SizeOfBuffer - WrOff;                // Space until end of buffer
+      memcpy(pRing->pBuffer + WrOff, pData, Rem);       // Copy 1st chunk
+      NumBytes -= Rem;
+      //
+      // Special case: First check that assumed RdOff == 0 calculated that last element before wrap-around could not be used
+      // But 2nd check (considering space until wrap-around and until RdOff) revealed that RdOff is not 0, so we can use the last element
+      // In this case, we may use a copy straight until buffer end anyway without needing to copy 2 chunks
+      // Therefore, check if 2nd memcpy is necessary at all
+      //
+      if (NumBytes) {
+        memcpy(pRing->pBuffer, pData + Rem, NumBytes);
+      }
+      pRing->WrOff = NumBytes;
+      return 1;
+    }
+  } else {                                             // Potential case 4)
+    Avail = RdOff - WrOff - 1u;
+    if (Avail >= NumBytes) {                           // Case 4)? => If not, we have case 5) (does not fit)
+      goto CopyStraight;
+    }
+  }
+  return 0;     // No space in buffer
+}
+#endif
+
+/*********************************************************************
+*
+*       SEGGER_RTT_WriteDownBufferNoLock
+*
+*  Function description
+*    Stores a specified number of characters in SEGGER RTT
+*    control block inside a <Down> buffer.
+*    SEGGER_RTT_WriteDownBufferNoLock does not lock the application.
+*    Used to do the same operation that J-Link does, to transfer 
+*    RTT data from other channels, such as TCP/IP or UART.
+*
+*  Parameters
+*    BufferIndex  Index of "Down"-buffer to be used.
+*    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
+*    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
+*
+*  Return value
+*    Number of bytes which have been stored in the "Down"-buffer.
+*
+*  Notes
+*    (1) Data is stored according to buffer flags.
+*    (2) For performance reasons this function does not call Init()
+*        and may only be called after RTT has been initialized.
+*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
+*
+*  Additional information
+*    This function must not be called when J-Link might also do RTT.
+*/
+unsigned SEGGER_RTT_WriteDownBufferNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
+  unsigned                Status;
+  unsigned                Avail;
+  const char*             pData;
+  SEGGER_RTT_BUFFER_UP*   pRing;
+
+  pData = (const char *)pBuffer;
+  //
+  // Get "to-target" ring buffer.
+  // It is save to cast that to a "to-host" buffer. Up and Down buffer differ in volatility of offsets that might be modified by J-Link.
+  //
+  pRing = (SEGGER_RTT_BUFFER_UP*)&_SEGGER_RTT.aDown[BufferIndex];
+  //
+  // How we output depends upon the mode...
+  //
+  switch (pRing->Flags) {
+  case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
+    //
+    // If we are in skip mode and there is no space for the whole
+    // of this output, don't bother.
+    //
+    Avail = _GetAvailWriteSpace(pRing);
+    if (Avail < NumBytes) {
+      Status = 0u;
+    } else {
+      Status = NumBytes;
+      _WriteNoCheck(pRing, pData, NumBytes);
+    }
+    break;
+  case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
+    //
+    // If we are in trim mode, trim to what we can output without blocking.
+    //
+    Avail = _GetAvailWriteSpace(pRing);
+    Status = Avail < NumBytes ? Avail : NumBytes;
+    _WriteNoCheck(pRing, pData, Status);
+    break;
+  case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
+    //
+    // If we are in blocking mode, output everything.
+    //
+    Status = _WriteBlocking(pRing, pData, NumBytes);
+    break;
+  default:
+    Status = 0u;
+    break;
+  }
+  //
+  // Finish up.
+  //
+  return Status;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_WriteNoLock
+*
+*  Function description
+*    Stores a specified number of characters in SEGGER RTT
+*    control block which is then read by the host.
+*    SEGGER_RTT_WriteNoLock does not lock the application.
+*
+*  Parameters
+*    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
+*    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
+*    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
+*
+*  Return value
+*    Number of bytes which have been stored in the "Up"-buffer.
+*
+*  Notes
+*    (1) Data is stored according to buffer flags.
+*    (2) For performance reasons this function does not call Init()
+*        and may only be called after RTT has been initialized.
+*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
+*/
+unsigned SEGGER_RTT_WriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
+  unsigned              Status;
+  unsigned              Avail;
+  const char*           pData;
+  SEGGER_RTT_BUFFER_UP* pRing;
+
+  pData = (const char *)pBuffer;
+  //
+  // Get "to-host" ring buffer.
+  //
+  pRing = &_SEGGER_RTT.aUp[BufferIndex];
+  //
+  // How we output depends upon the mode...
+  //
+  switch (pRing->Flags) {
+  case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
+    //
+    // If we are in skip mode and there is no space for the whole
+    // of this output, don't bother.
+    //
+    Avail = _GetAvailWriteSpace(pRing);
+    if (Avail < NumBytes) {
+      Status = 0u;
+    } else {
+      Status = NumBytes;
+      _WriteNoCheck(pRing, pData, NumBytes);
+    }
+    break;
+  case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
+    //
+    // If we are in trim mode, trim to what we can output without blocking.
+    //
+    Avail = _GetAvailWriteSpace(pRing);
+    Status = Avail < NumBytes ? Avail : NumBytes;
+    _WriteNoCheck(pRing, pData, Status);
+    break;
+  case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
+    //
+    // If we are in blocking mode, output everything.
+    //
+    Status = _WriteBlocking(pRing, pData, NumBytes);
+    break;
+  default:
+    Status = 0u;
+    break;
+  }
+  //
+  // Finish up.
+  //
+  return Status;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_WriteDownBuffer
+*
+*  Function description
+*    Stores a specified number of characters in SEGGER RTT control block in a <Down> buffer.
+*
+*  Parameters
+*    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
+*    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
+*    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
+*
+*  Return value
+*    Number of bytes which have been stored in the "Down"-buffer.
+*
+*  Notes
+*    (1) Data is stored according to buffer flags.
+*
+*  Additional information
+*    This function must not be called when J-Link might also do RTT.
+*    This function locks against all other RTT operations. I.e. during
+*    the write operation, writing from the application is also locked.
+*    If only one consumer writes to the down buffer, 
+*    call SEGGER_RTT_WriteDownBufferNoLock() instead.
+*/
+unsigned SEGGER_RTT_WriteDownBuffer(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
+  unsigned Status;
+  //
+  INIT();
+  SEGGER_RTT_LOCK();
+  //
+  // Call the non-locking write function
+  //
+  Status = SEGGER_RTT_WriteDownBufferNoLock(BufferIndex, pBuffer, NumBytes);
+  //
+  // Finish up.
+  //
+  SEGGER_RTT_UNLOCK();
+  //
+  return Status;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_Write
+*
+*  Function description
+*    Stores a specified number of characters in SEGGER RTT
+*    control block which is then read by the host.
+*
+*  Parameters
+*    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
+*    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
+*    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
+*
+*  Return value
+*    Number of bytes which have been stored in the "Up"-buffer.
+*
+*  Notes
+*    (1) Data is stored according to buffer flags.
+*/
+unsigned SEGGER_RTT_Write(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
+  unsigned Status;
+  //
+  INIT();
+  SEGGER_RTT_LOCK();
+  //
+  // Call the non-locking write function
+  //
+  Status = SEGGER_RTT_WriteNoLock(BufferIndex, pBuffer, NumBytes);
+  //
+  // Finish up.
+  //
+  SEGGER_RTT_UNLOCK();
+  //
+  return Status;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_WriteString
+*
+*  Function description
+*    Stores string in SEGGER RTT control block.
+*    This data is read by the host.
+*
+*  Parameters
+*    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
+*    s            Pointer to string.
+*
+*  Return value
+*    Number of bytes which have been stored in the "Up"-buffer.
+*
+*  Notes
+*    (1) Data is stored according to buffer flags.
+*    (2) String passed to this function has to be \0 terminated
+*    (3) \0 termination character is *not* stored in RTT buffer
+*/
+unsigned SEGGER_RTT_WriteString(unsigned BufferIndex, const char* s) {
+  unsigned Len;
+
+  Len = STRLEN(s);
+  return SEGGER_RTT_Write(BufferIndex, s, Len);
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_PutCharSkipNoLock
+*
+*  Function description
+*    Stores a single character/byte in SEGGER RTT buffer.
+*    SEGGER_RTT_PutCharSkipNoLock does not lock the application and
+*    skips the byte, if it does not fit into the buffer.
+*
+*  Parameters
+*    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
+*    c            Byte to be stored.
+*
+*  Return value
+*    Number of bytes which have been stored in the "Up"-buffer.
+*
+*  Notes
+*    (1) If there is not enough space in the "Up"-buffer, the character is dropped.
+*    (2) For performance reasons this function does not call Init()
+*        and may only be called after RTT has been initialized.
+*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
+*/
+
+unsigned SEGGER_RTT_PutCharSkipNoLock(unsigned BufferIndex, char c) {
+  SEGGER_RTT_BUFFER_UP* pRing;
+  unsigned              WrOff;
+  unsigned              Status;
+  //
+  // Get "to-host" ring buffer.
+  //
+  pRing = &_SEGGER_RTT.aUp[BufferIndex];
+  //
+  // Get write position and handle wrap-around if necessary
+  //
+  WrOff = pRing->WrOff + 1;
+  if (WrOff == pRing->SizeOfBuffer) {
+    WrOff = 0;
+  }
+  //
+  // Output byte if free space is available
+  //
+  if (WrOff != pRing->RdOff) {
+    pRing->pBuffer[pRing->WrOff] = c;
+    pRing->WrOff = WrOff;
+    Status = 1;
+  } else {
+    Status = 0;
+  }
+  //
+  return Status;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_PutCharSkip
+*
+*  Function description
+*    Stores a single character/byte in SEGGER RTT buffer.
+*
+*  Parameters
+*    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
+*    c            Byte to be stored.
+*
+*  Return value
+*    Number of bytes which have been stored in the "Up"-buffer.
+*
+*  Notes
+*    (1) If there is not enough space in the "Up"-buffer, the character is dropped.
+*/
+
+unsigned SEGGER_RTT_PutCharSkip(unsigned BufferIndex, char c) {
+  SEGGER_RTT_BUFFER_UP* pRing;
+  unsigned              WrOff;
+  unsigned              Status;
+  //
+  // Prepare
+  //
+  INIT();
+  SEGGER_RTT_LOCK();
+  //
+  // Get "to-host" ring buffer.
+  //
+  pRing = &_SEGGER_RTT.aUp[BufferIndex];
+  //
+  // Get write position and handle wrap-around if necessary
+  //
+  WrOff = pRing->WrOff + 1;
+  if (WrOff == pRing->SizeOfBuffer) {
+    WrOff = 0;
+  }
+  //
+  // Output byte if free space is available
+  //
+  if (WrOff != pRing->RdOff) {
+    pRing->pBuffer[pRing->WrOff] = c;
+    pRing->WrOff = WrOff;
+    Status = 1;
+  } else {
+    Status = 0;
+  }
+  //
+  // Finish up.
+  //
+  SEGGER_RTT_UNLOCK();
+  //
+  return Status;
+}
+
+ /*********************************************************************
+*
+*       SEGGER_RTT_PutChar
+*
+*  Function description
+*    Stores a single character/byte in SEGGER RTT buffer.
+*
+*  Parameters
+*    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
+*    c            Byte to be stored.
+*
+*  Return value
+*    Number of bytes which have been stored in the "Up"-buffer.
+*
+*  Notes
+*    (1) Data is stored according to buffer flags.
+*/
+
+unsigned SEGGER_RTT_PutChar(unsigned BufferIndex, char c) {
+  SEGGER_RTT_BUFFER_UP* pRing;
+  unsigned              WrOff;
+  unsigned              Status;
+  //
+  // Prepare
+  //
+  INIT();
+  SEGGER_RTT_LOCK();
+  //
+  // Get "to-host" ring buffer.
+  //
+  pRing = &_SEGGER_RTT.aUp[BufferIndex];
+  //
+  // Get write position and handle wrap-around if necessary
+  //
+  WrOff = pRing->WrOff + 1;
+  if (WrOff == pRing->SizeOfBuffer) {
+    WrOff = 0;
+  }
+  //
+  // Wait for free space if mode is set to blocking
+  //
+  if (pRing->Flags == SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL) {
+    while (WrOff == pRing->RdOff) {
+      ;
+    }
+  }
+  //
+  // Output byte if free space is available
+  //
+  if (WrOff != pRing->RdOff) {
+    pRing->pBuffer[pRing->WrOff] = c;
+    pRing->WrOff = WrOff;
+    Status = 1;
+  } else {
+    Status = 0;
+  }
+  //
+  // Finish up.
+  //
+  SEGGER_RTT_UNLOCK();
+  //
+  return Status;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_GetKey
+*
+*  Function description
+*    Reads one character from the SEGGER RTT buffer.
+*    Host has previously stored data there.
+*
+*  Return value
+*    <  0 -   No character available (buffer empty).
+*    >= 0 -   Character which has been read. (Possible values: 0 - 255)
+*
+*  Notes
+*    (1) This function is only specified for accesses to RTT buffer 0.
+*/
+int SEGGER_RTT_GetKey(void) {
+  char c;
+  int r;
+
+  r = (int)SEGGER_RTT_Read(0u, &c, 1u);
+  if (r == 1) {
+    r = (int)(unsigned char)c;
+  } else {
+    r = -1;
+  }
+  return r;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_WaitKey
+*
+*  Function description
+*    Waits until at least one character is avaible in the SEGGER RTT buffer.
+*    Once a character is available, it is read and this function returns.
+*
+*  Return value
+*    >=0 -   Character which has been read.
+*
+*  Notes
+*    (1) This function is only specified for accesses to RTT buffer 0
+*    (2) This function is blocking if no character is present in RTT buffer
+*/
+int SEGGER_RTT_WaitKey(void) {
+  int r;
+
+  do {
+    r = SEGGER_RTT_GetKey();
+  } while (r < 0);
+  return r;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_HasKey
+*
+*  Function description
+*    Checks if at least one character for reading is available in the SEGGER RTT buffer.
+*
+*  Return value
+*    == 0 -     No characters are available to read.
+*    == 1 -     At least one character is available.
+*
+*  Notes
+*    (1) This function is only specified for accesses to RTT buffer 0
+*/
+int SEGGER_RTT_HasKey(void) {
+  unsigned RdOff;
+  int r;
+
+  INIT();
+  RdOff = _SEGGER_RTT.aDown[0].RdOff;
+  if (RdOff != _SEGGER_RTT.aDown[0].WrOff) {
+    r = 1;
+  } else {
+    r = 0;
+  }
+  return r;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_HasData
+*
+*  Function description
+*    Check if there is data from the host in the given buffer.
+*
+*  Return value:
+*  ==0:  No data
+*  !=0:  Data in buffer
+*
+*/
+unsigned SEGGER_RTT_HasData(unsigned BufferIndex) {
+  SEGGER_RTT_BUFFER_DOWN* pRing;
+  unsigned                v;
+
+  pRing = &_SEGGER_RTT.aDown[BufferIndex];
+  v = pRing->WrOff;
+  return v - pRing->RdOff;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_HasDataUp
+*
+*  Function description
+*    Check if there is data remaining to be sent in the given buffer.
+*
+*  Return value:
+*  ==0:  No data
+*  !=0:  Data in buffer
+*
+*/
+unsigned SEGGER_RTT_HasDataUp(unsigned BufferIndex) {
+  SEGGER_RTT_BUFFER_UP* pRing;
+  unsigned                v;
+
+  pRing = &_SEGGER_RTT.aUp[BufferIndex];
+  v = pRing->RdOff;
+  return pRing->WrOff - v;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_AllocDownBuffer
+*
+*  Function description
+*    Run-time configuration of the next down-buffer (H->T).
+*    The next buffer, which is not used yet is configured.
+*    This includes: Buffer address, size, name, flags, ...
+*
+*  Parameters
+*    sName        Pointer to a constant name string.
+*    pBuffer      Pointer to a buffer to be used.
+*    BufferSize   Size of the buffer.
+*    Flags        Operating modes. Define behavior if buffer is full (not enough space for entire message).
+*
+*  Return value
+*    >= 0 - O.K. Buffer Index
+*     < 0 - Error
+*/
+int SEGGER_RTT_AllocDownBuffer(const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
+  int BufferIndex;
+
+  INIT();
+  SEGGER_RTT_LOCK();
+  BufferIndex = 0;
+  do {
+    if (_SEGGER_RTT.aDown[BufferIndex].pBuffer == NULL) {
+      break;
+    }
+    BufferIndex++;
+  } while (BufferIndex < _SEGGER_RTT.MaxNumDownBuffers);
+  if (BufferIndex < _SEGGER_RTT.MaxNumDownBuffers) {
+    _SEGGER_RTT.aDown[BufferIndex].sName        = sName;
+    _SEGGER_RTT.aDown[BufferIndex].pBuffer      = (char*)pBuffer;
+    _SEGGER_RTT.aDown[BufferIndex].SizeOfBuffer = BufferSize;
+    _SEGGER_RTT.aDown[BufferIndex].RdOff        = 0u;
+    _SEGGER_RTT.aDown[BufferIndex].WrOff        = 0u;
+    _SEGGER_RTT.aDown[BufferIndex].Flags        = Flags;
+  } else {
+    BufferIndex = -1;
+  }
+  SEGGER_RTT_UNLOCK();
+  return BufferIndex;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_AllocUpBuffer
+*
+*  Function description
+*    Run-time configuration of the next up-buffer (T->H).
+*    The next buffer, which is not used yet is configured.
+*    This includes: Buffer address, size, name, flags, ...
+*
+*  Parameters
+*    sName        Pointer to a constant name string.
+*    pBuffer      Pointer to a buffer to be used.
+*    BufferSize   Size of the buffer.
+*    Flags        Operating modes. Define behavior if buffer is full (not enough space for entire message).
+*
+*  Return value
+*    >= 0 - O.K. Buffer Index
+*     < 0 - Error
+*/
+int SEGGER_RTT_AllocUpBuffer(const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
+  int BufferIndex;
+
+  INIT();
+  SEGGER_RTT_LOCK();
+  BufferIndex = 0;
+  do {
+    if (_SEGGER_RTT.aUp[BufferIndex].pBuffer == NULL) {
+      break;
+    }
+    BufferIndex++;
+  } while (BufferIndex < _SEGGER_RTT.MaxNumUpBuffers);
+  if (BufferIndex < _SEGGER_RTT.MaxNumUpBuffers) {
+    _SEGGER_RTT.aUp[BufferIndex].sName        = sName;
+    _SEGGER_RTT.aUp[BufferIndex].pBuffer      = (char*)pBuffer;
+    _SEGGER_RTT.aUp[BufferIndex].SizeOfBuffer = BufferSize;
+    _SEGGER_RTT.aUp[BufferIndex].RdOff        = 0u;
+    _SEGGER_RTT.aUp[BufferIndex].WrOff        = 0u;
+    _SEGGER_RTT.aUp[BufferIndex].Flags        = Flags;
+  } else {
+    BufferIndex = -1;
+  }
+  SEGGER_RTT_UNLOCK();
+  return BufferIndex;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_ConfigUpBuffer
+*
+*  Function description
+*    Run-time configuration of a specific up-buffer (T->H).
+*    Buffer to be configured is specified by index.
+*    This includes: Buffer address, size, name, flags, ...
+*
+*  Parameters
+*    BufferIndex  Index of the buffer to configure.
+*    sName        Pointer to a constant name string.
+*    pBuffer      Pointer to a buffer to be used.
+*    BufferSize   Size of the buffer.
+*    Flags        Operating modes. Define behavior if buffer is full (not enough space for entire message).
+*
+*  Return value
+*    >= 0 - O.K.
+*     < 0 - Error
+*
+*  Additional information
+*    Buffer 0 is configured on compile-time.
+*    May only be called once per buffer.
+*    Buffer name and flags can be reconfigured using the appropriate functions.
+*/
+int SEGGER_RTT_ConfigUpBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
+  int r;
+
+  INIT();
+  if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumUpBuffers) {
+    SEGGER_RTT_LOCK();
+    if (BufferIndex > 0u) {
+      _SEGGER_RTT.aUp[BufferIndex].sName        = sName;
+      _SEGGER_RTT.aUp[BufferIndex].pBuffer      = (char*)pBuffer;
+      _SEGGER_RTT.aUp[BufferIndex].SizeOfBuffer = BufferSize;
+      _SEGGER_RTT.aUp[BufferIndex].RdOff        = 0u;
+      _SEGGER_RTT.aUp[BufferIndex].WrOff        = 0u;
+    }
+    _SEGGER_RTT.aUp[BufferIndex].Flags          = Flags;
+    SEGGER_RTT_UNLOCK();
+    r =  0;
+  } else {
+    r = -1;
+  }
+  return r;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_ConfigDownBuffer
+*
+*  Function description
+*    Run-time configuration of a specific down-buffer (H->T).
+*    Buffer to be configured is specified by index.
+*    This includes: Buffer address, size, name, flags, ...
+*
+*  Parameters
+*    BufferIndex  Index of the buffer to configure.
+*    sName        Pointer to a constant name string.
+*    pBuffer      Pointer to a buffer to be used.
+*    BufferSize   Size of the buffer.
+*    Flags        Operating modes. Define behavior if buffer is full (not enough space for entire message).
+*
+*  Return value
+*    >= 0  O.K.
+*     < 0  Error
+*
+*  Additional information
+*    Buffer 0 is configured on compile-time.
+*    May only be called once per buffer.
+*    Buffer name and flags can be reconfigured using the appropriate functions.
+*/
+int SEGGER_RTT_ConfigDownBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
+  int r;
+
+  INIT();
+  if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumDownBuffers) {
+    SEGGER_RTT_LOCK();
+    if (BufferIndex > 0u) {
+      _SEGGER_RTT.aDown[BufferIndex].sName        = sName;
+      _SEGGER_RTT.aDown[BufferIndex].pBuffer      = (char*)pBuffer;
+      _SEGGER_RTT.aDown[BufferIndex].SizeOfBuffer = BufferSize;
+      _SEGGER_RTT.aDown[BufferIndex].RdOff        = 0u;
+      _SEGGER_RTT.aDown[BufferIndex].WrOff        = 0u;
+    }
+    _SEGGER_RTT.aDown[BufferIndex].Flags          = Flags;
+    SEGGER_RTT_UNLOCK();
+    r =  0;
+  } else {
+    r = -1;
+  }
+  return r;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_SetNameUpBuffer
+*
+*  Function description
+*    Run-time configuration of a specific up-buffer name (T->H).
+*    Buffer to be configured is specified by index.
+*
+*  Parameters
+*    BufferIndex  Index of the buffer to renamed.
+*    sName        Pointer to a constant name string.
+*
+*  Return value
+*    >= 0  O.K.
+*     < 0  Error
+*/
+int SEGGER_RTT_SetNameUpBuffer(unsigned BufferIndex, const char* sName) {
+  int r;
+
+  INIT();
+  if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumUpBuffers) {
+    SEGGER_RTT_LOCK();
+    _SEGGER_RTT.aUp[BufferIndex].sName = sName;
+    SEGGER_RTT_UNLOCK();
+    r =  0;
+  } else {
+    r = -1;
+  }
+  return r;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_SetNameDownBuffer
+*
+*  Function description
+*    Run-time configuration of a specific Down-buffer name (T->H).
+*    Buffer to be configured is specified by index.
+*
+*  Parameters
+*    BufferIndex  Index of the buffer to renamed.
+*    sName        Pointer to a constant name string.
+*
+*  Return value
+*    >= 0  O.K.
+*     < 0  Error
+*/
+int SEGGER_RTT_SetNameDownBuffer(unsigned BufferIndex, const char* sName) {
+  int r;
+
+  INIT();
+  if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumDownBuffers) {
+    SEGGER_RTT_LOCK();
+    _SEGGER_RTT.aDown[BufferIndex].sName = sName;
+    SEGGER_RTT_UNLOCK();
+    r =  0;
+  } else {
+    r = -1;
+  }
+  return r;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_SetFlagsUpBuffer
+*
+*  Function description
+*    Run-time configuration of specific up-buffer flags (T->H).
+*    Buffer to be configured is specified by index.
+*
+*  Parameters
+*    BufferIndex  Index of the buffer.
+*    Flags        Flags to set for the buffer.
+*
+*  Return value
+*    >= 0  O.K.
+*     < 0  Error
+*/
+int SEGGER_RTT_SetFlagsUpBuffer(unsigned BufferIndex, unsigned Flags) {
+  int r;
+
+  INIT();
+  if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumUpBuffers) {
+    SEGGER_RTT_LOCK();
+    _SEGGER_RTT.aUp[BufferIndex].Flags = Flags;
+    SEGGER_RTT_UNLOCK();
+    r =  0;
+  } else {
+    r = -1;
+  }
+  return r;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_SetFlagsDownBuffer
+*
+*  Function description
+*    Run-time configuration of specific Down-buffer flags (T->H).
+*    Buffer to be configured is specified by index.
+*
+*  Parameters
+*    BufferIndex  Index of the buffer to renamed.
+*    Flags        Flags to set for the buffer.
+*
+*  Return value
+*    >= 0  O.K.
+*     < 0  Error
+*/
+int SEGGER_RTT_SetFlagsDownBuffer(unsigned BufferIndex, unsigned Flags) {
+  int r;
+
+  INIT();
+  if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumDownBuffers) {
+    SEGGER_RTT_LOCK();
+    _SEGGER_RTT.aDown[BufferIndex].Flags = Flags;
+    SEGGER_RTT_UNLOCK();
+    r =  0;
+  } else {
+    r = -1;
+  }
+  return r;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_Init
+*
+*  Function description
+*    Initializes the RTT Control Block.
+*    Should be used in RAM targets, at start of the application.
+*
+*/
+void SEGGER_RTT_Init (void) {
+  _DoInit();
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_SetTerminal
+*
+*  Function description
+*    Sets the terminal to be used for output on channel 0.
+*
+*  Parameters
+*    TerminalId  Index of the terminal.
+*
+*  Return value
+*    >= 0  O.K.
+*     < 0  Error (e.g. if RTT is configured for non-blocking mode and there was no space in the buffer to set the new terminal Id)
+*/
+int SEGGER_RTT_SetTerminal (unsigned char TerminalId) {
+  unsigned char         ac[2];
+  SEGGER_RTT_BUFFER_UP* pRing;
+  unsigned Avail;
+  int r;
+  //
+  INIT();
+  //
+  r = 0;
+  ac[0] = 0xFFu;
+  if (TerminalId < sizeof(_aTerminalId)) { // We only support a certain number of channels
+    ac[1] = _aTerminalId[TerminalId];
+    pRing = &_SEGGER_RTT.aUp[0];    // Buffer 0 is always reserved for terminal I/O, so we can use index 0 here, fixed
+    SEGGER_RTT_LOCK();    // Lock to make sure that no other task is writing into buffer, while we are and number of free bytes in buffer does not change downwards after checking and before writing
+    if ((pRing->Flags & SEGGER_RTT_MODE_MASK) == SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL) {
+      _ActiveTerminal = TerminalId;
+      _WriteBlocking(pRing, (const char*)ac, 2u);
+    } else {                                                                            // Skipping mode or trim mode? => We cannot trim this command so handling is the same for both modes
+      Avail = _GetAvailWriteSpace(pRing);
+      if (Avail >= 2) {
+        _ActiveTerminal = TerminalId;    // Only change active terminal in case of success
+        _WriteNoCheck(pRing, (const char*)ac, 2u);
+      } else {
+        r = -1;
+      }
+    }
+    SEGGER_RTT_UNLOCK();
+  } else {
+    r = -1;
+  }
+  return r;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_TerminalOut
+*
+*  Function description
+*    Writes a string to the given terminal
+*     without changing the terminal for channel 0.
+*
+*  Parameters
+*    TerminalId   Index of the terminal.
+*    s            String to be printed on the terminal.
+*
+*  Return value
+*    >= 0 - Number of bytes written.
+*     < 0 - Error.
+*
+*/
+int SEGGER_RTT_TerminalOut (unsigned char TerminalId, const char* s) {
+  int                   Status;
+  unsigned              FragLen;
+  unsigned              Avail;
+  SEGGER_RTT_BUFFER_UP* pRing;
+  //
+  INIT();
+  //
+  // Validate terminal ID.
+  //
+  if (TerminalId < (char)sizeof(_aTerminalId)) { // We only support a certain number of channels
+    //
+    // Get "to-host" ring buffer.
+    //
+    pRing = &_SEGGER_RTT.aUp[0];
+    //
+    // Need to be able to change terminal, write data, change back.
+    // Compute the fixed and variable sizes.
+    //
+    FragLen = STRLEN(s);
+    //
+    // How we output depends upon the mode...
+    //
+    SEGGER_RTT_LOCK();
+    Avail = _GetAvailWriteSpace(pRing);
+    switch (pRing->Flags & SEGGER_RTT_MODE_MASK) {
+    case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
+      //
+      // If we are in skip mode and there is no space for the whole
+      // of this output, don't bother switching terminals at all.
+      //
+      if (Avail < (FragLen + 4u)) {
+        Status = 0;
+      } else {
+        _PostTerminalSwitch(pRing, TerminalId);
+        Status = (int)_WriteBlocking(pRing, s, FragLen);
+        _PostTerminalSwitch(pRing, _ActiveTerminal);
+      }
+      break;
+    case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
+      //
+      // If we are in trim mode and there is not enough space for everything,
+      // trim the output but always include the terminal switch.  If no room
+      // for terminal switch, skip that totally.
+      //
+      if (Avail < 4u) {
+        Status = -1;
+      } else {
+        _PostTerminalSwitch(pRing, TerminalId);
+        Status = (int)_WriteBlocking(pRing, s, (FragLen < (Avail - 4u)) ? FragLen : (Avail - 4u));
+        _PostTerminalSwitch(pRing, _ActiveTerminal);
+      }
+      break;
+    case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
+      //
+      // If we are in blocking mode, output everything.
+      //
+      _PostTerminalSwitch(pRing, TerminalId);
+      Status = (int)_WriteBlocking(pRing, s, FragLen);
+      _PostTerminalSwitch(pRing, _ActiveTerminal);
+      break;
+    default:
+      Status = -1;
+      break;
+    }
+    //
+    // Finish up.
+    //
+    SEGGER_RTT_UNLOCK();
+  } else {
+    Status = -1;
+  }
+  return Status;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_GetAvailWriteSpace
+*
+*  Function description
+*    Returns the number of bytes available in the ring buffer.
+*
+*  Parameters
+*    BufferIndex  Index of the up buffer.
+*
+*  Return value
+*    Number of bytes that are free in the selected up buffer.
+*/
+unsigned SEGGER_RTT_GetAvailWriteSpace (unsigned BufferIndex){
+  return _GetAvailWriteSpace(&_SEGGER_RTT.aUp[BufferIndex]);
+}
+
+
+/*********************************************************************
+*
+*       SEGGER_RTT_GetBytesInBuffer()
+*
+*  Function description
+*    Returns the number of bytes currently used in the up buffer.
+*
+*  Parameters
+*    BufferIndex  Index of the up buffer.
+*
+*  Return value
+*    Number of bytes that are used in the buffer.
+*/
+unsigned SEGGER_RTT_GetBytesInBuffer(unsigned BufferIndex) {
+  unsigned RdOff;
+  unsigned WrOff;
+  unsigned r;
+  //
+  // Avoid warnings regarding volatile access order.  It's not a problem
+  // in this case, but dampen compiler enthusiasm.
+  //
+  RdOff = _SEGGER_RTT.aUp[BufferIndex].RdOff;
+  WrOff = _SEGGER_RTT.aUp[BufferIndex].WrOff;
+  if (RdOff <= WrOff) {
+    r = WrOff - RdOff;
+  } else {
+    r = _SEGGER_RTT.aUp[BufferIndex].SizeOfBuffer - (WrOff - RdOff);
+  }
+  return r;
+}
+
+/*************************** End of file ****************************/
diff --git a/sched/systemview/SEGGER_RTT.h b/sched/systemview/SEGGER_RTT.h
new file mode 100644
index 0000000000..f01651b364
--- /dev/null
+++ b/sched/systemview/SEGGER_RTT.h
@@ -0,0 +1,325 @@
+/*********************************************************************
+*                    SEGGER Microcontroller GmbH                     *
+*                        The Embedded Experts                        *
+**********************************************************************
+*                                                                    *
+*            (c) 1995 - 2019 SEGGER Microcontroller GmbH             *
+*                                                                    *
+*       www.segger.com     Support: support@segger.com               *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SEGGER SystemView * Real-time application analysis           *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+* All rights reserved.                                               *
+*                                                                    *
+* SEGGER strongly recommends to not make any changes                 *
+* to or modify the source code of this software in order to stay     *
+* compatible with the SystemView and RTT protocol, and J-Link.       *
+*                                                                    *
+* Redistribution and use in source and binary forms, with or         *
+* without modification, are permitted provided that the following    *
+* condition is met:                                                  *
+*                                                                    *
+* o Redistributions of source code must retain the above copyright   *
+*   notice, this condition and the following disclaimer.             *
+*                                                                    *
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
+* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
+* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
+* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
+* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
+* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
+* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
+* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
+* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
+* DAMAGE.                                                            *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SystemView version: V3.12                                    *
+*                                                                    *
+**********************************************************************
+---------------------------END-OF-HEADER------------------------------
+File    : SEGGER_RTT.h
+Purpose : Implementation of SEGGER real-time transfer which allows
+          real-time communication on targets which support debugger 
+          memory accesses while the CPU is running.
+Revision: $Rev: 17697 $
+----------------------------------------------------------------------
+*/
+
+#ifndef SEGGER_RTT_H
+#define SEGGER_RTT_H
+
+#include "SEGGER_RTT_Conf.h"
+
+
+
+/*********************************************************************
+*
+*       Defines, defaults
+*
+**********************************************************************
+*/
+#ifndef RTT_USE_ASM
+  #if (defined __SES_ARM)                       // SEGGER Embedded Studio
+    #define _CC_HAS_RTT_ASM_SUPPORT 1
+  #elif (defined __CROSSWORKS_ARM)              // Rowley Crossworks
+    #define _CC_HAS_RTT_ASM_SUPPORT 1
+  #elif (defined __GNUC__)                      // GCC
+    #define _CC_HAS_RTT_ASM_SUPPORT 1
+  #elif (defined __clang__)                     // Clang compiler
+    #define _CC_HAS_RTT_ASM_SUPPORT 1
+  #elif (defined __IASMARM__)                   // IAR assembler
+    #define _CC_HAS_RTT_ASM_SUPPORT 1
+  #elif (defined __ICCARM__)                    // IAR compiler
+    #define _CC_HAS_RTT_ASM_SUPPORT 1
+  #else
+    #define _CC_HAS_RTT_ASM_SUPPORT 0
+  #endif
+  #if (defined __ARM_ARCH_7M__)                 // Cortex-M3/4
+    #define _CORE_HAS_RTT_ASM_SUPPORT 1
+  #elif (defined __ARM_ARCH_7EM__)              // Cortex-M7
+    #define _CORE_HAS_RTT_ASM_SUPPORT 1
+  #elif (defined __ARM_ARCH_8M_MAIN__)          // Cortex-M33
+    #define _CORE_HAS_RTT_ASM_SUPPORT 1
+  #elif (defined __ARM7M__)                     // IAR Cortex-M3/4
+    #if (__CORE__ == __ARM7M__)
+      #define _CORE_HAS_RTT_ASM_SUPPORT 1
+    #else
+      #define _CORE_HAS_RTT_ASM_SUPPORT 0
+    #endif
+  #elif (defined __ARM7EM__)                    // IAR Cortex-M7
+    #if (__CORE__ == __ARM7EM__)
+      #define _CORE_HAS_RTT_ASM_SUPPORT 1
+    #else
+      #define _CORE_HAS_RTT_ASM_SUPPORT 0
+    #endif
+  #else
+    #define _CORE_HAS_RTT_ASM_SUPPORT 0
+  #endif
+  //
+  // If IDE and core support the ASM version, enable ASM version by default
+  //
+  #if (_CC_HAS_RTT_ASM_SUPPORT && _CORE_HAS_RTT_ASM_SUPPORT)
+    #define RTT_USE_ASM                           (1)
+  #else
+    #define RTT_USE_ASM                           (0)
+  #endif
+#endif
+
+#ifndef SEGGER_RTT_ASM  // defined when SEGGER_RTT.h is included from assembly file
+#include <stdlib.h>
+#include <stdarg.h>
+
+/*********************************************************************
+*
+*       Defines, fixed
+*
+**********************************************************************
+*/
+
+/*********************************************************************
+*
+*       Types
+*
+**********************************************************************
+*/
+
+//
+// Description for a circular buffer (also called "ring buffer")
+// which is used as up-buffer (T->H)
+//
+typedef struct {
+  const     char*    sName;         // Optional name. Standard names so far are: "Terminal", "SysView", "J-Scope_t4i4"
+            char*    pBuffer;       // Pointer to start of buffer
+            unsigned SizeOfBuffer;  // Buffer size in bytes. Note that one byte is lost, as this implementation does not fill up the buffer in order to avoid the problem of being unable to distinguish between full and empty.
+            unsigned WrOff;         // Position of next item to be written by either target.
+  volatile  unsigned RdOff;         // Position of next item to be read by host. Must be volatile since it may be modified by host.
+            unsigned Flags;         // Contains configuration flags
+} SEGGER_RTT_BUFFER_UP;
+
+//
+// Description for a circular buffer (also called "ring buffer")
+// which is used as down-buffer (H->T)
+//
+typedef struct {
+  const     char*    sName;         // Optional name. Standard names so far are: "Terminal", "SysView", "J-Scope_t4i4"
+            char*    pBuffer;       // Pointer to start of buffer
+            unsigned SizeOfBuffer;  // Buffer size in bytes. Note that one byte is lost, as this implementation does not fill up the buffer in order to avoid the problem of being unable to distinguish between full and empty.
+  volatile  unsigned WrOff;         // Position of next item to be written by host. Must be volatile since it may be modified by host.
+            unsigned RdOff;         // Position of next item to be read by target (down-buffer).
+            unsigned Flags;         // Contains configuration flags
+} SEGGER_RTT_BUFFER_DOWN;
+
+//
+// RTT control block which describes the number of buffers available
+// as well as the configuration for each buffer
+//
+//
+typedef struct {
+  char                    acID[16];                                 // Initialized to "SEGGER RTT"
+  int                     MaxNumUpBuffers;                          // Initialized to SEGGER_RTT_MAX_NUM_UP_BUFFERS (type. 2)
+  int                     MaxNumDownBuffers;                        // Initialized to SEGGER_RTT_MAX_NUM_DOWN_BUFFERS (type. 2)
+  SEGGER_RTT_BUFFER_UP    aUp[SEGGER_RTT_MAX_NUM_UP_BUFFERS];       // Up buffers, transferring information up from target via debug probe to host
+  SEGGER_RTT_BUFFER_DOWN  aDown[SEGGER_RTT_MAX_NUM_DOWN_BUFFERS];   // Down buffers, transferring information down from host via debug probe to target
+} SEGGER_RTT_CB;
+
+/*********************************************************************
+*
+*       Global data
+*
+**********************************************************************
+*/
+extern SEGGER_RTT_CB _SEGGER_RTT;
+
+/*********************************************************************
+*
+*       RTT API functions
+*
+**********************************************************************
+*/
+#ifdef __cplusplus
+  extern "C" {
+#endif
+int          SEGGER_RTT_AllocDownBuffer         (const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags);
+int          SEGGER_RTT_AllocUpBuffer           (const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags);
+int          SEGGER_RTT_ConfigUpBuffer          (unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags);
+int          SEGGER_RTT_ConfigDownBuffer        (unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags);
+int          SEGGER_RTT_GetKey                  (void);
+unsigned     SEGGER_RTT_HasData                 (unsigned BufferIndex);
+int          SEGGER_RTT_HasKey                  (void);
+unsigned     SEGGER_RTT_HasDataUp               (unsigned BufferIndex);
+void         SEGGER_RTT_Init                    (void);
+unsigned     SEGGER_RTT_Read                    (unsigned BufferIndex,       void* pBuffer, unsigned BufferSize);
+unsigned     SEGGER_RTT_ReadNoLock              (unsigned BufferIndex,       void* pData,   unsigned BufferSize);
+int          SEGGER_RTT_SetNameDownBuffer       (unsigned BufferIndex, const char* sName);
+int          SEGGER_RTT_SetNameUpBuffer         (unsigned BufferIndex, const char* sName);
+int          SEGGER_RTT_SetFlagsDownBuffer      (unsigned BufferIndex, unsigned Flags);
+int          SEGGER_RTT_SetFlagsUpBuffer        (unsigned BufferIndex, unsigned Flags);
+int          SEGGER_RTT_WaitKey                 (void);
+unsigned     SEGGER_RTT_Write                   (unsigned BufferIndex, const void* pBuffer, unsigned NumBytes);
+unsigned     SEGGER_RTT_WriteNoLock             (unsigned BufferIndex, const void* pBuffer, unsigned NumBytes);
+unsigned     SEGGER_RTT_WriteSkipNoLock         (unsigned BufferIndex, const void* pBuffer, unsigned NumBytes);
+unsigned     SEGGER_RTT_ASM_WriteSkipNoLock     (unsigned BufferIndex, const void* pBuffer, unsigned NumBytes);
+unsigned     SEGGER_RTT_WriteString             (unsigned BufferIndex, const char* s);
+void         SEGGER_RTT_WriteWithOverwriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes);
+unsigned     SEGGER_RTT_PutChar                 (unsigned BufferIndex, char c);
+unsigned     SEGGER_RTT_PutCharSkip             (unsigned BufferIndex, char c);
+unsigned     SEGGER_RTT_PutCharSkipNoLock       (unsigned BufferIndex, char c);
+unsigned     SEGGER_RTT_GetAvailWriteSpace      (unsigned BufferIndex);
+unsigned     SEGGER_RTT_GetBytesInBuffer        (unsigned BufferIndex);
+//
+// Function macro for performance optimization
+//
+#define      SEGGER_RTT_HASDATA(n)       (_SEGGER_RTT.aDown[n].WrOff - _SEGGER_RTT.aDown[n].RdOff)
+
+#if RTT_USE_ASM
+  #define SEGGER_RTT_WriteSkipNoLock  SEGGER_RTT_ASM_WriteSkipNoLock
+#endif
+
+/*********************************************************************
+*
+*       RTT transfer functions to send RTT data via other channels.
+*
+**********************************************************************
+*/
+unsigned     SEGGER_RTT_ReadUpBuffer            (unsigned BufferIndex, void* pBuffer, unsigned BufferSize);
+unsigned     SEGGER_RTT_ReadUpBufferNoLock      (unsigned BufferIndex, void* pData, unsigned BufferSize);
+unsigned     SEGGER_RTT_WriteDownBuffer         (unsigned BufferIndex, const void* pBuffer, unsigned NumBytes);
+unsigned     SEGGER_RTT_WriteDownBufferNoLock   (unsigned BufferIndex, const void* pBuffer, unsigned NumBytes);
+
+#define      SEGGER_RTT_HASDATA_UP(n)    (_SEGGER_RTT.aUp[n].WrOff - _SEGGER_RTT.aUp[n].RdOff)
+
+/*********************************************************************
+*
+*       RTT "Terminal" API functions
+*
+**********************************************************************
+*/
+int     SEGGER_RTT_SetTerminal        (unsigned char TerminalId);
+int     SEGGER_RTT_TerminalOut        (unsigned char TerminalId, const char* s);
+
+/*********************************************************************
+*
+*       RTT printf functions (require SEGGER_RTT_printf.c)
+*
+**********************************************************************
+*/
+int SEGGER_RTT_printf(unsigned BufferIndex, const char * sFormat, ...);
+int SEGGER_RTT_vprintf(unsigned BufferIndex, const char * sFormat, va_list * pParamList);
+
+#ifdef __cplusplus
+  }
+#endif
+
+#endif // ifndef(SEGGER_RTT_ASM)
+
+/*********************************************************************
+*
+*       Defines
+*
+**********************************************************************
+*/
+
+//
+// Operating modes. Define behavior if buffer is full (not enough space for entire message)
+//
+#define SEGGER_RTT_MODE_NO_BLOCK_SKIP         (0)     // Skip. Do not block, output nothing. (Default)
+#define SEGGER_RTT_MODE_NO_BLOCK_TRIM         (1)     // Trim: Do not block, output as much as fits.
+#define SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL    (2)     // Block: Wait until there is space in the buffer.
+#define SEGGER_RTT_MODE_MASK                  (3)
+
+//
+// Control sequences, based on ANSI.
+// Can be used to control color, and clear the screen
+//
+#define RTT_CTRL_RESET                "\x1B[0m"         // Reset to default colors
+#define RTT_CTRL_CLEAR                "\x1B[2J"         // Clear screen, reposition cursor to top left
+
+#define RTT_CTRL_TEXT_BLACK           "\x1B[2;30m"
+#define RTT_CTRL_TEXT_RED             "\x1B[2;31m"
+#define RTT_CTRL_TEXT_GREEN           "\x1B[2;32m"
+#define RTT_CTRL_TEXT_YELLOW          "\x1B[2;33m"
+#define RTT_CTRL_TEXT_BLUE            "\x1B[2;34m"
+#define RTT_CTRL_TEXT_MAGENTA         "\x1B[2;35m"
+#define RTT_CTRL_TEXT_CYAN            "\x1B[2;36m"
+#define RTT_CTRL_TEXT_WHITE           "\x1B[2;37m"
+
+#define RTT_CTRL_TEXT_BRIGHT_BLACK    "\x1B[1;30m"
+#define RTT_CTRL_TEXT_BRIGHT_RED      "\x1B[1;31m"
+#define RTT_CTRL_TEXT_BRIGHT_GREEN    "\x1B[1;32m"
+#define RTT_CTRL_TEXT_BRIGHT_YELLOW   "\x1B[1;33m"
+#define RTT_CTRL_TEXT_BRIGHT_BLUE     "\x1B[1;34m"
+#define RTT_CTRL_TEXT_BRIGHT_MAGENTA  "\x1B[1;35m"
+#define RTT_CTRL_TEXT_BRIGHT_CYAN     "\x1B[1;36m"
+#define RTT_CTRL_TEXT_BRIGHT_WHITE    "\x1B[1;37m"
+
+#define RTT_CTRL_BG_BLACK             "\x1B[24;40m"
+#define RTT_CTRL_BG_RED               "\x1B[24;41m"
+#define RTT_CTRL_BG_GREEN             "\x1B[24;42m"
+#define RTT_CTRL_BG_YELLOW            "\x1B[24;43m"
+#define RTT_CTRL_BG_BLUE              "\x1B[24;44m"
+#define RTT_CTRL_BG_MAGENTA           "\x1B[24;45m"
+#define RTT_CTRL_BG_CYAN              "\x1B[24;46m"
+#define RTT_CTRL_BG_WHITE             "\x1B[24;47m"
+
+#define RTT_CTRL_BG_BRIGHT_BLACK      "\x1B[4;40m"
+#define RTT_CTRL_BG_BRIGHT_RED        "\x1B[4;41m"
+#define RTT_CTRL_BG_BRIGHT_GREEN      "\x1B[4;42m"
+#define RTT_CTRL_BG_BRIGHT_YELLOW     "\x1B[4;43m"
+#define RTT_CTRL_BG_BRIGHT_BLUE       "\x1B[4;44m"
+#define RTT_CTRL_BG_BRIGHT_MAGENTA    "\x1B[4;45m"
+#define RTT_CTRL_BG_BRIGHT_CYAN       "\x1B[4;46m"
+#define RTT_CTRL_BG_BRIGHT_WHITE      "\x1B[4;47m"
+
+
+#endif
+
+/*************************** End of file ****************************/
diff --git a/sched/systemview/SEGGER_RTT_ASM_ARMv7M.S b/sched/systemview/SEGGER_RTT_ASM_ARMv7M.S
new file mode 100644
index 0000000000..0c0eae1c25
--- /dev/null
+++ b/sched/systemview/SEGGER_RTT_ASM_ARMv7M.S
@@ -0,0 +1,235 @@
+/*********************************************************************
+*                   (c) SEGGER Microcontroller GmbH                  *
+*                        The Embedded Experts                        *
+*                           www.segger.com                           *
+**********************************************************************
+
+-------------------------- END-OF-HEADER -----------------------------
+
+File    : SEGGER_RTT_ASM_ARMv7M.S
+Purpose : Assembler implementation of RTT functions for ARMv7M
+
+Additional information:
+  This module is written to be assembler-independent and works with
+  GCC and clang (Embedded Studio) and IAR.
+*/
+
+#define SEGGER_RTT_ASM      // Used to control processed input from header file
+#include "SEGGER_RTT.h"
+
+/*********************************************************************
+*
+*       Defines, fixed
+*
+**********************************************************************
+*/
+#define _CCIAR   0
+#define _CCCLANG 1
+
+#if (defined __SES_ARM) || (defined __GNUC__) || (defined __clang__)
+  #define _CC_TYPE             _CCCLANG
+  #define _PUB_SYM             .global
+  #define _EXT_SYM             .extern
+  #define _END                 .end
+  #define _WEAK                .weak
+  #define _THUMB_FUNC          .thumb_func
+  #define _THUMB_CODE          .code 16
+  #define _WORD                .word
+  #define _SECTION(Sect, Type, AlignExp) .section Sect ##, "ax"
+  #define _ALIGN(Exp)          .align Exp 
+  #define _PLACE_LITS          .ltorg
+  #define _DATA_SECT_START 
+  #define _C_STARTUP           _start
+  #define _STACK_END           __stack_end__
+  #define _RAMFUNC
+  //
+  // .text     => Link to flash
+  // .fast     => Link to RAM
+  // OtherSect => Usually link to RAM
+  // Alignment is 2^x
+  //
+#elif defined (__IASMARM__)
+  #define _CC_TYPE             _CCIAR
+  #define _PUB_SYM             PUBLIC
+  #define _EXT_SYM             EXTERN
+  #define _END                 END
+  #define _WEAK                _WEAK
+  #define _THUMB_FUNC
+  #define _THUMB_CODE          THUMB
+  #define _WORD                DCD
+  #define _SECTION(Sect, Type, AlignExp) SECTION Sect ## : ## Type ## :REORDER:NOROOT ## (AlignExp)
+  #define _ALIGN(Exp)          alignrom Exp 
+  #define _PLACE_LITS
+  #define _DATA_SECT_START     DATA
+  #define _C_STARTUP           __iar_program_start
+  #define _STACK_END           sfe(CSTACK)
+  #define _RAMFUNC             SECTION_TYPE SHT_PROGBITS, SHF_WRITE | SHF_EXECINSTR
+  //
+  // .text     => Link to flash
+  // .textrw   => Link to RAM
+  // OtherSect => Usually link to RAM
+  // NOROOT    => Allows linker to throw away the function, if not referenced
+  // Alignment is 2^x
+  //
+#endif
+
+#if (_CC_TYPE == _CCIAR)
+        NAME SEGGER_RTT_ASM_ARMv7M
+#else
+        .syntax unified
+#endif
+
+#if defined (RTT_USE_ASM) && (RTT_USE_ASM == 1)
+        #define SHT_PROGBITS 0x1
+
+/*********************************************************************
+*
+*       Public / external symbols
+*
+**********************************************************************
+*/
+
+        _EXT_SYM __aeabi_memcpy
+        _EXT_SYM __aeabi_memcpy4
+        _EXT_SYM _SEGGER_RTT
+
+        _PUB_SYM SEGGER_RTT_ASM_WriteSkipNoLock
+
+/*********************************************************************
+*
+*       SEGGER_RTT_WriteSkipNoLock
+*
+*  Function description
+*    Stores a specified number of characters in SEGGER RTT
+*    control block which is then read by the host.
+*    SEGGER_RTT_WriteSkipNoLock does not lock the application and
+*    skips all data, if the data does not fit into the buffer.
+*
+*  Parameters
+*    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
+*    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
+*    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
+*                 MUST be > 0!!!
+*                 This is done for performance reasons, so no initial check has do be done.
+*
+*  Return value
+*    1: Data has been copied
+*    0: No space, data has not been copied
+*
+*  Notes
+*    (1) If there is not enough space in the "Up"-buffer, all data is dropped.
+*    (2) For performance reasons this function does not call Init()
+*        and may only be called after RTT has been initialized.
+*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
+*/
+        _SECTION(.text, CODE, 2)
+        _ALIGN(2)
+        _THUMB_FUNC
+SEGGER_RTT_ASM_WriteSkipNoLock:   // unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pData, unsigned NumBytes) {
+        //
+        // Cases:
+        //   1) RdOff <= WrOff => Space until wrap-around is sufficient
+        //   2) RdOff <= WrOff => Space after wrap-around needed (copy in 2 chunks)
+        //   3) RdOff <  WrOff => No space in buf
+        //   4) RdOff >  WrOff => Space is sufficient
+        //   5) RdOff >  WrOff => No space in buf
+        //
+        // 1) is the most common case for large buffers and assuming that J-Link reads the data fast enough
+        //
+        // Register usage:
+        //   R0 Temporary needed as RdOff, <Tmp> register later on
+        //   R1 pData
+        //   R2 <NumBytes>
+        //   R3 <Tmp> register. Hold free for subroutine calls
+        //   R4 <Rem>
+        //   R5 pRing->pBuffer
+        //   R6 pRing (Points to active struct SEGGER_RTT_BUFFER_DOWN)
+        //   R7 WrOff
+        //
+        PUSH     {R4-R7}
+        ADD      R3,R0,R0, LSL #+1
+        LDR.W    R0,=_SEGGER_RTT                 // pRing = &_SEGGER_RTT.aUp[BufferIndex];
+        ADD      R0,R0,R3, LSL #+3
+        ADD      R6,R0,#+24
+        LDR      R0,[R6, #+16]                   // RdOff = pRing->RdOff;
+        LDR      R7,[R6, #+12]                   // WrOff = pRing->WrOff;
+        LDR      R5,[R6, #+4]                    // pRing->pBuffer
+        CMP      R7,R0
+        BCC.N    _CheckCase4                     // if (RdOff <= WrOff) {                           => Case 1), 2) or 3)
+        //
+        // Handling for case 1, later on identical to case 4
+        //
+        LDR      R3,[R6, #+8]                    //  Avail = pRing->SizeOfBuffer - WrOff - 1u;      => Space until wrap-around (assume 1 byte not usable for case that RdOff == 0)
+        SUBS     R4,R3,R7                        // <Rem> (Used in case we jump into case 2 afterwards)
+        SUBS     R3,R4,#+1                       // <Avail>
+        CMP      R3,R2
+        BCC.N    _CheckCase2                     // if (Avail >= NumBytes) {  => Case 1)?
+_Case4:
+        ADDS     R5,R7,R5                        // pBuffer += WrOff
+        ADDS     R0,R2,R7                        // v = WrOff + NumBytes
+        //
+        // 2x unrolling for the copy loop that is used most of the time
+        // This is a special optimization for small SystemView packets and makes them even faster
+        //
+        _ALIGN(2)
+_LoopCopyStraight:                               // memcpy(pRing->pBuffer + WrOff, pData, NumBytes);
+        LDRB     R3,[R1], #+1
+        STRB     R3,[R5], #+1                    // *pDest++ = *pSrc++
+        SUBS     R2,R2,#+1
+        BEQ      _CSDone
+        LDRB     R3,[R1], #+1
+        STRB     R3,[R5], #+1                    // *pDest++ = *pSrc++
+        SUBS     R2,R2,#+1
+        BNE      _LoopCopyStraight
+_CSDone:
+        STR      R0,[R6, #+12]                   // pRing->WrOff = WrOff + NumBytes;
+        MOVS     R0,#+1
+        POP      {R4-R7}
+        BX       LR                              // Return 1
+_CheckCase2:
+        ADDS     R0,R0,R3                        // Avail += RdOff; => Space incl. wrap-around
+        CMP      R0,R2
+        BCC.N    _Case3                          // if (Avail >= NumBytes) {           => Case 2? => If not, we have case 3) (does not fit)
+        //
+        // Handling for case 2
+        //
+        ADDS     R0,R7,R5                        // v = pRing->pBuffer + WrOff => Do not change pRing->pBuffer here because 2nd chunk needs org. value
+        SUBS     R2,R2,R4                        // NumBytes -= Rem;  (Rem = pRing->SizeOfBuffer - WrOff; => Space until end of buffer)
+_LoopCopyBeforeWrapAround:                       // memcpy(pRing->pBuffer + WrOff, pData, Rem); => Copy 1st chunk
+        LDRB     R3,[R1], #+1
+        STRB     R3,[R0], #+1                    // *pDest++ = *pSrc++
+        SUBS     R4,R4,#+1
+        BNE      _LoopCopyBeforeWrapAround
+        //
+        // Special case: First check that assumed RdOff == 0 calculated that last element before wrap-around could not be used
+        // But 2nd check (considering space until wrap-around and until RdOff) revealed that RdOff is not 0, so we can use the last element
+        // In this case, we may use a copy straight until buffer end anyway without needing to copy 2 chunks
+        // Therefore, check if 2nd memcpy is necessary at all
+        //
+        ADDS     R4,R2,#+0                       // Save <NumBytes> (needed as counter in loop but must be written to <WrOff> after the loop). Also use this inst to update the flags to skip 2nd loop if possible
+        BEQ.N    _No2ChunkNeeded                 // if (NumBytes) {
+_LoopCopyAfterWrapAround:                        // memcpy(pRing->pBuffer, pData + Rem, NumBytes);
+        LDRB     R3,[R1], #+1                    // pData already points to the next src byte due to copy loop increment before this loop
+        STRB     R3,[R5], #+1                    // *pDest++ = *pSrc++
+        SUBS     R2,R2,#+1
+        BNE      _LoopCopyAfterWrapAround
+_No2ChunkNeeded:
+        STR      R4,[R6, #+12]                   // pRing->WrOff = NumBytes; => Must be written after copying data because J-Link may read control block asynchronously while writing into buffer
+        MOVS     R0,#+1
+        POP      {R4-R7}
+        BX       LR                              // Return 1
+_CheckCase4:
+        SUBS     R0,R0,R7
+        SUBS     R0,R0,#+1                       // Avail = RdOff - WrOff - 1u;
+        CMP      R0,R2
+        BCS.N    _Case4                          // if (Avail >= NumBytes) {      => Case 4) == 1) ? => If not, we have case 5) == 3) (does not fit)
+_Case3:
+        MOVS     R0,#+0
+        POP      {R4-R7}
+        BX       LR                              // Return 0
+        _PLACE_LITS
+
+#endif  // defined (RTT_USE_ASM) && (RTT_USE_ASM == 1)
+        _END
+
+/*************************** End of file ****************************/
diff --git a/sched/systemview/SEGGER_RTT_Conf.h b/sched/systemview/SEGGER_RTT_Conf.h
new file mode 100644
index 0000000000..03804c8c62
--- /dev/null
+++ b/sched/systemview/SEGGER_RTT_Conf.h
@@ -0,0 +1,388 @@
+/*********************************************************************
+*                    SEGGER Microcontroller GmbH                     *
+*                        The Embedded Experts                        *
+**********************************************************************
+*                                                                    *
+*            (c) 1995 - 2019 SEGGER Microcontroller GmbH             *
+*                                                                    *
+*       www.segger.com     Support: support@segger.com               *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SEGGER SystemView * Real-time application analysis           *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+* All rights reserved.                                               *
+*                                                                    *
+* SEGGER strongly recommends to not make any changes                 *
+* to or modify the source code of this software in order to stay     *
+* compatible with the SystemView and RTT protocol, and J-Link.       *
+*                                                                    *
+* Redistribution and use in source and binary forms, with or         *
+* without modification, are permitted provided that the following    *
+* condition is met:                                                  *
+*                                                                    *
+* o Redistributions of source code must retain the above copyright   *
+*   notice, this condition and the following disclaimer.             *
+*                                                                    *
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
+* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
+* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
+* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
+* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
+* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
+* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
+* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
+* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
+* DAMAGE.                                                            *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SystemView version: V3.12                                    *
+*                                                                    *
+**********************************************************************
+---------------------------END-OF-HEADER------------------------------
+File    : SEGGER_RTT_Conf.h
+Purpose : Implementation of SEGGER real-time transfer (RTT) which
+          allows real-time communication on targets which support
+          debugger memory accesses while the CPU is running.
+Revision: $Rev: 18601 $
+
+*/
+
+#ifndef SEGGER_RTT_CONF_H
+#define SEGGER_RTT_CONF_H
+
+#ifdef __IAR_SYSTEMS_ICC__
+  #include <intrinsics.h>
+#endif
+
+/*********************************************************************
+*
+*       Defines, configurable
+*
+**********************************************************************
+*/
+#ifndef   SEGGER_RTT_MAX_NUM_UP_BUFFERS
+  #define SEGGER_RTT_MAX_NUM_UP_BUFFERS             (3)     // Max. number of up-buffers (T->H) available on this target    (Default: 3)
+#endif
+
+#ifndef   SEGGER_RTT_MAX_NUM_DOWN_BUFFERS
+  #define SEGGER_RTT_MAX_NUM_DOWN_BUFFERS           (3)     // Max. number of down-buffers (H->T) available on this target  (Default: 3)
+#endif
+
+#ifndef   BUFFER_SIZE_UP
+  #define BUFFER_SIZE_UP                            (1024)  // Size of the buffer for terminal output of target, up to host (Default: 1k)
+#endif
+
+#ifndef   BUFFER_SIZE_DOWN
+  #define BUFFER_SIZE_DOWN                          (16)    // Size of the buffer for terminal input to target from host (Usually keyboard input) (Default: 16)
+#endif
+
+#ifndef   SEGGER_RTT_PRINTF_BUFFER_SIZE
+  #define SEGGER_RTT_PRINTF_BUFFER_SIZE             (64u)    // Size of buffer for RTT printf to bulk-send chars via RTT     (Default: 64)
+#endif
+
+#ifndef   SEGGER_RTT_MODE_DEFAULT
+  #define SEGGER_RTT_MODE_DEFAULT                   SEGGER_RTT_MODE_NO_BLOCK_SKIP // Mode for pre-initialized terminal channel (buffer 0)
+#endif
+
+/*********************************************************************
+*
+*       RTT memcpy configuration
+*
+*       memcpy() is good for large amounts of data, 
+*       but the overhead is big for small amounts, which are usually stored via RTT.
+*       With SEGGER_RTT_MEMCPY_USE_BYTELOOP a simple byte loop can be used instead.
+*
+*       SEGGER_RTT_MEMCPY() can be used to replace standard memcpy() in RTT functions.
+*       This is may be required with memory access restrictions, 
+*       such as on Cortex-A devices with MMU.
+*/
+#ifndef   SEGGER_RTT_MEMCPY_USE_BYTELOOP
+  #define SEGGER_RTT_MEMCPY_USE_BYTELOOP              0 // 0: Use memcpy/SEGGER_RTT_MEMCPY, 1: Use a simple byte-loop
+#endif
+//
+// Example definition of SEGGER_RTT_MEMCPY to external memcpy with GCC toolchains and Cortex-A targets
+//
+//#if ((defined __SES_ARM) || (defined __CROSSWORKS_ARM) || (defined __GNUC__)) && (defined (__ARM_ARCH_7A__))  
+//  #define SEGGER_RTT_MEMCPY(pDest, pSrc, NumBytes)      SEGGER_memcpy((pDest), (pSrc), (NumBytes))
+//#endif
+
+//
+// Target is not allowed to perform other RTT operations while string still has not been stored completely.
+// Otherwise we would probably end up with a mixed string in the buffer.
+// If using  RTT from within interrupts, multiple tasks or multi processors, define the SEGGER_RTT_LOCK() and SEGGER_RTT_UNLOCK() function here.
+//
+// SEGGER_RTT_MAX_INTERRUPT_PRIORITY can be used in the sample lock routines on Cortex-M3/4.
+// Make sure to mask all interrupts which can send RTT data, i.e. generate SystemView events, or cause task switches.
+// When high-priority interrupts must not be masked while sending RTT data, SEGGER_RTT_MAX_INTERRUPT_PRIORITY needs to be adjusted accordingly.
+// (Higher priority = lower priority number)
+// Default value for embOS: 128u
+// Default configuration in FreeRTOS: configMAX_SYSCALL_INTERRUPT_PRIORITY: ( configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY << (8 - configPRIO_BITS) )
+// In case of doubt mask all interrupts: 1 << (8 - BASEPRI_PRIO_BITS) i.e. 1 << 5 when 3 bits are implemented in NVIC
+// or define SEGGER_RTT_LOCK() to completely disable interrupts.
+//
+#ifndef   SEGGER_RTT_MAX_INTERRUPT_PRIORITY
+  #define SEGGER_RTT_MAX_INTERRUPT_PRIORITY         (0x20)   // Interrupt priority to lock on SEGGER_RTT_LOCK on Cortex-M3/4 (Default: 0x20)
+#endif
+
+/*********************************************************************
+*
+*       RTT lock configuration for SEGGER Embedded Studio,
+*       Rowley CrossStudio and GCC
+*/
+#if ((defined(__SES_ARM) || defined(__SES_RISCV) || defined(__CROSSWORKS_ARM) || defined(__GNUC__) || defined(__clang__)) && !defined (__CC_ARM) && !defined(WIN32))
+  #if (defined(__ARM_ARCH_6M__) || defined(__ARM_ARCH_8M_BASE__))
+    #define SEGGER_RTT_LOCK()   {                                                                   \
+                                    unsigned int LockState;                                         \
+                                  __asm volatile ("mrs   %0, primask  \n\t"                         \
+                                                  "movs  r1, $1       \n\t"                         \
+                                                  "msr   primask, r1  \n\t"                         \
+                                                  : "=r" (LockState)                                \
+                                                  :                                                 \
+                                                  : "r1"                                            \
+                                                  );
+
+    #define SEGGER_RTT_UNLOCK()   __asm volatile ("msr   primask, %0  \n\t"                         \
+                                                  :                                                 \
+                                                  : "r" (LockState)                                 \
+                                                  :                                                 \
+                                                  );                                                \
+                                }
+  #elif (defined(__ARM_ARCH_7M__) || defined(__ARM_ARCH_7EM__) || defined(__ARM_ARCH_8M_MAIN__))
+    #ifndef   SEGGER_RTT_MAX_INTERRUPT_PRIORITY
+      #define SEGGER_RTT_MAX_INTERRUPT_PRIORITY   (0x20)
+    #endif
+    #define SEGGER_RTT_LOCK()   {                                                                   \
+                                    unsigned int LockState;                                         \
+                                  __asm volatile ("mrs   %0, basepri  \n\t"                         \
+                                                  "mov   r1, %1       \n\t"                         \
+                                                  "msr   basepri, r1  \n\t"                         \
+                                                  : "=r" (LockState)                                \
+                                                  : "i"(SEGGER_RTT_MAX_INTERRUPT_PRIORITY)          \
+                                                  : "r1"                                            \
+                                                  );
+
+    #define SEGGER_RTT_UNLOCK()   __asm volatile ("msr   basepri, %0  \n\t"                         \
+                                                  :                                                 \
+                                                  : "r" (LockState)                                 \
+                                                  :                                                 \
+                                                  );                                                \
+                                }
+
+  #elif defined(__ARM_ARCH_7A__)
+    #define SEGGER_RTT_LOCK() {                                                \
+                                 unsigned int LockState;                       \
+                                 __asm volatile ("mrs r1, CPSR \n\t"           \
+                                                 "mov %0, r1 \n\t"             \
+                                                 "orr r1, r1, #0xC0 \n\t"      \
+                                                 "msr CPSR_c, r1 \n\t"         \
+                                                 : "=r" (LockState)            \
+                                                 :                             \
+                                                 : "r1"                        \
+                                                 );
+
+    #define SEGGER_RTT_UNLOCK() __asm volatile ("mov r0, %0 \n\t"              \
+                                                "mrs r1, CPSR \n\t"            \
+                                                "bic r1, r1, #0xC0 \n\t"       \
+                                                "and r0, r0, #0xC0 \n\t"       \
+                                                "orr r1, r1, r0 \n\t"          \
+                                                "msr CPSR_c, r1 \n\t"          \
+                                                :                              \
+                                                : "r" (LockState)              \
+                                                : "r0", "r1"                   \
+                                                );                             \
+                            }
+  #elif defined(__riscv) || defined(__riscv_xlen)
+    #define SEGGER_RTT_LOCK()  {                                               \
+                                 unsigned int LockState;                       \
+                                 __asm volatile ("csrr  %0, mstatus  \n\t"     \
+                                                 "csrci mstatus, 8   \n\t"     \
+                                                 "andi  %0, %0,  8   \n\t"     \
+                                                 : "=r" (LockState)            \
+                                                 :                             \
+                                                 :                             \
+                                                );
+                               
+  #define SEGGER_RTT_UNLOCK()    __asm volatile ("csrr  a1, mstatus  \n\t"     \
+                                                 "or    %0, %0, a1   \n\t"     \
+                                                 "csrs  mstatus, %0  \n\t"     \
+                                                 :                             \
+                                                 : "r"  (LockState)            \
+                                                 : "a1"                        \
+                                                );                             \
+                               }
+  #else
+    #define SEGGER_RTT_LOCK()
+    #define SEGGER_RTT_UNLOCK()
+  #endif
+#endif
+
+/*********************************************************************
+*
+*       RTT lock configuration for IAR EWARM
+*/
+#ifdef __ICCARM__
+  #if (defined (__ARM6M__)          && (__CORE__ == __ARM6M__))             ||                      \
+      (defined (__ARM8M_BASELINE__) && (__CORE__ == __ARM8M_BASELINE__))
+    #define SEGGER_RTT_LOCK()   {                                                                   \
+                                  unsigned int LockState;                                           \
+                                  LockState = __get_PRIMASK();                                      \
+                                  __set_PRIMASK(1);
+
+    #define SEGGER_RTT_UNLOCK()   __set_PRIMASK(LockState);                                         \
+                                }
+  #elif (defined (__ARM7EM__)         && (__CORE__ == __ARM7EM__))          ||                      \
+        (defined (__ARM7M__)          && (__CORE__ == __ARM7M__))           ||                      \
+        (defined (__ARM8M_MAINLINE__) && (__CORE__ == __ARM8M_MAINLINE__))  ||                      \
+        (defined (__ARM8M_MAINLINE__) && (__CORE__ == __ARM8M_MAINLINE__))
+    #ifndef   SEGGER_RTT_MAX_INTERRUPT_PRIORITY
+      #define SEGGER_RTT_MAX_INTERRUPT_PRIORITY   (0x20)
+    #endif
+    #define SEGGER_RTT_LOCK()   {                                                                   \
+                                  unsigned int LockState;                                           \
+                                  LockState = __get_BASEPRI();                                      \
+                                  __set_BASEPRI(SEGGER_RTT_MAX_INTERRUPT_PRIORITY);
+
+    #define SEGGER_RTT_UNLOCK()   __set_BASEPRI(LockState);                                         \
+                                }
+  #endif
+#endif
+
+/*********************************************************************
+*
+*       RTT lock configuration for IAR RX
+*/
+#ifdef __ICCRX__
+  #define SEGGER_RTT_LOCK()   {                                                                     \
+                                unsigned long LockState;                                            \
+                                LockState = __get_interrupt_state();                                \
+                                __disable_interrupt();
+
+  #define SEGGER_RTT_UNLOCK()   __set_interrupt_state(LockState);                                   \
+                              }
+#endif
+
+/*********************************************************************
+*
+*       RTT lock configuration for IAR RL78
+*/
+#ifdef __ICCRL78__
+  #define SEGGER_RTT_LOCK()   {                                                                     \
+                                __istate_t LockState;                                               \
+                                LockState = __get_interrupt_state();                                \
+                                __disable_interrupt();
+
+  #define SEGGER_RTT_UNLOCK()   __set_interrupt_state(LockState);                                   \
+                              }
+#endif
+
+/*********************************************************************
+*
+*       RTT lock configuration for KEIL ARM
+*/
+#ifdef __CC_ARM
+  #if (defined __TARGET_ARCH_6S_M)
+    #define SEGGER_RTT_LOCK()   {                                                                   \
+                                  unsigned int LockState;                                           \
+                                  register unsigned char PRIMASK __asm( "primask");                 \
+                                  LockState = PRIMASK;                                              \
+                                  PRIMASK = 1u;                                                     \
+                                  __schedule_barrier();
+
+    #define SEGGER_RTT_UNLOCK()   PRIMASK = LockState;                                              \
+                                  __schedule_barrier();                                             \
+                                }
+  #elif (defined(__TARGET_ARCH_7_M) || defined(__TARGET_ARCH_7E_M))
+    #ifndef   SEGGER_RTT_MAX_INTERRUPT_PRIORITY
+      #define SEGGER_RTT_MAX_INTERRUPT_PRIORITY   (0x20)
+    #endif
+    #define SEGGER_RTT_LOCK()   {                                                                   \
+                                  unsigned int LockState;                                           \
+                                  register unsigned char BASEPRI __asm( "basepri");                 \
+                                  LockState = BASEPRI;                                              \
+                                  BASEPRI = SEGGER_RTT_MAX_INTERRUPT_PRIORITY;                      \
+                                  __schedule_barrier();
+
+    #define SEGGER_RTT_UNLOCK()   BASEPRI = LockState;                                              \
+                                  __schedule_barrier();                                             \
+                                }
+  #endif
+#endif
+
+/*********************************************************************
+*
+*       RTT lock configuration for TI ARM
+*/
+#ifdef __TI_ARM__
+  #if defined (__TI_ARM_V6M0__)
+    #define SEGGER_RTT_LOCK()   {                                                                   \
+                                  unsigned int LockState;                                           \
+                                  LockState = __get_PRIMASK();                                      \
+                                  __set_PRIMASK(1);
+
+    #define SEGGER_RTT_UNLOCK()   __set_PRIMASK(LockState);                                         \
+                                }
+  #elif (defined (__TI_ARM_V7M3__) || defined (__TI_ARM_V7M4__))
+    #ifndef   SEGGER_RTT_MAX_INTERRUPT_PRIORITY
+      #define SEGGER_RTT_MAX_INTERRUPT_PRIORITY   (0x20)
+    #endif
+    #define SEGGER_RTT_LOCK()   {                                                                   \
+                                  unsigned int LockState;                                           \
+                                  LockState = _set_interrupt_priority(SEGGER_RTT_MAX_INTERRUPT_PRIORITY);
+
+    #define SEGGER_RTT_UNLOCK()   _set_interrupt_priority(LockState);                               \
+                                }
+  #endif
+#endif
+
+/*********************************************************************
+*
+*       RTT lock configuration for CCRX
+*/
+#ifdef __RX
+  #define SEGGER_RTT_LOCK()   {                                                                     \
+                                unsigned long LockState;                                            \
+                                LockState = get_psw() & 0x010000;                                   \
+                                clrpsw_i();                           
+                                    
+  #define SEGGER_RTT_UNLOCK()   set_psw(get_psw() | LockState);                                     \
+                              }
+#endif
+
+/*********************************************************************
+*
+*       RTT lock configuration for embOS Simulation on Windows
+*       (Can also be used for generic RTT locking with embOS)
+*/
+#if defined(WIN32) || defined(SEGGER_RTT_LOCK_EMBOS)
+
+void OS_SIM_EnterCriticalSection(void);
+void OS_SIM_LeaveCriticalSection(void);
+
+#define SEGGER_RTT_LOCK()       {                                                                   \
+                                  OS_SIM_EnterCriticalSection();
+
+#define SEGGER_RTT_UNLOCK()       OS_SIM_LeaveCriticalSection();                                    \
+                                }
+#endif
+
+/*********************************************************************
+*
+*       RTT lock configuration fallback
+*/
+#ifndef   SEGGER_RTT_LOCK
+  #define SEGGER_RTT_LOCK()                // Lock RTT (nestable)   (i.e. disable interrupts)
+#endif
+
+#ifndef   SEGGER_RTT_UNLOCK
+  #define SEGGER_RTT_UNLOCK()              // Unlock RTT (nestable) (i.e. enable previous interrupt lock state)
+#endif
+
+#endif
+/*************************** End of file ****************************/
diff --git a/sched/systemview/SEGGER_RTT_printf.c b/sched/systemview/SEGGER_RTT_printf.c
new file mode 100644
index 0000000000..85ab7eca3b
--- /dev/null
+++ b/sched/systemview/SEGGER_RTT_printf.c
@@ -0,0 +1,504 @@
+/*********************************************************************
+*                    SEGGER Microcontroller GmbH                     *
+*                        The Embedded Experts                        *
+**********************************************************************
+*                                                                    *
+*            (c) 1995 - 2019 SEGGER Microcontroller GmbH             *
+*                                                                    *
+*       www.segger.com     Support: support@segger.com               *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SEGGER SystemView * Real-time application analysis           *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+* All rights reserved.                                               *
+*                                                                    *
+* SEGGER strongly recommends to not make any changes                 *
+* to or modify the source code of this software in order to stay     *
+* compatible with the SystemView and RTT protocol, and J-Link.       *
+*                                                                    *
+* Redistribution and use in source and binary forms, with or         *
+* without modification, are permitted provided that the following    *
+* condition is met:                                                  *
+*                                                                    *
+* o Redistributions of source code must retain the above copyright   *
+*   notice, this condition and the following disclaimer.             *
+*                                                                    *
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
+* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
+* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
+* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
+* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
+* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
+* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
+* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
+* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
+* DAMAGE.                                                            *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SystemView version: V3.12                                    *
+*                                                                    *
+**********************************************************************
+---------------------------END-OF-HEADER------------------------------
+File    : SEGGER_RTT_printf.c
+Purpose : Replacement for printf to write formatted data via RTT
+Revision: $Rev: 17697 $
+----------------------------------------------------------------------
+*/
+#include "SEGGER_RTT.h"
+#include "SEGGER_RTT_Conf.h"
+
+/*********************************************************************
+*
+*       Defines, configurable
+*
+**********************************************************************
+*/
+
+#ifndef SEGGER_RTT_PRINTF_BUFFER_SIZE
+  #define SEGGER_RTT_PRINTF_BUFFER_SIZE (64)
+#endif
+
+#include <stdlib.h>
+#include <stdarg.h>
+
+
+#define FORMAT_FLAG_LEFT_JUSTIFY   (1u << 0)
+#define FORMAT_FLAG_PAD_ZERO       (1u << 1)
+#define FORMAT_FLAG_PRINT_SIGN     (1u << 2)
+#define FORMAT_FLAG_ALTERNATE      (1u << 3)
+
+/*********************************************************************
+*
+*       Types
+*
+**********************************************************************
+*/
+
+typedef struct {
+  char*     pBuffer;
+  unsigned  BufferSize;
+  unsigned  Cnt;
+
+  int   ReturnValue;
+
+  unsigned RTTBufferIndex;
+} SEGGER_RTT_PRINTF_DESC;
+
+/*********************************************************************
+*
+*       Function prototypes
+*
+**********************************************************************
+*/
+
+/*********************************************************************
+*
+*       Static code
+*
+**********************************************************************
+*/
+/*********************************************************************
+*
+*       _StoreChar
+*/
+static void _StoreChar(SEGGER_RTT_PRINTF_DESC * p, char c) {
+  unsigned Cnt;
+
+  Cnt = p->Cnt;
+  if ((Cnt + 1u) <= p->BufferSize) {
+    *(p->pBuffer + Cnt) = c;
+    p->Cnt = Cnt + 1u;
+    p->ReturnValue++;
+  }
+  //
+  // Write part of string, when the buffer is full
+  //
+  if (p->Cnt == p->BufferSize) {
+    if (SEGGER_RTT_Write(p->RTTBufferIndex, p->pBuffer, p->Cnt) != p->Cnt) {
+      p->ReturnValue = -1;
+    } else {
+      p->Cnt = 0u;
+    }
+  }
+}
+
+/*********************************************************************
+*
+*       _PrintUnsigned
+*/
+static void _PrintUnsigned(SEGGER_RTT_PRINTF_DESC * pBufferDesc, unsigned v, unsigned Base, unsigned NumDigits, unsigned FieldWidth, unsigned FormatFlags) {
+  static const char _aV2C[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
+  unsigned Div;
+  unsigned Digit;
+  unsigned Number;
+  unsigned Width;
+  char c;
+
+  Number = v;
+  Digit = 1u;
+  //
+  // Get actual field width
+  //
+  Width = 1u;
+  while (Number >= Base) {
+    Number = (Number / Base);
+    Width++;
+  }
+  if (NumDigits > Width) {
+    Width = NumDigits;
+  }
+  //
+  // Print leading chars if necessary
+  //
+  if ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u) {
+    if (FieldWidth != 0u) {
+      if (((FormatFlags & FORMAT_FLAG_PAD_ZERO) == FORMAT_FLAG_PAD_ZERO) && (NumDigits == 0u)) {
+        c = '0';
+      } else {
+        c = ' ';
+      }
+      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
+        FieldWidth--;
+        _StoreChar(pBufferDesc, c);
+        if (pBufferDesc->ReturnValue < 0) {
+          break;
+        }
+      }
+    }
+  }
+  if (pBufferDesc->ReturnValue >= 0) {
+    //
+    // Compute Digit.
+    // Loop until Digit has the value of the highest digit required.
+    // Example: If the output is 345 (Base 10), loop 2 times until Digit is 100.
+    //
+    while (1) {
+      if (NumDigits > 1u) {       // User specified a min number of digits to print? => Make sure we loop at least that often, before checking anything else (> 1 check avoids problems with NumDigits being signed / unsigned)
+        NumDigits--;
+      } else {
+        Div = v / Digit;
+        if (Div < Base) {        // Is our divider big enough to extract the highest digit from value? => Done
+          break;
+        }
+      }
+      Digit *= Base;
+    }
+    //
+    // Output digits
+    //
+    do {
+      Div = v / Digit;
+      v -= Div * Digit;
+      _StoreChar(pBufferDesc, _aV2C[Div]);
+      if (pBufferDesc->ReturnValue < 0) {
+        break;
+      }
+      Digit /= Base;
+    } while (Digit);
+    //
+    // Print trailing spaces if necessary
+    //
+    if ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == FORMAT_FLAG_LEFT_JUSTIFY) {
+      if (FieldWidth != 0u) {
+        while ((FieldWidth != 0u) && (Width < FieldWidth)) {
+          FieldWidth--;
+          _StoreChar(pBufferDesc, ' ');
+          if (pBufferDesc->ReturnValue < 0) {
+            break;
+          }
+        }
+      }
+    }
+  }
+}
+
+/*********************************************************************
+*
+*       _PrintInt
+*/
+static void _PrintInt(SEGGER_RTT_PRINTF_DESC * pBufferDesc, int v, unsigned Base, unsigned NumDigits, unsigned FieldWidth, unsigned FormatFlags) {
+  unsigned Width;
+  int Number;
+
+  Number = (v < 0) ? -v : v;
+
+  //
+  // Get actual field width
+  //
+  Width = 1u;
+  while (Number >= (int)Base) {
+    Number = (Number / (int)Base);
+    Width++;
+  }
+  if (NumDigits > Width) {
+    Width = NumDigits;
+  }
+  if ((FieldWidth > 0u) && ((v < 0) || ((FormatFlags & FORMAT_FLAG_PRINT_SIGN) == FORMAT_FLAG_PRINT_SIGN))) {
+    FieldWidth--;
+  }
+
+  //
+  // Print leading spaces if necessary
+  //
+  if ((((FormatFlags & FORMAT_FLAG_PAD_ZERO) == 0u) || (NumDigits != 0u)) && ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u)) {
+    if (FieldWidth != 0u) {
+      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
+        FieldWidth--;
+        _StoreChar(pBufferDesc, ' ');
+        if (pBufferDesc->ReturnValue < 0) {
+          break;
+        }
+      }
+    }
+  }
+  //
+  // Print sign if necessary
+  //
+  if (pBufferDesc->ReturnValue >= 0) {
+    if (v < 0) {
+      v = -v;
+      _StoreChar(pBufferDesc, '-');
+    } else if ((FormatFlags & FORMAT_FLAG_PRINT_SIGN) == FORMAT_FLAG_PRINT_SIGN) {
+      _StoreChar(pBufferDesc, '+');
+    } else {
+
+    }
+    if (pBufferDesc->ReturnValue >= 0) {
+      //
+      // Print leading zeros if necessary
+      //
+      if (((FormatFlags & FORMAT_FLAG_PAD_ZERO) == FORMAT_FLAG_PAD_ZERO) && ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u) && (NumDigits == 0u)) {
+        if (FieldWidth != 0u) {
+          while ((FieldWidth != 0u) && (Width < FieldWidth)) {
+            FieldWidth--;
+            _StoreChar(pBufferDesc, '0');
+            if (pBufferDesc->ReturnValue < 0) {
+              break;
+            }
+          }
+        }
+      }
+      if (pBufferDesc->ReturnValue >= 0) {
+        //
+        // Print number without sign
+        //
+        _PrintUnsigned(pBufferDesc, (unsigned)v, Base, NumDigits, FieldWidth, FormatFlags);
+      }
+    }
+  }
+}
+
+/*********************************************************************
+*
+*       Public code
+*
+**********************************************************************
+*/
+/*********************************************************************
+*
+*       SEGGER_RTT_vprintf
+*
+*  Function description
+*    Stores a formatted string in SEGGER RTT control block.
+*    This data is read by the host.
+*
+*  Parameters
+*    BufferIndex  Index of "Up"-buffer to be used. (e.g. 0 for "Terminal")
+*    sFormat      Pointer to format string
+*    pParamList   Pointer to the list of arguments for the format string
+*
+*  Return values
+*    >= 0:  Number of bytes which have been stored in the "Up"-buffer.
+*     < 0:  Error
+*/
+int SEGGER_RTT_vprintf(unsigned BufferIndex, const char * sFormat, va_list * pParamList) {
+  char c;
+  SEGGER_RTT_PRINTF_DESC BufferDesc;
+  int v;
+  unsigned NumDigits;
+  unsigned FormatFlags;
+  unsigned FieldWidth;
+  char acBuffer[SEGGER_RTT_PRINTF_BUFFER_SIZE];
+
+  BufferDesc.pBuffer        = acBuffer;
+  BufferDesc.BufferSize     = SEGGER_RTT_PRINTF_BUFFER_SIZE;
+  BufferDesc.Cnt            = 0u;
+  BufferDesc.RTTBufferIndex = BufferIndex;
+  BufferDesc.ReturnValue    = 0;
+
+  do {
+    c = *sFormat;
+    sFormat++;
+    if (c == 0u) {
+      break;
+    }
+    if (c == '%') {
+      //
+      // Filter out flags
+      //
+      FormatFlags = 0u;
+      v = 1;
+      do {
+        c = *sFormat;
+        switch (c) {
+        case '-': FormatFlags |= FORMAT_FLAG_LEFT_JUSTIFY; sFormat++; break;
+        case '0': FormatFlags |= FORMAT_FLAG_PAD_ZERO;     sFormat++; break;
+        case '+': FormatFlags |= FORMAT_FLAG_PRINT_SIGN;   sFormat++; break;
+        case '#': FormatFlags |= FORMAT_FLAG_ALTERNATE;    sFormat++; break;
+        default:  v = 0; break;
+        }
+      } while (v);
+      //
+      // filter out field with
+      //
+      FieldWidth = 0u;
+      do {
+        c = *sFormat;
+        if ((c < '0') || (c > '9')) {
+          break;
+        }
+        sFormat++;
+        FieldWidth = (FieldWidth * 10u) + ((unsigned)c - '0');
+      } while (1);
+
+      //
+      // Filter out precision (number of digits to display)
+      //
+      NumDigits = 0u;
+      c = *sFormat;
+      if (c == '.') {
+        sFormat++;
+        do {
+          c = *sFormat;
+          if ((c < '0') || (c > '9')) {
+            break;
+          }
+          sFormat++;
+          NumDigits = NumDigits * 10u + ((unsigned)c - '0');
+        } while (1);
+      }
+      //
+      // Filter out length modifier
+      //
+      c = *sFormat;
+      do {
+        if ((c == 'l') || (c == 'h')) {
+          sFormat++;
+          c = *sFormat;
+        } else {
+          break;
+        }
+      } while (1);
+      //
+      // Handle specifiers
+      //
+      switch (c) {
+      case 'c': {
+        char c0;
+        v = va_arg(*pParamList, int);
+        c0 = (char)v;
+        _StoreChar(&BufferDesc, c0);
+        break;
+      }
+      case 'd':
+        v = va_arg(*pParamList, int);
+        _PrintInt(&BufferDesc, v, 10u, NumDigits, FieldWidth, FormatFlags);
+        break;
+      case 'u':
+        v = va_arg(*pParamList, int);
+        _PrintUnsigned(&BufferDesc, (unsigned)v, 10u, NumDigits, FieldWidth, FormatFlags);
+        break;
+      case 'x':
+      case 'X':
+        v = va_arg(*pParamList, int);
+        _PrintUnsigned(&BufferDesc, (unsigned)v, 16u, NumDigits, FieldWidth, FormatFlags);
+        break;
+      case 's':
+        {
+          const char * s = va_arg(*pParamList, const char *);
+          do {
+            c = *s;
+            s++;
+            if (c == '\0') {
+              break;
+            }
+           _StoreChar(&BufferDesc, c);
+          } while (BufferDesc.ReturnValue >= 0);
+        }
+        break;
+      case 'p':
+        v = va_arg(*pParamList, int);
+        _PrintUnsigned(&BufferDesc, (unsigned)v, 16u, 8u, 8u, 0u);
+        break;
+      case '%':
+        _StoreChar(&BufferDesc, '%');
+        break;
+      default:
+        break;
+      }
+      sFormat++;
+    } else {
+      _StoreChar(&BufferDesc, c);
+    }
+  } while (BufferDesc.ReturnValue >= 0);
+
+  if (BufferDesc.ReturnValue > 0) {
+    //
+    // Write remaining data, if any
+    //
+    if (BufferDesc.Cnt != 0u) {
+      SEGGER_RTT_Write(BufferIndex, acBuffer, BufferDesc.Cnt);
+    }
+    BufferDesc.ReturnValue += (int)BufferDesc.Cnt;
+  }
+  return BufferDesc.ReturnValue;
+}
+
+/*********************************************************************
+*
+*       SEGGER_RTT_printf
+*
+*  Function description
+*    Stores a formatted string in SEGGER RTT control block.
+*    This data is read by the host.
+*
+*  Parameters
+*    BufferIndex  Index of "Up"-buffer to be used. (e.g. 0 for "Terminal")
+*    sFormat      Pointer to format string, followed by the arguments for conversion
+*
+*  Return values
+*    >= 0:  Number of bytes which have been stored in the "Up"-buffer.
+*     < 0:  Error
+*
+*  Notes
+*    (1) Conversion specifications have following syntax:
+*          %[flags][FieldWidth][.Precision]ConversionSpecifier
+*    (2) Supported flags:
+*          -: Left justify within the field width
+*          +: Always print sign extension for signed conversions
+*          0: Pad with 0 instead of spaces. Ignored when using '-'-flag or precision
+*        Supported conversion specifiers:
+*          c: Print the argument as one char
+*          d: Print the argument as a signed integer
+*          u: Print the argument as an unsigned integer
+*          x: Print the argument as an hexadecimal integer
+*          s: Print the string pointed to by the argument
+*          p: Print the argument as an 8-digit hexadecimal integer. (Argument shall be a pointer to void.)
+*/
+int SEGGER_RTT_printf(unsigned BufferIndex, const char * sFormat, ...) {
+  int r;
+  va_list ParamList;
+
+  va_start(ParamList, sFormat);
+  r = SEGGER_RTT_vprintf(BufferIndex, sFormat, &ParamList);
+  va_end(ParamList);
+  return r;
+}
+/*************************** End of file ****************************/
diff --git a/sched/systemview/SEGGER_SYSVIEW.c b/sched/systemview/SEGGER_SYSVIEW.c
new file mode 100644
index 0000000000..e2f3657a30
--- /dev/null
+++ b/sched/systemview/SEGGER_SYSVIEW.c
@@ -0,0 +1,2945 @@
+/*********************************************************************
+*                    SEGGER Microcontroller GmbH                     *
+*                        The Embedded Experts                        *
+**********************************************************************
+*                                                                    *
+*            (c) 1995 - 2019 SEGGER Microcontroller GmbH             *
+*                                                                    *
+*       www.segger.com     Support: support@segger.com               *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SEGGER SystemView * Real-time application analysis           *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+* All rights reserved.                                               *
+*                                                                    *
+* SEGGER strongly recommends to not make any changes                 *
+* to or modify the source code of this software in order to stay     *
+* compatible with the SystemView and RTT protocol, and J-Link.       *
+*                                                                    *
+* Redistribution and use in source and binary forms, with or         *
+* without modification, are permitted provided that the following    *
+* condition is met:                                                  *
+*                                                                    *
+* o Redistributions of source code must retain the above copyright   *
+*   notice, this condition and the following disclaimer.             *
+*                                                                    *
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
+* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
+* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
+* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
+* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
+* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
+* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
+* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
+* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
+* DAMAGE.                                                            *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SystemView version: V3.12                                    *
+*                                                                    *
+**********************************************************************
+-------------------------- END-OF-HEADER -----------------------------
+
+File    : SEGGER_SYSVIEW.c
+Purpose : System visualization API implementation.
+Revision: $Rev: 17331 $
+
+Additional information:
+  Packet format:
+    Packets with IDs 0..23 are standard packets with known structure.
+    For efficiency, they do *NOT* contain a length field.
+    <ID><Data><TimeStampDelta>
+
+    Packets with IDs 24..31 are standard packets with extendible
+    structure and contain a length field.
+    <ID><Lenght><Data><TimeStampDelta>
+    
+    Packet ID 31 is used for SystemView extended events.
+    <ID><Lenght><ID_EX><Data><TimeStampDelta>
+
+    Packets with IDs >= 32 always contain a length field.
+    <ID><Length><Data><TimeStampDelta>
+
+  Packet IDs:
+       0..  31 : Standard packets, known by SystemView.
+      32..1023 : OS-definable packets, described in a SystemView description file.
+    1024..2047 : User-definable packets, described in a SystemView description file.
+    2048..32767: Undefined.
+
+  Data encoding:
+    Basic types (int, short, char, ...):
+      Basic types are encoded little endian with most-significant bit variant
+      encoding.
+      Each encoded byte contains 7 data bits [6:0] and the MSB continuation bit.
+      The continuation bit indicates whether the next byte belongs to the data
+      (bit set) or this is the last byte (bit clear).
+      The most significant bits of data are encoded first, proceeding to the
+      least significant bits in the final byte (little endian).
+
+      Example encoding:
+        Data: 0x1F4 (500)
+        Encoded: 0xF4 (First 7 data bits 74 | Continuation bit)
+                 0x03 (Second 7 data bits 03, no continuation)
+
+        Data: 0xFFFFFFFF
+        Encoded: 0xFF 0xFF 0xFF 0xFF 0x0F
+
+        Data: 0xA2 (162),   0x03 (3), 0x7000
+        Encoded: 0xA2 0x01  0x03      0x80 0xE0 0x01
+
+    Byte arrays and strings:
+      Byte arrays and strings are encoded as <NumBytes> followed by the raw data.
+      NumBytes is encoded as a basic type with a theoretical maximum of 4G.
+
+      Example encoding:
+        Data: "Hello World\0" (0x48 0x65 0x6C 0x6C 0x6F 0x20 0x57 0x6F 0x72 0x6C 0x64 0x00)
+        Encoded: 0x0B 0x48 0x65 0x6C 0x6C 0x6F 0x20 0x57 0x6F 0x72 0x6C 0x64
+
+  Examples packets:
+  01 F4 03 80 80 10 // Overflow packet. Data is a single U32.
+                       This packet means: 500 packets lost, Timestamp is 0x40000
+
+  02 0F 50          // ISR(15) Enter. Timestamp 80 (0x50)
+
+  03 20             // ISR Exit. Timestamp 32 (0x20) (Shortest possible packet.)
+
+  Sample code for user defined Packets:
+    #define MY_ID   0x400                // Any value between 0x400 and 0x7FF
+    void SendMyPacket(unsigned Para0, unsigned Para1, const char* s) {
+      U8  aPacket[SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32 + MAX_STR_LEN + 1];
+      U8* pPayload;
+      //
+      pPayload = SEGGER_SYSVIEW_PPREPARE_PACKET(aPacket);               // Prepare the packet for SystemView
+      pPayload = SEGGER_SYSVIEW_EncodeU32(pPayload, Para0);             // Add the first parameter to the packet
+      pPayload = SEGGER_SYSVIEW_EncodeU32(pPayload, Para1);             // Add the second parameter to the packet
+      pPayload = SEGGER_SYSVIEW_EncodeString(pPayload, s, MAX_STR_LEN); // Add the string to the packet
+      //
+      SEGGER_SYSVIEW_SendPacket(&aPacket[0], pPayload, MY_ID);          // Send the packet with EventId = MY_ID
+    }
+
+    #define MY_ID_1 0x401
+    void SendOnePara(unsigned Para0) {
+      SEGGER_SYSVIEW_RecordU32(MY_ID_1, Para0);
+    }
+
+*/
+
+/*********************************************************************
+*
+*       #include section
+*
+**********************************************************************
+*/
+
+#include "SEGGER_SYSVIEW_Int.h"
+#include "SEGGER_RTT.h"
+#include <string.h>
+#include <stdlib.h>
+#include <stdarg.h>
+
+/*********************************************************************
+*
+*       Defines, fixed
+*
+**********************************************************************
+*/
+#if SEGGER_SYSVIEW_ID_SHIFT
+  #define SHRINK_ID(Id)   (((Id) - _SYSVIEW_Globals.RAMBaseAddress) >> SEGGER_SYSVIEW_ID_SHIFT)
+#else
+  #define SHRINK_ID(Id)   ((Id) - _SYSVIEW_Globals.RAMBaseAddress)
+#endif
+
+#if SEGGER_SYSVIEW_RTT_CHANNEL > 0
+  #define CHANNEL_ID_UP   SEGGER_SYSVIEW_RTT_CHANNEL
+  #define CHANNEL_ID_DOWN SEGGER_SYSVIEW_RTT_CHANNEL
+#else
+  #define CHANNEL_ID_UP   _SYSVIEW_Globals.UpChannel
+  #define CHANNEL_ID_DOWN _SYSVIEW_Globals.DownChannel
+#endif
+
+/*********************************************************************
+*
+*       Defines, configurable
+*
+**********************************************************************
+*/
+// Timestamps may be less than full 32-bits, in which case we need to zero
+// the unused bits to properly handle overflows.
+// Note that this is a quite common scenario, as a 32-bit time such as
+// SysTick might be scaled down to reduce bandwith
+// or a 16-bit hardware time might be used.
+#if SEGGER_SYSVIEW_TIMESTAMP_BITS < 32  // Eliminate unused bits in case hardware timestamps are less than 32 bits
+  #define MAKE_DELTA_32BIT(Delta) Delta <<= 32 - SEGGER_SYSVIEW_TIMESTAMP_BITS; \
+                                  Delta >>= 32 - SEGGER_SYSVIEW_TIMESTAMP_BITS;
+#else
+  #define MAKE_DELTA_32BIT(Delta)
+#endif
+
+
+/*********************************************************************
+*
+*       Defines, fixed
+*
+**********************************************************************
+*/
+#define ENABLE_STATE_OFF        0
+#define ENABLE_STATE_ON         1
+#define ENABLE_STATE_DROPPING   2
+
+#define FORMAT_FLAG_LEFT_JUSTIFY   (1u << 0)
+#define FORMAT_FLAG_PAD_ZERO       (1u << 1)
+#define FORMAT_FLAG_PRINT_SIGN     (1u << 2)
+#define FORMAT_FLAG_ALTERNATE      (1u << 3)
+
+#define MODULE_EVENT_OFFSET        (512)
+
+/*********************************************************************
+*
+*       Types, local
+*
+**********************************************************************
+*/
+typedef struct {
+  U8*       pBuffer;
+  U8*       pPayload;
+  U8*       pPayloadStart;
+  U32       Options;
+  unsigned  Cnt;
+} SEGGER_SYSVIEW_PRINTF_DESC;
+
+typedef struct {
+        U8                      EnableState;   // 0: Disabled, 1: Enabled, (2: Dropping)
+        U8                      UpChannel;
+        U8                      RecursionCnt;
+        U32                     SysFreq;
+        U32                     CPUFreq;
+        U32                     LastTxTimeStamp;
+        U32                     RAMBaseAddress;
+#if (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
+        U32                     PacketCount;
+#else
+        U32                     DropCount;
+        U8                      DownChannel;
+#endif
+        U32                     DisabledEvents;
+  const SEGGER_SYSVIEW_OS_API*  pOSAPI;
+        SEGGER_SYSVIEW_SEND_SYS_DESC_FUNC*   pfSendSysDesc;
+} SEGGER_SYSVIEW_GLOBALS;
+
+/*********************************************************************
+*
+*       Function prototypes, required
+*
+**********************************************************************
+*/
+static void _SendPacket(U8* pStartPacket, U8* pEndPacket, unsigned int EventId);
+
+/*********************************************************************
+*
+*       Static data
+*
+**********************************************************************
+*/
+static const U8 _abSync[10] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+
+#ifdef SEGGER_SYSVIEW_SECTION
+  #if (defined __GNUC__)
+    __attribute__ ((section (SEGGER_SYSVIEW_SECTION))) static char _UpBuffer  [SEGGER_SYSVIEW_RTT_BUFFER_SIZE];
+    #if (SEGGER_SYSVIEW_POST_MORTEM_MODE != 1)
+    __attribute__ ((section (SEGGER_SYSVIEW_SECTION))) static char _DownBuffer[8];  // Small, fixed-size buffer, for back-channel comms
+    #endif
+  #elif (defined __ICCARM__) || (defined __ICCRX__)
+    #pragma location=SEGGER_SYSVIEW_SECTION
+    static char _UpBuffer  [SEGGER_SYSVIEW_RTT_BUFFER_SIZE];
+    #pragma location=SEGGER_SYSVIEW_SECTION
+    static char _DownBuffer[8];  // Small, fixed-size buffer, for back-channel comms
+  #elif (defined __CC_ARM)
+    __attribute__ ((section (SEGGER_SYSVIEW_SECTION), zero_init)) static char _UpBuffer  [SEGGER_SYSVIEW_RTT_BUFFER_SIZE];
+    #if (SEGGER_SYSVIEW_POST_MORTEM_MODE != 1)
+    __attribute__ ((section (SEGGER_SYSVIEW_SECTION), zero_init)) static char _DownBuffer[8];  // Small, fixed-size buffer, for back-channel comms
+    #endif
+  #else
+    static char _UpBuffer  [SEGGER_SYSVIEW_RTT_BUFFER_SIZE];
+    #if (SEGGER_SYSVIEW_POST_MORTEM_MODE != 1)
+    static char _DownBuffer[8];  // Small, fixed-size buffer, for back-channel comms
+    #endif
+  #endif
+#else
+    static char _UpBuffer  [SEGGER_SYSVIEW_RTT_BUFFER_SIZE];
+    #if (SEGGER_SYSVIEW_POST_MORTEM_MODE != 1)
+    static char _DownBuffer[8];  // Small, fixed-size buffer, for back-channel comms
+    #endif
+#endif
+
+static SEGGER_SYSVIEW_GLOBALS _SYSVIEW_Globals;
+
+static SEGGER_SYSVIEW_MODULE* _pFirstModule;
+static U8                     _NumModules;
+
+/*********************************************************************
+*
+*       Static code
+*
+**********************************************************************
+*/
+
+#define ENCODE_U32(pDest, Value) {                                                  \
+                                   U8* pSysviewPointer;                             \
+                                   U32 SysViewData;                                 \
+                                   pSysviewPointer = pDest;                         \
+                                   SysViewData = Value;                             \
+                                   while(SysViewData > 0x7F) {                      \
+                                     *pSysviewPointer++ = (U8)(SysViewData | 0x80); \
+                                     SysViewData >>= 7;                             \
+                                   };                                               \
+                                   *pSysviewPointer++ = (U8)SysViewData;            \
+                                   pDest = pSysviewPointer;                         \
+                                 };
+
+
+
+#if (SEGGER_SYSVIEW_USE_STATIC_BUFFER == 1)
+static U8 _aPacket[SEGGER_SYSVIEW_MAX_PACKET_SIZE];
+
+#define RECORD_START(PacketSize)  SEGGER_SYSVIEW_LOCK();                            \
+                                  pPayloadStart = _PreparePacket(_aPacket);
+
+#define RECORD_END()              SEGGER_SYSVIEW_UNLOCK()
+
+#else
+
+#define RECORD_START(PacketSize)  U8 aPacket[(PacketSize)];                         \
+                                  pPayloadStart = _PreparePacket(aPacket);          \
+
+#define RECORD_END()
+
+#endif
+
+/*********************************************************************
+*
+*       _EncodeData()
+*
+*  Function description
+*    Encode a byte buffer in variable-length format.
+*
+*  Parameters
+*    pPayload - Pointer to where string will be encoded.
+*    pSrc     - Pointer to data buffer to be encoded.
+*    NumBytes - Number of bytes in the buffer to be encoded.
+*
+*  Return value
+*    Pointer to the byte following the value, i.e. the first free
+*    byte in the payload and the next position to store payload
+*    content.
+*
+*  Additional information
+*    The data is encoded as a count byte followed by the contents
+*    of the data buffer.
+*    Make sure NumBytes + 1 bytes are free for the payload.
+*/
+static U8* _EncodeData(U8* pPayload, const char* pSrc, unsigned int NumBytes) {
+  unsigned int n;
+  //
+  n = 0;
+  *pPayload++ = NumBytes;
+  while (n < NumBytes) {
+    *pPayload++ = *pSrc++;
+    n++;
+  }
+  return pPayload;
+}
+
+/*********************************************************************
+*
+*       _EncodeStr()
+*
+*  Function description
+*    Encode a string in variable-length format.
+*
+*  Parameters
+*    pPayload - Pointer to where string will be encoded.
+*    pText    - String to encode.
+*    Limit    - Maximum number of characters to encode from string.
+*
+*  Return value
+*    Pointer to the byte following the value, i.e. the first free
+*    byte in the payload and the next position to store payload
+*    content.
+*
+*  Additional information
+*    The string is encoded as a count byte followed by the contents
+*    of the string.
+*    No more than 1 + Limit bytes will be encoded to the payload.
+*/
+static U8 *_EncodeStr(U8 *pPayload, const char *pText, unsigned int Limit) {
+  unsigned int n;
+  unsigned int Len;
+  //
+  // Compute string len
+  //
+  Len = 0;
+  while(*(pText + Len) != 0) {
+    Len++;
+  }
+  if (Len > Limit) {
+    Len = Limit;
+  }
+  //
+  // Write Len
+  //
+  if (Len < 255)  {
+    *pPayload++ = Len; 
+  } else {
+    *pPayload++ = 255;
+    *pPayload++ = (Len & 255);
+    *pPayload++ = ((Len >> 8) & 255);
+  }
+  //
+  // copy string
+  //
+  n = 0;
+  while (n < Len) {
+    *pPayload++ = *pText++;
+    n++;
+  }
+  return pPayload;
+}
+
+/*********************************************************************
+*
+*       _PreparePacket()
+*
+*  Function description
+*    Prepare a SystemView event packet header.
+*
+*  Parameters
+*    pPacket - Pointer to start of packet to initialize.
+*
+*  Return value
+*    Pointer to first byte of packet payload.
+*
+*  Additional information
+*    The payload length and evnetId are not initialized.
+*    PreparePacket only reserves space for them and they are
+*    computed and filled in by the sending function.
+*/
+static U8* _PreparePacket(U8* pPacket) {
+  return pPacket + 4;
+}
+
+/*********************************************************************
+*
+*       _HandleIncomingPacket()
+*
+*  Function description
+*    Read an incoming command from the down channel and process it.
+*
+*  Additional information
+*    This function is called each time after sending a packet.
+*    Processing incoming packets is done asynchronous. SystemView might
+*    already have sent event packets after the host has sent a command.
+*/
+#if (SEGGER_SYSVIEW_POST_MORTEM_MODE != 1)
+static void _HandleIncomingPacket(void) {
+  U8  Cmd;
+  int Status;
+  //
+  Status = SEGGER_RTT_ReadNoLock(CHANNEL_ID_DOWN, &Cmd, 1);
+  if (Status > 0) {
+    switch (Cmd) {
+    case SEGGER_SYSVIEW_COMMAND_ID_START:
+      SEGGER_SYSVIEW_Start();
+      break;
+    case SEGGER_SYSVIEW_COMMAND_ID_STOP:
+      SEGGER_SYSVIEW_Stop();
+      break;
+    case SEGGER_SYSVIEW_COMMAND_ID_GET_SYSTIME:
+      SEGGER_SYSVIEW_RecordSystime();
+      break;
+    case SEGGER_SYSVIEW_COMMAND_ID_GET_TASKLIST:
+      SEGGER_SYSVIEW_SendTaskList();
+      break;
+    case SEGGER_SYSVIEW_COMMAND_ID_GET_SYSDESC:
+      SEGGER_SYSVIEW_GetSysDesc();
+      break;
+    case SEGGER_SYSVIEW_COMMAND_ID_GET_NUMMODULES:
+      SEGGER_SYSVIEW_SendNumModules();
+      break;
+    case SEGGER_SYSVIEW_COMMAND_ID_GET_MODULEDESC:
+      SEGGER_SYSVIEW_SendModuleDescription();
+      break;
+    case SEGGER_SYSVIEW_COMMAND_ID_GET_MODULE:
+      Status = SEGGER_RTT_ReadNoLock(CHANNEL_ID_DOWN, &Cmd, 1);
+      if (Status > 0) {
+        SEGGER_SYSVIEW_SendModule(Cmd);
+      }
+      break;
+    default:
+      if (Cmd >= 128) { // Unknown extended command. Dummy read its parameter.
+        SEGGER_RTT_ReadNoLock(CHANNEL_ID_DOWN, &Cmd, 1);
+      }
+      break;
+    }
+  }
+}
+#endif // (SEGGER_SYSVIEW_POST_MORTEM_MODE != 1)
+
+/*********************************************************************
+*
+*       _TrySendOverflowPacket()
+*
+*  Function description
+*    Try to transmit an SystemView Overflow packet containing the
+*    number of dropped packets.
+*
+*  Additional information
+*    Format as follows:
+*      01 <DropCnt><TimeStamp>  Max. packet len is 1 + 5 + 5 = 11
+*
+*    Example packets sent
+*      01 20 40
+*
+*  Return value
+*    !=0:  Success, Message sent (stored in RTT-Buffer)
+*    ==0:  Buffer full, Message *NOT* stored
+*
+*/
+#if (SEGGER_SYSVIEW_POST_MORTEM_MODE != 1)
+static int _TrySendOverflowPacket(void) {
+  U32 TimeStamp;
+  I32 Delta;
+  int Status;
+  U8  aPacket[11];
+  U8* pPayload;
+
+  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
+  pPayload   = &aPacket[1];
+  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
+  //
+  // Compute time stamp delta and append it to packet.
+  //
+  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
+  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
+  MAKE_DELTA_32BIT(Delta);
+  ENCODE_U32(pPayload, Delta);
+  //
+  // Try to store packet in RTT buffer and update time stamp when this was successful
+  //
+  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
+  SEGGER_SYSVIEW_ON_EVENT_RECORDED(pPayload - aPacket);
+  if (Status) {
+    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
+    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
+  } else {
+    _SYSVIEW_Globals.DropCount++;
+  }
+  //
+  return Status;
+}
+#endif  // (SEGGER_SYSVIEW_POST_MORTEM_MODE != 1)
+
+/*********************************************************************
+*
+*       _SendSyncInfo()
+*
+*  Function description
+*    Send SystemView sync packet and system information in 
+*    post mortem mode.
+*
+*  Additional information
+*    Sync is 10 * 0x00 without timestamp
+*/
+#if (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
+static void _SendSyncInfo(void) {
+  //
+  // Add sync packet ( 10 * 0x00)
+  // Send system description
+  // Send system time
+  // Send task list
+  // Send module description
+  // Send module information
+  //
+  SEGGER_RTT_WriteWithOverwriteNoLock(CHANNEL_ID_UP, _abSync, 10);
+  SEGGER_SYSVIEW_ON_EVENT_RECORDED(10);
+  SEGGER_SYSVIEW_RecordVoid(SYSVIEW_EVTID_TRACE_START);
+  {
+    U8* pPayload;
+    U8* pPayloadStart;
+    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 4 * SEGGER_SYSVIEW_QUANTA_U32);
+    //
+    pPayload = pPayloadStart;
+    ENCODE_U32(pPayload, _SYSVIEW_Globals.SysFreq);
+    ENCODE_U32(pPayload, _SYSVIEW_Globals.CPUFreq);
+    ENCODE_U32(pPayload, _SYSVIEW_Globals.RAMBaseAddress);
+    ENCODE_U32(pPayload, SEGGER_SYSVIEW_ID_SHIFT);
+    _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_INIT);
+    RECORD_END();
+  }
+  if (_SYSVIEW_Globals.pfSendSysDesc) {
+    _SYSVIEW_Globals.pfSendSysDesc();
+  }
+  SEGGER_SYSVIEW_RecordSystime();
+  SEGGER_SYSVIEW_SendTaskList();
+  if (_NumModules > 0) {
+    int n;
+    SEGGER_SYSVIEW_SendNumModules();
+    for (n = 0; n < _NumModules; n++) {
+      SEGGER_SYSVIEW_SendModule(n);
+    }
+    SEGGER_SYSVIEW_SendModuleDescription();
+  }
+}
+#endif  // (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
+
+/*********************************************************************
+*
+*       _SendPacket()
+*
+*  Function description
+*    Send a SystemView packet over RTT. RTT channel and mode are
+*    configured by macros when the SystemView component is initialized.
+*    This function takes care of maintaining the packet drop count
+*    and sending overflow packets when necessary.
+*    The packet must be passed without Id and Length because this
+*    function prepends it to the packet before transmission.
+*
+*  Parameters
+*    pStartPacket - Pointer to start of packet payload.
+*                   There must be at least 4 bytes free to prepend Id and Length.
+*    pEndPacket   - Pointer to end of packet payload.
+*    EventId      - Id of the event to send.
+*
+*/
+static void _SendPacket(U8* pStartPacket, U8* pEndPacket, unsigned int EventId) {
+  unsigned int  NumBytes;
+  U32           TimeStamp;
+  U32           Delta;
+#if (SEGGER_SYSVIEW_POST_MORTEM_MODE != 1)
+  int           Status;
+#endif
+
+#if (SEGGER_SYSVIEW_USE_STATIC_BUFFER == 0)
+  SEGGER_SYSVIEW_LOCK();
+#endif
+
+#if (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
+  if (_SYSVIEW_Globals.EnableState == 0) {
+    goto SendDone;
+  }
+#else
+  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
+    goto Send;
+  }
+  if (_SYSVIEW_Globals.EnableState == 0) {
+    goto SendDone;
+  }
+  //
+  // Handle buffer full situations:
+  // Have packets been dropped before because buffer was full?
+  // In this case try to send and overflow packet.
+  //
+  if (_SYSVIEW_Globals.EnableState == 2) {
+    _TrySendOverflowPacket();
+    if (_SYSVIEW_Globals.EnableState != 1) {
+      goto SendDone;
+    }
+  }
+Send:
+#endif
+  //
+  // Check if event is disabled from being recorded.
+  //
+  if (EventId < 32) {
+    if (_SYSVIEW_Globals.DisabledEvents & ((U32)1u << EventId)) {
+      goto SendDone;
+    }
+  }
+  //
+  // Prepare actual packet.
+  // If it is a known packet, prepend eventId only,
+  // otherwise prepend packet length and eventId.
+  //
+  if (EventId < 24) {
+    *--pStartPacket = EventId;
+  } else {
+    NumBytes = pEndPacket - pStartPacket;
+    if (NumBytes > 127) {
+      *--pStartPacket = (NumBytes >> 7);
+      *--pStartPacket = NumBytes | 0x80;
+    } else {
+      *--pStartPacket = NumBytes;
+    }
+    if (EventId > 127) {
+      *--pStartPacket = (EventId >> 7);
+      *--pStartPacket = EventId | 0x80;
+    } else {
+      *--pStartPacket = EventId;
+    }
+  }
+  //
+  // Compute time stamp delta and append it to packet.
+  //
+  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
+  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
+  MAKE_DELTA_32BIT(Delta);
+  ENCODE_U32(pEndPacket, Delta);
+#if (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
+  //
+  // Store packet in RTT buffer by overwriting old data and update time stamp
+  //
+  SEGGER_RTT_WriteWithOverwriteNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
+  SEGGER_SYSVIEW_ON_EVENT_RECORDED(pEndPacket - pStartPacket);
+  _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
+#else
+  //
+  // Try to store packet in RTT buffer and update time stamp when this was successful
+  //
+  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
+  SEGGER_SYSVIEW_ON_EVENT_RECORDED(pEndPacket - pStartPacket);
+  if (Status) {
+    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
+  } else {
+    _SYSVIEW_Globals.EnableState++; // EnableState has been 1, will be 2. Always.
+  }
+#endif
+
+#if (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
+  //
+  // Add sync and system information periodically if we are in post mortem mode
+  //
+  if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
+    _SYSVIEW_Globals.RecursionCnt = 1;
+    if (_SYSVIEW_Globals.PacketCount++ & (1 << SEGGER_SYSVIEW_SYNC_PERIOD_SHIFT)) {
+      _SendSyncInfo();
+      _SYSVIEW_Globals.PacketCount = 0;
+    }
+    _SYSVIEW_Globals.RecursionCnt = 0;
+  }
+SendDone:
+  ; // Avoid "label at end of compound statement" error when using static buffer
+#else
+SendDone:
+  //
+  // Check if host is sending data which needs to be processed.
+  // Note that since this code is called for every packet, it is very time critical, so we do
+  // only what is really needed here, which is checking if there is any data
+  //
+  if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
+    if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
+      _SYSVIEW_Globals.RecursionCnt = 1;
+      _HandleIncomingPacket();
+      _SYSVIEW_Globals.RecursionCnt = 0;
+    }
+  }
+#endif
+  //
+#if (SEGGER_SYSVIEW_USE_STATIC_BUFFER == 0)
+  SEGGER_SYSVIEW_UNLOCK();  // We are done. Unlock and return
+#endif
+}
+
+#ifndef SEGGER_SYSVIEW_EXCLUDE_PRINTF // Define in project to avoid warnings about variable parameter list
+/*********************************************************************
+*
+*       _VPrintHost()
+*
+*  Function description
+*    Send a format string and its parameters to the host.
+*
+*  Parameters
+*    s            Pointer to format string.
+*    Options      Options to be sent to the host.
+*    pParamList   Pointer to the list of arguments for the format string.
+*/
+static int _VPrintHost(const char* s, U32 Options, va_list* pParamList) {
+  U32         aParas[SEGGER_SYSVIEW_MAX_ARGUMENTS];
+  U32*        pParas;
+  U32         NumArguments;
+  const char* p;
+  char        c;
+  U8*         pPayload;
+  U8*         pPayloadStart;
+#if SEGGER_SYSVIEW_PRINTF_IMPLICIT_FORMAT
+  U8 HasNonScalar;
+  
+  HasNonScalar = 0;
+#endif  
+  //
+  // Count number of arguments by counting '%' characters in string.
+  // If enabled, check for non-scalar modifier flags to format string on the target.
+  //
+  p = s;
+  NumArguments = 0;
+  for (;;) {
+    c = *p++;
+    if (c == 0) {
+      break;
+    }
+    if (c == '%') {
+      c = *p;
+#if SEGGER_SYSVIEW_PRINTF_IMPLICIT_FORMAT == 0
+      aParas[NumArguments++] = va_arg(*pParamList, int);
+      if (NumArguments == SEGGER_SYSVIEW_MAX_ARGUMENTS) {
+        break;
+      }
+#else
+      if (c == 's') {
+        HasNonScalar = 1;
+        break;
+      } else {
+        aParas[NumArguments++] = va_arg(*pParamList, int);
+        if (NumArguments == SEGGER_SYSVIEW_MAX_ARGUMENTS) {
+          break;
+        }
+      }
+#endif
+    }
+  }
+
+#if SEGGER_SYSVIEW_PRINTF_IMPLICIT_FORMAT
+  if (HasNonScalar) {
+    return -1;
+  }
+#endif
+  //
+  // Send string and parameters to host
+  //
+  {
+    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_MAX_STRING_LEN + 2 * SEGGER_SYSVIEW_QUANTA_U32 + SEGGER_SYSVIEW_MAX_ARGUMENTS * SEGGER_SYSVIEW_QUANTA_U32);
+    pPayload = _EncodeStr(pPayloadStart, s, SEGGER_SYSVIEW_MAX_STRING_LEN);
+    ENCODE_U32(pPayload, Options);
+    ENCODE_U32(pPayload, NumArguments);
+    pParas = aParas;
+    while (NumArguments--) {
+      ENCODE_U32(pPayload, (*pParas));
+      pParas++;
+    }
+    _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
+    RECORD_END();
+  }
+  return 0;
+}
+
+/*********************************************************************
+*
+*       _StoreChar()
+*
+*  Function description
+*    Stores a character in the printf-buffer and sends the buffer when
+*     it is filled.
+*
+*  Parameters
+*    p            Pointer to the buffer description.
+*    c            Character to be printed.
+*/
+static void _StoreChar(SEGGER_SYSVIEW_PRINTF_DESC * p, char c) {
+  unsigned int  Cnt;
+  U8*           pPayload;
+  U32           Options;
+
+  Cnt = p->Cnt;
+  if ((Cnt + 1u) <= SEGGER_SYSVIEW_MAX_STRING_LEN) {
+    *(p->pPayload++) = c;
+    p->Cnt = Cnt + 1u;
+  }
+  //
+  // Write part of string, when the buffer is full
+  //
+  if (p->Cnt == SEGGER_SYSVIEW_MAX_STRING_LEN) {
+    *(p->pPayloadStart) = p->Cnt;
+    pPayload = p->pPayload;
+    Options = p->Options;
+    ENCODE_U32(pPayload, Options);
+    ENCODE_U32(pPayload, 0);
+    _SendPacket(p->pPayloadStart, pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
+    p->pPayloadStart = _PreparePacket(p->pBuffer);
+    p->pPayload = p->pPayloadStart + 1u;
+    p->Cnt = 0u;
+  }
+}
+
+/*********************************************************************
+*
+*       _PrintUnsigned()
+*
+*  Function description
+*    Print an unsigned integer with the given formatting into the 
+*     formatted string.
+*
+*  Parameters
+*    pBufferDesc  Pointer to the buffer description.
+*    v            Value to be printed.
+*    Base         Base of the value.
+*    NumDigits    Number of digits to be printed.
+*    FieldWidth   Width of the printed field.
+*    FormatFlags  Flags for formatting the value.
+*/
+static void _PrintUnsigned(SEGGER_SYSVIEW_PRINTF_DESC * pBufferDesc, unsigned int v, unsigned int Base, unsigned int NumDigits, unsigned int FieldWidth, unsigned int FormatFlags) {
+  static const char _aV2C[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
+  unsigned int      Div;
+  unsigned int      Digit;
+  unsigned int      Number;
+  unsigned int      Width;
+  char              c;
+
+  Number = v;
+  Digit = 1u;
+  //
+  // Get actual field width
+  //
+  Width = 1u;
+  while (Number >= Base) {
+    Number = (Number / Base);
+    Width++;
+  }
+  if (NumDigits > Width) {
+    Width = NumDigits;
+  }
+  //
+  // Print leading chars if necessary
+  //
+  if ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u) {
+    if (FieldWidth != 0u) {
+      if (((FormatFlags & FORMAT_FLAG_PAD_ZERO) == FORMAT_FLAG_PAD_ZERO) && (NumDigits == 0u)) {
+        c = '0';
+      } else {
+        c = ' ';
+      }
+      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
+        FieldWidth--;
+        _StoreChar(pBufferDesc, c);
+      }
+    }
+  }
+  //
+  // Compute Digit.
+  // Loop until Digit has the value of the highest digit required.
+  // Example: If the output is 345 (Base 10), loop 2 times until Digit is 100.
+  //
+  while (1) {
+    if (NumDigits > 1u) {       // User specified a min number of digits to print? => Make sure we loop at least that often, before checking anything else (> 1 check avoids problems with NumDigits being signed / unsigned)
+      NumDigits--;
+    } else {
+      Div = v / Digit;
+      if (Div < Base) {        // Is our divider big enough to extract the highest digit from value? => Done
+        break;
+      }
+    }
+    Digit *= Base;
+  }
+  //
+  // Output digits
+  //
+  do {
+    Div = v / Digit;
+    v -= Div * Digit;
+    _StoreChar(pBufferDesc, _aV2C[Div]);
+    Digit /= Base;
+  } while (Digit);
+  //
+  // Print trailing spaces if necessary
+  //
+  if ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == FORMAT_FLAG_LEFT_JUSTIFY) {
+    if (FieldWidth != 0u) {
+      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
+        FieldWidth--;
+        _StoreChar(pBufferDesc, ' ');
+      }
+    }
+  }
+}
+
+/*********************************************************************
+*
+*       _PrintInt()
+*
+*  Function description
+*    Print a signed integer with the given formatting into the 
+*     formatted string.
+*
+*  Parameters
+*    pBufferDesc  Pointer to the buffer description.
+*    v            Value to be printed.
+*    Base         Base of the value.
+*    NumDigits    Number of digits to be printed.
+*    FieldWidth   Width of the printed field.
+*    FormatFlags  Flags for formatting the value.
+*/
+static void _PrintInt(SEGGER_SYSVIEW_PRINTF_DESC * pBufferDesc, int v, unsigned int Base, unsigned int NumDigits, unsigned int FieldWidth, unsigned int FormatFlags) {
+  unsigned int  Width;
+  int           Number;
+
+  Number = (v < 0) ? -v : v;
+
+  //
+  // Get actual field width
+  //
+  Width = 1u;
+  while (Number >= (int)Base) {
+    Number = (Number / (int)Base);
+    Width++;
+  }
+  if (NumDigits > Width) {
+    Width = NumDigits;
+  }
+  if ((FieldWidth > 0u) && ((v < 0) || ((FormatFlags & FORMAT_FLAG_PRINT_SIGN) == FORMAT_FLAG_PRINT_SIGN))) {
+    FieldWidth--;
+  }
+
+  //
+  // Print leading spaces if necessary
+  //
+  if ((((FormatFlags & FORMAT_FLAG_PAD_ZERO) == 0u) || (NumDigits != 0u)) && ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u)) {
+    if (FieldWidth != 0u) {
+      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
+        FieldWidth--;
+        _StoreChar(pBufferDesc, ' ');
+      }
+    }
+  }
+  //
+  // Print sign if necessary
+  //
+  if (v < 0) {
+    v = -v;
+    _StoreChar(pBufferDesc, '-');
+  } else if ((FormatFlags & FORMAT_FLAG_PRINT_SIGN) == FORMAT_FLAG_PRINT_SIGN) {
+    _StoreChar(pBufferDesc, '+');
+  } else {
+
+  }
+  //
+  // Print leading zeros if necessary
+  //
+  if (((FormatFlags & FORMAT_FLAG_PAD_ZERO) == FORMAT_FLAG_PAD_ZERO) && ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u) && (NumDigits == 0u)) {
+    if (FieldWidth != 0u) {
+      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
+        FieldWidth--;
+        _StoreChar(pBufferDesc, '0');
+      }
+    }
+  }
+  //
+  // Print number without sign
+  //
+  _PrintUnsigned(pBufferDesc, (unsigned int)v, Base, NumDigits, FieldWidth, FormatFlags);
+}
+
+/*********************************************************************
+*
+*       _VPrintTarget()
+*
+*  Function description
+*    Stores a formatted string.
+*    This data is read by the host.
+*
+*  Parameters
+*    sFormat      Pointer to format string.
+*    Options      Options to be sent to the host.
+*    pParamList   Pointer to the list of arguments for the format string.
+*/
+static void _VPrintTarget(const char* sFormat, U32 Options, va_list* pParamList) {
+  SEGGER_SYSVIEW_PRINTF_DESC BufferDesc;
+  char          c;
+  int           v;
+  unsigned int  NumDigits;
+  unsigned int  FormatFlags;
+  unsigned int  FieldWidth;
+  U8*           pPayloadStart;
+#if SEGGER_SYSVIEW_USE_STATIC_BUFFER == 0
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_MAX_STRING_LEN + 1 + 2 * SEGGER_SYSVIEW_QUANTA_U32);
+  SEGGER_SYSVIEW_LOCK();
+#else
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_MAX_STRING_LEN + 1 + 2 * SEGGER_SYSVIEW_QUANTA_U32);
+#endif
+
+#if SEGGER_SYSVIEW_USE_STATIC_BUFFER == 0
+  BufferDesc.pBuffer        = aPacket;
+#else
+  BufferDesc.pBuffer        = _aPacket;
+#endif
+  BufferDesc.Cnt            = 0u;
+  BufferDesc.pPayloadStart  = pPayloadStart;
+  BufferDesc.pPayload       = BufferDesc.pPayloadStart + 1u;
+  BufferDesc.Options        =  Options;
+
+  do {
+    c = *sFormat;
+    sFormat++;
+    if (c == 0u) {
+      break;
+    }
+    if (c == '%') {
+      //
+      // Filter out flags
+      //
+      FormatFlags = 0u;
+      v = 1;
+      do {
+        c = *sFormat;
+        switch (c) {
+        case '-': FormatFlags |= FORMAT_FLAG_LEFT_JUSTIFY; sFormat++; break;
+        case '0': FormatFlags |= FORMAT_FLAG_PAD_ZERO;     sFormat++; break;
+        case '+': FormatFlags |= FORMAT_FLAG_PRINT_SIGN;   sFormat++; break;
+        case '#': FormatFlags |= FORMAT_FLAG_ALTERNATE;    sFormat++; break;
+        default:  v = 0; break;
+        }
+      } while (v);
+      //
+      // filter out field with
+      //
+      FieldWidth = 0u;
+      do {
+        c = *sFormat;
+        if ((c < '0') || (c > '9')) {
+          break;
+        }
+        sFormat++;
+        FieldWidth = (FieldWidth * 10u) + ((unsigned int)c - '0');
+      } while (1);
+
+      //
+      // Filter out precision (number of digits to display)
+      //
+      NumDigits = 0u;
+      c = *sFormat;
+      if (c == '.') {
+        sFormat++;
+        do {
+          c = *sFormat;
+          if ((c < '0') || (c > '9')) {
+            break;
+          }
+          sFormat++;
+          NumDigits = NumDigits * 10u + ((unsigned int)c - '0');
+        } while (1);
+      }
+      //
+      // Filter out length modifier
+      //
+      c = *sFormat;
+      do {
+        if ((c == 'l') || (c == 'h')) {
+          c = *sFormat;
+          sFormat++;
+        } else {
+          break;
+        }
+      } while (1);
+      //
+      // Handle specifiers
+      //
+      switch (c) {
+      case 'c': {
+        char c0;
+        v = va_arg(*pParamList, int);
+        c0 = (char)v;
+        _StoreChar(&BufferDesc, c0);
+        break;
+      }
+      case 'd':
+        v = va_arg(*pParamList, int);
+        _PrintInt(&BufferDesc, v, 10u, NumDigits, FieldWidth, FormatFlags);
+        break;
+      case 'u':
+        v = va_arg(*pParamList, int);
+        _PrintUnsigned(&BufferDesc, (unsigned int)v, 10u, NumDigits, FieldWidth, FormatFlags);
+        break;
+      case 'x':
+      case 'X':
+        v = va_arg(*pParamList, int);
+        _PrintUnsigned(&BufferDesc, (unsigned int)v, 16u, NumDigits, FieldWidth, FormatFlags);
+        break;
+      case 'p':
+        v = va_arg(*pParamList, int);
+        _PrintUnsigned(&BufferDesc, (unsigned int)v, 16u, 8u, 8u, 0u);
+        break;
+      case '%':
+        _StoreChar(&BufferDesc, '%');
+        break;
+      default:
+        break;
+      }
+      sFormat++;
+    } else {
+      _StoreChar(&BufferDesc, c);
+    }
+  } while (*sFormat);
+
+  //
+  // Write remaining data, if any
+  //
+  if (BufferDesc.Cnt != 0u) {
+    *(BufferDesc.pPayloadStart) = BufferDesc.Cnt;
+    ENCODE_U32(BufferDesc.pPayload, BufferDesc.Options);
+    ENCODE_U32(BufferDesc.pPayload, 0);
+    _SendPacket(BufferDesc.pPayloadStart, BufferDesc.pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
+  }
+#if SEGGER_SYSVIEW_USE_STATIC_BUFFER == 0
+  SEGGER_SYSVIEW_UNLOCK();
+  RECORD_END();
+#else
+  RECORD_END();
+#endif
+}
+#endif // SEGGER_SYSVIEW_EXCLUDE_PRINTF
+
+/*********************************************************************
+*
+*       Public code
+*
+**********************************************************************
+*/
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_Init()
+*
+*  Function description
+*    Initializes the SYSVIEW module.
+*    Must be called before the Systemview Application connects to 
+*    the system.
+*
+*  Parameters
+*    SysFreq        - Frequency of timestamp, usually CPU core clock frequency.
+*    CPUFreq        - CPU core clock frequency.
+*    pOSAPI         - Pointer to the API structure for OS-specific functions.
+*    pfSendSysDesc  - Pointer to record system description callback function.
+*
+*  Additional information
+*    This function initializes the RTT channel used to transport 
+*    SEGGER SystemView packets. 
+*    The channel is assigned the label "SysView" for client software 
+*    to identify the SystemView channel.
+*
+*    The channel is configured with the macro SEGGER_SYSVIEW_RTT_CHANNEL.
+*/
+void SEGGER_SYSVIEW_Init(U32 SysFreq, U32 CPUFreq, const SEGGER_SYSVIEW_OS_API *pOSAPI, SEGGER_SYSVIEW_SEND_SYS_DESC_FUNC pfSendSysDesc) {
+#ifdef SEGGER_RTT_SECTION
+  //
+  // Explicitly initialize the RTT Control Block if it is in its dedicated section.
+  //
+  SEGGER_RTT_Init();
+#endif
+#if (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
+#if SEGGER_SYSVIEW_RTT_CHANNEL > 0
+  SEGGER_RTT_ConfigUpBuffer(SEGGER_SYSVIEW_RTT_CHANNEL, "SysView", &_UpBuffer[0],   sizeof(_UpBuffer),   SEGGER_RTT_MODE_NO_BLOCK_SKIP);
+#else
+  _SYSVIEW_Globals.UpChannel = SEGGER_RTT_AllocUpBuffer  ("SysView", &_UpBuffer[0],   sizeof(_UpBuffer),   SEGGER_RTT_MODE_NO_BLOCK_SKIP);
+#endif
+  _SYSVIEW_Globals.RAMBaseAddress   = SEGGER_SYSVIEW_ID_BASE;
+  _SYSVIEW_Globals.LastTxTimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
+  _SYSVIEW_Globals.pOSAPI           = pOSAPI;
+  _SYSVIEW_Globals.SysFreq          = SysFreq;
+  _SYSVIEW_Globals.CPUFreq          = CPUFreq;
+  _SYSVIEW_Globals.pfSendSysDesc    = pfSendSysDesc;
+  _SYSVIEW_Globals.EnableState      = 0;
+  _SYSVIEW_Globals.PacketCount      = 0;
+#else // (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
+#if SEGGER_SYSVIEW_RTT_CHANNEL > 0
+  SEGGER_RTT_ConfigUpBuffer   (SEGGER_SYSVIEW_RTT_CHANNEL, "SysView", &_UpBuffer[0],   sizeof(_UpBuffer),   SEGGER_RTT_MODE_NO_BLOCK_SKIP);
+  SEGGER_RTT_ConfigDownBuffer (SEGGER_SYSVIEW_RTT_CHANNEL, "SysView", &_DownBuffer[0], sizeof(_DownBuffer), SEGGER_RTT_MODE_NO_BLOCK_SKIP);
+#else
+  _SYSVIEW_Globals.UpChannel = SEGGER_RTT_AllocUpBuffer  ("SysView", &_UpBuffer[0],   sizeof(_UpBuffer),   SEGGER_RTT_MODE_NO_BLOCK_SKIP);
+  _SYSVIEW_Globals.DownChannel = _SYSVIEW_Globals.UpChannel;
+  SEGGER_RTT_ConfigDownBuffer (_SYSVIEW_Globals.DownChannel, "SysView", &_DownBuffer[0], sizeof(_DownBuffer), SEGGER_RTT_MODE_NO_BLOCK_SKIP);
+#endif
+  _SYSVIEW_Globals.RAMBaseAddress   = SEGGER_SYSVIEW_ID_BASE;
+  _SYSVIEW_Globals.LastTxTimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
+  _SYSVIEW_Globals.pOSAPI           = pOSAPI;
+  _SYSVIEW_Globals.SysFreq          = SysFreq;
+  _SYSVIEW_Globals.CPUFreq          = CPUFreq;
+  _SYSVIEW_Globals.pfSendSysDesc    = pfSendSysDesc;
+  _SYSVIEW_Globals.EnableState      = 0;
+#endif  // (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_SetRAMBase()
+*
+*  Function description
+*    Sets the RAM base address, which is subtracted from IDs in order
+*     to save bandwidth.
+*
+*  Parameters
+*    RAMBaseAddress - Lowest RAM Address. (i.e. 0x20000000 on most Cortex-M)
+*/
+void SEGGER_SYSVIEW_SetRAMBase(U32 RAMBaseAddress) {
+  _SYSVIEW_Globals.RAMBaseAddress = RAMBaseAddress;
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordVoid()
+*
+*  Function description
+*    Formats and sends a SystemView packet with an empty payload.
+*
+*  Parameters
+*    EventID - SystemView event ID.
+*/
+void SEGGER_SYSVIEW_RecordVoid(unsigned int EventID) {
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
+  //
+  _SendPacket(pPayloadStart, pPayloadStart, EventID);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordU32()
+*
+*  Function description
+*    Formats and sends a SystemView packet containing a single U32
+*    parameter payload.
+*
+*  Parameters
+*    EventID - SystemView event ID.
+*    Value   - The 32-bit parameter encoded to SystemView packet payload.
+*/
+void SEGGER_SYSVIEW_RecordU32(unsigned int EventID, U32 Value) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, Value);
+  _SendPacket(pPayloadStart, pPayload, EventID);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordU32x2()
+*
+*  Function description
+*    Formats and sends a SystemView packet containing 2 U32 parameter payload.
+*
+*  Parameters
+*    EventID - SystemView event ID.
+*    Para0   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para1   - The 32-bit parameter encoded to SystemView packet payload.
+*/
+void SEGGER_SYSVIEW_RecordU32x2(unsigned int EventID, U32 Para0, U32 Para1) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, Para0);
+  ENCODE_U32(pPayload, Para1);
+  _SendPacket(pPayloadStart, pPayload, EventID);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordU32x3()
+*
+*  Function description
+*    Formats and sends a SystemView packet containing 3 U32 parameter payload.
+*
+*  Parameters
+*    EventID - SystemView event ID.
+*    Para0   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para1   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para2   - The 32-bit parameter encoded to SystemView packet payload.
+*/
+void SEGGER_SYSVIEW_RecordU32x3(unsigned int EventID, U32 Para0, U32 Para1, U32 Para2) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 3 * SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, Para0);
+  ENCODE_U32(pPayload, Para1);
+  ENCODE_U32(pPayload, Para2);
+  _SendPacket(pPayloadStart, pPayload, EventID);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordU32x4()
+*
+*  Function description
+*    Formats and sends a SystemView packet containing 4 U32 parameter payload.
+*
+*  Parameters
+*    EventID - SystemView event ID.
+*    Para0   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para1   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para2   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para3   - The 32-bit parameter encoded to SystemView packet payload.
+*/
+void SEGGER_SYSVIEW_RecordU32x4(unsigned int EventID, U32 Para0, U32 Para1, U32 Para2, U32 Para3) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 4 * SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, Para0);
+  ENCODE_U32(pPayload, Para1);
+  ENCODE_U32(pPayload, Para2);
+  ENCODE_U32(pPayload, Para3);
+  _SendPacket(pPayloadStart, pPayload, EventID);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordU32x5()
+*
+*  Function description
+*    Formats and sends a SystemView packet containing 5 U32 parameter payload.
+*
+*  Parameters
+*    EventID - SystemView event ID.
+*    Para0   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para1   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para2   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para3   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para4   - The 32-bit parameter encoded to SystemView packet payload.
+*/
+void SEGGER_SYSVIEW_RecordU32x5(unsigned int EventID, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 5 * SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, Para0);
+  ENCODE_U32(pPayload, Para1);
+  ENCODE_U32(pPayload, Para2);
+  ENCODE_U32(pPayload, Para3);
+  ENCODE_U32(pPayload, Para4);
+  _SendPacket(pPayloadStart, pPayload, EventID);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordU32x6()
+*
+*  Function description
+*    Formats and sends a SystemView packet containing 6 U32 parameter payload.
+*
+*  Parameters
+*    EventID - SystemView event ID.
+*    Para0   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para1   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para2   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para3   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para4   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para5   - The 32-bit parameter encoded to SystemView packet payload.
+*/
+void SEGGER_SYSVIEW_RecordU32x6(unsigned int EventID, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4, U32 Para5) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 6 * SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, Para0);
+  ENCODE_U32(pPayload, Para1);
+  ENCODE_U32(pPayload, Para2);
+  ENCODE_U32(pPayload, Para3);
+  ENCODE_U32(pPayload, Para4);
+  ENCODE_U32(pPayload, Para5);
+  _SendPacket(pPayloadStart, pPayload, EventID);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordU32x7()
+*
+*  Function description
+*    Formats and sends a SystemView packet containing 7 U32 parameter payload.
+*
+*  Parameters
+*    EventID - SystemView event ID.
+*    Para0   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para1   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para2   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para3   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para4   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para5   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para6   - The 32-bit parameter encoded to SystemView packet payload.
+*/
+void SEGGER_SYSVIEW_RecordU32x7(unsigned int EventID, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4, U32 Para5, U32 Para6) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 7 * SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, Para0);
+  ENCODE_U32(pPayload, Para1);
+  ENCODE_U32(pPayload, Para2);
+  ENCODE_U32(pPayload, Para3);
+  ENCODE_U32(pPayload, Para4);
+  ENCODE_U32(pPayload, Para5);
+  ENCODE_U32(pPayload, Para6);
+  _SendPacket(pPayloadStart, pPayload, EventID);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordU32x8()
+*
+*  Function description
+*    Formats and sends a SystemView packet containing 8 U32 parameter payload.
+*
+*  Parameters
+*    EventID - SystemView event ID.
+*    Para0   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para1   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para2   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para3   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para4   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para5   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para6   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para7   - The 32-bit parameter encoded to SystemView packet payload.
+*/
+void SEGGER_SYSVIEW_RecordU32x8(unsigned int EventID, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4, U32 Para5, U32 Para6, U32 Para7) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 8 * SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, Para0);
+  ENCODE_U32(pPayload, Para1);
+  ENCODE_U32(pPayload, Para2);
+  ENCODE_U32(pPayload, Para3);
+  ENCODE_U32(pPayload, Para4);
+  ENCODE_U32(pPayload, Para5);
+  ENCODE_U32(pPayload, Para6);
+  ENCODE_U32(pPayload, Para7);
+  _SendPacket(pPayloadStart, pPayload, EventID);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordU32x9()
+*
+*  Function description
+*    Formats and sends a SystemView packet containing 9 U32 parameter payload.
+*
+*  Parameters
+*    EventID - SystemView event ID.
+*    Para0   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para1   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para2   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para3   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para4   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para5   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para6   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para7   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para8   - The 32-bit parameter encoded to SystemView packet payload.
+*/
+void SEGGER_SYSVIEW_RecordU32x9(unsigned int EventID, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4, U32 Para5, U32 Para6, U32 Para7, U32 Para8) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 9 * SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, Para0);
+  ENCODE_U32(pPayload, Para1);
+  ENCODE_U32(pPayload, Para2);
+  ENCODE_U32(pPayload, Para3);
+  ENCODE_U32(pPayload, Para4);
+  ENCODE_U32(pPayload, Para5);
+  ENCODE_U32(pPayload, Para6);
+  ENCODE_U32(pPayload, Para7);
+  ENCODE_U32(pPayload, Para8);
+  _SendPacket(pPayloadStart, pPayload, EventID);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordU32x10()
+*
+*  Function description
+*    Formats and sends a SystemView packet containing 10 U32 parameter payload.
+*
+*  Parameters
+*    EventID - SystemView event ID.
+*    Para0   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para1   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para2   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para3   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para4   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para5   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para6   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para7   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para8   - The 32-bit parameter encoded to SystemView packet payload.
+*    Para9   - The 32-bit parameter encoded to SystemView packet payload.
+*/
+void SEGGER_SYSVIEW_RecordU32x10(unsigned int EventID, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4, U32 Para5, U32 Para6, U32 Para7, U32 Para8, U32 Para9) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 10 * SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, Para0);
+  ENCODE_U32(pPayload, Para1);
+  ENCODE_U32(pPayload, Para2);
+  ENCODE_U32(pPayload, Para3);
+  ENCODE_U32(pPayload, Para4);
+  ENCODE_U32(pPayload, Para5);
+  ENCODE_U32(pPayload, Para6);
+  ENCODE_U32(pPayload, Para7);
+  ENCODE_U32(pPayload, Para8);
+  ENCODE_U32(pPayload, Para9);
+  _SendPacket(pPayloadStart, pPayload, EventID);
+  RECORD_END();
+}
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordString()
+*
+*  Function description
+*    Formats and sends a SystemView packet containing a string.
+*
+*  Parameters
+*    EventID - SystemView event ID.
+*    pString - The string to be sent in the SystemView packet payload.
+*
+*  Additional information
+*    The string is encoded as a count byte followed by the contents
+*    of the string.
+*    No more than SEGGER_SYSVIEW_MAX_STRING_LEN bytes will be encoded to the payload.
+*/
+void SEGGER_SYSVIEW_RecordString(unsigned int EventID, const char* pString) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 1 + SEGGER_SYSVIEW_MAX_STRING_LEN);
+  //
+  pPayload = _EncodeStr(pPayloadStart, pString, SEGGER_SYSVIEW_MAX_STRING_LEN);
+  _SendPacket(pPayloadStart, pPayload, EventID);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_Start()
+*
+*  Function description
+*    Start recording SystemView events.
+*
+*    This function is triggered by the SystemView Application on connect.
+*    For single-shot or post-mortem mode recording, it needs to be called
+*    by the application.
+*
+*  Additional information
+*    This function enables transmission of SystemView packets recorded
+*    by subsequent trace calls and records a SystemView Start event.
+*
+*    As part of start, a SystemView Init packet is sent, containing the system
+*    frequency. The list of current tasks, the current system time and the
+*    system description string is sent, too.
+*
+*  Notes
+*    SEGGER_SYSVIEW_Start and SEGGER_SYSVIEW_Stop do not nest.
+*    When SEGGER_SYSVIEW_CAN_RESTART is 1, each received start command
+*    records the system information. This is required to enable restart
+*    of recordings when SystemView unexpectedly disconnects without sending
+*    a stop command before.
+*/
+void SEGGER_SYSVIEW_Start(void) {
+#if (SEGGER_SYSVIEW_CAN_RESTART == 0)
+  if (_SYSVIEW_Globals.EnableState == 0) {
+#endif
+    _SYSVIEW_Globals.EnableState = 1;
+#if (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
+    _SendSyncInfo();
+#else
+    SEGGER_SYSVIEW_LOCK();
+    SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, _abSync, 10);
+    SEGGER_SYSVIEW_UNLOCK();
+    SEGGER_SYSVIEW_ON_EVENT_RECORDED(10);
+    SEGGER_SYSVIEW_RecordVoid(SYSVIEW_EVTID_TRACE_START);
+    {
+      U8* pPayload;
+      U8* pPayloadStart;
+      RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 4 * SEGGER_SYSVIEW_QUANTA_U32);
+      //
+      pPayload = pPayloadStart;
+      ENCODE_U32(pPayload, _SYSVIEW_Globals.SysFreq);
+      ENCODE_U32(pPayload, _SYSVIEW_Globals.CPUFreq);
+      ENCODE_U32(pPayload, _SYSVIEW_Globals.RAMBaseAddress);
+      ENCODE_U32(pPayload, SEGGER_SYSVIEW_ID_SHIFT);
+      _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_INIT);
+      RECORD_END();
+    }
+    if (_SYSVIEW_Globals.pfSendSysDesc) {
+      _SYSVIEW_Globals.pfSendSysDesc();
+    }
+    SEGGER_SYSVIEW_RecordSystime();
+    SEGGER_SYSVIEW_SendTaskList();
+    SEGGER_SYSVIEW_SendNumModules();
+#endif
+#if (SEGGER_SYSVIEW_CAN_RESTART == 0)
+  }
+#endif
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_Stop()
+*
+*  Function description
+*    Stop recording SystemView events.
+*
+*    This function is triggered by the SystemView Application on disconnect.
+*    For single-shot or post-mortem mode recording, it can be called
+*    by the application.
+*
+*  Additional information
+*    This function disables transmission of SystemView packets recorded
+*    by subsequent trace calls.  If transmission is enabled when
+*    this function is called, a single SystemView Stop event is recorded
+*    to the trace, send, and then trace transmission is halted.
+*/
+void SEGGER_SYSVIEW_Stop(void) {
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
+  //
+  if (_SYSVIEW_Globals.EnableState) {
+    _SendPacket(pPayloadStart, pPayloadStart, SYSVIEW_EVTID_TRACE_STOP);
+    _SYSVIEW_Globals.EnableState = 0;
+  }
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_GetChannelID()
+*
+*  Function description
+*    Returns the RTT <Up> / <Down> channel ID used by SystemView.
+*/
+int SEGGER_SYSVIEW_GetChannelID(void) {
+  return CHANNEL_ID_UP;
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_GetSysDesc()
+*
+*  Function description
+*    Triggers a send of the system information and description.
+*
+*/
+void SEGGER_SYSVIEW_GetSysDesc(void) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 4 * SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, _SYSVIEW_Globals.SysFreq);
+  ENCODE_U32(pPayload, _SYSVIEW_Globals.CPUFreq);
+  ENCODE_U32(pPayload, _SYSVIEW_Globals.RAMBaseAddress);
+  ENCODE_U32(pPayload, SEGGER_SYSVIEW_ID_SHIFT);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_INIT);
+  RECORD_END();
+  if (_SYSVIEW_Globals.pfSendSysDesc) {
+    _SYSVIEW_Globals.pfSendSysDesc();
+  }
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_SendTaskInfo()
+*
+*  Function description
+*    Send a Task Info Packet, containing TaskId for identification,
+*    task priority and task name.
+*
+*  Parameters
+*    pInfo - Pointer to task information to send.
+*/
+void SEGGER_SYSVIEW_SendTaskInfo(const SEGGER_SYSVIEW_TASKINFO *pInfo) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32 + 1 + 32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, SHRINK_ID(pInfo->TaskID));
+  ENCODE_U32(pPayload, pInfo->Prio);
+  pPayload = _EncodeStr(pPayload, pInfo->sName, 32);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_INFO);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, SHRINK_ID(pInfo->TaskID));
+  ENCODE_U32(pPayload, pInfo->StackBase);
+  ENCODE_U32(pPayload, pInfo->StackSize);
+  ENCODE_U32(pPayload, 0); // Stack End, future use
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_STACK_INFO);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_SendTaskList()
+*
+*  Function description
+*    Send all tasks descriptors to the host.
+*/
+void SEGGER_SYSVIEW_SendTaskList(void) {
+  if (_SYSVIEW_Globals.pOSAPI && _SYSVIEW_Globals.pOSAPI->pfSendTaskList) {
+    _SYSVIEW_Globals.pOSAPI->pfSendTaskList();
+  }
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_SendSysDesc()
+*
+*  Function description
+*    Send the system description string to the host.
+*    The system description is used by the Systemview Application
+*    to identify the current application and handle events accordingly.
+*
+*    The system description is usually called by the system description
+*    callback, to ensure it is only sent when the SystemView Application
+*    is connected.  
+*
+*  Parameters
+*    sSysDesc - Pointer to the 0-terminated system description string.
+*
+*  Additional information
+*    One system description string may not exceed SEGGER_SYSVIEW_MAX_STRING_LEN characters.
+*    Multiple description strings can be recorded.
+*
+*    The Following items can be described in a system description string.
+*    Each item is identified by its identifier, followed by '=' and the value.
+*    Items are separated by ','.
+*/
+void SEGGER_SYSVIEW_SendSysDesc(const char *sSysDesc) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 1 + SEGGER_SYSVIEW_MAX_STRING_LEN);
+  //
+  pPayload = _EncodeStr(pPayloadStart, sSysDesc, SEGGER_SYSVIEW_MAX_STRING_LEN);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_SYSDESC);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordSystime()
+*
+*  Function description
+*    Formats and sends a SystemView Systime containing a single U64 or U32
+*    parameter payload.
+*/
+void SEGGER_SYSVIEW_RecordSystime(void) {
+  U64 Systime;
+
+  if (_SYSVIEW_Globals.pOSAPI && _SYSVIEW_Globals.pOSAPI->pfGetTime) {
+    Systime = _SYSVIEW_Globals.pOSAPI->pfGetTime();
+    SEGGER_SYSVIEW_RecordU32x2(SYSVIEW_EVTID_SYSTIME_US,
+                               (U32)(Systime),
+                               (U32)(Systime >> 32));
+  } else {
+    SEGGER_SYSVIEW_RecordU32(SYSVIEW_EVTID_SYSTIME_CYCLES, SEGGER_SYSVIEW_GET_TIMESTAMP());
+  }
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordEnterISR()
+*
+*  Function description
+*    Format and send an ISR entry event.
+*
+*  Additional information
+*    Example packets sent
+*      02 0F 50              // ISR(15) Enter. Timestamp is 80 (0x50)
+*/
+void SEGGER_SYSVIEW_RecordEnterISR(void) {
+  unsigned v;
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  v = SEGGER_SYSVIEW_GET_INTERRUPT_ID();
+  ENCODE_U32(pPayload, v);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_ISR_ENTER);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordExitISR()
+*
+*  Function description
+*    Format and send an ISR exit event.
+*
+*  Additional information
+*    Format as follows:
+*      03 <TimeStamp>        // Max. packet len is 6
+*
+*    Example packets sent
+*      03 20                // ISR Exit. Timestamp is 32 (0x20)
+*/
+void SEGGER_SYSVIEW_RecordExitISR(void) {
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
+  //
+  _SendPacket(pPayloadStart, pPayloadStart, SYSVIEW_EVTID_ISR_EXIT);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordExitISRToScheduler()
+*
+*  Function description
+*    Format and send an ISR exit into scheduler event.
+*
+*  Additional information
+*    Format as follows:
+*      18 <TimeStamp>        // Max. packet len is 6
+*
+*    Example packets sent
+*      18 20                // ISR Exit to Scheduler. Timestamp is 32 (0x20)
+*/
+void SEGGER_SYSVIEW_RecordExitISRToScheduler(void) {
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
+  //
+  _SendPacket(pPayloadStart, pPayloadStart, SYSVIEW_EVTID_ISR_TO_SCHEDULER);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordEnterTimer()
+*
+*  Function description
+*    Format and send a Timer entry event.
+*  
+*  Parameters
+*    TimerId - Id of the timer which starts.
+*/
+void SEGGER_SYSVIEW_RecordEnterTimer(U32 TimerId) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, SHRINK_ID(TimerId));
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TIMER_ENTER);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordExitTimer()
+*
+*  Function description
+*    Format and send a Timer exit event.
+*/
+void SEGGER_SYSVIEW_RecordExitTimer(void) {
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
+  //
+  _SendPacket(pPayloadStart, pPayloadStart, SYSVIEW_EVTID_TIMER_EXIT);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordEndCall()
+*
+*  Function description
+*    Format and send an End API Call event without return value.
+*  
+*  Parameters
+*    EventID - Id of API function which ends.
+*/
+void SEGGER_SYSVIEW_RecordEndCall(unsigned int EventID) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, EventID);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_END_CALL);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordEndCallU32()
+*
+*  Function description
+*    Format and send an End API Call event with return value.
+*  
+*  Parameters
+*    EventID      - Id of API function which ends.
+*    Para0        - Return value which will be returned by the API function.
+*/
+void SEGGER_SYSVIEW_RecordEndCallU32(unsigned int EventID, U32 Para0) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, EventID);
+  ENCODE_U32(pPayload, Para0);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_END_CALL);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_OnIdle()
+*
+*  Function description
+*    Record an Idle event.
+*/
+void SEGGER_SYSVIEW_OnIdle(void) {
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
+  //
+  _SendPacket(pPayloadStart, pPayloadStart, SYSVIEW_EVTID_IDLE);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_OnTaskCreate()
+*
+*  Function description
+*    Record a Task Create event.  The Task Create event corresponds
+*    to creating a task in the OS.
+*
+*  Parameters
+*    TaskId        - Task ID of created task.
+*/
+void SEGGER_SYSVIEW_OnTaskCreate(U32 TaskId) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  TaskId = SHRINK_ID(TaskId);
+  ENCODE_U32(pPayload, TaskId);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_CREATE);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_OnTaskTerminate()
+*
+*  Function description
+*    Record a Task termination event.  
+*    The Task termination event corresponds to terminating a task in 
+*    the OS. If the TaskId is the currently active task, 
+*    SEGGER_SYSVIEW_OnTaskStopExec may be used, either.
+*
+*  Parameters
+*    TaskId        - Task ID of terminated task.
+*/
+void SEGGER_SYSVIEW_OnTaskTerminate(U32 TaskId) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  TaskId = SHRINK_ID(TaskId);
+  ENCODE_U32(pPayload, TaskId);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_TERMINATE);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_OnTaskStartExec()
+*
+*  Function description
+*    Record a Task Start Execution event.  The Task Start event
+*    corresponds to when a task has started to execute rather than
+*    when it is ready to execute.
+*
+*  Parameters
+*    TaskId - Task ID of task that started to execute.
+*/
+void SEGGER_SYSVIEW_OnTaskStartExec(U32 TaskId) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  TaskId = SHRINK_ID(TaskId);
+  ENCODE_U32(pPayload, TaskId);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_START_EXEC);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_OnTaskStopExec()
+*
+*  Function description
+*    Record a Task Stop Execution event.  The Task Stop event
+*    corresponds to when a task stops executing and terminates.
+*/
+void SEGGER_SYSVIEW_OnTaskStopExec(void) {
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
+  //
+  _SendPacket(pPayloadStart, pPayloadStart, SYSVIEW_EVTID_TASK_STOP_EXEC);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_OnTaskStartReady()
+*
+*  Function description
+*    Record a Task Start Ready event.
+*
+*  Parameters
+*    TaskId - Task ID of task that started to execute.
+*/
+void SEGGER_SYSVIEW_OnTaskStartReady(U32 TaskId) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  TaskId = SHRINK_ID(TaskId);
+  ENCODE_U32(pPayload, TaskId);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_START_READY);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_OnTaskStopReady()
+*
+*  Function description
+*    Record a Task Stop Ready event.
+*
+*  Parameters
+*    TaskId - Task ID of task that completed execution.
+*    Cause  - Reason for task to stop (i.e. Idle/Sleep)
+*/
+void SEGGER_SYSVIEW_OnTaskStopReady(U32 TaskId, unsigned int Cause) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  TaskId = SHRINK_ID(TaskId);
+  ENCODE_U32(pPayload, TaskId);
+  ENCODE_U32(pPayload, Cause);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_STOP_READY);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_MarkStart()
+*
+*  Function description
+*    Record a Performance Marker Start event to start measuring runtime.
+*
+*  Parameters
+*    MarkerId  - User defined ID for the marker.
+*/
+void SEGGER_SYSVIEW_MarkStart(unsigned MarkerId) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, MarkerId);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_MARK_START);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_MarkStop()
+*
+*  Function description
+*    Record a Performance Marker Stop event to stop measuring runtime.
+*
+*  Parameters
+*    MarkerId  - User defined ID for the marker.
+*/
+void SEGGER_SYSVIEW_MarkStop(unsigned MarkerId) {
+  U8 * pPayload;
+  U8 * pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, MarkerId);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_MARK_STOP);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_Mark()
+*
+*  Function description
+*    Record a Performance Marker intermediate event.
+*
+*  Parameters
+*    MarkerId  - User defined ID for the marker.
+*/
+void SEGGER_SYSVIEW_Mark(unsigned int MarkerId) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, SYSVIEW_EVTID_EX_MARK);
+  ENCODE_U32(pPayload, MarkerId);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_EX);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_NameMarker()
+*
+*  Function description
+*    Send the name of a Performance Marker to be displayed in SystemView.
+*
+*    Marker names are usually set in the system description
+*    callback, to ensure it is only sent when the SystemView Application
+*    is connected.  
+*
+*  Parameters
+*    MarkerId   - User defined ID for the marker.
+*    sName      - Pointer to the marker name. (Max. SEGGER_SYSVIEW_MAX_STRING_LEN Bytes)
+*/
+void SEGGER_SYSVIEW_NameMarker(unsigned int MarkerId, const char* sName) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32 + 1 + SEGGER_SYSVIEW_MAX_STRING_LEN);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, SYSVIEW_EVTID_EX_NAME_MARKER);
+  ENCODE_U32(pPayload, MarkerId);
+  pPayload = _EncodeStr(pPayload, sName, SEGGER_SYSVIEW_MAX_STRING_LEN);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_EX);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_NameResource()
+*
+*  Function description
+*    Send the name of a resource to be displayed in SystemView.
+*
+*    Marker names are usually set in the system description
+*    callback, to ensure it is only sent when the SystemView Application
+*    is connected.  
+*
+*  Parameters
+*    ResourceId - Id of the resource to be named. i.e. its address.
+*    sName      - Pointer to the resource name. (Max. SEGGER_SYSVIEW_MAX_STRING_LEN Bytes)
+*/
+void SEGGER_SYSVIEW_NameResource(U32 ResourceId, const char* sName) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32 + 1 + SEGGER_SYSVIEW_MAX_STRING_LEN);
+  //
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, SHRINK_ID(ResourceId));
+  pPayload = _EncodeStr(pPayload, sName, SEGGER_SYSVIEW_MAX_STRING_LEN);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_NAME_RESOURCE);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_SendPacket()
+*
+*  Function description
+*    Send an event packet.
+*
+*  Parameters
+*    pPacket      - Pointer to the start of the packet.
+*    pPayloadEnd  - Pointer to the end of the payload.
+*                   Make sure there are at least 5 bytes free after the payload.
+*    EventId      - Id of the event packet.
+*
+*  Return value
+*    !=0:  Success, Message sent.
+*    ==0:  Buffer full, Message *NOT* sent.
+*/
+int SEGGER_SYSVIEW_SendPacket(U8* pPacket, U8* pPayloadEnd, unsigned int EventId) {
+#if (SEGGER_SYSVIEW_USE_STATIC_BUFFER == 1)
+  SEGGER_SYSVIEW_LOCK();
+#endif
+  _SendPacket(pPacket + 4, pPayloadEnd, EventId);
+#if (SEGGER_SYSVIEW_USE_STATIC_BUFFER == 1)
+  SEGGER_SYSVIEW_UNLOCK();
+#endif
+  return 0;
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_EncodeU32()
+*
+*  Function description
+*    Encode a U32 in variable-length format.
+*
+*  Parameters
+*    pPayload - Pointer to where U32 will be encoded.
+*    Value    - The 32-bit value to be encoded.
+*
+*  Return value
+*    Pointer to the byte following the value, i.e. the first free
+*    byte in the payload and the next position to store payload
+*    content.
+*/
+U8* SEGGER_SYSVIEW_EncodeU32(U8* pPayload, U32 Value) {
+  ENCODE_U32(pPayload, Value);
+  return pPayload;
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_EncodeString()
+*
+*  Function description
+*    Encode a string in variable-length format.
+*
+*  Parameters
+*    pPayload - Pointer to where string will be encoded.
+*    s        - String to encode.
+*    MaxLen   - Maximum number of characters to encode from string.
+*
+*  Return value
+*    Pointer to the byte following the value, i.e. the first free
+*    byte in the payload and the next position to store payload
+*    content.
+*
+*  Additional information
+*    The string is encoded as a count byte followed by the contents
+*    of the string.
+*    No more than 1 + MaxLen bytes will be encoded to the payload.
+*/
+U8* SEGGER_SYSVIEW_EncodeString(U8* pPayload, const char* s, unsigned int MaxLen) {
+  return _EncodeStr(pPayload, s, MaxLen);
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_EncodeData()
+*
+*  Function description
+*    Encode a byte buffer in variable-length format.
+*
+*  Parameters
+*    pPayload - Pointer to where string will be encoded.
+*    pSrc     - Pointer to data buffer to be encoded.
+*    NumBytes - Number of bytes in the buffer to be encoded.
+*
+*  Return value
+*    Pointer to the byte following the value, i.e. the first free
+*    byte in the payload and the next position to store payload
+*    content.
+*
+*  Additional information
+*    The data is encoded as a count byte followed by the contents
+*    of the data buffer.
+*    Make sure NumBytes + 1 bytes are free for the payload.
+*/
+U8* SEGGER_SYSVIEW_EncodeData(U8 *pPayload, const char* pSrc, unsigned int NumBytes) {
+  return _EncodeData(pPayload, pSrc, NumBytes);
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_EncodeId()
+*
+*  Function description
+*    Encode a 32-bit Id in shrunken variable-length format.
+*
+*  Parameters
+*    pPayload - Pointer to where the Id will be encoded.
+*    Id       - The 32-bit value to be encoded.
+*
+*  Return value
+*    Pointer to the byte following the value, i.e. the first free
+*    byte in the payload and the next position to store payload
+*    content.
+*
+*  Additional information
+*    The parameters to shrink an Id can be configured in
+*    SEGGER_SYSVIEW_Conf.h and via SEGGER_SYSVIEW_SetRAMBase().
+*     SEGGER_SYSVIEW_ID_BASE: Lowest Id reported by the application.
+*       (i.e. 0x20000000 when all Ids are an address in this RAM)
+*     SEGGER_SYSVIEW_ID_SHIFT: Number of bits to shift the Id to
+*       save bandwidth. (i.e. 2 when Ids are 4 byte aligned)
+*/
+U8* SEGGER_SYSVIEW_EncodeId(U8* pPayload, U32 Id) {
+  Id = SHRINK_ID(Id);
+  ENCODE_U32(pPayload, Id);
+  return pPayload;
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_ShrinkId()
+*
+*  Function description
+*    Get the shrunken value of an Id for further processing like in
+*    SEGGER_SYSVIEW_NameResource().
+*
+*  Parameters
+*    Id       - The 32-bit value to be shrunken.
+*
+*  Return value
+*    Shrunken Id.
+*
+*  Additional information
+*    The parameters to shrink an Id can be configured in
+*    SEGGER_SYSVIEW_Conf.h and via SEGGER_SYSVIEW_SetRAMBase().
+*     SEGGER_SYSVIEW_ID_BASE: Lowest Id reported by the application.
+*       (i.e. 0x20000000 when all Ids are an address in this RAM)
+*     SEGGER_SYSVIEW_ID_SHIFT: Number of bits to shift the Id to
+*       save bandwidth. (i.e. 2 when Ids are 4 byte aligned)
+*/
+U32 SEGGER_SYSVIEW_ShrinkId(U32 Id) {
+  return SHRINK_ID(Id);
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RegisterModule()
+*
+*  Function description
+*    Register a middleware module for recording its events.
+*
+*  Parameters
+*    pModule  - The middleware module information.
+*
+*  Additional information
+*    SEGGER_SYSVIEW_MODULE elements:
+*      sDescription      - Pointer to a string containing the module name and optionally the module event description.
+*      NumEvents         - Number of events the module wants to register.
+*      EventOffset       - Offset to be added to the event Ids. Out parameter, set by this function. Do not modify after calling this function.
+*      pfSendModuleDesc  - Callback function pointer to send more detailed module description to SystemView Application.
+*      pNext             - Pointer to next registered module. Out parameter, set by this function. Do not modify after calling this function.
+*/
+void SEGGER_SYSVIEW_RegisterModule(SEGGER_SYSVIEW_MODULE* pModule) {
+  SEGGER_SYSVIEW_LOCK();
+  if (_pFirstModule == 0) {
+    //
+    // No module registered, yet.
+    // Start list with new module.
+    // EventOffset is the base offset for modules
+    //
+    pModule->EventOffset = MODULE_EVENT_OFFSET;
+    pModule->pNext = 0;
+    _pFirstModule = pModule;
+    _NumModules = 1;
+  } else {
+    //
+    // Registreded module(s) present.
+    // Prepend new module in list.
+    // EventOffset set from number of events and offset of previous module.
+    //
+    pModule->EventOffset = _pFirstModule->EventOffset + _pFirstModule->NumEvents;
+    pModule->pNext = _pFirstModule;
+    _pFirstModule = pModule;
+    _NumModules++;
+  }
+  SEGGER_SYSVIEW_SendModule(0);
+  if (pModule->pfSendModuleDesc) {
+    pModule->pfSendModuleDesc();
+  }
+  SEGGER_SYSVIEW_UNLOCK();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_RecordModuleDescription()
+*
+*  Function description
+*    Sends detailed information of a registered module to the host.
+*
+*  Parameters
+*    pModule      - Pointer to the described module.
+*    sDescription - Pointer to a description string.
+*/
+void SEGGER_SYSVIEW_RecordModuleDescription(const SEGGER_SYSVIEW_MODULE* pModule, const char* sDescription) {
+  U8  ModuleId;
+  SEGGER_SYSVIEW_MODULE* p;
+
+  p = _pFirstModule;
+  ModuleId = 0;
+  do {
+    if (p == pModule) {
+      break;
+    }
+    ModuleId++;
+    p = p->pNext;
+  } while (p);
+  {
+    U8* pPayload;
+    U8* pPayloadStart;
+    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32 + 1 + SEGGER_SYSVIEW_MAX_STRING_LEN);
+    //
+    pPayload = pPayloadStart;
+    //
+    // Send module description
+    // Send event offset and number of events
+    //
+    ENCODE_U32(pPayload, ModuleId);
+    ENCODE_U32(pPayload, (pModule->EventOffset));
+    pPayload = _EncodeStr(pPayload, sDescription, SEGGER_SYSVIEW_MAX_STRING_LEN);
+    _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_MODULEDESC);
+    RECORD_END();
+  }
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_SendModule()
+*
+*  Function description
+*    Sends the information of a registered module to the host.
+*
+*  Parameters
+*    ModuleId   - Id of the requested module.
+*/
+void SEGGER_SYSVIEW_SendModule(U8 ModuleId) {
+  SEGGER_SYSVIEW_MODULE* pModule;
+  U32 n;
+
+  if (_pFirstModule != 0) {
+    pModule = _pFirstModule;
+    for (n = 0; n < ModuleId; n++) {
+      pModule = pModule->pNext;
+      if (pModule == 0) {
+        break;
+      }
+    }
+    if (pModule != 0) {
+      U8* pPayload;
+      U8* pPayloadStart;
+      RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32 + 1 + SEGGER_SYSVIEW_MAX_STRING_LEN);
+      //
+      pPayload = pPayloadStart;
+      //
+      // Send module description
+      // Send event offset and number of events
+      //
+      ENCODE_U32(pPayload, ModuleId);
+      ENCODE_U32(pPayload, (pModule->EventOffset));
+      pPayload = _EncodeStr(pPayload, pModule->sModule, SEGGER_SYSVIEW_MAX_STRING_LEN);
+      _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_MODULEDESC);
+      RECORD_END();
+    }
+  }
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_SendModuleDescription()
+*
+*  Function description
+*    Triggers a send of the registered module descriptions.
+*
+*/
+void SEGGER_SYSVIEW_SendModuleDescription(void) {
+  SEGGER_SYSVIEW_MODULE* pModule;
+
+  if (_pFirstModule != 0) {
+    pModule = _pFirstModule;
+    do {
+      if (pModule->pfSendModuleDesc) {
+        pModule->pfSendModuleDesc();
+      }
+      pModule = pModule->pNext;
+    } while (pModule);
+  }
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_SendNumModules()
+*
+*  Function description
+*    Send the number of registered modules to the host.
+*/
+void SEGGER_SYSVIEW_SendNumModules(void) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2*SEGGER_SYSVIEW_QUANTA_U32);
+  pPayload = pPayloadStart;
+  ENCODE_U32(pPayload, _NumModules);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_NUMMODULES);
+  RECORD_END();
+}
+
+#ifndef SEGGER_SYSVIEW_EXCLUDE_PRINTF // Define in project to avoid warnings about variable parameter list
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_PrintfHostEx()
+*
+*  Function description
+*    Print a string which is formatted on the host by the SystemView Application
+*    with Additional information.
+*
+*  Parameters
+*    s        - String to be formatted.
+*    Options  - Options for the string. i.e. Log level.
+*
+*  Additional information
+*    All format arguments are treated as 32-bit scalar values.
+*/
+void SEGGER_SYSVIEW_PrintfHostEx(const char* s, U32 Options, ...) {
+  va_list ParamList;
+#if SEGGER_SYSVIEW_PRINTF_IMPLICIT_FORMAT
+  int r;
+
+  va_start(ParamList, Options);
+  r = _VPrintHost(s, Options, &ParamList);
+  va_end(ParamList);
+
+  if (r == -1) {
+    va_start(ParamList, Options);
+    _VPrintTarget(s, Options, &ParamList);
+    va_end(ParamList);
+  }
+#else
+  va_start(ParamList, Options);
+  _VPrintHost(s, Options, &ParamList);
+  va_end(ParamList);
+#endif
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_PrintfHost()
+*
+*  Function description
+*    Print a string which is formatted on the host by the SystemView Application.
+*
+*  Parameters
+*    s        - String to be formatted.
+*
+*  Additional information
+*    All format arguments are treated as 32-bit scalar values.
+*/
+void SEGGER_SYSVIEW_PrintfHost(const char* s, ...) {
+  va_list ParamList;
+#if SEGGER_SYSVIEW_PRINTF_IMPLICIT_FORMAT
+  int r;
+
+  va_start(ParamList, s);
+  r = _VPrintHost(s, SEGGER_SYSVIEW_LOG, &ParamList);
+  va_end(ParamList);
+
+  if (r == -1) {
+    va_start(ParamList, s);
+    _VPrintTarget(s, SEGGER_SYSVIEW_LOG, &ParamList);
+    va_end(ParamList);
+  }
+#else
+  va_start(ParamList, s);
+  _VPrintHost(s, SEGGER_SYSVIEW_LOG, &ParamList);
+  va_end(ParamList);
+#endif
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_WarnfHost()
+*
+*  Function description
+*    Print a warnin string which is formatted on the host by 
+*    the SystemView Application.
+*
+*  Parameters
+*    s        - String to be formatted.
+*
+*  Additional information
+*    All format arguments are treated as 32-bit scalar values.
+*/
+void SEGGER_SYSVIEW_WarnfHost(const char* s, ...) {
+  va_list ParamList;
+#if SEGGER_SYSVIEW_PRINTF_IMPLICIT_FORMAT
+  int r;
+
+  va_start(ParamList, s);
+  r = _VPrintHost(s, SEGGER_SYSVIEW_WARNING, &ParamList);
+  va_end(ParamList);
+
+  if (r == -1) {
+    va_start(ParamList, s);
+    _VPrintTarget(s, SEGGER_SYSVIEW_WARNING, &ParamList);
+    va_end(ParamList);
+  }
+#else
+  va_start(ParamList, s);
+  _VPrintHost(s, SEGGER_SYSVIEW_WARNING, &ParamList);
+  va_end(ParamList);
+#endif
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_ErrorfHost()
+*
+*  Function description
+*    Print an error string which is formatted on the host by 
+*    the SystemView Application.
+*
+*  Parameters
+*    s        - String to be formatted.
+*
+*  Additional information
+*    All format arguments are treated as 32-bit scalar values.
+*/
+void SEGGER_SYSVIEW_ErrorfHost(const char* s, ...) {
+  va_list ParamList;
+#if SEGGER_SYSVIEW_PRINTF_IMPLICIT_FORMAT
+  int r;
+
+  va_start(ParamList, s);
+  r = _VPrintHost(s, SEGGER_SYSVIEW_ERROR, &ParamList);
+  va_end(ParamList);
+
+  if (r == -1) {
+    va_start(ParamList, s);
+    _VPrintTarget(s, SEGGER_SYSVIEW_ERROR, &ParamList);
+    va_end(ParamList);
+  }
+#else
+  va_start(ParamList, s);
+  _VPrintHost(s, SEGGER_SYSVIEW_ERROR, &ParamList);
+  va_end(ParamList);
+#endif
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_PrintfTargetEx()
+*
+*  Function description
+*    Print a string which is formatted on the target before sent to 
+*    the host with Additional information.
+*
+*  Parameters
+*    s        - String to be formatted.
+*    Options  - Options for the string. i.e. Log level.
+*/
+void SEGGER_SYSVIEW_PrintfTargetEx(const char* s, U32 Options, ...) {
+  va_list ParamList;
+
+  va_start(ParamList, Options);
+  _VPrintTarget(s, Options, &ParamList);
+  va_end(ParamList);
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_PrintfTarget()
+*
+*  Function description
+*    Print a string which is formatted on the target before sent to 
+*    the host.
+*
+*  Parameters
+*    s        - String to be formatted.
+*/
+void SEGGER_SYSVIEW_PrintfTarget(const char* s, ...) {
+  va_list ParamList;
+
+  va_start(ParamList, s);
+  _VPrintTarget(s, SEGGER_SYSVIEW_LOG, &ParamList);
+  va_end(ParamList);
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_WarnfTarget()
+*
+*  Function description
+*    Print a warning string which is formatted on the target before
+*    sent to the host.
+*
+*  Parameters
+*    s        - String to be formatted.
+*/
+void SEGGER_SYSVIEW_WarnfTarget(const char* s, ...) {
+  va_list ParamList;
+
+  va_start(ParamList, s);
+  _VPrintTarget(s, SEGGER_SYSVIEW_WARNING, &ParamList);
+  va_end(ParamList);
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_ErrorfTarget()
+*
+*  Function description
+*    Print an error string which is formatted on the target before
+*    sent to the host.
+*
+*  Parameters
+*    s        - String to be formatted.
+*/
+void SEGGER_SYSVIEW_ErrorfTarget(const char* s, ...) {
+  va_list ParamList;
+
+  va_start(ParamList, s);
+  _VPrintTarget(s, SEGGER_SYSVIEW_ERROR, &ParamList);
+  va_end(ParamList);
+}
+#endif // SEGGER_SYSVIEW_EXCLUDE_PRINTF
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_Print()
+*
+*  Function description
+*    Print a string to the host.
+*
+*  Parameters
+*    s        - String to sent.
+*/
+void SEGGER_SYSVIEW_Print(const char* s) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32 + SEGGER_SYSVIEW_MAX_STRING_LEN);
+  //
+  pPayload = _EncodeStr(pPayloadStart, s, SEGGER_SYSVIEW_MAX_STRING_LEN);
+  ENCODE_U32(pPayload, SEGGER_SYSVIEW_LOG);
+  ENCODE_U32(pPayload, 0);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_Warn()
+*
+*  Function description
+*    Print a warning string to the host.
+*
+*  Parameters
+*    s        - String to sent.
+*/
+void SEGGER_SYSVIEW_Warn(const char* s) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32 + SEGGER_SYSVIEW_MAX_STRING_LEN);
+  //
+  pPayload = _EncodeStr(pPayloadStart, s, SEGGER_SYSVIEW_MAX_STRING_LEN);
+  ENCODE_U32(pPayload, SEGGER_SYSVIEW_WARNING);
+  ENCODE_U32(pPayload, 0);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_Error()
+*
+*  Function description
+*    Print an error string to the host.
+*
+*  Parameters
+*    s        - String to sent.
+*/
+void SEGGER_SYSVIEW_Error(const char* s) {
+  U8* pPayload;
+  U8* pPayloadStart;
+  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32 + SEGGER_SYSVIEW_MAX_STRING_LEN);
+  //
+  pPayload = _EncodeStr(pPayloadStart, s, SEGGER_SYSVIEW_MAX_STRING_LEN);
+  ENCODE_U32(pPayload, SEGGER_SYSVIEW_ERROR);
+  ENCODE_U32(pPayload, 0);
+  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
+  RECORD_END();
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_EnableEvents()
+*
+*  Function description
+*    Enable standard SystemView events to be generated.
+*
+*  Parameters
+*    EnableMask   - Events to be enabled.
+*/
+void SEGGER_SYSVIEW_EnableEvents(U32 EnableMask) {
+  _SYSVIEW_Globals.DisabledEvents &= ~EnableMask;
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_DisableEvents()
+*
+*  Function description
+*    Disable standard SystemView events to not be generated.
+*
+*  Parameters
+*    DisableMask  - Events to be disabled.
+*/
+void SEGGER_SYSVIEW_DisableEvents(U32 DisableMask) {
+  _SYSVIEW_Globals.DisabledEvents |= DisableMask;
+}
+
+/*********************************************************************
+*
+*       SEGGER_SYSVIEW_IsStarted()
+*
+*  Function description
+*    Handle incoming packets if any and check if recording is started.
+*
+*  Return value
+*      0: Recording not started.
+*    > 0: Recording started.
+*/
+int SEGGER_SYSVIEW_IsStarted(void) {
+#if (SEGGER_SYSVIEW_POST_MORTEM_MODE != 1)
+  //
+  // Check if host is sending data which needs to be processed.
+  //
+  if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
+    if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
+      _SYSVIEW_Globals.RecursionCnt = 1;
+      _HandleIncomingPacket();
+      _SYSVIEW_Globals.RecursionCnt = 0;
+    }
+  }
+#endif
+  return _SYSVIEW_Globals.EnableState;
+}
+
+
+/*************************** End of file ****************************/
diff --git a/sched/systemview/SEGGER_SYSVIEW.h b/sched/systemview/SEGGER_SYSVIEW.h
new file mode 100644
index 0000000000..26f98dbc06
--- /dev/null
+++ b/sched/systemview/SEGGER_SYSVIEW.h
@@ -0,0 +1,346 @@
+/*********************************************************************
+*                    SEGGER Microcontroller GmbH                     *
+*                        The Embedded Experts                        *
+**********************************************************************
+*                                                                    *
+*            (c) 1995 - 2019 SEGGER Microcontroller GmbH             *
+*                                                                    *
+*       www.segger.com     Support: support@segger.com               *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SEGGER SystemView * Real-time application analysis           *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+* All rights reserved.                                               *
+*                                                                    *
+* SEGGER strongly recommends to not make any changes                 *
+* to or modify the source code of this software in order to stay     *
+* compatible with the SystemView and RTT protocol, and J-Link.       *
+*                                                                    *
+* Redistribution and use in source and binary forms, with or         *
+* without modification, are permitted provided that the following    *
+* condition is met:                                                  *
+*                                                                    *
+* o Redistributions of source code must retain the above copyright   *
+*   notice, this condition and the following disclaimer.             *
+*                                                                    *
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
+* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
+* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
+* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
+* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
+* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
+* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
+* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
+* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
+* DAMAGE.                                                            *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SystemView version: V3.12                                    *
+*                                                                    *
+**********************************************************************
+-------------------------- END-OF-HEADER -----------------------------
+File    : SEGGER_SYSVIEW.h
+Purpose : System visualization API.
+Revision: $Rev: 17331 $
+*/
+
+#ifndef SEGGER_SYSVIEW_H
+#define SEGGER_SYSVIEW_H
+
+/*********************************************************************
+*
+*       #include Section
+*
+**********************************************************************
+*/
+
+#include "SEGGER.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/*********************************************************************
+*
+*       Defines, fixed
+*
+**********************************************************************
+*/
+
+#define SEGGER_SYSVIEW_MAJOR          3
+#define SEGGER_SYSVIEW_MINOR          10
+#define SEGGER_SYSVIEW_REV            0
+#define SEGGER_SYSVIEW_VERSION        ((SEGGER_SYSVIEW_MAJOR * 10000) + (SEGGER_SYSVIEW_MINOR * 100) + SEGGER_SYSVIEW_REV)
+
+#define SEGGER_SYSVIEW_INFO_SIZE      9   // Minimum size, which has to be reserved for a packet. 1-2 byte of message type, 0-2  byte of payload length, 1-5 bytes of timestamp.
+#define SEGGER_SYSVIEW_QUANTA_U32     5   // Maximum number of bytes to encode a U32, should be reserved for each 32-bit value in a packet.
+
+#define SEGGER_SYSVIEW_LOG            (0u)
+#define SEGGER_SYSVIEW_WARNING        (1u)
+#define SEGGER_SYSVIEW_ERROR          (2u)
+#define SEGGER_SYSVIEW_FLAG_APPEND    (1u << 6)
+
+#define SEGGER_SYSVIEW_PREPARE_PACKET(p)  (p) + 4
+//
+// SystemView events. First 32 IDs from 0 .. 31 are reserved for these
+//
+#define   SYSVIEW_EVTID_NOP                0  // Dummy packet.
+#define   SYSVIEW_EVTID_OVERFLOW           1
+#define   SYSVIEW_EVTID_ISR_ENTER          2
+#define   SYSVIEW_EVTID_ISR_EXIT           3
+#define   SYSVIEW_EVTID_TASK_START_EXEC    4
+#define   SYSVIEW_EVTID_TASK_STOP_EXEC     5
+#define   SYSVIEW_EVTID_TASK_START_READY   6
+#define   SYSVIEW_EVTID_TASK_STOP_READY    7
+#define   SYSVIEW_EVTID_TASK_CREATE        8
+#define   SYSVIEW_EVTID_TASK_INFO          9
+#define   SYSVIEW_EVTID_TRACE_START       10
+#define   SYSVIEW_EVTID_TRACE_STOP        11
+#define   SYSVIEW_EVTID_SYSTIME_CYCLES    12
+#define   SYSVIEW_EVTID_SYSTIME_US        13
+#define   SYSVIEW_EVTID_SYSDESC           14
+#define   SYSVIEW_EVTID_MARK_START        15
+#define   SYSVIEW_EVTID_MARK_STOP         16
+#define   SYSVIEW_EVTID_IDLE              17
+#define   SYSVIEW_EVTID_ISR_TO_SCHEDULER  18
+#define   SYSVIEW_EVTID_TIMER_ENTER       19
+#define   SYSVIEW_EVTID_TIMER_EXIT        20
+#define   SYSVIEW_EVTID_STACK_INFO        21
+#define   SYSVIEW_EVTID_MODULEDESC        22
+
+#define   SYSVIEW_EVTID_INIT              24
+#define   SYSVIEW_EVTID_NAME_RESOURCE     25
+#define   SYSVIEW_EVTID_PRINT_FORMATTED   26
+#define   SYSVIEW_EVTID_NUMMODULES        27
+#define   SYSVIEW_EVTID_END_CALL          28
+#define   SYSVIEW_EVTID_TASK_TERMINATE    29
+
+#define   SYSVIEW_EVTID_EX                31
+//
+// SystemView extended events. Sent with ID 31.
+//
+#define   SYSVIEW_EVTID_EX_MARK            0
+#define   SYSVIEW_EVTID_EX_NAME_MARKER     1
+//
+// Event masks to disable/enable events
+//
+#define   SYSVIEW_EVTMASK_NOP               (1 << SYSVIEW_EVTID_NOP)
+#define   SYSVIEW_EVTMASK_OVERFLOW          (1 << SYSVIEW_EVTID_OVERFLOW)
+#define   SYSVIEW_EVTMASK_ISR_ENTER         (1 << SYSVIEW_EVTID_ISR_ENTER)
+#define   SYSVIEW_EVTMASK_ISR_EXIT          (1 << SYSVIEW_EVTID_ISR_EXIT)
+#define   SYSVIEW_EVTMASK_TASK_START_EXEC   (1 << SYSVIEW_EVTID_TASK_START_EXEC)
+#define   SYSVIEW_EVTMASK_TASK_STOP_EXEC    (1 << SYSVIEW_EVTID_TASK_STOP_EXEC)
+#define   SYSVIEW_EVTMASK_TASK_START_READY  (1 << SYSVIEW_EVTID_TASK_START_READY)
+#define   SYSVIEW_EVTMASK_TASK_STOP_READY   (1 << SYSVIEW_EVTID_TASK_STOP_READY)
+#define   SYSVIEW_EVTMASK_TASK_CREATE       (1 << SYSVIEW_EVTID_TASK_CREATE)
+#define   SYSVIEW_EVTMASK_TASK_INFO         (1 << SYSVIEW_EVTID_TASK_INFO)
+#define   SYSVIEW_EVTMASK_TRACE_START       (1 << SYSVIEW_EVTID_TRACE_START)
+#define   SYSVIEW_EVTMASK_TRACE_STOP        (1 << SYSVIEW_EVTID_TRACE_STOP)
+#define   SYSVIEW_EVTMASK_SYSTIME_CYCLES    (1 << SYSVIEW_EVTID_SYSTIME_CYCLES)
+#define   SYSVIEW_EVTMASK_SYSTIME_US        (1 << SYSVIEW_EVTID_SYSTIME_US)
+#define   SYSVIEW_EVTMASK_SYSDESC           (1 << SYSVIEW_EVTID_SYSDESC)
+#define   SYSVIEW_EVTMASK_USER_START        (1 << SYSVIEW_EVTID_USER_START)
+#define   SYSVIEW_EVTMASK_USER_STOP         (1 << SYSVIEW_EVTID_USER_STOP)
+#define   SYSVIEW_EVTMASK_IDLE              (1 << SYSVIEW_EVTID_IDLE)
+#define   SYSVIEW_EVTMASK_ISR_TO_SCHEDULER  (1 << SYSVIEW_EVTID_ISR_TO_SCHEDULER)
+#define   SYSVIEW_EVTMASK_TIMER_ENTER       (1 << SYSVIEW_EVTID_TIMER_ENTER)
+#define   SYSVIEW_EVTMASK_TIMER_EXIT        (1 << SYSVIEW_EVTID_TIMER_EXIT)
+#define   SYSVIEW_EVTMASK_STACK_INFO        (1 << SYSVIEW_EVTID_STACK_INFO)
+#define   SYSVIEW_EVTMASK_MODULEDESC        (1 << SYSVIEW_EVTID_MODULEDESC)
+
+#define   SYSVIEW_EVTMASK_INIT              (1 << SYSVIEW_EVTID_INIT)
+#define   SYSVIEW_EVTMASK_NAME_RESOURCE     (1 << SYSVIEW_EVTID_NAME_RESOURCE)
+#define   SYSVIEW_EVTMASK_PRINT_FORMATTED   (1 << SYSVIEW_EVTID_PRINT_FORMATTED)
+#define   SYSVIEW_EVTMASK_NUMMODULES        (1 << SYSVIEW_EVTID_NUMMODULES)
+#define   SYSVIEW_EVTMASK_END_CALL          (1 << SYSVIEW_EVTID_END_CALL)
+#define   SYSVIEW_EVTMASK_TASK_TERMINATE    (1 << SYSVIEW_EVTID_TASK_TERMINATE)
+
+#define   SYSVIEW_EVTMASK_EX                (1 << SYSVIEW_EVTID_EX)
+
+#define   SYSVIEW_EVTMASK_ALL_INTERRUPTS    ( SYSVIEW_EVTMASK_ISR_ENTER           \
+                                            | SYSVIEW_EVTMASK_ISR_EXIT            \
+                                            | SYSVIEW_EVTMASK_ISR_TO_SCHEDULER)
+#define   SYSVIEW_EVTMASK_ALL_TASKS         ( SYSVIEW_EVTMASK_TASK_START_EXEC     \
+                                            | SYSVIEW_EVTMASK_TASK_STOP_EXEC      \
+                                            | SYSVIEW_EVTMASK_TASK_START_READY    \
+                                            | SYSVIEW_EVTMASK_TASK_STOP_READY     \
+                                            | SYSVIEW_EVTMASK_TASK_CREATE         \
+                                            | SYSVIEW_EVTMASK_TASK_INFO           \
+                                            | SYSVIEW_EVTMASK_STACK_INFO          \
+                                            | SYSVIEW_EVTMASK_TASK_TERMINATE)
+
+/*********************************************************************
+*
+*       Structures
+*
+**********************************************************************
+*/
+
+typedef struct {
+  U32          TaskID;
+  const char*  sName;
+  U32          Prio;
+  U32          StackBase;
+  U32          StackSize;
+} SEGGER_SYSVIEW_TASKINFO;
+
+typedef struct SEGGER_SYSVIEW_MODULE_STRUCT SEGGER_SYSVIEW_MODULE;
+
+struct SEGGER_SYSVIEW_MODULE_STRUCT {
+  const char*                   sModule;
+        U32                     NumEvents;
+        U32                     EventOffset;
+        void                    (*pfSendModuleDesc)(void);
+        SEGGER_SYSVIEW_MODULE*  pNext;
+};
+
+typedef void (SEGGER_SYSVIEW_SEND_SYS_DESC_FUNC)(void);
+
+/*********************************************************************
+*
+*       API functions
+*
+**********************************************************************
+*/
+
+typedef struct {
+  U64  (*pfGetTime)      (void);
+  void (*pfSendTaskList) (void);
+} SEGGER_SYSVIEW_OS_API;
+
+/*********************************************************************
+*
+*       Control and initialization functions
+*/
+void SEGGER_SYSVIEW_Init                          (U32 SysFreq, U32 CPUFreq, const SEGGER_SYSVIEW_OS_API *pOSAPI, SEGGER_SYSVIEW_SEND_SYS_DESC_FUNC pfSendSysDesc);
+void SEGGER_SYSVIEW_SetRAMBase                    (U32 RAMBaseAddress);
+void SEGGER_SYSVIEW_Start                         (void);
+void SEGGER_SYSVIEW_Stop                          (void);
+void SEGGER_SYSVIEW_GetSysDesc                    (void);
+void SEGGER_SYSVIEW_SendTaskList                  (void);
+void SEGGER_SYSVIEW_SendTaskInfo                  (const SEGGER_SYSVIEW_TASKINFO* pInfo);
+void SEGGER_SYSVIEW_SendSysDesc                   (const char* sSysDesc);
+int  SEGGER_SYSVIEW_IsStarted                     (void);
+int  SEGGER_SYSVIEW_GetChannelID                  (void);
+
+/*********************************************************************
+*
+*       Event recording functions
+*/
+void SEGGER_SYSVIEW_RecordVoid                    (unsigned int EventId);
+void SEGGER_SYSVIEW_RecordU32                     (unsigned int EventId, U32 Para0);
+void SEGGER_SYSVIEW_RecordU32x2                   (unsigned int EventId, U32 Para0, U32 Para1);
+void SEGGER_SYSVIEW_RecordU32x3                   (unsigned int EventId, U32 Para0, U32 Para1, U32 Para2);
+void SEGGER_SYSVIEW_RecordU32x4                   (unsigned int EventId, U32 Para0, U32 Para1, U32 Para2, U32 Para3);
+void SEGGER_SYSVIEW_RecordU32x5                   (unsigned int EventId, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4);
+void SEGGER_SYSVIEW_RecordU32x6                   (unsigned int EventId, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4, U32 Para5);
+void SEGGER_SYSVIEW_RecordU32x7                   (unsigned int EventId, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4, U32 Para5, U32 Para6);
+void SEGGER_SYSVIEW_RecordU32x8                   (unsigned int EventId, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4, U32 Para5, U32 Para6, U32 Para7);
+void SEGGER_SYSVIEW_RecordU32x9                   (unsigned int EventId, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4, U32 Para5, U32 Para6, U32 Para7, U32 Para8);
+void SEGGER_SYSVIEW_RecordU32x10                  (unsigned int EventId, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4, U32 Para5, U32 Para6, U32 Para7, U32 Para8, U32 Para9);
+void SEGGER_SYSVIEW_RecordString                  (unsigned int EventId, const char* pString);
+void SEGGER_SYSVIEW_RecordSystime                 (void);
+void SEGGER_SYSVIEW_RecordEnterISR                (void);
+void SEGGER_SYSVIEW_RecordExitISR                 (void);
+void SEGGER_SYSVIEW_RecordExitISRToScheduler      (void);
+void SEGGER_SYSVIEW_RecordEnterTimer              (U32 TimerId);
+void SEGGER_SYSVIEW_RecordExitTimer               (void);
+void SEGGER_SYSVIEW_RecordEndCall                 (unsigned int EventID);
+void SEGGER_SYSVIEW_RecordEndCallU32              (unsigned int EventID, U32 Para0);
+
+void SEGGER_SYSVIEW_OnIdle                        (void);
+void SEGGER_SYSVIEW_OnTaskCreate                  (U32 TaskId);
+void SEGGER_SYSVIEW_OnTaskTerminate               (U32 TaskId);
+void SEGGER_SYSVIEW_OnTaskStartExec               (U32 TaskId);
+void SEGGER_SYSVIEW_OnTaskStopExec                (void);
+void SEGGER_SYSVIEW_OnTaskStartReady              (U32 TaskId);
+void SEGGER_SYSVIEW_OnTaskStopReady               (U32 TaskId, unsigned int Cause);
+void SEGGER_SYSVIEW_MarkStart                     (unsigned int MarkerId);
+void SEGGER_SYSVIEW_MarkStop                      (unsigned int MarkerId);
+void SEGGER_SYSVIEW_Mark                          (unsigned int MarkerId);
+void SEGGER_SYSVIEW_NameMarker                    (unsigned int MarkerId, const char* sName);
+
+void SEGGER_SYSVIEW_NameResource                  (U32 ResourceId, const char* sName);
+
+int  SEGGER_SYSVIEW_SendPacket                    (U8* pPacket, U8* pPayloadEnd, unsigned int EventId);
+
+/*********************************************************************
+*
+*       Event parameter encoding functions
+*/
+U8*  SEGGER_SYSVIEW_EncodeU32                     (U8* pPayload, U32 Value);
+U8*  SEGGER_SYSVIEW_EncodeData                    (U8* pPayload, const char* pSrc, unsigned int Len);
+U8*  SEGGER_SYSVIEW_EncodeString                  (U8* pPayload, const char* s, unsigned int MaxLen);
+U8*  SEGGER_SYSVIEW_EncodeId                      (U8* pPayload, U32 Id);
+U32  SEGGER_SYSVIEW_ShrinkId                      (U32 Id);
+
+
+/*********************************************************************
+*
+*       Middleware module registration
+*/
+void SEGGER_SYSVIEW_RegisterModule                (SEGGER_SYSVIEW_MODULE* pModule);
+void SEGGER_SYSVIEW_RecordModuleDescription       (const SEGGER_SYSVIEW_MODULE* pModule, const char* sDescription);
+void SEGGER_SYSVIEW_SendModule                    (U8 ModuleId);
+void SEGGER_SYSVIEW_SendModuleDescription         (void);
+void SEGGER_SYSVIEW_SendNumModules                (void);
+
+/*********************************************************************
+*
+*       printf-Style functions
+*/
+#ifndef SEGGER_SYSVIEW_EXCLUDE_PRINTF // Define in project to avoid warnings about variable parameter list
+void SEGGER_SYSVIEW_PrintfHostEx                  (const char* s, U32 Options, ...);
+void SEGGER_SYSVIEW_PrintfTargetEx                (const char* s, U32 Options, ...);
+void SEGGER_SYSVIEW_PrintfHost                    (const char* s, ...);
+void SEGGER_SYSVIEW_PrintfTarget                  (const char* s, ...);
+void SEGGER_SYSVIEW_WarnfHost                     (const char* s, ...);
+void SEGGER_SYSVIEW_WarnfTarget                   (const char* s, ...);
+void SEGGER_SYSVIEW_ErrorfHost                    (const char* s, ...);
+void SEGGER_SYSVIEW_ErrorfTarget                  (const char* s, ...);
+#endif
+
+void SEGGER_SYSVIEW_Print                         (const char* s);
+void SEGGER_SYSVIEW_Warn                          (const char* s);
+void SEGGER_SYSVIEW_Error                         (const char* s);
+
+/*********************************************************************
+*
+*       Run-time configuration functions
+*/
+void SEGGER_SYSVIEW_EnableEvents                  (U32 EnableMask);
+void SEGGER_SYSVIEW_DisableEvents                 (U32 DisableMask);
+
+/*********************************************************************
+*
+*       Application-provided functions
+*/
+void SEGGER_SYSVIEW_Conf                          (void);
+U32  SEGGER_SYSVIEW_X_GetTimestamp                (void);
+U32  SEGGER_SYSVIEW_X_GetInterruptId              (void);
+
+void SEGGER_SYSVIEW_X_StartComm                   (void);
+void SEGGER_SYSVIEW_X_OnEventRecorded             (unsigned NumBytes);
+
+#ifdef __cplusplus
+}
+#endif
+
+/*********************************************************************
+*
+*       Compatibility API defines
+*/
+#define SEGGER_SYSVIEW_OnUserStart      SEGGER_SYSVIEW_MarkStart
+#define SEGGER_SYSVIEW_OnUserStop       SEGGER_SYSVIEW_MarkStop
+
+#endif
+
+/*************************** End of file ****************************/
diff --git a/sched/systemview/SEGGER_SYSVIEW_Conf.h b/sched/systemview/SEGGER_SYSVIEW_Conf.h
new file mode 100644
index 0000000000..58bc46709f
--- /dev/null
+++ b/sched/systemview/SEGGER_SYSVIEW_Conf.h
@@ -0,0 +1,203 @@
+/*********************************************************************
+*                    SEGGER Microcontroller GmbH                     *
+*                        The Embedded Experts                        *
+**********************************************************************
+*                                                                    *
+*            (c) 1995 - 2019 SEGGER Microcontroller GmbH             *
+*                                                                    *
+*       www.segger.com     Support: support@segger.com               *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SEGGER SystemView * Real-time application analysis           *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+* All rights reserved.                                               *
+*                                                                    *
+* SEGGER strongly recommends to not make any changes                 *
+* to or modify the source code of this software in order to stay     *
+* compatible with the SystemView and RTT protocol, and J-Link.       *
+*                                                                    *
+* Redistribution and use in source and binary forms, with or         *
+* without modification, are permitted provided that the following    *
+* condition is met:                                                  *
+*                                                                    *
+* o Redistributions of source code must retain the above copyright   *
+*   notice, this condition and the following disclaimer.             *
+*                                                                    *
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
+* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
+* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
+* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
+* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
+* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
+* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
+* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
+* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
+* DAMAGE.                                                            *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SystemView version: V3.12                                    *
+*                                                                    *
+**********************************************************************
+-------------------------- END-OF-HEADER -----------------------------
+
+File    : SEGGER_SYSVIEW_Conf.h
+Purpose : SEGGER SystemView configuration.
+Revision: $Rev: 17066 $
+*/
+
+#include <nuttx/config.h>
+
+#ifndef SEGGER_SYSVIEW_CONF_H
+#define SEGGER_SYSVIEW_CONF_H
+
+/*********************************************************************
+*
+*       Defines, fixed
+*
+**********************************************************************
+*/
+//
+// Constants for known core configuration
+//
+#define SEGGER_SYSVIEW_CORE_OTHER   0
+#define SEGGER_SYSVIEW_CORE_CM0     1 // Cortex-M0/M0+/M1
+#define SEGGER_SYSVIEW_CORE_CM3     2 // Cortex-M3/M4/M7
+#define SEGGER_SYSVIEW_CORE_RX      3 // Renesas RX
+
+#if (defined __SES_ARM) || (defined __CROSSWORKS_ARM) || (defined __GNUC__) || (defined __clang__)
+  #if (defined __ARM_ARCH_6M__) || (defined __ARM_ARCH_8M_BASE__)
+    #define SEGGER_SYSVIEW_CORE SEGGER_SYSVIEW_CORE_CM0
+  #elif (defined(__ARM_ARCH_7M__) || defined(__ARM_ARCH_7EM__) || defined(__ARM_ARCH_8M_MAIN__))
+    #define SEGGER_SYSVIEW_CORE SEGGER_SYSVIEW_CORE_CM3
+  #endif
+#elif defined(__ICCARM__)
+  #if (defined (__ARM6M__)          && (__CORE__ == __ARM6M__))          \
+   || (defined (__ARM8M_BASELINE__) && (__CORE__ == __ARM8M_BASELINE__))
+    #define SEGGER_SYSVIEW_CORE SEGGER_SYSVIEW_CORE_CM0
+  #elif (defined (__ARM7EM__)         && (__CORE__ == __ARM7EM__))         \
+     || (defined (__ARM7M__)          && (__CORE__ == __ARM7M__))          \
+     || (defined (__ARM8M_MAINLINE__) && (__CORE__ == __ARM8M_MAINLINE__)) \
+     || (defined (__ARM8M_MAINLINE__) && (__CORE__ == __ARM8M_MAINLINE__))
+    #define SEGGER_SYSVIEW_CORE SEGGER_SYSVIEW_CORE_CM3
+  #endif
+#elif defined(__CC_ARM)
+  #if (defined(__TARGET_ARCH_6S_M))
+    #define SEGGER_SYSVIEW_CORE SEGGER_SYSVIEW_CORE_CM0
+  #elif (defined(__TARGET_ARCH_7_M) || defined(__TARGET_ARCH_7E_M))
+    #define SEGGER_SYSVIEW_CORE SEGGER_SYSVIEW_CORE_CM3
+  #endif
+#elif defined(__TI_ARM__)
+  #ifdef __TI_ARM_V6M0__
+    #define SEGGER_SYSVIEW_CORE SEGGER_SYSVIEW_CORE_CM0
+  #elif (defined(__TI_ARM_V7M3__) || defined(__TI_ARM_V7M4__))
+    #define SEGGER_SYSVIEW_CORE SEGGER_SYSVIEW_CORE_CM3
+  #endif
+#elif defined(__ICCRX__)
+  #define SEGGER_SYSVIEW_CORE SEGGER_SYSVIEW_CORE_RX
+#elif defined(__RX)
+  #define SEGGER_SYSVIEW_CORE SEGGER_SYSVIEW_CORE_RX
+#endif
+
+#ifndef   SEGGER_SYSVIEW_CORE
+  #define SEGGER_SYSVIEW_CORE SEGGER_SYSVIEW_CORE_OTHER
+#endif
+
+#ifndef   SEGGER_SYSVIEW_ON_EVENT_RECORDED
+  #define SEGGER_SYSVIEW_ON_EVENT_RECORDED(NumBytes)                            // Needed for SystemView via non-J-Link Recorder. Macro to enable the UART or notify IP task.
+#endif
+
+/*********************************************************************
+*
+*       Defines, configurable
+*
+**********************************************************************
+*/
+/*********************************************************************
+*
+*       SystemView buffer configuration
+*/
+#ifndef   SEGGER_SYSVIEW_RTT_BUFFER_SIZE
+  #define SEGGER_SYSVIEW_RTT_BUFFER_SIZE        CONFIG_SYSTEMVIEW_BUFFER_SIZE   // Number of bytes that SystemView uses for the buffer.
+#endif
+
+#ifndef   SEGGER_SYSVIEW_RTT_CHANNEL
+  #define SEGGER_SYSVIEW_RTT_CHANNEL            CONFIG_SYSTEMVIEW_RTT_CHANNEL   // The RTT channel that SystemView will use. 0: Auto selection
+#endif
+
+#ifndef   SEGGER_SYSVIEW_USE_STATIC_BUFFER
+#ifdef CONFIG_SYSTEMVIEW_USE_STATIC_BUFFER
+  #define SEGGER_SYSVIEW_USE_STATIC_BUFFER      1                               // Use a static buffer to generate events instead of a buffer on the stack
+#else
+  #define SEGGER_SYSVIEW_USE_STATIC_BUFFER      0                               // Use a static buffer to generate events instead of a buffer on the stack
+#endif
+#endif
+
+#ifndef   SEGGER_SYSVIEW_POST_MORTEM_MODE
+#ifdef   CONFIG_SYSTEMVIEW_POST_MORTEM_MODE
+  #define SEGGER_SYSVIEW_POST_MORTEM_MODE       1                               // 1: Enable post mortem analysis mode
+#else
+  #define SEGGER_SYSVIEW_POST_MORTEM_MODE       0                               // 1: Enable post mortem analysis mode
+#endif
+#endif
+
+#ifndef   SEGGER_SYSVIEW_CAN_RESTART
+  #define SEGGER_SYSVIEW_CAN_RESTART            1                               // 1: Send the SystemView start sequence on every start command, not just on the first. Enables restart when SystemView Application disconnected unexpectedly.
+#endif
+
+/*********************************************************************
+*
+*       SystemView timestamp configuration
+*/
+#if !defined(SEGGER_SYSVIEW_GET_TIMESTAMP) && !defined(SEGGER_SYSVIEW_TIMESTAMP_BITS)
+  #if SEGGER_SYSVIEW_CORE == SEGGER_SYSVIEW_CORE_CM3
+    #define SEGGER_SYSVIEW_GET_TIMESTAMP()      (*(U32 *)(0xE0001004))          // Retrieve a system timestamp. Cortex-M cycle counter.
+    #define SEGGER_SYSVIEW_TIMESTAMP_BITS       32                              // Define number of valid bits low-order delivered by clock source
+  #else
+    #define SEGGER_SYSVIEW_GET_TIMESTAMP()      SEGGER_SYSVIEW_X_GetTimestamp() // Retrieve a system timestamp via user-defined function
+    #define SEGGER_SYSVIEW_TIMESTAMP_BITS       32                              // Define number of valid bits low-order delivered by SEGGER_SYSVIEW_X_GetTimestamp()
+  #endif
+#endif
+
+/*********************************************************************
+*
+*       SystemView Id configuration
+*/
+#ifndef   SEGGER_SYSVIEW_ID_BASE
+  #define SEGGER_SYSVIEW_ID_BASE                CONFIG_SYSTEMVIEW_RES_ID_BASE                      // Default value for the lowest Id reported by the application. Can be overridden by the application via SEGGER_SYSVIEW_SetRAMBase(). (i.e. 0x20000000 when all Ids are an address in this RAM)
+#endif
+
+#ifndef   SEGGER_SYSVIEW_ID_SHIFT
+  #define SEGGER_SYSVIEW_ID_SHIFT               CONFIG_SYSTEMVIEW_RES_ID_SHIFT                               // Number of bits to shift the Id to save bandwidth. (i.e. 2 when Ids are 4 byte aligned)
+#endif
+/*********************************************************************
+*
+*       SystemView interrupt configuration
+*/
+#ifndef SEGGER_SYSVIEW_GET_INTERRUPT_ID
+  #if SEGGER_SYSVIEW_CORE == SEGGER_SYSVIEW_CORE_CM3
+    #define SEGGER_SYSVIEW_GET_INTERRUPT_ID()      ((*(U32*)(0xE000ED04)) & 0x1FF)    // Get the currently active interrupt Id. (i.e. read Cortex-M ICSR[8:0] = active vector)
+  #elif SEGGER_SYSVIEW_CORE == SEGGER_SYSVIEW_CORE_CM0
+    #if defined(__ICCARM__)
+      #if (__VER__ > 6010000)
+        #define SEGGER_SYSVIEW_GET_INTERRUPT_ID()  (__get_IPSR())                     // Workaround for IAR, which might do a byte-access to 0xE000ED04. Read IPSR instead.
+      #else
+        #define SEGGER_SYSVIEW_GET_INTERRUPT_ID()  ((*(U32*)(0xE000ED04)) & 0x3F)     // Older versions of IAR do not include __get_IPSR, but might also not optimize to byte-access.
+      #endif
+    #else
+      #define SEGGER_SYSVIEW_GET_INTERRUPT_ID()    ((*(U32*)(0xE000ED04)) & 0x3F)     // Get the currently active interrupt Id. (i.e. read Cortex-M ICSR[5:0] = active vector)
+    #endif
+  #else
+    #define SEGGER_SYSVIEW_GET_INTERRUPT_ID()      SEGGER_SYSVIEW_X_GetInterruptId()  // Get the currently active interrupt Id from the user-provided function.
+  #endif
+#endif
+
+#endif  // SEGGER_SYSVIEW_CONF_H
+
+/*************************** End of file ****************************/
diff --git a/sched/systemview/SEGGER_SYSVIEW_ConfDefaults.h b/sched/systemview/SEGGER_SYSVIEW_ConfDefaults.h
new file mode 100644
index 0000000000..0196fbd446
--- /dev/null
+++ b/sched/systemview/SEGGER_SYSVIEW_ConfDefaults.h
@@ -0,0 +1,172 @@
+/*********************************************************************
+*                    SEGGER Microcontroller GmbH                     *
+*                        The Embedded Experts                        *
+**********************************************************************
+*                                                                    *
+*            (c) 1995 - 2019 SEGGER Microcontroller GmbH             *
+*                                                                    *
+*       www.segger.com     Support: support@segger.com               *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SEGGER SystemView * Real-time application analysis           *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+* All rights reserved.                                               *
+*                                                                    *
+* SEGGER strongly recommends to not make any changes                 *
+* to or modify the source code of this software in order to stay     *
+* compatible with the SystemView and RTT protocol, and J-Link.       *
+*                                                                    *
+* Redistribution and use in source and binary forms, with or         *
+* without modification, are permitted provided that the following    *
+* condition is met:                                                  *
+*                                                                    *
+* o Redistributions of source code must retain the above copyright   *
+*   notice, this condition and the following disclaimer.             *
+*                                                                    *
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
+* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
+* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
+* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
+* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
+* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
+* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
+* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
+* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
+* DAMAGE.                                                            *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SystemView version: V3.12                                    *
+*                                                                    *
+**********************************************************************
+-------------------------- END-OF-HEADER -----------------------------
+File    : SEGGER_SYSVIEW_ConfDefaults.h
+Purpose : Defines defaults for configurable defines used in
+          SEGGER SystemView.
+Revision: $Rev: 9599 $
+*/
+
+#ifndef SEGGER_SYSVIEW_CONFDEFAULTS_H
+#define SEGGER_SYSVIEW_CONFDEFAULTS_H
+
+/*********************************************************************
+*
+*       #include Section
+*
+**********************************************************************
+*/
+
+#include "SEGGER_SYSVIEW_Conf.h"
+#include "SEGGER_RTT_Conf.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*********************************************************************
+*
+*       Configuration defaults
+*
+**********************************************************************
+*/
+
+// Number of bytes that SystemView uses for a buffer.
+#ifndef   SEGGER_SYSVIEW_RTT_BUFFER_SIZE
+  #define SEGGER_SYSVIEW_RTT_BUFFER_SIZE    1024
+#endif
+
+// The RTT channel that SystemView will use.
+#ifndef   SEGGER_SYSVIEW_RTT_CHANNEL
+  #define SEGGER_SYSVIEW_RTT_CHANNEL        0
+#endif
+// Sanity check of RTT channel
+#if (SEGGER_SYSVIEW_RTT_CHANNEL == 0) && (SEGGER_RTT_MAX_NUM_UP_BUFFERS < 2)
+  #error "SEGGER_RTT_MAX_NUM_UP_BUFFERS in SEGGER_RTT_Conf.h has to be > 1!"
+#elif (SEGGER_SYSVIEW_RTT_CHANNEL >= SEGGER_RTT_MAX_NUM_UP_BUFFERS)
+  #error "SEGGER_RTT_MAX_NUM_UP_BUFFERS  in SEGGER_RTT_Conf.h has to be > SEGGER_SYSVIEW_RTT_CHANNEL!"
+#endif
+
+// Place the SystemView buffer into its own/the RTT section
+#if !(defined SEGGER_SYSVIEW_BUFFER_SECTION) && (defined SEGGER_RTT_SECTION)
+  #define SEGGER_SYSVIEW_BUFFER_SECTION            SEGGER_RTT_SECTION
+#endif
+
+// Retrieve a system timestamp.  This gets the Cortex-M cycle counter.
+#ifndef   SEGGER_SYSVIEW_GET_TIMESTAMP
+  #error "SEGGER_SYSVIEW_GET_TIMESTAMP has to be defined in SEGGER_SYSVIEW_Conf.h!"
+#endif
+
+// Define number of valid bits low-order delivered by clock source.
+#ifndef   SEGGER_SYSVIEW_TIMESTAMP_BITS
+  #define SEGGER_SYSVIEW_TIMESTAMP_BITS     32
+#endif
+
+// Lowest Id reported by the Application.
+#ifndef   SEGGER_SYSVIEW_ID_BASE 
+  #define SEGGER_SYSVIEW_ID_BASE            0
+#endif
+
+// Number of bits to shift Ids to save bandwidth
+#ifndef   SEGGER_SYSVIEW_ID_SHIFT
+  #define SEGGER_SYSVIEW_ID_SHIFT           0
+#endif
+
+#ifndef   SEGGER_SYSVIEW_GET_INTERRUPT_ID
+  #error "SEGGER_SYSVIEW_GET_INTERRUPT_ID has to be defined in SEGGER_SYSVIEW_Conf.h!"
+#endif
+
+#ifndef   SEGGER_SYSVIEW_MAX_ARGUMENTS
+  #define SEGGER_SYSVIEW_MAX_ARGUMENTS      16
+#endif
+
+#ifndef   SEGGER_SYSVIEW_MAX_STRING_LEN
+  #define SEGGER_SYSVIEW_MAX_STRING_LEN     128
+#endif
+
+#ifndef   SEGGER_SYSVIEW_PRINTF_IMPLICIT_FORMAT
+  #define SEGGER_SYSVIEW_PRINTF_IMPLICIT_FORMAT 0
+#endif
+
+// Use a static buffer instead of a buffer on the stack for packets
+#ifndef   SEGGER_SYSVIEW_USE_STATIC_BUFFER
+  #define SEGGER_SYSVIEW_USE_STATIC_BUFFER  1
+#endif
+
+// Maximum packet size used by SystemView for the static buffer
+#ifndef   SEGGER_SYSVIEW_MAX_PACKET_SIZE
+  #define SEGGER_SYSVIEW_MAX_PACKET_SIZE   SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_MAX_STRING_LEN + 2 * SEGGER_SYSVIEW_QUANTA_U32 + SEGGER_SYSVIEW_MAX_ARGUMENTS * SEGGER_SYSVIEW_QUANTA_U32
+#endif
+
+// Use post-mortem analysis instead of real-time analysis
+#ifndef   SEGGER_SYSVIEW_POST_MORTEM_MODE
+  #define SEGGER_SYSVIEW_POST_MORTEM_MODE   0
+#endif
+
+// Configure how frequently syncronization is sent
+#ifndef   SEGGER_SYSVIEW_SYNC_PERIOD_SHIFT
+  #define SEGGER_SYSVIEW_SYNC_PERIOD_SHIFT  8
+#endif
+
+// Lock SystemView (nestable)
+#ifndef   SEGGER_SYSVIEW_LOCK
+  #define SEGGER_SYSVIEW_LOCK()             SEGGER_RTT_LOCK()
+#endif
+
+// Unlock SystemView (nestable)
+#ifndef   SEGGER_SYSVIEW_UNLOCK
+  #define SEGGER_SYSVIEW_UNLOCK()           SEGGER_RTT_UNLOCK()
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+/*************************** End of file ****************************/
diff --git a/sched/systemview/SEGGER_SYSVIEW_Config_NuttX.c b/sched/systemview/SEGGER_SYSVIEW_Config_NuttX.c
new file mode 100644
index 0000000000..95244fd7e9
--- /dev/null
+++ b/sched/systemview/SEGGER_SYSVIEW_Config_NuttX.c
@@ -0,0 +1,194 @@
+/*********************************************************************
+*                    SEGGER Microcontroller GmbH                     *
+*                        The Embedded Experts                        *
+**********************************************************************
+*                                                                    *
+*            (c) 1995 - 2019 SEGGER Microcontroller GmbH             *
+*                                                                    *
+*       www.segger.com     Support: support@segger.com               *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SEGGER SystemView * Real-time application analysis           *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+* All rights reserved.                                               *
+*                                                                    *
+* SEGGER strongly recommends to not make any changes                 *
+* to or modify the source code of this software in order to stay     *
+* compatible with the SystemView and RTT protocol, and J-Link.       *
+*                                                                    *
+* Redistribution and use in source and binary forms, with or         *
+* without modification, are permitted provided that the following    *
+* condition is met:                                                  *
+*                                                                    *
+* o Redistributions of source code must retain the above copyright   *
+*   notice, this condition and the following disclaimer.             *
+*                                                                    *
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
+* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
+* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
+* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
+* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
+* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
+* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
+* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
+* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
+* DAMAGE.                                                            *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SystemView version: V3.12                                    *
+*                                                                    *
+**********************************************************************
+-------------------------- END-OF-HEADER -----------------------------
+
+File    : SEGGER_SYSVIEW_Config_NuttX.c
+Purpose : Sample setup configuration of SystemView with NuttX.
+Revision: $Rev$
+*/
+#include "SEGGER_SYSVIEW.h"
+#include "SEGGER_SYSVIEW_Conf.h"
+#include "SEGGER_SYSVIEW_NuttX.h"
+
+
+/*********************************************************************
+*
+*       Defines, configurable
+*
+**********************************************************************
+*/
+#ifndef CONFIG_SYSTEMVIEW_APP_NAME
+#error CONFIG_SYSTEMVIEW_APP_NAME undefined!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+#endif
+// The application name to be displayed in SystemViewer
+#ifndef   SYSVIEW_APP_NAME
+  #define SYSVIEW_APP_NAME        CONFIG_SYSTEMVIEW_APP_NAME
+#endif
+
+// The target device name
+#ifndef   SYSVIEW_DEVICE_NAME
+  #define SYSVIEW_DEVICE_NAME     CONFIG_SYSTEMVIEW_DEVICE_NAME
+#endif
+
+// Frequency of the timestamp. Must match SEGGER_SYSVIEW_Conf.h
+#ifndef   SYSVIEW_TIMESTAMP_FREQ
+  #define SYSVIEW_TIMESTAMP_FREQ  (CONFIG_SYSTEMVIEW_TIMESTAMP_FREQ)
+#endif
+
+// System Frequency. SystemcoreClock is used in most CMSIS compatible projects.
+#ifndef   SYSVIEW_CPU_FREQ
+  #define SYSVIEW_CPU_FREQ        (CONFIG_SYSTEMVIEW_CPU_FREQ)
+#endif
+
+// The lowest RAM address used for IDs (pointers)
+#ifndef   SYSVIEW_RAM_BASE
+  #define SYSVIEW_RAM_BASE        (CONFIG_SYSTEMVIEW_RES_ID_BASE)
+#endif
+
+#ifndef   SYSVIEW_SYSDESC0
+  #define SYSVIEW_SYSDESC0        CONFIG_SYSTEMVIEW_SYSDESC_0
+#endif
+
+// Define as 1 if the Cortex-M cycle counter is used as SystemView timestamp. Must match SEGGER_SYSVIEW_Conf.h
+#ifndef   USE_CYCCNT_TIMESTAMP
+  #define USE_CYCCNT_TIMESTAMP    1
+#endif
+
+// Define as 1 if the Cortex-M cycle counter is used and there might be no debugger attached while recording,
+// for example in post-mortem mode, or when recording via IP.
+#ifndef   ENABLE_DWT_CYCCNT
+  #define ENABLE_DWT_CYCCNT       (USE_CYCCNT_TIMESTAMP & SEGGER_SYSVIEW_POST_MORTEM_MODE)
+#endif
+
+// Define as 1 to immediately start recording after initialization to catch system initialization.
+#ifndef   SYSVIEW_START_ON_INIT
+#ifdef CONFIG_SYSTEMVIEW_START_ON_INIT
+  #define SYSVIEW_START_ON_INIT   1
+#else
+  #define SYSVIEW_START_ON_INIT   0
+#endif
+#endif
+
+//#ifndef   SYSVIEW_SYSDESC1
+//  #define SYSVIEW_SYSDESC1      ""
+//#endif
+
+//#ifndef   SYSVIEW_SYSDESC2
+//  #define SYSVIEW_SYSDESC2      ""
+//#endif
+
+/*********************************************************************
+*
+*       Defines, fixed
+*
+**********************************************************************
+*/
+#define DEMCR         (*(volatile U32*) (0xE000EDFCuL))  // Debug Exception and Monitor Control Register
+#define TRACEENA_BIT  (1uL << 24)                        // Trace enable bit
+#define DWT_CTRL      (*(volatile U32*) (0xE0001000uL))  // DWT Control Register
+#define NOCYCCNT_BIT  (1uL << 25)                        // Cycle counter support bit
+#define CYCCNTENA_BIT (1uL << 0)                         // Cycle counter enable bit
+
+/*********************************************************************
+*
+*       _cbSendSystemDesc()
+*
+*  Function description
+*    Sends SystemView description strings.
+*/
+static void _cbSendSystemDesc(void) {
+  SEGGER_SYSVIEW_SendSysDesc("N=" SYSVIEW_APP_NAME ",O=NuttX,D=" SYSVIEW_DEVICE_NAME );
+#ifdef SYSVIEW_SYSDESC0
+  SEGGER_SYSVIEW_SendSysDesc(SYSVIEW_SYSDESC0);
+#endif
+#ifdef SYSVIEW_SYSDESC1
+  SEGGER_SYSVIEW_SendSysDesc(SYSVIEW_SYSDESC1);
+#endif
+#ifdef SYSVIEW_SYSDESC2
+  SEGGER_SYSVIEW_SendSysDesc(SYSVIEW_SYSDESC2);
+#endif
+}
+
+/*********************************************************************
+*
+*       Global functions
+*
+**********************************************************************
+*/
+void SEGGER_SYSVIEW_Conf(void) {
+#if USE_CYCCNT_TIMESTAMP
+#if ENABLE_DWT_CYCCNT
+  //
+  // If no debugger is connected, the DWT must be enabled by the application
+  //
+  if ((DEMCR & TRACEENA_BIT) == 0) {
+    DEMCR |= TRACEENA_BIT;
+  }
+#endif
+  //
+  //  The cycle counter must be activated in order
+  //  to use time related functions.
+  //
+  if ((DWT_CTRL & NOCYCCNT_BIT) == 0) {       // Cycle counter supported?
+    if ((DWT_CTRL & CYCCNTENA_BIT) == 0) {    // Cycle counter not enabled?
+      DWT_CTRL |= CYCCNTENA_BIT;              // Enable Cycle counter
+    }
+  }
+#endif
+  SEGGER_SYSVIEW_Init(SYSVIEW_TIMESTAMP_FREQ, SYSVIEW_CPU_FREQ,
+                      &SYSVIEW_X_OS_TraceAPI, _cbSendSystemDesc);
+  SEGGER_SYSVIEW_SetRAMBase(SYSVIEW_RAM_BASE);
+
+  SYSVIEW_InitTime();
+
+#if SYSVIEW_START_ON_INIT
+  SEGGER_SYSVIEW_Start();                     // Start recording to catch system initialization.
+#endif
+}
+
+/*************************** End of file ****************************/
diff --git a/sched/systemview/SEGGER_SYSVIEW_Int.h b/sched/systemview/SEGGER_SYSVIEW_Int.h
new file mode 100644
index 0000000000..b97bbec211
--- /dev/null
+++ b/sched/systemview/SEGGER_SYSVIEW_Int.h
@@ -0,0 +1,100 @@
+/*********************************************************************
+*                    SEGGER Microcontroller GmbH                     *
+*                        The Embedded Experts                        *
+**********************************************************************
+*                                                                    *
+*            (c) 1995 - 2019 SEGGER Microcontroller GmbH             *
+*                                                                    *
+*       www.segger.com     Support: support@segger.com               *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SEGGER SystemView * Real-time application analysis           *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+* All rights reserved.                                               *
+*                                                                    *
+* SEGGER strongly recommends to not make any changes                 *
+* to or modify the source code of this software in order to stay     *
+* compatible with the SystemView and RTT protocol, and J-Link.       *
+*                                                                    *
+* Redistribution and use in source and binary forms, with or         *
+* without modification, are permitted provided that the following    *
+* condition is met:                                                  *
+*                                                                    *
+* o Redistributions of source code must retain the above copyright   *
+*   notice, this condition and the following disclaimer.             *
+*                                                                    *
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
+* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
+* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
+* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
+* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
+* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
+* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
+* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
+* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
+* DAMAGE.                                                            *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SystemView version: V3.12                                    *
+*                                                                    *
+**********************************************************************
+-------------------------- END-OF-HEADER -----------------------------
+File    : SEGGER_SYSVIEW_Int.h
+Purpose : SEGGER SystemView internal header.
+Revision: $Rev: 9599 $
+*/
+
+#ifndef SEGGER_SYSVIEW_INT_H
+#define SEGGER_SYSVIEW_INT_H
+
+/*********************************************************************
+*
+*       #include Section
+*
+**********************************************************************
+*/
+
+#include "SEGGER_SYSVIEW.h"
+#include "SEGGER_SYSVIEW_Conf.h"
+#include "SEGGER_SYSVIEW_ConfDefaults.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/*********************************************************************
+*
+*       Private data types
+*
+**********************************************************************
+*/
+//
+// Commands that Host can send to target
+//
+typedef enum {
+  SEGGER_SYSVIEW_COMMAND_ID_START = 1,
+  SEGGER_SYSVIEW_COMMAND_ID_STOP,
+  SEGGER_SYSVIEW_COMMAND_ID_GET_SYSTIME,
+  SEGGER_SYSVIEW_COMMAND_ID_GET_TASKLIST,
+  SEGGER_SYSVIEW_COMMAND_ID_GET_SYSDESC,
+  SEGGER_SYSVIEW_COMMAND_ID_GET_NUMMODULES,
+  SEGGER_SYSVIEW_COMMAND_ID_GET_MODULEDESC,
+  // Extended commands: Commands >= 128 have a second parameter
+  SEGGER_SYSVIEW_COMMAND_ID_GET_MODULE = 128
+} SEGGER_SYSVIEW_COMMAND_ID;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+/*************************** End of file ****************************/
diff --git a/sched/systemview/SEGGER_SYSVIEW_NuttX.c b/sched/systemview/SEGGER_SYSVIEW_NuttX.c
new file mode 100644
index 0000000000..586bdaeec5
--- /dev/null
+++ b/sched/systemview/SEGGER_SYSVIEW_NuttX.c
@@ -0,0 +1,269 @@
+/*********************************************************************
+*                    SEGGER Microcontroller GmbH                     *
+*                        The Embedded Experts                        *
+**********************************************************************
+*                                                                    *
+*            (c) 1995 - 2019 SEGGER Microcontroller GmbH             *
+*                                                                    *
+*       www.segger.com     Support: support@segger.com               *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SEGGER SystemView * Real-time application analysis           *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+* All rights reserved.                                               *
+*                                                                    *
+* SEGGER strongly recommends to not make any changes                 *
+* to or modify the source code of this software in order to stay     *
+* compatible with the SystemView and RTT protocol, and J-Link.       *
+*                                                                    *
+* Redistribution and use in source and binary forms, with or         *
+* without modification, are permitted provided that the following    *
+* condition is met:                                                  *
+*                                                                    *
+* o Redistributions of source code must retain the above copyright   *
+*   notice, this condition and the following disclaimer.             *
+*                                                                    *
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
+* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
+* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
+* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
+* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
+* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
+* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
+* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
+* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
+* DAMAGE.                                                            *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SystemView version: V3.12                                    *
+*                                                                    *
+**********************************************************************
+-------------------------- END-OF-HEADER -----------------------------
+
+File    : SEGGER_SYSVIEW_NuttX.c
+Purpose : Interface between NuttX and SystemView.
+Revision: $Rev $
+*/
+#include <nuttx/config.h>
+
+#include "SEGGER_SYSVIEW.h"
+#include "SEGGER_SYSVIEW_NuttX.h"
+#include "string.h" // Required for memset
+
+#include <time.h>
+
+
+#ifdef CONFIG_CLOCK_MONOTONIC
+#  define _TIME_CLOCK CLOCK_MONOTONIC
+#else
+#  define _TIME_CLOCK CLOCK_REALTIME
+#endif
+
+
+typedef struct _SYSVIEW_NUTTX_TASK_STATUS _SYSVIEW_NUTTX_TASK_STATUS;
+
+struct _SYSVIEW_NUTTX_TASK_STATUS {
+  U32         TaskID;
+  const char* sName;
+  unsigned    Priority;
+  U32         StackAddr;
+  unsigned    StackSize;
+};
+
+static _SYSVIEW_NUTTX_TASK_STATUS _aTasks[SYSVIEW_NUTTX_MAX_NOF_TASKS];
+static unsigned _NumTasks;
+
+
+static U64      _Time;
+static U64      _TimeStart;
+
+/*********************************************************************
+*
+*       _cbSendTaskList()
+*
+*  Function description
+*    This function is part of the link between NuttX and SYSVIEW.
+*    Called from SystemView when asked by the host, it uses SYSVIEW
+*    functions to send the entire task list to the host.
+*/
+static void _cbSendTaskList(void) {
+  unsigned n;
+
+  for (n = 0; n < _NumTasks; n++) {
+    SYSVIEW_SendTaskInfo(_aTasks[n].TaskID, _aTasks[n].sName, _aTasks[n].Priority, _aTasks[n].StackAddr, _aTasks[n].StackSize);
+  }
+}
+
+/*********************************************************************
+*
+*       _cbGetTime()
+*
+*  Function description
+*    This function is part of the link between FreeRTOS and SYSVIEW.
+*    Called from SystemView when asked by the host, returns the
+*    current system time in micro seconds.
+*/
+static U64 _cbGetTime(void) {
+  struct timespec TimeSpec;
+  int             r;
+
+  r = clock_gettime(_TIME_CLOCK, &TimeSpec);
+
+  if (r >= 0) {
+    _Time = (U64)TimeSpec.tv_sec;
+    _Time *= 1000000uLL;
+    _Time += TimeSpec.tv_nsec / 1000u;
+  }
+  return _Time - _TimeStart;
+}
+
+/*********************************************************************
+*
+*       Global functions
+*
+**********************************************************************
+*/
+/*********************************************************************
+*
+*       SYSVIEW_InitTime()
+*
+*  Function description
+*    Initialize system time of SystemView, to start at 0 with the initialization.
+*/
+void SYSVIEW_InitTime(void) {
+  _TimeStart = 0;
+  _TimeStart = _cbGetTime();
+}
+
+/*********************************************************************
+*
+*       SYSVIEW_AddTask()
+*
+*  Function description
+*    Add a task to the internal list and record its information.
+*/
+void SYSVIEW_AddTask(U32 TaskID, const char* sName, unsigned Priority, U32 StackAddr, unsigned StackSize) {
+  
+  if (_NumTasks >= SYSVIEW_NUTTX_MAX_NOF_TASKS) {
+    SEGGER_SYSVIEW_Warn("SYSTEMVIEW: Could not record task information. Maximum number of tasks reached.");
+    return;
+  }
+
+  _aTasks[_NumTasks].TaskID = TaskID;
+  _aTasks[_NumTasks].sName = sName;
+  _aTasks[_NumTasks].Priority = Priority;
+  _aTasks[_NumTasks].StackAddr = StackAddr;
+  _aTasks[_NumTasks].StackSize = StackSize;
+
+  _NumTasks++;
+
+  SYSVIEW_SendTaskInfo(TaskID, sName, Priority, StackAddr, StackSize);
+}
+
+/*********************************************************************
+*
+*       SYSVIEW_UpdateTask()
+*
+*  Function description
+*    Update a task in the internal list and record its information.
+*/
+void SYSVIEW_UpdateTask(U32 TaskID, const char* sName, unsigned Priority, U32 StackAddr, unsigned StackSize) {
+  unsigned n;
+
+  for (n = 0; n < _NumTasks; n++) {
+    if (_aTasks[n].TaskID == TaskID) {
+      break;
+    }
+  }
+  if (n < _NumTasks) {
+    _aTasks[n].sName = sName;
+    _aTasks[n].Priority = Priority;
+    _aTasks[n].StackAddr = StackAddr;
+    _aTasks[n].StackSize = StackSize;
+
+    SYSVIEW_SendTaskInfo(TaskID, sName, Priority, StackAddr, StackSize);
+  } else {
+    SYSVIEW_AddTask(TaskID, sName, Priority, StackAddr, StackSize);
+  }
+}
+
+/*********************************************************************
+*
+*       SYSVIEW_DeleteTask()
+*
+*  Function description
+*    Delete a task from the internal list.
+*/
+void SYSVIEW_DeleteTask(U32 TaskID) {
+  unsigned n;
+  
+  if (_NumTasks == 0) {
+    return; // Early out
+  }  
+  for (n = 0; n < _NumTasks; n++) {
+    if (_aTasks[n].TaskID == TaskID) {
+      break;
+    }
+  }
+  if (n == (_NumTasks - 1)) {  
+    //
+    // Task is last item in list.
+    // Simply zero the item and decrement number of tasks.
+    //
+    memset(&_aTasks[n], 0, sizeof(_aTasks[n]));
+    _NumTasks--;
+  } else if (n < _NumTasks) {
+    //
+    // Task is in the middle of the list.
+    // Move last item to current position and decrement number of tasks.
+    // Order of tasks does not really matter, so no need to move all following items.
+    //
+    _aTasks[n].TaskID         = _aTasks[_NumTasks - 1].TaskID;
+    _aTasks[n].sName          = _aTasks[_NumTasks - 1].sName;
+    _aTasks[n].Priority       = _aTasks[_NumTasks - 1].Priority;
+    _aTasks[n].StackAddr      = _aTasks[_NumTasks - 1].StackAddr;
+    _aTasks[n].StackSize      = _aTasks[_NumTasks - 1].StackSize;
+    memset(&_aTasks[_NumTasks - 1], 0, sizeof(_aTasks[_NumTasks - 1]));
+    _NumTasks--;
+  }
+}
+
+/*********************************************************************
+*
+*       SYSVIEW_SendTaskInfo()
+*
+*  Function description
+*    Record task information.
+*/
+void SYSVIEW_SendTaskInfo(U32 TaskID, const char* sName, unsigned Prio, U32 StackAddr, unsigned StackSize) {
+  SEGGER_SYSVIEW_TASKINFO TaskInfo;
+
+  memset(&TaskInfo, 0, sizeof(TaskInfo)); // Fill all elements with 0 to allow extending the structure in future version without breaking the code
+  TaskInfo.TaskID     = TaskID;
+  TaskInfo.sName      = sName;
+  TaskInfo.Prio       = Prio;
+  TaskInfo.StackBase  = StackAddr;
+  TaskInfo.StackSize  = StackSize;
+  SEGGER_SYSVIEW_SendTaskInfo(&TaskInfo);
+}
+
+/*********************************************************************
+*
+*       Public API structures
+*
+**********************************************************************
+*/
+// Callbacks provided to SYSTEMVIEW by FreeRTOS
+const SEGGER_SYSVIEW_OS_API SYSVIEW_X_OS_TraceAPI = {
+  _cbGetTime,
+  _cbSendTaskList,
+};
+
+/*************************** End of file ****************************/
diff --git a/sched/systemview/SEGGER_SYSVIEW_NuttX.h b/sched/systemview/SEGGER_SYSVIEW_NuttX.h
new file mode 100644
index 0000000000..b63abbaff2
--- /dev/null
+++ b/sched/systemview/SEGGER_SYSVIEW_NuttX.h
@@ -0,0 +1,156 @@
+/*********************************************************************
+*                    SEGGER Microcontroller GmbH                     *
+*                        The Embedded Experts                        *
+**********************************************************************
+*                                                                    *
+*            (c) 1995 - 2019 SEGGER Microcontroller GmbH             *
+*                                                                    *
+*       www.segger.com     Support: support@segger.com               *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SEGGER SystemView * Real-time application analysis           *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+* All rights reserved.                                               *
+*                                                                    *
+* SEGGER strongly recommends to not make any changes                 *
+* to or modify the source code of this software in order to stay     *
+* compatible with the SystemView and RTT protocol, and J-Link.       *
+*                                                                    *
+* Redistribution and use in source and binary forms, with or         *
+* without modification, are permitted provided that the following    *
+* condition is met:                                                  *
+*                                                                    *
+* o Redistributions of source code must retain the above copyright   *
+*   notice, this condition and the following disclaimer.             *
+*                                                                    *
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
+* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
+* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
+* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
+* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
+* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
+* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
+* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
+* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
+* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
+* DAMAGE.                                                            *
+*                                                                    *
+**********************************************************************
+*                                                                    *
+*       SystemView version: V3.12                                    *
+*                                                                    *
+**********************************************************************
+-------------------------- END-OF-HEADER -----------------------------
+
+File    : SEGGER_SYSVIEW_NuttX.h
+Purpose : Interface between NuttX and SystemView.
+Revision: $Rev: 7745 $
+*/
+
+#ifndef SYSVIEW_NUTTX_H
+#define SYSVIEW_NUTTX_H
+
+#include "SEGGER_SYSVIEW.h"
+
+/*********************************************************************
+*
+*       Defines, configurable
+*
+**********************************************************************
+*/
+#ifdef CONFIG_SYSTEMVIEW_MAX_NOF_TASKS
+  #define SYSVIEW_NUTTX_MAX_NOF_TASKS  CONFIG_SYSTEMVIEW_MAX_NOF_TASKS
+#else
+  #define SYSVIEW_NUTTX_MAX_NOF_TASKS  8
+#endif
+
+/*********************************************************************
+*
+*       Defines, fixed
+*
+**********************************************************************
+*/
+#define _SYSTEMVIEW_ID_OFFSET                              (32u)
+#define _TRACE_API_ID_TASK_CREATE                          (1u + _SYSTEMVIEW_ID_OFFSET)
+#define _TRACE_API_ID_NXTASK_CREATE                        (2u + _SYSTEMVIEW_ID_OFFSET)
+#define _TRACE_API_ID_KTHREAD_CREATE                       (3u + _SYSTEMVIEW_ID_OFFSET)
+#define _TRACE_API_ID_PTHREAD_CREATE                       (4u + _SYSTEMVIEW_ID_OFFSET)
+
+#if !defined(CONFIG_SYSTEMVIEW_ENABLE)
+  #define TRACE_INIT()
+  #define TRACE_START()
+  #define TRACE_TASK_CREATED(PID, Name, Priority, StackAddr, StackSize)
+  #define TRACE_TASK_READY(PID)
+  #define TRACE_TASK_START(pTCB)
+  #define TRACE_TASK_BLOCK(PID, State)
+  #define TRACE_TASK_TERMINATE(PID)
+#else
+  #define TRACE_INIT()                              							SEGGER_SYSVIEW_Conf()
+  #define TRACE_START()                             							SEGGER_SYSVIEW_Start()
+  #define TRACE_TASK_CREATED(PID, Name, Priority, StackAddr, StackSize) 		SEGGER_SYSVIEW_OnTaskCreate(PID); 													\
+                                                                                SYSVIEW_AddTask((U32)PID, (const char*)Name, (unsigned)Priority, (U32)StackAddr, (unsigned)StackSize)
+  #define TRACE_TASK_READY(PID)													SEGGER_SYSVIEW_OnTaskStartReady(PID)
+  #define TRACE_TASK_START(PID)  												{ if (PID == 0) { SEGGER_SYSVIEW_OnIdle(); } else { SEGGER_SYSVIEW_OnTaskStartExec(PID); } }
+  #define TRACE_TASK_BLOCK(PID, State) 											SEGGER_SYSVIEW_OnTaskStopReady(PID, (U32)State)
+  #define TRACE_TASK_TERMINATE(PID)                                             { SEGGER_SYSVIEW_OnTaskTerminate(PID); SYSVIEW_DeleteTask(PID); }
+#endif
+
+#if !defined(CONFIG_SYSTEMVIEW_ENABLE) && !defined(CONFIG_SYSTEMVIEW_RECORD_ISR)
+  #define TRACE_ISR_ENTER()
+  #define TRACE_ISR_EXIT()
+  #define TRACE_ISR_EXIT_TO_SCHEDULER()
+#else
+  #define TRACE_ISR_ENTER()                         							SEGGER_SYSVIEW_RecordEnterISR()
+  #define TRACE_ISR_EXIT()                          							SEGGER_SYSVIEW_RecordExitISR()
+  #define TRACE_ISR_EXIT_TO_SCHEDULER()             							SEGGER_SYSVIEW_RecordExitISRToScheduler()
+#endif
+
+#if !defined(CONFIG_SYSTEMVIEW_ENABLE) && !defined(CONFIG_SYSTEMVIEW_RECORD_API)
+  #define TRACE_API_TASK_CREATE(name, priority, stack_size, entry, argv)
+  #define TRACE_API_TASK_CREATE_RETURN(ret)
+  #define TRACE_API_NXTASK_CREATE(name, priority, stack_size, entry, argv)
+  #define TRACE_API_NXTASK_CREATE_RETURN(ret)
+  #define TRACE_API_KTHREAD_CREATE(name, priority, stack_size, entry, argv)
+  #define TRACE_API_KTHREAD_CREATE_RETURN(ret)
+  #define TRACE_API_PTHREAD_CREATE(thread, attr, start_routine, arg)
+  #define TRACE_API_PTHREAD_CREATE_RETURN(ret)
+#else
+  #define TRACE_API_TASK_CREATE(name, priority, stack_size, entry, argv)        SEGGER_SYSVIEW_RecordU32x5     (_TRACE_API_ID_TASK_CREATE,  (U32)name, (U32)priority, (U32)stack_size, (U32)entry, (U32)argv)
+  #define TRACE_API_TASK_CREATE_RETURN(ret)         														SEGGER_SYSVIEW_RecordEndCallU32(_TRACE_API_ID_TASK_CREATE,  ret)
+  #define TRACE_API_NXTASK_CREATE(name, priority, stack_size, entry, argv)      SEGGER_SYSVIEW_RecordU32x5     (_TRACE_API_ID_NXTASK_CREATE, (U32)name, (U32)priority, (U32)stack_size, (U32)entry, (U32)argv)
+  #define TRACE_API_NXTASK_CREATE_RETURN(ret)                                   SEGGER_SYSVIEW_RecordEndCallU32(_TRACE_API_ID_NXTASK_CREATE, ret)
+  #define TRACE_API_KTHREAD_CREATE(name, priority, stack_size, entry, argv)     SEGGER_SYSVIEW_RecordU32x5     (_TRACE_API_ID_KTHREAD_CREATE,  (U32)name, (U32)priority, (U32)stack_size, (U32)entry, (U32)argv)
+  #define TRACE_API_KTHREAD_CREATE_RETURN(ret)                                  SEGGER_SYSVIEW_RecordEndCallU32(_TRACE_API_ID_KTHREAD_CREATE,  ret)
+  #define TRACE_API_PTHREAD_CREATE(thread, attr, start_routine, arg)            SEGGER_SYSVIEW_RecordU32x4     (_TRACE_API_ID_PTHREAD_CREATE, (U32)thread, (U32)attr, (U32)start_routine, (U32)arg)
+  #define TRACE_API_PTHREAD_CREATE_RETURN(ret)                                  SEGGER_SYSVIEW_RecordEndCallU32(_TRACE_API_ID_PTHREAD_CREATE,  ret)
+#endif
+
+/*********************************************************************
+*
+*       API functions
+*
+**********************************************************************
+*/
+#ifdef __cplusplus
+extern "C" {
+#endif
+void SYSVIEW_InitTime     (void);
+void SYSVIEW_AddTask      (U32 TaskID, const char* sName, unsigned Priority, U32 StackAddr, unsigned StackSize);
+void SYSVIEW_UpdateTask   (U32 TaskID, const char* sName, unsigned Priority, U32 StackAddr, unsigned StackSize);
+void SYSVIEW_DeleteTask   (U32 TaskID);
+void SYSVIEW_SendTaskInfo (U32 TaskID, const char* sName, unsigned Priority, U32 StackAddr, unsigned StackSize);
+
+extern const SEGGER_SYSVIEW_OS_API SYSVIEW_X_OS_TraceAPI;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+/*************************** End of file ****************************/
diff --git a/sched/task/task_create.c b/sched/task/task_create.c
index c2259bea8a..befaa6f53c 100644
--- a/sched/task/task_create.c
+++ b/sched/task/task_create.c
@@ -38,6 +38,8 @@
 #include "group/group.h"
 #include "task/task.h"
 
+#include "systemview/SEGGER_SYSVIEW_NuttX.h"
+
 /****************************************************************************
  * Private Functions
  ****************************************************************************/
@@ -146,6 +148,7 @@ static int nxthread_create(FAR const char *name, uint8_t ttype,
   /* Activate the task */
 
   nxtask_activate((FAR struct tcb_s *)tcb);
+  TRACE_TASK_CREATED(pid, name, priority, tcb->cmn.adj_stack_ptr, stack_size);
   return pid;
 
 errout_with_active:
@@ -205,8 +208,13 @@ errout_with_tcb:
 int nxtask_create(FAR const char *name, int priority,
                   int stack_size, main_t entry, FAR char * const argv[])
 {
-  return nxthread_create(name, TCB_FLAG_TTYPE_TASK, priority, stack_size,
+  int ret;
+
+  TRACE_API_NXTASK_CREATE(name, priority, stack_size, entry, argv);
+  ret = nxthread_create(name, TCB_FLAG_TTYPE_TASK, priority, stack_size,
                          entry, argv);
+  TRACE_API_NXTASK_CREATE_RETURN(ret);
+  return ret;
 }
 
 /****************************************************************************
@@ -245,13 +253,16 @@ int nxtask_create(FAR const char *name, int priority,
 int task_create(FAR const char *name, int priority,
                 int stack_size, main_t entry, FAR char * const argv[])
 {
-  int ret = nxtask_create(name, priority, stack_size, entry, argv);
+  int ret;
+
+  TRACE_API_TASK_CREATE(name, priority, stack_size, entry, argv);
+  ret = nxtask_create(name, priority, stack_size, entry, argv);
   if (ret < 0)
     {
       set_errno(-ret);
       ret = ERROR;
     }
-
+  TRACE_API_TASK_CREATE_RETURN(ret);
   return ret;
 }
 #endif
@@ -283,6 +294,11 @@ int task_create(FAR const char *name, int priority,
 int kthread_create(FAR const char *name, int priority,
                    int stack_size, main_t entry, FAR char * const argv[])
 {
-  return nxthread_create(name, TCB_FLAG_TTYPE_KERNEL, priority, stack_size,
+  int ret;
+
+  TRACE_API_KTHREAD_CREATE(name, priority, stack_size, entry, argv);
+  ret = nxthread_create(name, TCB_FLAG_TTYPE_KERNEL, priority, stack_size,
                          entry, argv);
+  TRACE_API_KTHREAD_CREATE_RETURN(ret);
+  return ret;
 }
diff --git a/sched/task/task_start.c b/sched/task/task_start.c
index ccb3315529..11dc6bb813 100644
--- a/sched/task/task_start.c
+++ b/sched/task/task_start.c
@@ -52,6 +52,8 @@
 #include "signal/signal.h"
 #include "task/task.h"
 
+#include "systemview/SEGGER_SYSVIEW_NuttX.h"
+
 /****************************************************************************
  * Pre-processor Definitions
  ****************************************************************************/
@@ -134,6 +136,8 @@ void nxtask_start(void)
    * we have to switch to user-mode before calling the task.
    */
 
+  TRACE_TASK_START(tcb->cmn.pid);
+
 #ifndef CONFIG_BUILD_FLAT
   if ((tcb->cmn.flags & TCB_FLAG_TTYPE_MASK) != TCB_FLAG_TTYPE_KERNEL)
     {
@@ -146,6 +150,8 @@ void nxtask_start(void)
       exitcode = tcb->cmn.entry.main(argc, tcb->argv);
     }
 
+  TRACE_TASK_TERMINATE(tcb->cmn.pid);
+
   /* Call exit() if/when the task returns */
 
   exit(exitcode);
-- 
2.17.1

